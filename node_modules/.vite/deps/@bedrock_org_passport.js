import {
  detect
} from "./chunk-KMTODQPO.js";
import {
  require_buffer
} from "./chunk-MZXFFUKN.js";
import {
  AbiConstructor_exports,
  AbiFunction_exports,
  AbiItem_exports,
  AbiParameters_exports,
  AccountNotFoundError,
  Address_exports,
  BaseError as BaseError2,
  BlockOverrides_exports,
  Bytes_exports,
  Caches_exports,
  DataSizeTooSmallError,
  Errors_exports,
  Hash_exports,
  Hex_exports,
  InvalidAddressError as InvalidAddressError2,
  InvalidInputError,
  InvalidLengthError,
  InvalidSelectorSizeError,
  Json_exports,
  NotFoundError,
  PositionOutOfBoundsError,
  PublicKey_exports,
  Solidity_exports,
  Withdrawal_exports,
  assert,
  bytesRegex,
  concat,
  concat2,
  create,
  createClient,
  custom,
  decode,
  defineBlock,
  defineChain,
  defineTransaction,
  defineTransactionReceipt,
  encode,
  format,
  formatLog,
  formatTransaction,
  from,
  from2,
  from3,
  from4,
  from5,
  fromAbi,
  fromArray,
  fromBytes,
  fromHex as fromHex2,
  fromNumber,
  fromNumber2,
  fromPublicKey,
  fromRpc,
  fromString,
  fromString2,
  getBalance,
  getBlockNumber,
  getEnsAddress,
  getEnsAvatar,
  getEnsName,
  getSelector,
  getSignatureHash,
  getUrl,
  http,
  integerRegex,
  isEqual,
  isEqual2,
  keccak256 as keccak2562,
  maxUint256 as maxUint2562,
  multicall,
  padLeft,
  prettyPrint,
  random,
  readContract,
  rpc,
  serializeAccessList,
  serializeTransaction,
  sha256 as sha2562,
  sha2562 as sha2563,
  signMessage,
  size,
  size2,
  slice,
  slice2,
  stringify,
  toBigInt,
  toBytes as toBytes2,
  toBytes2 as toBytes4,
  toHex as toHex2,
  toHex2 as toHex3,
  toNumber,
  toRlp,
  toRpc,
  toString,
  toString2,
  toYParitySignatureArray,
  trimLeft,
  validate,
  validate2,
  validate3,
  validate4,
  watchBlockNumber,
  withRetry,
  withTimeout
} from "./chunk-XCHAA4CS.js";
import {
  require_events
} from "./chunk-NPY75PGV.js";
import {
  calcGeneratorVelocity,
  glide,
  invariant,
  noopReturn,
  pregenerateKeyframes,
  require_dijkstra,
  spring,
  warning
} from "./chunk-OJHIN7PC.js";
import {
  Field,
  FpInvertBatch,
  FpLegendre,
  FpPow,
  bitGet,
  bitLen,
  bitMask,
  bytesToHex,
  bytesToNumberBE,
  concatBytes,
  createCurve,
  createHasher,
  ensureBytes,
  getMinHashLength,
  isogenyMap,
  mapHashToField,
  mapToCurveSimpleSWU,
  memoized,
  mod,
  notImplemented,
  numberToBytesBE,
  randomBytes,
  secp256k1,
  sha256,
  weierstrassPoints
} from "./chunk-TABXEZ4W.js";
import {
  BaseError,
  ContractFunctionExecutionError,
  FeeCapTooHighError,
  InvalidAddressError,
  InvalidChainIdError,
  ResourceUnavailableRpcError,
  RpcRequestError,
  SwitchChainError,
  TipAboveFeeCapError,
  UserRejectedRequestError,
  assertRequest,
  concatHex,
  defineTransactionRequest,
  extract,
  formatTransactionRequest,
  formatUnits,
  fromHex,
  getAddress,
  getCallError,
  hexToBigInt,
  hexToBytes,
  hexToNumber,
  hexToString,
  isAddress,
  keccak256,
  maxUint16,
  maxUint256,
  numberToHex,
  pad,
  parseAccount,
  stringToHex,
  toBytes,
  toHex,
  trim,
  weiUnits
} from "./chunk-ZRZONEMC.js";
import {
  formatAbi,
  formatAbiItem,
  parseAbi
} from "./chunk-AVNE4FUI.js";
import {
  Hash,
  SHA256_IV,
  abytes,
  add,
  add3H,
  add3L,
  aexists,
  anumber,
  aoutput,
  clean,
  createOptHasher,
  createXOFer,
  fromBig,
  rotr,
  rotr32H,
  rotr32L,
  rotrBH,
  rotrBL,
  rotrSH,
  rotrSL,
  swap32IfBE,
  swap8IfBE,
  toBytes as toBytes3,
  u32,
  u8
} from "./chunk-EJEBLTYM.js";
import {
  require_sha3,
  require_utils
} from "./chunk-KMUCU7ZA.js";
import {
  QueryClient,
  QueryClientProvider,
  useMutation,
  useQuery,
  useQueryClient
} from "./chunk-LVEWR7JL.js";
import {
  __assign,
  __extends,
  __read,
  __rest,
  __spreadArray,
  __values,
  init_tslib_es6
} from "./chunk-CO3FTJWH.js";
import {
  require_jsx_runtime
} from "./chunk-TLG7CTPL.js";
import {
  require_react_dom
} from "./chunk-QTY7PMUO.js";
import {
  require_react
} from "./chunk-VT65UQWK.js";
import {
  __commonJS,
  __esm,
  __export,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField,
  __require,
  __toCommonJS,
  __toESM
} from "./chunk-ONY6HBPH.js";

// node_modules/@wagmi/core/node_modules/eventemitter3/index.js
var require_eventemitter3 = __commonJS({
  "node_modules/@wagmi/core/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter4() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      var names2 = [], events, name;
      if (this._eventsCount === 0) return names2;
      for (name in events = this._events) {
        if (has.call(events, name)) names2.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events));
      }
      return names2;
    };
    EventEmitter4.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l3 = handlers.length, ee2 = new Array(l3); i2 < l3; i2++) {
        ee2[i2] = handlers[i2].fn;
      }
      return ee2;
    };
    EventEmitter4.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2) return 0;
      if (listeners2.fn) return 1;
      return listeners2.length;
    };
    EventEmitter4.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i2;
      if (listeners2.fn) {
        if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a22), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a22, a3), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length2 = listeners2.length, j3;
        for (i2 = 0; i2 < length2; i2++) {
          if (listeners2[i2].once) this.removeListener(event, listeners2[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i2].fn.call(listeners2[i2].context);
              break;
            case 2:
              listeners2[i2].fn.call(listeners2[i2].context, a1);
              break;
            case 3:
              listeners2[i2].fn.call(listeners2[i2].context, a1, a22);
              break;
            case 4:
              listeners2[i2].fn.call(listeners2[i2].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners2[i2].fn.apply(listeners2[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter4.prototype.on = function on2(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter4.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter4.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn2 && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length2 = listeners2.length; i2 < length2; i2++) {
          if (listeners2[i2].fn !== fn2 || once && !listeners2[i2].once || context && listeners2[i2].context !== context) {
            events.push(listeners2[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.addListener = EventEmitter4.prototype.on;
    EventEmitter4.prefixed = prefix;
    EventEmitter4.EventEmitter = EventEmitter4;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter4;
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js
var require_use_sync_external_store_shim_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      function useSyncExternalStore$2(subscribe2, getSnapshot) {
        didWarnOld18Alpha || void 0 === React14.startTransition || (didWarnOld18Alpha = true, console.error(
          "You are using an outdated, pre-release alpha of React 18 that does not support useSyncExternalStore. The use-sync-external-store shim will not work correctly. Upgrade to a newer pre-release."
        ));
        var value = getSnapshot();
        if (!didWarnUncachedGetSnapshot) {
          var cachedValue = getSnapshot();
          objectIs(value, cachedValue) || (console.error(
            "The result of getSnapshot should be cached to avoid an infinite loop"
          ), didWarnUncachedGetSnapshot = true);
        }
        cachedValue = useState11({
          inst: { value, getSnapshot }
        });
        var inst = cachedValue[0].inst, forceUpdate = cachedValue[1];
        useLayoutEffect4(
          function() {
            inst.value = value;
            inst.getSnapshot = getSnapshot;
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
          },
          [subscribe2, value, getSnapshot]
        );
        useEffect34(
          function() {
            checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            return subscribe2(function() {
              checkIfSnapshotChanged(inst) && forceUpdate({ inst });
            });
          },
          [subscribe2]
        );
        useDebugValue(value);
        return value;
      }
      function checkIfSnapshotChanged(inst) {
        var latestGetSnapshot = inst.getSnapshot;
        inst = inst.value;
        try {
          var nextValue = latestGetSnapshot();
          return !objectIs(inst, nextValue);
        } catch (error) {
          return true;
        }
      }
      function useSyncExternalStore$1(subscribe2, getSnapshot) {
        return getSnapshot();
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React14 = require_react(), objectIs = "function" === typeof Object.is ? Object.is : is2, useState11 = React14.useState, useEffect34 = React14.useEffect, useLayoutEffect4 = React14.useLayoutEffect, useDebugValue = React14.useDebugValue, didWarnOld18Alpha = false, didWarnUncachedGetSnapshot = false, shim = "undefined" === typeof window || "undefined" === typeof window.document || "undefined" === typeof window.document.createElement ? useSyncExternalStore$1 : useSyncExternalStore$2;
      exports.useSyncExternalStore = void 0 !== React14.useSyncExternalStore ? React14.useSyncExternalStore : shim;
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/index.js
var require_shim = __commonJS({
  "node_modules/use-sync-external-store/shim/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_use_sync_external_store_shim_development();
    }
  }
});

// node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js
var require_with_selector_development = __commonJS({
  "node_modules/use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js"(exports) {
    "use strict";
    (function() {
      function is2(x2, y2) {
        return x2 === y2 && (0 !== x2 || 1 / x2 === 1 / y2) || x2 !== x2 && y2 !== y2;
      }
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(Error());
      var React14 = require_react(), shim = require_shim(), objectIs = "function" === typeof Object.is ? Object.is : is2, useSyncExternalStore5 = shim.useSyncExternalStore, useRef21 = React14.useRef, useEffect34 = React14.useEffect, useMemo12 = React14.useMemo, useDebugValue = React14.useDebugValue;
      exports.useSyncExternalStoreWithSelector = function(subscribe2, getSnapshot, getServerSnapshot, selector, isEqual3) {
        var instRef = useRef21(null);
        if (null === instRef.current) {
          var inst = { hasValue: false, value: null };
          instRef.current = inst;
        } else inst = instRef.current;
        instRef = useMemo12(
          function() {
            function memoizedSelector(nextSnapshot) {
              if (!hasMemo) {
                hasMemo = true;
                memoizedSnapshot = nextSnapshot;
                nextSnapshot = selector(nextSnapshot);
                if (void 0 !== isEqual3 && inst.hasValue) {
                  var currentSelection = inst.value;
                  if (isEqual3(currentSelection, nextSnapshot))
                    return memoizedSelection = currentSelection;
                }
                return memoizedSelection = nextSnapshot;
              }
              currentSelection = memoizedSelection;
              if (objectIs(memoizedSnapshot, nextSnapshot))
                return currentSelection;
              var nextSelection = selector(nextSnapshot);
              if (void 0 !== isEqual3 && isEqual3(currentSelection, nextSelection))
                return memoizedSnapshot = nextSnapshot, currentSelection;
              memoizedSnapshot = nextSnapshot;
              return memoizedSelection = nextSelection;
            }
            var hasMemo = false, memoizedSnapshot, memoizedSelection, maybeGetServerSnapshot = void 0 === getServerSnapshot ? null : getServerSnapshot;
            return [
              function() {
                return memoizedSelector(getSnapshot());
              },
              null === maybeGetServerSnapshot ? void 0 : function() {
                return memoizedSelector(maybeGetServerSnapshot());
              }
            ];
          },
          [getSnapshot, getServerSnapshot, selector, isEqual3]
        );
        var value = useSyncExternalStore5(subscribe2, instRef[0], instRef[1]);
        useEffect34(
          function() {
            inst.hasValue = true;
            inst.value = value;
          },
          [value]
        );
        useDebugValue(value);
        return value;
      };
      "undefined" !== typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ && "function" === typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop && __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(Error());
    })();
  }
});

// node_modules/use-sync-external-store/shim/with-selector.js
var require_with_selector = __commonJS({
  "node_modules/use-sync-external-store/shim/with-selector.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_with_selector_development();
    }
  }
});

// node_modules/@emotion/memoize/dist/memoize.browser.esm.js
function memoize(fn2) {
  var cache = {};
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn2(arg);
    return cache[arg];
  };
}
var memoize_browser_esm_default;
var init_memoize_browser_esm = __esm({
  "node_modules/@emotion/memoize/dist/memoize.browser.esm.js"() {
    memoize_browser_esm_default = memoize;
  }
});

// node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js
var is_prop_valid_browser_esm_exports = {};
__export(is_prop_valid_browser_esm_exports, {
  default: () => is_prop_valid_browser_esm_default
});
var reactPropsRegex, index2, is_prop_valid_browser_esm_default;
var init_is_prop_valid_browser_esm = __esm({
  "node_modules/@emotion/is-prop-valid/dist/is-prop-valid.browser.esm.js"() {
    init_memoize_browser_esm();
    reactPropsRegex = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|download|draggable|encType|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|inert|itemProp|itemScope|itemType|itemID|itemRef|on|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
    index2 = memoize_browser_esm_default(
      function(prop) {
        return reactPropsRegex.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
      }
      /* Z+1 */
    );
    is_prop_valid_browser_esm_default = index2;
  }
});

// node_modules/react-is/cjs/react-is.development.js
var require_react_is_development = __commonJS({
  "node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var REACT_ELEMENT_TYPE = Symbol.for("react.element");
        var REACT_PORTAL_TYPE = Symbol.for("react.portal");
        var REACT_FRAGMENT_TYPE = Symbol.for("react.fragment");
        var REACT_STRICT_MODE_TYPE = Symbol.for("react.strict_mode");
        var REACT_PROFILER_TYPE = Symbol.for("react.profiler");
        var REACT_PROVIDER_TYPE = Symbol.for("react.provider");
        var REACT_CONTEXT_TYPE = Symbol.for("react.context");
        var REACT_SERVER_CONTEXT_TYPE = Symbol.for("react.server_context");
        var REACT_FORWARD_REF_TYPE = Symbol.for("react.forward_ref");
        var REACT_SUSPENSE_TYPE = Symbol.for("react.suspense");
        var REACT_SUSPENSE_LIST_TYPE = Symbol.for("react.suspense_list");
        var REACT_MEMO_TYPE = Symbol.for("react.memo");
        var REACT_LAZY_TYPE = Symbol.for("react.lazy");
        var REACT_OFFSCREEN_TYPE = Symbol.for("react.offscreen");
        var enableScopeAPI = false;
        var enableCacheElement = false;
        var enableTransitionTracing = false;
        var enableLegacyHidden = false;
        var enableDebugTracing = false;
        var REACT_MODULE_REFERENCE;
        {
          REACT_MODULE_REFERENCE = Symbol.for("react.module.reference");
        }
        function isValidElementType(type6) {
          if (typeof type6 === "string" || typeof type6 === "function") {
            return true;
          }
          if (type6 === REACT_FRAGMENT_TYPE || type6 === REACT_PROFILER_TYPE || enableDebugTracing || type6 === REACT_STRICT_MODE_TYPE || type6 === REACT_SUSPENSE_TYPE || type6 === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type6 === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {
            return true;
          }
          if (typeof type6 === "object" && type6 !== null) {
            if (type6.$$typeof === REACT_LAZY_TYPE || type6.$$typeof === REACT_MEMO_TYPE || type6.$$typeof === REACT_PROVIDER_TYPE || type6.$$typeof === REACT_CONTEXT_TYPE || type6.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object
            // types supported by any Flight configuration anywhere since
            // we don't know which Flight build this will end up being used
            // with.
            type6.$$typeof === REACT_MODULE_REFERENCE || type6.getModuleId !== void 0) {
              return true;
            }
          }
          return false;
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type6 = object.type;
                switch (type6) {
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                  case REACT_SUSPENSE_LIST_TYPE:
                    return type6;
                  default:
                    var $$typeofType = type6 && type6.$$typeof;
                    switch ($$typeofType) {
                      case REACT_SERVER_CONTEXT_TYPE:
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment4 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var SuspenseList = REACT_SUSPENSE_LIST_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        var hasWarnedAboutDeprecatedIsConcurrentMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isConcurrentMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsConcurrentMode) {
              hasWarnedAboutDeprecatedIsConcurrentMode = true;
              console["warn"]("The ReactIs.isConcurrentMode() alias has been deprecated, and will be removed in React 18+.");
            }
          }
          return false;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        function isSuspenseList(object) {
          return typeOf(object) === REACT_SUSPENSE_LIST_TYPE;
        }
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment4;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.SuspenseList = SuspenseList;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isSuspenseList = isSuspenseList;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/react-is/index.js
var require_react_is = __commonJS({
  "node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development();
    }
  }
});

// node_modules/shallowequal/index.js
var require_shallowequal = __commonJS({
  "node_modules/shallowequal/index.js"(exports, module) {
    module.exports = function shallowEqual(objA, objB, compare, compareContext) {
      var ret = compare ? compare.call(compareContext, objA, objB) : void 0;
      if (ret !== void 0) {
        return !!ret;
      }
      if (objA === objB) {
        return true;
      }
      if (typeof objA !== "object" || !objA || typeof objB !== "object" || !objB) {
        return false;
      }
      var keysA = Object.keys(objA);
      var keysB = Object.keys(objB);
      if (keysA.length !== keysB.length) {
        return false;
      }
      var bHasOwnProperty = Object.prototype.hasOwnProperty.bind(objB);
      for (var idx = 0; idx < keysA.length; idx++) {
        var key = keysA[idx];
        if (!bHasOwnProperty(key)) {
          return false;
        }
        var valueA = objA[key];
        var valueB = objB[key];
        ret = compare ? compare.call(compareContext, valueA, valueB, key) : void 0;
        if (ret === false || ret === void 0 && valueA !== valueB) {
          return false;
        }
      }
      return true;
    };
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js
var require_react_is_development2 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/cjs/react-is.development.js"(exports) {
    "use strict";
    if (true) {
      (function() {
        "use strict";
        var hasSymbol = typeof Symbol === "function" && Symbol.for;
        var REACT_ELEMENT_TYPE = hasSymbol ? Symbol.for("react.element") : 60103;
        var REACT_PORTAL_TYPE = hasSymbol ? Symbol.for("react.portal") : 60106;
        var REACT_FRAGMENT_TYPE = hasSymbol ? Symbol.for("react.fragment") : 60107;
        var REACT_STRICT_MODE_TYPE = hasSymbol ? Symbol.for("react.strict_mode") : 60108;
        var REACT_PROFILER_TYPE = hasSymbol ? Symbol.for("react.profiler") : 60114;
        var REACT_PROVIDER_TYPE = hasSymbol ? Symbol.for("react.provider") : 60109;
        var REACT_CONTEXT_TYPE = hasSymbol ? Symbol.for("react.context") : 60110;
        var REACT_ASYNC_MODE_TYPE = hasSymbol ? Symbol.for("react.async_mode") : 60111;
        var REACT_CONCURRENT_MODE_TYPE = hasSymbol ? Symbol.for("react.concurrent_mode") : 60111;
        var REACT_FORWARD_REF_TYPE = hasSymbol ? Symbol.for("react.forward_ref") : 60112;
        var REACT_SUSPENSE_TYPE = hasSymbol ? Symbol.for("react.suspense") : 60113;
        var REACT_SUSPENSE_LIST_TYPE = hasSymbol ? Symbol.for("react.suspense_list") : 60120;
        var REACT_MEMO_TYPE = hasSymbol ? Symbol.for("react.memo") : 60115;
        var REACT_LAZY_TYPE = hasSymbol ? Symbol.for("react.lazy") : 60116;
        var REACT_BLOCK_TYPE = hasSymbol ? Symbol.for("react.block") : 60121;
        var REACT_FUNDAMENTAL_TYPE = hasSymbol ? Symbol.for("react.fundamental") : 60117;
        var REACT_RESPONDER_TYPE = hasSymbol ? Symbol.for("react.responder") : 60118;
        var REACT_SCOPE_TYPE = hasSymbol ? Symbol.for("react.scope") : 60119;
        function isValidElementType(type6) {
          return typeof type6 === "string" || typeof type6 === "function" || // Note: its typeof might be other than 'symbol' or 'number' if it's a polyfill.
          type6 === REACT_FRAGMENT_TYPE || type6 === REACT_CONCURRENT_MODE_TYPE || type6 === REACT_PROFILER_TYPE || type6 === REACT_STRICT_MODE_TYPE || type6 === REACT_SUSPENSE_TYPE || type6 === REACT_SUSPENSE_LIST_TYPE || typeof type6 === "object" && type6 !== null && (type6.$$typeof === REACT_LAZY_TYPE || type6.$$typeof === REACT_MEMO_TYPE || type6.$$typeof === REACT_PROVIDER_TYPE || type6.$$typeof === REACT_CONTEXT_TYPE || type6.$$typeof === REACT_FORWARD_REF_TYPE || type6.$$typeof === REACT_FUNDAMENTAL_TYPE || type6.$$typeof === REACT_RESPONDER_TYPE || type6.$$typeof === REACT_SCOPE_TYPE || type6.$$typeof === REACT_BLOCK_TYPE);
        }
        function typeOf(object) {
          if (typeof object === "object" && object !== null) {
            var $$typeof = object.$$typeof;
            switch ($$typeof) {
              case REACT_ELEMENT_TYPE:
                var type6 = object.type;
                switch (type6) {
                  case REACT_ASYNC_MODE_TYPE:
                  case REACT_CONCURRENT_MODE_TYPE:
                  case REACT_FRAGMENT_TYPE:
                  case REACT_PROFILER_TYPE:
                  case REACT_STRICT_MODE_TYPE:
                  case REACT_SUSPENSE_TYPE:
                    return type6;
                  default:
                    var $$typeofType = type6 && type6.$$typeof;
                    switch ($$typeofType) {
                      case REACT_CONTEXT_TYPE:
                      case REACT_FORWARD_REF_TYPE:
                      case REACT_LAZY_TYPE:
                      case REACT_MEMO_TYPE:
                      case REACT_PROVIDER_TYPE:
                        return $$typeofType;
                      default:
                        return $$typeof;
                    }
                }
              case REACT_PORTAL_TYPE:
                return $$typeof;
            }
          }
          return void 0;
        }
        var AsyncMode = REACT_ASYNC_MODE_TYPE;
        var ConcurrentMode = REACT_CONCURRENT_MODE_TYPE;
        var ContextConsumer = REACT_CONTEXT_TYPE;
        var ContextProvider = REACT_PROVIDER_TYPE;
        var Element2 = REACT_ELEMENT_TYPE;
        var ForwardRef = REACT_FORWARD_REF_TYPE;
        var Fragment4 = REACT_FRAGMENT_TYPE;
        var Lazy = REACT_LAZY_TYPE;
        var Memo = REACT_MEMO_TYPE;
        var Portal2 = REACT_PORTAL_TYPE;
        var Profiler = REACT_PROFILER_TYPE;
        var StrictMode = REACT_STRICT_MODE_TYPE;
        var Suspense = REACT_SUSPENSE_TYPE;
        var hasWarnedAboutDeprecatedIsAsyncMode = false;
        function isAsyncMode(object) {
          {
            if (!hasWarnedAboutDeprecatedIsAsyncMode) {
              hasWarnedAboutDeprecatedIsAsyncMode = true;
              console["warn"]("The ReactIs.isAsyncMode() alias has been deprecated, and will be removed in React 17+. Update your code to use ReactIs.isConcurrentMode() instead. It has the exact same API.");
            }
          }
          return isConcurrentMode(object) || typeOf(object) === REACT_ASYNC_MODE_TYPE;
        }
        function isConcurrentMode(object) {
          return typeOf(object) === REACT_CONCURRENT_MODE_TYPE;
        }
        function isContextConsumer(object) {
          return typeOf(object) === REACT_CONTEXT_TYPE;
        }
        function isContextProvider(object) {
          return typeOf(object) === REACT_PROVIDER_TYPE;
        }
        function isElement(object) {
          return typeof object === "object" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;
        }
        function isForwardRef(object) {
          return typeOf(object) === REACT_FORWARD_REF_TYPE;
        }
        function isFragment(object) {
          return typeOf(object) === REACT_FRAGMENT_TYPE;
        }
        function isLazy(object) {
          return typeOf(object) === REACT_LAZY_TYPE;
        }
        function isMemo(object) {
          return typeOf(object) === REACT_MEMO_TYPE;
        }
        function isPortal(object) {
          return typeOf(object) === REACT_PORTAL_TYPE;
        }
        function isProfiler(object) {
          return typeOf(object) === REACT_PROFILER_TYPE;
        }
        function isStrictMode(object) {
          return typeOf(object) === REACT_STRICT_MODE_TYPE;
        }
        function isSuspense(object) {
          return typeOf(object) === REACT_SUSPENSE_TYPE;
        }
        exports.AsyncMode = AsyncMode;
        exports.ConcurrentMode = ConcurrentMode;
        exports.ContextConsumer = ContextConsumer;
        exports.ContextProvider = ContextProvider;
        exports.Element = Element2;
        exports.ForwardRef = ForwardRef;
        exports.Fragment = Fragment4;
        exports.Lazy = Lazy;
        exports.Memo = Memo;
        exports.Portal = Portal2;
        exports.Profiler = Profiler;
        exports.StrictMode = StrictMode;
        exports.Suspense = Suspense;
        exports.isAsyncMode = isAsyncMode;
        exports.isConcurrentMode = isConcurrentMode;
        exports.isContextConsumer = isContextConsumer;
        exports.isContextProvider = isContextProvider;
        exports.isElement = isElement;
        exports.isForwardRef = isForwardRef;
        exports.isFragment = isFragment;
        exports.isLazy = isLazy;
        exports.isMemo = isMemo;
        exports.isPortal = isPortal;
        exports.isProfiler = isProfiler;
        exports.isStrictMode = isStrictMode;
        exports.isSuspense = isSuspense;
        exports.isValidElementType = isValidElementType;
        exports.typeOf = typeOf;
      })();
    }
  }
});

// node_modules/hoist-non-react-statics/node_modules/react-is/index.js
var require_react_is2 = __commonJS({
  "node_modules/hoist-non-react-statics/node_modules/react-is/index.js"(exports, module) {
    "use strict";
    if (false) {
      module.exports = null;
    } else {
      module.exports = require_react_is_development2();
    }
  }
});

// node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js
var require_hoist_non_react_statics_cjs = __commonJS({
  "node_modules/hoist-non-react-statics/dist/hoist-non-react-statics.cjs.js"(exports, module) {
    "use strict";
    var reactIs = require_react_is2();
    var REACT_STATICS = {
      childContextTypes: true,
      contextType: true,
      contextTypes: true,
      defaultProps: true,
      displayName: true,
      getDefaultProps: true,
      getDerivedStateFromError: true,
      getDerivedStateFromProps: true,
      mixins: true,
      propTypes: true,
      type: true
    };
    var KNOWN_STATICS = {
      name: true,
      length: true,
      prototype: true,
      caller: true,
      callee: true,
      arguments: true,
      arity: true
    };
    var FORWARD_REF_STATICS = {
      "$$typeof": true,
      render: true,
      defaultProps: true,
      displayName: true,
      propTypes: true
    };
    var MEMO_STATICS = {
      "$$typeof": true,
      compare: true,
      defaultProps: true,
      displayName: true,
      propTypes: true,
      type: true
    };
    var TYPE_STATICS = {};
    TYPE_STATICS[reactIs.ForwardRef] = FORWARD_REF_STATICS;
    TYPE_STATICS[reactIs.Memo] = MEMO_STATICS;
    function getStatics(component) {
      if (reactIs.isMemo(component)) {
        return MEMO_STATICS;
      }
      return TYPE_STATICS[component["$$typeof"]] || REACT_STATICS;
    }
    var defineProperty = Object.defineProperty;
    var getOwnPropertyNames = Object.getOwnPropertyNames;
    var getOwnPropertySymbols = Object.getOwnPropertySymbols;
    var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
    var getPrototypeOf2 = Object.getPrototypeOf;
    var objectPrototype = Object.prototype;
    function hoistNonReactStatics(targetComponent, sourceComponent, blacklist) {
      if (typeof sourceComponent !== "string") {
        if (objectPrototype) {
          var inheritedComponent = getPrototypeOf2(sourceComponent);
          if (inheritedComponent && inheritedComponent !== objectPrototype) {
            hoistNonReactStatics(targetComponent, inheritedComponent, blacklist);
          }
        }
        var keys = getOwnPropertyNames(sourceComponent);
        if (getOwnPropertySymbols) {
          keys = keys.concat(getOwnPropertySymbols(sourceComponent));
        }
        var targetStatics = getStatics(targetComponent);
        var sourceStatics = getStatics(sourceComponent);
        for (var i2 = 0; i2 < keys.length; ++i2) {
          var key = keys[i2];
          if (!KNOWN_STATICS[key] && !(blacklist && blacklist[key]) && !(sourceStatics && sourceStatics[key]) && !(targetStatics && targetStatics[key])) {
            var descriptor = getOwnPropertyDescriptor(sourceComponent, key);
            try {
              defineProperty(targetComponent, key, descriptor);
            } catch (e2) {
            }
          }
        }
      }
      return targetComponent;
    }
    module.exports = hoistNonReactStatics;
  }
});

// node_modules/ox/node_modules/eventemitter3/index.js
var require_eventemitter32 = __commonJS({
  "node_modules/ox/node_modules/eventemitter3/index.js"(exports, module) {
    "use strict";
    var has = Object.prototype.hasOwnProperty;
    var prefix = "~";
    function Events() {
    }
    if (Object.create) {
      Events.prototype = /* @__PURE__ */ Object.create(null);
      if (!new Events().__proto__) prefix = false;
    }
    function EE(fn2, context, once) {
      this.fn = fn2;
      this.context = context;
      this.once = once || false;
    }
    function addListener(emitter, event, fn2, context, once) {
      if (typeof fn2 !== "function") {
        throw new TypeError("The listener must be a function");
      }
      var listener = new EE(fn2, context || emitter, once), evt = prefix ? prefix + event : event;
      if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;
      else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);
      else emitter._events[evt] = [emitter._events[evt], listener];
      return emitter;
    }
    function clearEvent(emitter, evt) {
      if (--emitter._eventsCount === 0) emitter._events = new Events();
      else delete emitter._events[evt];
    }
    function EventEmitter4() {
      this._events = new Events();
      this._eventsCount = 0;
    }
    EventEmitter4.prototype.eventNames = function eventNames() {
      var names2 = [], events, name;
      if (this._eventsCount === 0) return names2;
      for (name in events = this._events) {
        if (has.call(events, name)) names2.push(prefix ? name.slice(1) : name);
      }
      if (Object.getOwnPropertySymbols) {
        return names2.concat(Object.getOwnPropertySymbols(events));
      }
      return names2;
    };
    EventEmitter4.prototype.listeners = function listeners2(event) {
      var evt = prefix ? prefix + event : event, handlers = this._events[evt];
      if (!handlers) return [];
      if (handlers.fn) return [handlers.fn];
      for (var i2 = 0, l3 = handlers.length, ee2 = new Array(l3); i2 < l3; i2++) {
        ee2[i2] = handlers[i2].fn;
      }
      return ee2;
    };
    EventEmitter4.prototype.listenerCount = function listenerCount(event) {
      var evt = prefix ? prefix + event : event, listeners2 = this._events[evt];
      if (!listeners2) return 0;
      if (listeners2.fn) return 1;
      return listeners2.length;
    };
    EventEmitter4.prototype.emit = function emit(event, a1, a22, a3, a4, a5) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return false;
      var listeners2 = this._events[evt], len = arguments.length, args, i2;
      if (listeners2.fn) {
        if (listeners2.once) this.removeListener(event, listeners2.fn, void 0, true);
        switch (len) {
          case 1:
            return listeners2.fn.call(listeners2.context), true;
          case 2:
            return listeners2.fn.call(listeners2.context, a1), true;
          case 3:
            return listeners2.fn.call(listeners2.context, a1, a22), true;
          case 4:
            return listeners2.fn.call(listeners2.context, a1, a22, a3), true;
          case 5:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4), true;
          case 6:
            return listeners2.fn.call(listeners2.context, a1, a22, a3, a4, a5), true;
        }
        for (i2 = 1, args = new Array(len - 1); i2 < len; i2++) {
          args[i2 - 1] = arguments[i2];
        }
        listeners2.fn.apply(listeners2.context, args);
      } else {
        var length2 = listeners2.length, j3;
        for (i2 = 0; i2 < length2; i2++) {
          if (listeners2[i2].once) this.removeListener(event, listeners2[i2].fn, void 0, true);
          switch (len) {
            case 1:
              listeners2[i2].fn.call(listeners2[i2].context);
              break;
            case 2:
              listeners2[i2].fn.call(listeners2[i2].context, a1);
              break;
            case 3:
              listeners2[i2].fn.call(listeners2[i2].context, a1, a22);
              break;
            case 4:
              listeners2[i2].fn.call(listeners2[i2].context, a1, a22, a3);
              break;
            default:
              if (!args) for (j3 = 1, args = new Array(len - 1); j3 < len; j3++) {
                args[j3 - 1] = arguments[j3];
              }
              listeners2[i2].fn.apply(listeners2[i2].context, args);
          }
        }
      }
      return true;
    };
    EventEmitter4.prototype.on = function on2(event, fn2, context) {
      return addListener(this, event, fn2, context, false);
    };
    EventEmitter4.prototype.once = function once(event, fn2, context) {
      return addListener(this, event, fn2, context, true);
    };
    EventEmitter4.prototype.removeListener = function removeListener(event, fn2, context, once) {
      var evt = prefix ? prefix + event : event;
      if (!this._events[evt]) return this;
      if (!fn2) {
        clearEvent(this, evt);
        return this;
      }
      var listeners2 = this._events[evt];
      if (listeners2.fn) {
        if (listeners2.fn === fn2 && (!once || listeners2.once) && (!context || listeners2.context === context)) {
          clearEvent(this, evt);
        }
      } else {
        for (var i2 = 0, events = [], length2 = listeners2.length; i2 < length2; i2++) {
          if (listeners2[i2].fn !== fn2 || once && !listeners2[i2].once || context && listeners2[i2].context !== context) {
            events.push(listeners2[i2]);
          }
        }
        if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;
        else clearEvent(this, evt);
      }
      return this;
    };
    EventEmitter4.prototype.removeAllListeners = function removeAllListeners(event) {
      var evt;
      if (event) {
        evt = prefix ? prefix + event : event;
        if (this._events[evt]) clearEvent(this, evt);
      } else {
        this._events = new Events();
        this._eventsCount = 0;
      }
      return this;
    };
    EventEmitter4.prototype.off = EventEmitter4.prototype.removeListener;
    EventEmitter4.prototype.addListener = EventEmitter4.prototype.on;
    EventEmitter4.prefixed = prefix;
    EventEmitter4.EventEmitter = EventEmitter4;
    if ("undefined" !== typeof module) {
      module.exports = EventEmitter4;
    }
  }
});

// node_modules/qrcode/lib/can-promise.js
var require_can_promise = __commonJS({
  "node_modules/qrcode/lib/can-promise.js"(exports, module) {
    module.exports = function() {
      return typeof Promise === "function" && Promise.prototype && Promise.prototype.then;
    };
  }
});

// node_modules/qrcode/lib/core/utils.js
var require_utils2 = __commonJS({
  "node_modules/qrcode/lib/core/utils.js"(exports) {
    var toSJISFunction;
    var CODEWORDS_COUNT = [
      0,
      // Not used
      26,
      44,
      70,
      100,
      134,
      172,
      196,
      242,
      292,
      346,
      404,
      466,
      532,
      581,
      655,
      733,
      815,
      901,
      991,
      1085,
      1156,
      1258,
      1364,
      1474,
      1588,
      1706,
      1828,
      1921,
      2051,
      2185,
      2323,
      2465,
      2611,
      2761,
      2876,
      3034,
      3196,
      3362,
      3532,
      3706
    ];
    exports.getSymbolSize = function getSymbolSize(version7) {
      if (!version7) throw new Error('"version" cannot be null or undefined');
      if (version7 < 1 || version7 > 40) throw new Error('"version" should be in range from 1 to 40');
      return version7 * 4 + 17;
    };
    exports.getSymbolTotalCodewords = function getSymbolTotalCodewords(version7) {
      return CODEWORDS_COUNT[version7];
    };
    exports.getBCHDigit = function(data) {
      let digit = 0;
      while (data !== 0) {
        digit++;
        data >>>= 1;
      }
      return digit;
    };
    exports.setToSJISFunction = function setToSJISFunction(f3) {
      if (typeof f3 !== "function") {
        throw new Error('"toSJISFunc" is not a valid function.');
      }
      toSJISFunction = f3;
    };
    exports.isKanjiModeEnabled = function() {
      return typeof toSJISFunction !== "undefined";
    };
    exports.toSJIS = function toSJIS(kanji) {
      return toSJISFunction(kanji);
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-level.js
var require_error_correction_level = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-level.js"(exports) {
    exports.L = { bit: 1 };
    exports.M = { bit: 0 };
    exports.Q = { bit: 3 };
    exports.H = { bit: 2 };
    function fromString5(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "l":
        case "low":
          return exports.L;
        case "m":
        case "medium":
          return exports.M;
        case "q":
        case "quartile":
          return exports.Q;
        case "h":
        case "high":
          return exports.H;
        default:
          throw new Error("Unknown EC Level: " + string);
      }
    }
    exports.isValid = function isValid(level) {
      return level && typeof level.bit !== "undefined" && level.bit >= 0 && level.bit < 4;
    };
    exports.from = function from26(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString5(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/bit-buffer.js
var require_bit_buffer = __commonJS({
  "node_modules/qrcode/lib/core/bit-buffer.js"(exports, module) {
    function BitBuffer() {
      this.buffer = [];
      this.length = 0;
    }
    BitBuffer.prototype = {
      get: function(index5) {
        const bufIndex = Math.floor(index5 / 8);
        return (this.buffer[bufIndex] >>> 7 - index5 % 8 & 1) === 1;
      },
      put: function(num, length2) {
        for (let i2 = 0; i2 < length2; i2++) {
          this.putBit((num >>> length2 - i2 - 1 & 1) === 1);
        }
      },
      getLengthInBits: function() {
        return this.length;
      },
      putBit: function(bit) {
        const bufIndex = Math.floor(this.length / 8);
        if (this.buffer.length <= bufIndex) {
          this.buffer.push(0);
        }
        if (bit) {
          this.buffer[bufIndex] |= 128 >>> this.length % 8;
        }
        this.length++;
      }
    };
    module.exports = BitBuffer;
  }
});

// node_modules/qrcode/lib/core/bit-matrix.js
var require_bit_matrix = __commonJS({
  "node_modules/qrcode/lib/core/bit-matrix.js"(exports, module) {
    function BitMatrix(size5) {
      if (!size5 || size5 < 1) {
        throw new Error("BitMatrix size must be defined and greater than 0");
      }
      this.size = size5;
      this.data = new Uint8Array(size5 * size5);
      this.reservedBit = new Uint8Array(size5 * size5);
    }
    BitMatrix.prototype.set = function(row, col, value, reserved) {
      const index5 = row * this.size + col;
      this.data[index5] = value;
      if (reserved) this.reservedBit[index5] = true;
    };
    BitMatrix.prototype.get = function(row, col) {
      return this.data[row * this.size + col];
    };
    BitMatrix.prototype.xor = function(row, col, value) {
      this.data[row * this.size + col] ^= value;
    };
    BitMatrix.prototype.isReserved = function(row, col) {
      return this.reservedBit[row * this.size + col];
    };
    module.exports = BitMatrix;
  }
});

// node_modules/qrcode/lib/core/alignment-pattern.js
var require_alignment_pattern = __commonJS({
  "node_modules/qrcode/lib/core/alignment-pattern.js"(exports) {
    var getSymbolSize = require_utils2().getSymbolSize;
    exports.getRowColCoords = function getRowColCoords(version7) {
      if (version7 === 1) return [];
      const posCount = Math.floor(version7 / 7) + 2;
      const size5 = getSymbolSize(version7);
      const intervals = size5 === 145 ? 26 : Math.ceil((size5 - 13) / (2 * posCount - 2)) * 2;
      const positions = [size5 - 7];
      for (let i2 = 1; i2 < posCount - 1; i2++) {
        positions[i2] = positions[i2 - 1] - intervals;
      }
      positions.push(6);
      return positions.reverse();
    };
    exports.getPositions = function getPositions(version7) {
      const coords = [];
      const pos = exports.getRowColCoords(version7);
      const posLength = pos.length;
      for (let i2 = 0; i2 < posLength; i2++) {
        for (let j3 = 0; j3 < posLength; j3++) {
          if (i2 === 0 && j3 === 0 || // top-left
          i2 === 0 && j3 === posLength - 1 || // bottom-left
          i2 === posLength - 1 && j3 === 0) {
            continue;
          }
          coords.push([pos[i2], pos[j3]]);
        }
      }
      return coords;
    };
  }
});

// node_modules/qrcode/lib/core/finder-pattern.js
var require_finder_pattern = __commonJS({
  "node_modules/qrcode/lib/core/finder-pattern.js"(exports) {
    var getSymbolSize = require_utils2().getSymbolSize;
    var FINDER_PATTERN_SIZE = 7;
    exports.getPositions = function getPositions(version7) {
      const size5 = getSymbolSize(version7);
      return [
        // top-left
        [0, 0],
        // top-right
        [size5 - FINDER_PATTERN_SIZE, 0],
        // bottom-left
        [0, size5 - FINDER_PATTERN_SIZE]
      ];
    };
  }
});

// node_modules/qrcode/lib/core/mask-pattern.js
var require_mask_pattern = __commonJS({
  "node_modules/qrcode/lib/core/mask-pattern.js"(exports) {
    exports.Patterns = {
      PATTERN000: 0,
      PATTERN001: 1,
      PATTERN010: 2,
      PATTERN011: 3,
      PATTERN100: 4,
      PATTERN101: 5,
      PATTERN110: 6,
      PATTERN111: 7
    };
    var PenaltyScores = {
      N1: 3,
      N2: 3,
      N3: 40,
      N4: 10
    };
    exports.isValid = function isValid(mask) {
      return mask != null && mask !== "" && !isNaN(mask) && mask >= 0 && mask <= 7;
    };
    exports.from = function from26(value) {
      return exports.isValid(value) ? parseInt(value, 10) : void 0;
    };
    exports.getPenaltyN1 = function getPenaltyN1(data) {
      const size5 = data.size;
      let points = 0;
      let sameCountCol = 0;
      let sameCountRow = 0;
      let lastCol = null;
      let lastRow = null;
      for (let row = 0; row < size5; row++) {
        sameCountCol = sameCountRow = 0;
        lastCol = lastRow = null;
        for (let col = 0; col < size5; col++) {
          let module2 = data.get(row, col);
          if (module2 === lastCol) {
            sameCountCol++;
          } else {
            if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
            lastCol = module2;
            sameCountCol = 1;
          }
          module2 = data.get(col, row);
          if (module2 === lastRow) {
            sameCountRow++;
          } else {
            if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
            lastRow = module2;
            sameCountRow = 1;
          }
        }
        if (sameCountCol >= 5) points += PenaltyScores.N1 + (sameCountCol - 5);
        if (sameCountRow >= 5) points += PenaltyScores.N1 + (sameCountRow - 5);
      }
      return points;
    };
    exports.getPenaltyN2 = function getPenaltyN2(data) {
      const size5 = data.size;
      let points = 0;
      for (let row = 0; row < size5 - 1; row++) {
        for (let col = 0; col < size5 - 1; col++) {
          const last = data.get(row, col) + data.get(row, col + 1) + data.get(row + 1, col) + data.get(row + 1, col + 1);
          if (last === 4 || last === 0) points++;
        }
      }
      return points * PenaltyScores.N2;
    };
    exports.getPenaltyN3 = function getPenaltyN3(data) {
      const size5 = data.size;
      let points = 0;
      let bitsCol = 0;
      let bitsRow = 0;
      for (let row = 0; row < size5; row++) {
        bitsCol = bitsRow = 0;
        for (let col = 0; col < size5; col++) {
          bitsCol = bitsCol << 1 & 2047 | data.get(row, col);
          if (col >= 10 && (bitsCol === 1488 || bitsCol === 93)) points++;
          bitsRow = bitsRow << 1 & 2047 | data.get(col, row);
          if (col >= 10 && (bitsRow === 1488 || bitsRow === 93)) points++;
        }
      }
      return points * PenaltyScores.N3;
    };
    exports.getPenaltyN4 = function getPenaltyN4(data) {
      let darkCount = 0;
      const modulesCount = data.data.length;
      for (let i2 = 0; i2 < modulesCount; i2++) darkCount += data.data[i2];
      const k4 = Math.abs(Math.ceil(darkCount * 100 / modulesCount / 5) - 10);
      return k4 * PenaltyScores.N4;
    };
    function getMaskAt(maskPattern, i2, j3) {
      switch (maskPattern) {
        case exports.Patterns.PATTERN000:
          return (i2 + j3) % 2 === 0;
        case exports.Patterns.PATTERN001:
          return i2 % 2 === 0;
        case exports.Patterns.PATTERN010:
          return j3 % 3 === 0;
        case exports.Patterns.PATTERN011:
          return (i2 + j3) % 3 === 0;
        case exports.Patterns.PATTERN100:
          return (Math.floor(i2 / 2) + Math.floor(j3 / 3)) % 2 === 0;
        case exports.Patterns.PATTERN101:
          return i2 * j3 % 2 + i2 * j3 % 3 === 0;
        case exports.Patterns.PATTERN110:
          return (i2 * j3 % 2 + i2 * j3 % 3) % 2 === 0;
        case exports.Patterns.PATTERN111:
          return (i2 * j3 % 3 + (i2 + j3) % 2) % 2 === 0;
        default:
          throw new Error("bad maskPattern:" + maskPattern);
      }
    }
    exports.applyMask = function applyMask(pattern, data) {
      const size5 = data.size;
      for (let col = 0; col < size5; col++) {
        for (let row = 0; row < size5; row++) {
          if (data.isReserved(row, col)) continue;
          data.xor(row, col, getMaskAt(pattern, row, col));
        }
      }
    };
    exports.getBestMask = function getBestMask(data, setupFormatFunc) {
      const numPatterns = Object.keys(exports.Patterns).length;
      let bestPattern = 0;
      let lowerPenalty = Infinity;
      for (let p2 = 0; p2 < numPatterns; p2++) {
        setupFormatFunc(p2);
        exports.applyMask(p2, data);
        const penalty = exports.getPenaltyN1(data) + exports.getPenaltyN2(data) + exports.getPenaltyN3(data) + exports.getPenaltyN4(data);
        exports.applyMask(p2, data);
        if (penalty < lowerPenalty) {
          lowerPenalty = penalty;
          bestPattern = p2;
        }
      }
      return bestPattern;
    };
  }
});

// node_modules/qrcode/lib/core/error-correction-code.js
var require_error_correction_code = __commonJS({
  "node_modules/qrcode/lib/core/error-correction-code.js"(exports) {
    var ECLevel = require_error_correction_level();
    var EC_BLOCKS_TABLE = [
      // L  M  Q  H
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      2,
      2,
      1,
      2,
      2,
      4,
      1,
      2,
      4,
      4,
      2,
      4,
      4,
      4,
      2,
      4,
      6,
      5,
      2,
      4,
      6,
      6,
      2,
      5,
      8,
      8,
      4,
      5,
      8,
      8,
      4,
      5,
      8,
      11,
      4,
      8,
      10,
      11,
      4,
      9,
      12,
      16,
      4,
      9,
      16,
      16,
      6,
      10,
      12,
      18,
      6,
      10,
      17,
      16,
      6,
      11,
      16,
      19,
      6,
      13,
      18,
      21,
      7,
      14,
      21,
      25,
      8,
      16,
      20,
      25,
      8,
      17,
      23,
      25,
      9,
      17,
      23,
      34,
      9,
      18,
      25,
      30,
      10,
      20,
      27,
      32,
      12,
      21,
      29,
      35,
      12,
      23,
      34,
      37,
      12,
      25,
      34,
      40,
      13,
      26,
      35,
      42,
      14,
      28,
      38,
      45,
      15,
      29,
      40,
      48,
      16,
      31,
      43,
      51,
      17,
      33,
      45,
      54,
      18,
      35,
      48,
      57,
      19,
      37,
      51,
      60,
      19,
      38,
      53,
      63,
      20,
      40,
      56,
      66,
      21,
      43,
      59,
      70,
      22,
      45,
      62,
      74,
      24,
      47,
      65,
      77,
      25,
      49,
      68,
      81
    ];
    var EC_CODEWORDS_TABLE = [
      // L  M  Q  H
      7,
      10,
      13,
      17,
      10,
      16,
      22,
      28,
      15,
      26,
      36,
      44,
      20,
      36,
      52,
      64,
      26,
      48,
      72,
      88,
      36,
      64,
      96,
      112,
      40,
      72,
      108,
      130,
      48,
      88,
      132,
      156,
      60,
      110,
      160,
      192,
      72,
      130,
      192,
      224,
      80,
      150,
      224,
      264,
      96,
      176,
      260,
      308,
      104,
      198,
      288,
      352,
      120,
      216,
      320,
      384,
      132,
      240,
      360,
      432,
      144,
      280,
      408,
      480,
      168,
      308,
      448,
      532,
      180,
      338,
      504,
      588,
      196,
      364,
      546,
      650,
      224,
      416,
      600,
      700,
      224,
      442,
      644,
      750,
      252,
      476,
      690,
      816,
      270,
      504,
      750,
      900,
      300,
      560,
      810,
      960,
      312,
      588,
      870,
      1050,
      336,
      644,
      952,
      1110,
      360,
      700,
      1020,
      1200,
      390,
      728,
      1050,
      1260,
      420,
      784,
      1140,
      1350,
      450,
      812,
      1200,
      1440,
      480,
      868,
      1290,
      1530,
      510,
      924,
      1350,
      1620,
      540,
      980,
      1440,
      1710,
      570,
      1036,
      1530,
      1800,
      570,
      1064,
      1590,
      1890,
      600,
      1120,
      1680,
      1980,
      630,
      1204,
      1770,
      2100,
      660,
      1260,
      1860,
      2220,
      720,
      1316,
      1950,
      2310,
      750,
      1372,
      2040,
      2430
    ];
    exports.getBlocksCount = function getBlocksCount(version7, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_BLOCKS_TABLE[(version7 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_BLOCKS_TABLE[(version7 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_BLOCKS_TABLE[(version7 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_BLOCKS_TABLE[(version7 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
    exports.getTotalCodewordsCount = function getTotalCodewordsCount(version7, errorCorrectionLevel) {
      switch (errorCorrectionLevel) {
        case ECLevel.L:
          return EC_CODEWORDS_TABLE[(version7 - 1) * 4 + 0];
        case ECLevel.M:
          return EC_CODEWORDS_TABLE[(version7 - 1) * 4 + 1];
        case ECLevel.Q:
          return EC_CODEWORDS_TABLE[(version7 - 1) * 4 + 2];
        case ECLevel.H:
          return EC_CODEWORDS_TABLE[(version7 - 1) * 4 + 3];
        default:
          return void 0;
      }
    };
  }
});

// node_modules/qrcode/lib/core/galois-field.js
var require_galois_field = __commonJS({
  "node_modules/qrcode/lib/core/galois-field.js"(exports) {
    var EXP_TABLE = new Uint8Array(512);
    var LOG_TABLE = new Uint8Array(256);
    (function initTables() {
      let x2 = 1;
      for (let i2 = 0; i2 < 255; i2++) {
        EXP_TABLE[i2] = x2;
        LOG_TABLE[x2] = i2;
        x2 <<= 1;
        if (x2 & 256) {
          x2 ^= 285;
        }
      }
      for (let i2 = 255; i2 < 512; i2++) {
        EXP_TABLE[i2] = EXP_TABLE[i2 - 255];
      }
    })();
    exports.log = function log(n2) {
      if (n2 < 1) throw new Error("log(" + n2 + ")");
      return LOG_TABLE[n2];
    };
    exports.exp = function exp(n2) {
      return EXP_TABLE[n2];
    };
    exports.mul = function mul(x2, y2) {
      if (x2 === 0 || y2 === 0) return 0;
      return EXP_TABLE[LOG_TABLE[x2] + LOG_TABLE[y2]];
    };
  }
});

// node_modules/qrcode/lib/core/polynomial.js
var require_polynomial = __commonJS({
  "node_modules/qrcode/lib/core/polynomial.js"(exports) {
    var GF = require_galois_field();
    exports.mul = function mul(p1, p2) {
      const coeff = new Uint8Array(p1.length + p2.length - 1);
      for (let i2 = 0; i2 < p1.length; i2++) {
        for (let j3 = 0; j3 < p2.length; j3++) {
          coeff[i2 + j3] ^= GF.mul(p1[i2], p2[j3]);
        }
      }
      return coeff;
    };
    exports.mod = function mod2(divident, divisor) {
      let result = new Uint8Array(divident);
      while (result.length - divisor.length >= 0) {
        const coeff = result[0];
        for (let i2 = 0; i2 < divisor.length; i2++) {
          result[i2] ^= GF.mul(divisor[i2], coeff);
        }
        let offset = 0;
        while (offset < result.length && result[offset] === 0) offset++;
        result = result.slice(offset);
      }
      return result;
    };
    exports.generateECPolynomial = function generateECPolynomial(degree) {
      let poly = new Uint8Array([1]);
      for (let i2 = 0; i2 < degree; i2++) {
        poly = exports.mul(poly, new Uint8Array([1, GF.exp(i2)]));
      }
      return poly;
    };
  }
});

// node_modules/qrcode/lib/core/reed-solomon-encoder.js
var require_reed_solomon_encoder = __commonJS({
  "node_modules/qrcode/lib/core/reed-solomon-encoder.js"(exports, module) {
    var Polynomial = require_polynomial();
    function ReedSolomonEncoder(degree) {
      this.genPoly = void 0;
      this.degree = degree;
      if (this.degree) this.initialize(this.degree);
    }
    ReedSolomonEncoder.prototype.initialize = function initialize(degree) {
      this.degree = degree;
      this.genPoly = Polynomial.generateECPolynomial(this.degree);
    };
    ReedSolomonEncoder.prototype.encode = function encode9(data) {
      if (!this.genPoly) {
        throw new Error("Encoder not initialized");
      }
      const paddedData = new Uint8Array(data.length + this.degree);
      paddedData.set(data);
      const remainder = Polynomial.mod(paddedData, this.genPoly);
      const start = this.degree - remainder.length;
      if (start > 0) {
        const buff = new Uint8Array(this.degree);
        buff.set(remainder, start);
        return buff;
      }
      return remainder;
    };
    module.exports = ReedSolomonEncoder;
  }
});

// node_modules/qrcode/lib/core/version-check.js
var require_version_check = __commonJS({
  "node_modules/qrcode/lib/core/version-check.js"(exports) {
    exports.isValid = function isValid(version7) {
      return !isNaN(version7) && version7 >= 1 && version7 <= 40;
    };
  }
});

// node_modules/qrcode/lib/core/regex.js
var require_regex = __commonJS({
  "node_modules/qrcode/lib/core/regex.js"(exports) {
    var numeric = "[0-9]+";
    var alphanumeric = "[A-Z $%*+\\-./:]+";
    var kanji = "(?:[u3000-u303F]|[u3040-u309F]|[u30A0-u30FF]|[uFF00-uFFEF]|[u4E00-u9FAF]|[u2605-u2606]|[u2190-u2195]|u203B|[u2010u2015u2018u2019u2025u2026u201Cu201Du2225u2260]|[u0391-u0451]|[u00A7u00A8u00B1u00B4u00D7u00F7])+";
    kanji = kanji.replace(/u/g, "\\u");
    var byte = "(?:(?![A-Z0-9 $%*+\\-./:]|" + kanji + ")(?:.|[\r\n]))+";
    exports.KANJI = new RegExp(kanji, "g");
    exports.BYTE_KANJI = new RegExp("[^A-Z0-9 $%*+\\-./:]+", "g");
    exports.BYTE = new RegExp(byte, "g");
    exports.NUMERIC = new RegExp(numeric, "g");
    exports.ALPHANUMERIC = new RegExp(alphanumeric, "g");
    var TEST_KANJI = new RegExp("^" + kanji + "$");
    var TEST_NUMERIC = new RegExp("^" + numeric + "$");
    var TEST_ALPHANUMERIC = new RegExp("^[A-Z0-9 $%*+\\-./:]+$");
    exports.testKanji = function testKanji(str) {
      return TEST_KANJI.test(str);
    };
    exports.testNumeric = function testNumeric(str) {
      return TEST_NUMERIC.test(str);
    };
    exports.testAlphanumeric = function testAlphanumeric(str) {
      return TEST_ALPHANUMERIC.test(str);
    };
  }
});

// node_modules/qrcode/lib/core/mode.js
var require_mode = __commonJS({
  "node_modules/qrcode/lib/core/mode.js"(exports) {
    var VersionCheck = require_version_check();
    var Regex = require_regex();
    exports.NUMERIC = {
      id: "Numeric",
      bit: 1 << 0,
      ccBits: [10, 12, 14]
    };
    exports.ALPHANUMERIC = {
      id: "Alphanumeric",
      bit: 1 << 1,
      ccBits: [9, 11, 13]
    };
    exports.BYTE = {
      id: "Byte",
      bit: 1 << 2,
      ccBits: [8, 16, 16]
    };
    exports.KANJI = {
      id: "Kanji",
      bit: 1 << 3,
      ccBits: [8, 10, 12]
    };
    exports.MIXED = {
      bit: -1
    };
    exports.getCharCountIndicator = function getCharCountIndicator(mode3, version7) {
      if (!mode3.ccBits) throw new Error("Invalid mode: " + mode3);
      if (!VersionCheck.isValid(version7)) {
        throw new Error("Invalid version: " + version7);
      }
      if (version7 >= 1 && version7 < 10) return mode3.ccBits[0];
      else if (version7 < 27) return mode3.ccBits[1];
      return mode3.ccBits[2];
    };
    exports.getBestModeForData = function getBestModeForData(dataStr) {
      if (Regex.testNumeric(dataStr)) return exports.NUMERIC;
      else if (Regex.testAlphanumeric(dataStr)) return exports.ALPHANUMERIC;
      else if (Regex.testKanji(dataStr)) return exports.KANJI;
      else return exports.BYTE;
    };
    exports.toString = function toString7(mode3) {
      if (mode3 && mode3.id) return mode3.id;
      throw new Error("Invalid mode");
    };
    exports.isValid = function isValid(mode3) {
      return mode3 && mode3.bit && mode3.ccBits;
    };
    function fromString5(string) {
      if (typeof string !== "string") {
        throw new Error("Param is not a string");
      }
      const lcStr = string.toLowerCase();
      switch (lcStr) {
        case "numeric":
          return exports.NUMERIC;
        case "alphanumeric":
          return exports.ALPHANUMERIC;
        case "kanji":
          return exports.KANJI;
        case "byte":
          return exports.BYTE;
        default:
          throw new Error("Unknown mode: " + string);
      }
    }
    exports.from = function from26(value, defaultValue) {
      if (exports.isValid(value)) {
        return value;
      }
      try {
        return fromString5(value);
      } catch (e2) {
        return defaultValue;
      }
    };
  }
});

// node_modules/qrcode/lib/core/version.js
var require_version = __commonJS({
  "node_modules/qrcode/lib/core/version.js"(exports) {
    var Utils = require_utils2();
    var ECCode = require_error_correction_code();
    var ECLevel = require_error_correction_level();
    var Mode = require_mode();
    var VersionCheck = require_version_check();
    var G18 = 1 << 12 | 1 << 11 | 1 << 10 | 1 << 9 | 1 << 8 | 1 << 5 | 1 << 2 | 1 << 0;
    var G18_BCH = Utils.getBCHDigit(G18);
    function getBestVersionForDataLength(mode3, length2, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, mode3)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    function getReservedBitsCount(mode3, version7) {
      return Mode.getCharCountIndicator(mode3, version7) + 4;
    }
    function getTotalBitsFromDataArray(segments, version7) {
      let totalBits = 0;
      segments.forEach(function(data) {
        const reservedBits = getReservedBitsCount(data.mode, version7);
        totalBits += reservedBits + data.getBitsLength();
      });
      return totalBits;
    }
    function getBestVersionForMixedData(segments, errorCorrectionLevel) {
      for (let currentVersion = 1; currentVersion <= 40; currentVersion++) {
        const length2 = getTotalBitsFromDataArray(segments, currentVersion);
        if (length2 <= exports.getCapacity(currentVersion, errorCorrectionLevel, Mode.MIXED)) {
          return currentVersion;
        }
      }
      return void 0;
    }
    exports.from = function from26(value, defaultValue) {
      if (VersionCheck.isValid(value)) {
        return parseInt(value, 10);
      }
      return defaultValue;
    };
    exports.getCapacity = function getCapacity(version7, errorCorrectionLevel, mode3) {
      if (!VersionCheck.isValid(version7)) {
        throw new Error("Invalid QR Code version");
      }
      if (typeof mode3 === "undefined") mode3 = Mode.BYTE;
      const totalCodewords = Utils.getSymbolTotalCodewords(version7);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version7, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (mode3 === Mode.MIXED) return dataTotalCodewordsBits;
      const usableBits = dataTotalCodewordsBits - getReservedBitsCount(mode3, version7);
      switch (mode3) {
        case Mode.NUMERIC:
          return Math.floor(usableBits / 10 * 3);
        case Mode.ALPHANUMERIC:
          return Math.floor(usableBits / 11 * 2);
        case Mode.KANJI:
          return Math.floor(usableBits / 13);
        case Mode.BYTE:
        default:
          return Math.floor(usableBits / 8);
      }
    };
    exports.getBestVersionForData = function getBestVersionForData(data, errorCorrectionLevel) {
      let seg;
      const ecl = ECLevel.from(errorCorrectionLevel, ECLevel.M);
      if (Array.isArray(data)) {
        if (data.length > 1) {
          return getBestVersionForMixedData(data, ecl);
        }
        if (data.length === 0) {
          return 1;
        }
        seg = data[0];
      } else {
        seg = data;
      }
      return getBestVersionForDataLength(seg.mode, seg.getLength(), ecl);
    };
    exports.getEncodedBits = function getEncodedBits(version7) {
      if (!VersionCheck.isValid(version7) || version7 < 7) {
        throw new Error("Invalid QR Code version");
      }
      let d2 = version7 << 12;
      while (Utils.getBCHDigit(d2) - G18_BCH >= 0) {
        d2 ^= G18 << Utils.getBCHDigit(d2) - G18_BCH;
      }
      return version7 << 12 | d2;
    };
  }
});

// node_modules/qrcode/lib/core/format-info.js
var require_format_info = __commonJS({
  "node_modules/qrcode/lib/core/format-info.js"(exports) {
    var Utils = require_utils2();
    var G15 = 1 << 10 | 1 << 8 | 1 << 5 | 1 << 4 | 1 << 2 | 1 << 1 | 1 << 0;
    var G15_MASK = 1 << 14 | 1 << 12 | 1 << 10 | 1 << 4 | 1 << 1;
    var G15_BCH = Utils.getBCHDigit(G15);
    exports.getEncodedBits = function getEncodedBits(errorCorrectionLevel, mask) {
      const data = errorCorrectionLevel.bit << 3 | mask;
      let d2 = data << 10;
      while (Utils.getBCHDigit(d2) - G15_BCH >= 0) {
        d2 ^= G15 << Utils.getBCHDigit(d2) - G15_BCH;
      }
      return (data << 10 | d2) ^ G15_MASK;
    };
  }
});

// node_modules/qrcode/lib/core/numeric-data.js
var require_numeric_data = __commonJS({
  "node_modules/qrcode/lib/core/numeric-data.js"(exports, module) {
    var Mode = require_mode();
    function NumericData(data) {
      this.mode = Mode.NUMERIC;
      this.data = data.toString();
    }
    NumericData.getBitsLength = function getBitsLength(length2) {
      return 10 * Math.floor(length2 / 3) + (length2 % 3 ? length2 % 3 * 3 + 1 : 0);
    };
    NumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    NumericData.prototype.getBitsLength = function getBitsLength() {
      return NumericData.getBitsLength(this.data.length);
    };
    NumericData.prototype.write = function write(bitBuffer) {
      let i2, group, value;
      for (i2 = 0; i2 + 3 <= this.data.length; i2 += 3) {
        group = this.data.substr(i2, 3);
        value = parseInt(group, 10);
        bitBuffer.put(value, 10);
      }
      const remainingNum = this.data.length - i2;
      if (remainingNum > 0) {
        group = this.data.substr(i2);
        value = parseInt(group, 10);
        bitBuffer.put(value, remainingNum * 3 + 1);
      }
    };
    module.exports = NumericData;
  }
});

// node_modules/qrcode/lib/core/alphanumeric-data.js
var require_alphanumeric_data = __commonJS({
  "node_modules/qrcode/lib/core/alphanumeric-data.js"(exports, module) {
    var Mode = require_mode();
    var ALPHA_NUM_CHARS = [
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      " ",
      "$",
      "%",
      "*",
      "+",
      "-",
      ".",
      "/",
      ":"
    ];
    function AlphanumericData(data) {
      this.mode = Mode.ALPHANUMERIC;
      this.data = data;
    }
    AlphanumericData.getBitsLength = function getBitsLength(length2) {
      return 11 * Math.floor(length2 / 2) + 6 * (length2 % 2);
    };
    AlphanumericData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    AlphanumericData.prototype.getBitsLength = function getBitsLength() {
      return AlphanumericData.getBitsLength(this.data.length);
    };
    AlphanumericData.prototype.write = function write(bitBuffer) {
      let i2;
      for (i2 = 0; i2 + 2 <= this.data.length; i2 += 2) {
        let value = ALPHA_NUM_CHARS.indexOf(this.data[i2]) * 45;
        value += ALPHA_NUM_CHARS.indexOf(this.data[i2 + 1]);
        bitBuffer.put(value, 11);
      }
      if (this.data.length % 2) {
        bitBuffer.put(ALPHA_NUM_CHARS.indexOf(this.data[i2]), 6);
      }
    };
    module.exports = AlphanumericData;
  }
});

// node_modules/qrcode/lib/core/byte-data.js
var require_byte_data = __commonJS({
  "node_modules/qrcode/lib/core/byte-data.js"(exports, module) {
    var Mode = require_mode();
    function ByteData(data) {
      this.mode = Mode.BYTE;
      if (typeof data === "string") {
        this.data = new TextEncoder().encode(data);
      } else {
        this.data = new Uint8Array(data);
      }
    }
    ByteData.getBitsLength = function getBitsLength(length2) {
      return length2 * 8;
    };
    ByteData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    ByteData.prototype.getBitsLength = function getBitsLength() {
      return ByteData.getBitsLength(this.data.length);
    };
    ByteData.prototype.write = function(bitBuffer) {
      for (let i2 = 0, l3 = this.data.length; i2 < l3; i2++) {
        bitBuffer.put(this.data[i2], 8);
      }
    };
    module.exports = ByteData;
  }
});

// node_modules/qrcode/lib/core/kanji-data.js
var require_kanji_data = __commonJS({
  "node_modules/qrcode/lib/core/kanji-data.js"(exports, module) {
    var Mode = require_mode();
    var Utils = require_utils2();
    function KanjiData(data) {
      this.mode = Mode.KANJI;
      this.data = data;
    }
    KanjiData.getBitsLength = function getBitsLength(length2) {
      return length2 * 13;
    };
    KanjiData.prototype.getLength = function getLength() {
      return this.data.length;
    };
    KanjiData.prototype.getBitsLength = function getBitsLength() {
      return KanjiData.getBitsLength(this.data.length);
    };
    KanjiData.prototype.write = function(bitBuffer) {
      let i2;
      for (i2 = 0; i2 < this.data.length; i2++) {
        let value = Utils.toSJIS(this.data[i2]);
        if (value >= 33088 && value <= 40956) {
          value -= 33088;
        } else if (value >= 57408 && value <= 60351) {
          value -= 49472;
        } else {
          throw new Error(
            "Invalid SJIS character: " + this.data[i2] + "\nMake sure your charset is UTF-8"
          );
        }
        value = (value >>> 8 & 255) * 192 + (value & 255);
        bitBuffer.put(value, 13);
      }
    };
    module.exports = KanjiData;
  }
});

// node_modules/qrcode/lib/core/segments.js
var require_segments = __commonJS({
  "node_modules/qrcode/lib/core/segments.js"(exports) {
    var Mode = require_mode();
    var NumericData = require_numeric_data();
    var AlphanumericData = require_alphanumeric_data();
    var ByteData = require_byte_data();
    var KanjiData = require_kanji_data();
    var Regex = require_regex();
    var Utils = require_utils2();
    var dijkstra = require_dijkstra();
    function getStringByteLength(str) {
      return unescape(encodeURIComponent(str)).length;
    }
    function getSegments(regex, mode3, str) {
      const segments = [];
      let result;
      while ((result = regex.exec(str)) !== null) {
        segments.push({
          data: result[0],
          index: result.index,
          mode: mode3,
          length: result[0].length
        });
      }
      return segments;
    }
    function getSegmentsFromString(dataStr) {
      const numSegs = getSegments(Regex.NUMERIC, Mode.NUMERIC, dataStr);
      const alphaNumSegs = getSegments(Regex.ALPHANUMERIC, Mode.ALPHANUMERIC, dataStr);
      let byteSegs;
      let kanjiSegs;
      if (Utils.isKanjiModeEnabled()) {
        byteSegs = getSegments(Regex.BYTE, Mode.BYTE, dataStr);
        kanjiSegs = getSegments(Regex.KANJI, Mode.KANJI, dataStr);
      } else {
        byteSegs = getSegments(Regex.BYTE_KANJI, Mode.BYTE, dataStr);
        kanjiSegs = [];
      }
      const segs = numSegs.concat(alphaNumSegs, byteSegs, kanjiSegs);
      return segs.sort(function(s1, s2) {
        return s1.index - s2.index;
      }).map(function(obj) {
        return {
          data: obj.data,
          mode: obj.mode,
          length: obj.length
        };
      });
    }
    function getSegmentBitsLength(length2, mode3) {
      switch (mode3) {
        case Mode.NUMERIC:
          return NumericData.getBitsLength(length2);
        case Mode.ALPHANUMERIC:
          return AlphanumericData.getBitsLength(length2);
        case Mode.KANJI:
          return KanjiData.getBitsLength(length2);
        case Mode.BYTE:
          return ByteData.getBitsLength(length2);
      }
    }
    function mergeSegments(segs) {
      return segs.reduce(function(acc, curr) {
        const prevSeg = acc.length - 1 >= 0 ? acc[acc.length - 1] : null;
        if (prevSeg && prevSeg.mode === curr.mode) {
          acc[acc.length - 1].data += curr.data;
          return acc;
        }
        acc.push(curr);
        return acc;
      }, []);
    }
    function buildNodes(segs) {
      const nodes = [];
      for (let i2 = 0; i2 < segs.length; i2++) {
        const seg = segs[i2];
        switch (seg.mode) {
          case Mode.NUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.ALPHANUMERIC, length: seg.length },
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.ALPHANUMERIC:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: seg.length }
            ]);
            break;
          case Mode.KANJI:
            nodes.push([
              seg,
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
            break;
          case Mode.BYTE:
            nodes.push([
              { data: seg.data, mode: Mode.BYTE, length: getStringByteLength(seg.data) }
            ]);
        }
      }
      return nodes;
    }
    function buildGraph(nodes, version7) {
      const table = {};
      const graph = { start: {} };
      let prevNodeIds = ["start"];
      for (let i2 = 0; i2 < nodes.length; i2++) {
        const nodeGroup2 = nodes[i2];
        const currentNodeIds = [];
        for (let j3 = 0; j3 < nodeGroup2.length; j3++) {
          const node = nodeGroup2[j3];
          const key = "" + i2 + j3;
          currentNodeIds.push(key);
          table[key] = { node, lastCount: 0 };
          graph[key] = {};
          for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
            const prevNodeId = prevNodeIds[n2];
            if (table[prevNodeId] && table[prevNodeId].node.mode === node.mode) {
              graph[prevNodeId][key] = getSegmentBitsLength(table[prevNodeId].lastCount + node.length, node.mode) - getSegmentBitsLength(table[prevNodeId].lastCount, node.mode);
              table[prevNodeId].lastCount += node.length;
            } else {
              if (table[prevNodeId]) table[prevNodeId].lastCount = node.length;
              graph[prevNodeId][key] = getSegmentBitsLength(node.length, node.mode) + 4 + Mode.getCharCountIndicator(node.mode, version7);
            }
          }
        }
        prevNodeIds = currentNodeIds;
      }
      for (let n2 = 0; n2 < prevNodeIds.length; n2++) {
        graph[prevNodeIds[n2]].end = 0;
      }
      return { map: graph, table };
    }
    function buildSingleSegment(data, modesHint) {
      let mode3;
      const bestMode = Mode.getBestModeForData(data);
      mode3 = Mode.from(modesHint, bestMode);
      if (mode3 !== Mode.BYTE && mode3.bit < bestMode.bit) {
        throw new Error('"' + data + '" cannot be encoded with mode ' + Mode.toString(mode3) + ".\n Suggested mode is: " + Mode.toString(bestMode));
      }
      if (mode3 === Mode.KANJI && !Utils.isKanjiModeEnabled()) {
        mode3 = Mode.BYTE;
      }
      switch (mode3) {
        case Mode.NUMERIC:
          return new NumericData(data);
        case Mode.ALPHANUMERIC:
          return new AlphanumericData(data);
        case Mode.KANJI:
          return new KanjiData(data);
        case Mode.BYTE:
          return new ByteData(data);
      }
    }
    exports.fromArray = function fromArray2(array) {
      return array.reduce(function(acc, seg) {
        if (typeof seg === "string") {
          acc.push(buildSingleSegment(seg, null));
        } else if (seg.data) {
          acc.push(buildSingleSegment(seg.data, seg.mode));
        }
        return acc;
      }, []);
    };
    exports.fromString = function fromString5(data, version7) {
      const segs = getSegmentsFromString(data, Utils.isKanjiModeEnabled());
      const nodes = buildNodes(segs);
      const graph = buildGraph(nodes, version7);
      const path2 = dijkstra.find_path(graph.map, "start", "end");
      const optimizedSegs = [];
      for (let i2 = 1; i2 < path2.length - 1; i2++) {
        optimizedSegs.push(graph.table[path2[i2]].node);
      }
      return exports.fromArray(mergeSegments(optimizedSegs));
    };
    exports.rawSplit = function rawSplit(data) {
      return exports.fromArray(
        getSegmentsFromString(data, Utils.isKanjiModeEnabled())
      );
    };
  }
});

// node_modules/qrcode/lib/core/qrcode.js
var require_qrcode = __commonJS({
  "node_modules/qrcode/lib/core/qrcode.js"(exports) {
    var Utils = require_utils2();
    var ECLevel = require_error_correction_level();
    var BitBuffer = require_bit_buffer();
    var BitMatrix = require_bit_matrix();
    var AlignmentPattern = require_alignment_pattern();
    var FinderPattern = require_finder_pattern();
    var MaskPattern = require_mask_pattern();
    var ECCode = require_error_correction_code();
    var ReedSolomonEncoder = require_reed_solomon_encoder();
    var Version = require_version();
    var FormatInfo = require_format_info();
    var Mode = require_mode();
    var Segments = require_segments();
    function setupFinderPattern(matrix, version7) {
      const size5 = matrix.size;
      const pos = FinderPattern.getPositions(version7);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r2 = -1; r2 <= 7; r2++) {
          if (row + r2 <= -1 || size5 <= row + r2) continue;
          for (let c3 = -1; c3 <= 7; c3++) {
            if (col + c3 <= -1 || size5 <= col + c3) continue;
            if (r2 >= 0 && r2 <= 6 && (c3 === 0 || c3 === 6) || c3 >= 0 && c3 <= 6 && (r2 === 0 || r2 === 6) || r2 >= 2 && r2 <= 4 && c3 >= 2 && c3 <= 4) {
              matrix.set(row + r2, col + c3, true, true);
            } else {
              matrix.set(row + r2, col + c3, false, true);
            }
          }
        }
      }
    }
    function setupTimingPattern(matrix) {
      const size5 = matrix.size;
      for (let r2 = 8; r2 < size5 - 8; r2++) {
        const value = r2 % 2 === 0;
        matrix.set(r2, 6, value, true);
        matrix.set(6, r2, value, true);
      }
    }
    function setupAlignmentPattern(matrix, version7) {
      const pos = AlignmentPattern.getPositions(version7);
      for (let i2 = 0; i2 < pos.length; i2++) {
        const row = pos[i2][0];
        const col = pos[i2][1];
        for (let r2 = -2; r2 <= 2; r2++) {
          for (let c3 = -2; c3 <= 2; c3++) {
            if (r2 === -2 || r2 === 2 || c3 === -2 || c3 === 2 || r2 === 0 && c3 === 0) {
              matrix.set(row + r2, col + c3, true, true);
            } else {
              matrix.set(row + r2, col + c3, false, true);
            }
          }
        }
      }
    }
    function setupVersionInfo(matrix, version7) {
      const size5 = matrix.size;
      const bits = Version.getEncodedBits(version7);
      let row, col, mod2;
      for (let i2 = 0; i2 < 18; i2++) {
        row = Math.floor(i2 / 3);
        col = i2 % 3 + size5 - 8 - 3;
        mod2 = (bits >> i2 & 1) === 1;
        matrix.set(row, col, mod2, true);
        matrix.set(col, row, mod2, true);
      }
    }
    function setupFormatInfo(matrix, errorCorrectionLevel, maskPattern) {
      const size5 = matrix.size;
      const bits = FormatInfo.getEncodedBits(errorCorrectionLevel, maskPattern);
      let i2, mod2;
      for (i2 = 0; i2 < 15; i2++) {
        mod2 = (bits >> i2 & 1) === 1;
        if (i2 < 6) {
          matrix.set(i2, 8, mod2, true);
        } else if (i2 < 8) {
          matrix.set(i2 + 1, 8, mod2, true);
        } else {
          matrix.set(size5 - 15 + i2, 8, mod2, true);
        }
        if (i2 < 8) {
          matrix.set(8, size5 - i2 - 1, mod2, true);
        } else if (i2 < 9) {
          matrix.set(8, 15 - i2 - 1 + 1, mod2, true);
        } else {
          matrix.set(8, 15 - i2 - 1, mod2, true);
        }
      }
      matrix.set(size5 - 8, 8, 1, true);
    }
    function setupData(matrix, data) {
      const size5 = matrix.size;
      let inc = -1;
      let row = size5 - 1;
      let bitIndex = 7;
      let byteIndex = 0;
      for (let col = size5 - 1; col > 0; col -= 2) {
        if (col === 6) col--;
        while (true) {
          for (let c3 = 0; c3 < 2; c3++) {
            if (!matrix.isReserved(row, col - c3)) {
              let dark = false;
              if (byteIndex < data.length) {
                dark = (data[byteIndex] >>> bitIndex & 1) === 1;
              }
              matrix.set(row, col - c3, dark);
              bitIndex--;
              if (bitIndex === -1) {
                byteIndex++;
                bitIndex = 7;
              }
            }
          }
          row += inc;
          if (row < 0 || size5 <= row) {
            row -= inc;
            inc = -inc;
            break;
          }
        }
      }
    }
    function createData(version7, errorCorrectionLevel, segments) {
      const buffer3 = new BitBuffer();
      segments.forEach(function(data) {
        buffer3.put(data.mode.bit, 4);
        buffer3.put(data.getLength(), Mode.getCharCountIndicator(data.mode, version7));
        data.write(buffer3);
      });
      const totalCodewords = Utils.getSymbolTotalCodewords(version7);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version7, errorCorrectionLevel);
      const dataTotalCodewordsBits = (totalCodewords - ecTotalCodewords) * 8;
      if (buffer3.getLengthInBits() + 4 <= dataTotalCodewordsBits) {
        buffer3.put(0, 4);
      }
      while (buffer3.getLengthInBits() % 8 !== 0) {
        buffer3.putBit(0);
      }
      const remainingByte = (dataTotalCodewordsBits - buffer3.getLengthInBits()) / 8;
      for (let i2 = 0; i2 < remainingByte; i2++) {
        buffer3.put(i2 % 2 ? 17 : 236, 8);
      }
      return createCodewords(buffer3, version7, errorCorrectionLevel);
    }
    function createCodewords(bitBuffer, version7, errorCorrectionLevel) {
      const totalCodewords = Utils.getSymbolTotalCodewords(version7);
      const ecTotalCodewords = ECCode.getTotalCodewordsCount(version7, errorCorrectionLevel);
      const dataTotalCodewords = totalCodewords - ecTotalCodewords;
      const ecTotalBlocks = ECCode.getBlocksCount(version7, errorCorrectionLevel);
      const blocksInGroup2 = totalCodewords % ecTotalBlocks;
      const blocksInGroup1 = ecTotalBlocks - blocksInGroup2;
      const totalCodewordsInGroup1 = Math.floor(totalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup1 = Math.floor(dataTotalCodewords / ecTotalBlocks);
      const dataCodewordsInGroup2 = dataCodewordsInGroup1 + 1;
      const ecCount = totalCodewordsInGroup1 - dataCodewordsInGroup1;
      const rs2 = new ReedSolomonEncoder(ecCount);
      let offset = 0;
      const dcData = new Array(ecTotalBlocks);
      const ecData = new Array(ecTotalBlocks);
      let maxDataSize = 0;
      const buffer3 = new Uint8Array(bitBuffer.buffer);
      for (let b4 = 0; b4 < ecTotalBlocks; b4++) {
        const dataSize = b4 < blocksInGroup1 ? dataCodewordsInGroup1 : dataCodewordsInGroup2;
        dcData[b4] = buffer3.slice(offset, offset + dataSize);
        ecData[b4] = rs2.encode(dcData[b4]);
        offset += dataSize;
        maxDataSize = Math.max(maxDataSize, dataSize);
      }
      const data = new Uint8Array(totalCodewords);
      let index5 = 0;
      let i2, r2;
      for (i2 = 0; i2 < maxDataSize; i2++) {
        for (r2 = 0; r2 < ecTotalBlocks; r2++) {
          if (i2 < dcData[r2].length) {
            data[index5++] = dcData[r2][i2];
          }
        }
      }
      for (i2 = 0; i2 < ecCount; i2++) {
        for (r2 = 0; r2 < ecTotalBlocks; r2++) {
          data[index5++] = ecData[r2][i2];
        }
      }
      return data;
    }
    function createSymbol(data, version7, errorCorrectionLevel, maskPattern) {
      let segments;
      if (Array.isArray(data)) {
        segments = Segments.fromArray(data);
      } else if (typeof data === "string") {
        let estimatedVersion = version7;
        if (!estimatedVersion) {
          const rawSegments = Segments.rawSplit(data);
          estimatedVersion = Version.getBestVersionForData(rawSegments, errorCorrectionLevel);
        }
        segments = Segments.fromString(data, estimatedVersion || 40);
      } else {
        throw new Error("Invalid data");
      }
      const bestVersion = Version.getBestVersionForData(segments, errorCorrectionLevel);
      if (!bestVersion) {
        throw new Error("The amount of data is too big to be stored in a QR Code");
      }
      if (!version7) {
        version7 = bestVersion;
      } else if (version7 < bestVersion) {
        throw new Error(
          "\nThe chosen QR Code version cannot contain this amount of data.\nMinimum version required to store current data is: " + bestVersion + ".\n"
        );
      }
      const dataBits = createData(version7, errorCorrectionLevel, segments);
      const moduleCount = Utils.getSymbolSize(version7);
      const modules = new BitMatrix(moduleCount);
      setupFinderPattern(modules, version7);
      setupTimingPattern(modules);
      setupAlignmentPattern(modules, version7);
      setupFormatInfo(modules, errorCorrectionLevel, 0);
      if (version7 >= 7) {
        setupVersionInfo(modules, version7);
      }
      setupData(modules, dataBits);
      if (isNaN(maskPattern)) {
        maskPattern = MaskPattern.getBestMask(
          modules,
          setupFormatInfo.bind(null, modules, errorCorrectionLevel)
        );
      }
      MaskPattern.applyMask(maskPattern, modules);
      setupFormatInfo(modules, errorCorrectionLevel, maskPattern);
      return {
        modules,
        version: version7,
        errorCorrectionLevel,
        maskPattern,
        segments
      };
    }
    exports.create = function create5(data, options) {
      if (typeof data === "undefined" || data === "") {
        throw new Error("No input text");
      }
      let errorCorrectionLevel = ECLevel.M;
      let version7;
      let mask;
      if (typeof options !== "undefined") {
        errorCorrectionLevel = ECLevel.from(options.errorCorrectionLevel, ECLevel.M);
        version7 = Version.from(options.version);
        mask = MaskPattern.from(options.maskPattern);
        if (options.toSJISFunc) {
          Utils.setToSJISFunction(options.toSJISFunc);
        }
      }
      return createSymbol(data, version7, errorCorrectionLevel, mask);
    };
  }
});

// node_modules/qrcode/lib/renderer/utils.js
var require_utils3 = __commonJS({
  "node_modules/qrcode/lib/renderer/utils.js"(exports) {
    function hex2rgba(hex3) {
      if (typeof hex3 === "number") {
        hex3 = hex3.toString();
      }
      if (typeof hex3 !== "string") {
        throw new Error("Color should be defined as hex string");
      }
      let hexCode = hex3.slice().replace("#", "").split("");
      if (hexCode.length < 3 || hexCode.length === 5 || hexCode.length > 8) {
        throw new Error("Invalid hex color: " + hex3);
      }
      if (hexCode.length === 3 || hexCode.length === 4) {
        hexCode = Array.prototype.concat.apply([], hexCode.map(function(c3) {
          return [c3, c3];
        }));
      }
      if (hexCode.length === 6) hexCode.push("F", "F");
      const hexValue = parseInt(hexCode.join(""), 16);
      return {
        r: hexValue >> 24 & 255,
        g: hexValue >> 16 & 255,
        b: hexValue >> 8 & 255,
        a: hexValue & 255,
        hex: "#" + hexCode.slice(0, 6).join("")
      };
    }
    exports.getOptions = function getOptions2(options) {
      if (!options) options = {};
      if (!options.color) options.color = {};
      const margin = typeof options.margin === "undefined" || options.margin === null || options.margin < 0 ? 4 : options.margin;
      const width = options.width && options.width >= 21 ? options.width : void 0;
      const scale2 = options.scale || 4;
      return {
        width,
        scale: width ? 4 : scale2,
        margin,
        color: {
          dark: hex2rgba(options.color.dark || "#000000ff"),
          light: hex2rgba(options.color.light || "#ffffffff")
        },
        type: options.type,
        rendererOpts: options.rendererOpts || {}
      };
    };
    exports.getScale = function getScale(qrSize, opts) {
      return opts.width && opts.width >= qrSize + opts.margin * 2 ? opts.width / (qrSize + opts.margin * 2) : opts.scale;
    };
    exports.getImageWidth = function getImageWidth(qrSize, opts) {
      const scale2 = exports.getScale(qrSize, opts);
      return Math.floor((qrSize + opts.margin * 2) * scale2);
    };
    exports.qrToImageData = function qrToImageData(imgData, qr2, opts) {
      const size5 = qr2.modules.size;
      const data = qr2.modules.data;
      const scale2 = exports.getScale(size5, opts);
      const symbolSize = Math.floor((size5 + opts.margin * 2) * scale2);
      const scaledMargin = opts.margin * scale2;
      const palette = [opts.color.light, opts.color.dark];
      for (let i2 = 0; i2 < symbolSize; i2++) {
        for (let j3 = 0; j3 < symbolSize; j3++) {
          let posDst = (i2 * symbolSize + j3) * 4;
          let pxColor = opts.color.light;
          if (i2 >= scaledMargin && j3 >= scaledMargin && i2 < symbolSize - scaledMargin && j3 < symbolSize - scaledMargin) {
            const iSrc = Math.floor((i2 - scaledMargin) / scale2);
            const jSrc = Math.floor((j3 - scaledMargin) / scale2);
            pxColor = palette[data[iSrc * size5 + jSrc] ? 1 : 0];
          }
          imgData[posDst++] = pxColor.r;
          imgData[posDst++] = pxColor.g;
          imgData[posDst++] = pxColor.b;
          imgData[posDst] = pxColor.a;
        }
      }
    };
  }
});

// node_modules/qrcode/lib/renderer/canvas.js
var require_canvas = __commonJS({
  "node_modules/qrcode/lib/renderer/canvas.js"(exports) {
    var Utils = require_utils3();
    function clearCanvas(ctx, canvas, size5) {
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      if (!canvas.style) canvas.style = {};
      canvas.height = size5;
      canvas.width = size5;
      canvas.style.height = size5 + "px";
      canvas.style.width = size5 + "px";
    }
    function getCanvasElement() {
      try {
        return document.createElement("canvas");
      } catch (e2) {
        throw new Error("You need to specify a canvas element");
      }
    }
    exports.render = function render(qrData, canvas, options) {
      let opts = options;
      let canvasEl = canvas;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!canvas) {
        canvasEl = getCanvasElement();
      }
      opts = Utils.getOptions(opts);
      const size5 = Utils.getImageWidth(qrData.modules.size, opts);
      const ctx = canvasEl.getContext("2d");
      const image = ctx.createImageData(size5, size5);
      Utils.qrToImageData(image.data, qrData, opts);
      clearCanvas(ctx, canvasEl, size5);
      ctx.putImageData(image, 0, 0);
      return canvasEl;
    };
    exports.renderToDataURL = function renderToDataURL(qrData, canvas, options) {
      let opts = options;
      if (typeof opts === "undefined" && (!canvas || !canvas.getContext)) {
        opts = canvas;
        canvas = void 0;
      }
      if (!opts) opts = {};
      const canvasEl = exports.render(qrData, canvas, opts);
      const type6 = opts.type || "image/png";
      const rendererOpts = opts.rendererOpts || {};
      return canvasEl.toDataURL(type6, rendererOpts.quality);
    };
  }
});

// node_modules/qrcode/lib/renderer/svg-tag.js
var require_svg_tag = __commonJS({
  "node_modules/qrcode/lib/renderer/svg-tag.js"(exports) {
    var Utils = require_utils3();
    function getColorAttrib(color2, attrib) {
      const alpha2 = color2.a / 255;
      const str = attrib + '="' + color2.hex + '"';
      return alpha2 < 1 ? str + " " + attrib + '-opacity="' + alpha2.toFixed(2).slice(1) + '"' : str;
    }
    function svgCmd(cmd, x2, y2) {
      let str = cmd + x2;
      if (typeof y2 !== "undefined") str += " " + y2;
      return str;
    }
    function qrToPath(data, size5, margin) {
      let path2 = "";
      let moveBy = 0;
      let newRow = false;
      let lineLength = 0;
      for (let i2 = 0; i2 < data.length; i2++) {
        const col = Math.floor(i2 % size5);
        const row = Math.floor(i2 / size5);
        if (!col && !newRow) newRow = true;
        if (data[i2]) {
          lineLength++;
          if (!(i2 > 0 && col > 0 && data[i2 - 1])) {
            path2 += newRow ? svgCmd("M", col + margin, 0.5 + row + margin) : svgCmd("m", moveBy, 0);
            moveBy = 0;
            newRow = false;
          }
          if (!(col + 1 < size5 && data[i2 + 1])) {
            path2 += svgCmd("h", lineLength);
            lineLength = 0;
          }
        } else {
          moveBy++;
        }
      }
      return path2;
    }
    exports.render = function render(qrData, options, cb2) {
      const opts = Utils.getOptions(options);
      const size5 = qrData.modules.size;
      const data = qrData.modules.data;
      const qrcodesize = size5 + opts.margin * 2;
      const bg = !opts.color.light.a ? "" : "<path " + getColorAttrib(opts.color.light, "fill") + ' d="M0 0h' + qrcodesize + "v" + qrcodesize + 'H0z"/>';
      const path2 = "<path " + getColorAttrib(opts.color.dark, "stroke") + ' d="' + qrToPath(data, size5, opts.margin) + '"/>';
      const viewBox = 'viewBox="0 0 ' + qrcodesize + " " + qrcodesize + '"';
      const width = !opts.width ? "" : 'width="' + opts.width + '" height="' + opts.width + '" ';
      const svgTag = '<svg xmlns="http://www.w3.org/2000/svg" ' + width + viewBox + ' shape-rendering="crispEdges">' + bg + path2 + "</svg>\n";
      if (typeof cb2 === "function") {
        cb2(null, svgTag);
      }
      return svgTag;
    };
  }
});

// node_modules/qrcode/lib/browser.js
var require_browser = __commonJS({
  "node_modules/qrcode/lib/browser.js"(exports) {
    var canPromise = require_can_promise();
    var QRCode2 = require_qrcode();
    var CanvasRenderer = require_canvas();
    var SvgRenderer = require_svg_tag();
    function renderCanvas(renderFunc, canvas, text, opts, cb2) {
      const args = [].slice.call(arguments, 1);
      const argsNum = args.length;
      const isLastArgCb = typeof args[argsNum - 1] === "function";
      if (!isLastArgCb && !canPromise()) {
        throw new Error("Callback required as last argument");
      }
      if (isLastArgCb) {
        if (argsNum < 2) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 2) {
          cb2 = text;
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 3) {
          if (canvas.getContext && typeof cb2 === "undefined") {
            cb2 = opts;
            opts = void 0;
          } else {
            cb2 = opts;
            opts = text;
            text = canvas;
            canvas = void 0;
          }
        }
      } else {
        if (argsNum < 1) {
          throw new Error("Too few arguments provided");
        }
        if (argsNum === 1) {
          text = canvas;
          canvas = opts = void 0;
        } else if (argsNum === 2 && !canvas.getContext) {
          opts = text;
          text = canvas;
          canvas = void 0;
        }
        return new Promise(function(resolve, reject) {
          try {
            const data = QRCode2.create(text, opts);
            resolve(renderFunc(data, canvas, opts));
          } catch (e2) {
            reject(e2);
          }
        });
      }
      try {
        const data = QRCode2.create(text, opts);
        cb2(null, renderFunc(data, canvas, opts));
      } catch (e2) {
        cb2(e2);
      }
    }
    exports.create = QRCode2.create;
    exports.toCanvas = renderCanvas.bind(null, CanvasRenderer.render);
    exports.toDataURL = renderCanvas.bind(null, CanvasRenderer.renderToDataURL);
    exports.toString = renderCanvas.bind(null, function(data, _2, opts) {
      return SvgRenderer.render(data, opts);
    });
  }
});

// node_modules/apg-js/src/apg-lib/identifiers.js
var require_identifiers = __commonJS({
  "node_modules/apg-js/src/apg-lib/identifiers.js"(exports, module) {
    module.exports = {
      // Identifies the operator type. Used by the generator
      // to indicate operator types in the grammar object.
      // Used by the [parser](./parser.html) when interpreting the grammar object.
      /* the original ABNF operators */
      ALT: 1,
      CAT: 2,
      REP: 3,
      RNM: 4,
      TRG: 5,
      TBS: 6,
      TLS: 7,
      /* the super set, SABNF operators */
      UDT: 11,
      AND: 12,
      NOT: 13,
      BKR: 14,
      BKA: 15,
      BKN: 16,
      ABG: 17,
      AEN: 18,
      // Used by the parser and the user's `RNM` and `UDT` callback functions.
      // Identifies the parser state as it traverses the parse tree nodes.
      // - *ACTIVE* - indicates the downward direction through the parse tree node.
      // - *MATCH* - indicates the upward direction and a phrase, of length \> 0, has been successfully matched
      // - *EMPTY* - indicates the upward direction and a phrase, of length = 0, has been successfully matched
      // - *NOMATCH* - indicates the upward direction and the parser failed to match any phrase at all
      ACTIVE: 100,
      MATCH: 101,
      EMPTY: 102,
      NOMATCH: 103,
      // Used by [`AST` translator](./ast.html) (semantic analysis) and the user's callback functions
      // to indicate the direction of flow through the `AST` nodes.
      // - *SEM_PRE* - indicates the downward (pre-branch) direction through the `AST` node.
      // - *SEM_POST* - indicates the upward (post-branch) direction through the `AST` node.
      SEM_PRE: 200,
      SEM_POST: 201,
      // Used by the user's callback functions to indicate to the `AST` translator (semantic analysis) how to proceed.
      // - *SEM_OK* - normal return value
      // - *SEM_SKIP* - if a callback function returns this value from the SEM_PRE state,
      // the translator will skip processing all `AST` nodes in the branch below the current node.
      // Ignored if returned from the SEM_POST state.
      SEM_OK: 300,
      SEM_SKIP: 301,
      // Used in attribute generation to distinguish the necessary attribute categories.
      // - *ATTR_N* - non-recursive
      // - *ATTR_R* - recursive
      // - *ATTR_MR* - belongs to a mutually-recursive set
      ATTR_N: 400,
      ATTR_R: 401,
      ATTR_MR: 402,
      // Look around values indicate whether the parser is in look ahead or look behind mode.
      // Used by the tracing facility to indicate the look around mode in the trace records display.
      // - *LOOKAROUND_NONE* - the parser is in normal parsing mode
      // - *LOOKAROUND_AHEAD* - the parse is in look-ahead mode, phrase matching for operator `AND(&)` or `NOT(!)`
      // - *LOOKAROUND_BEHIND* - the parse is in look-behind mode, phrase matching for operator `BKA(&&)` or `BKN(!!)`
      LOOKAROUND_NONE: 500,
      LOOKAROUND_AHEAD: 501,
      LOOKAROUND_BEHIND: 502,
      // Back reference rule mode indicators
      // - *BKR_MODE_UM* - the back reference is using universal mode
      // - *BKR_MODE_PM* - the back reference is using parent frame mode
      // - *BKR_MODE_CS* - the back reference is using case-sensitive phrase matching
      // - *BKR_MODE_CI* - the back reference is using case-insensitive phrase matching
      BKR_MODE_UM: 601,
      BKR_MODE_PM: 602,
      BKR_MODE_CS: 603,
      BKR_MODE_CI: 604
    };
  }
});

// node_modules/apg-js/src/apg-lib/style.js
var require_style = __commonJS({
  "node_modules/apg-js/src/apg-lib/style.js"(exports, module) {
    module.exports = {
      // Generated by apglib/style.js 
      CLASS_MONOSPACE: "apg-mono",
      CLASS_ACTIVE: "apg-active",
      CLASS_EMPTY: "apg-empty",
      CLASS_MATCH: "apg-match",
      CLASS_NOMATCH: "apg-nomatch",
      CLASS_LOOKAHEAD: "apg-lh-match",
      CLASS_LOOKBEHIND: "apg-lb-match",
      CLASS_REMAINDER: "apg-remainder",
      CLASS_CTRLCHAR: "apg-ctrl-char",
      CLASS_LINEEND: "apg-line-end",
      CLASS_ERROR: "apg-error",
      CLASS_PHRASE: "apg-phrase",
      CLASS_EMPTYPHRASE: "apg-empty-phrase",
      CLASS_STATE: "apg-state",
      CLASS_STATS: "apg-stats",
      CLASS_TRACE: "apg-trace",
      CLASS_GRAMMAR: "apg-grammar",
      CLASS_RULES: "apg-rules",
      CLASS_RULESLINK: "apg-rules-link",
      CLASS_ATTRIBUTES: "apg-attrs"
    };
  }
});

// node_modules/apg-js/src/apg-conv-api/transformers.js
var require_transformers = __commonJS({
  "node_modules/apg-js/src/apg-conv-api/transformers.js"(exports) {
    "use strict;";
    var { Buffer: Buffer3 } = require_buffer();
    var NON_SHORTEST = 4294967292;
    var TRAILING = 4294967293;
    var RANGE = 4294967294;
    var ILL_FORMED = 4294967295;
    var mask = [0, 1, 3, 7, 15, 31, 63, 127, 255, 511, 1023];
    var ascii = [
      "00",
      "01",
      "02",
      "03",
      "04",
      "05",
      "06",
      "07",
      "08",
      "09",
      "0A",
      "0B",
      "0C",
      "0D",
      "0E",
      "0F",
      "10",
      "11",
      "12",
      "13",
      "14",
      "15",
      "16",
      "17",
      "18",
      "19",
      "1A",
      "1B",
      "1C",
      "1D",
      "1E",
      "1F",
      "20",
      "21",
      "22",
      "23",
      "24",
      "25",
      "26",
      "27",
      "28",
      "29",
      "2A",
      "2B",
      "2C",
      "2D",
      "2E",
      "2F",
      "30",
      "31",
      "32",
      "33",
      "34",
      "35",
      "36",
      "37",
      "38",
      "39",
      "3A",
      "3B",
      "3C",
      "3D",
      "3E",
      "3F",
      "40",
      "41",
      "42",
      "43",
      "44",
      "45",
      "46",
      "47",
      "48",
      "49",
      "4A",
      "4B",
      "4C",
      "4D",
      "4E",
      "4F",
      "50",
      "51",
      "52",
      "53",
      "54",
      "55",
      "56",
      "57",
      "58",
      "59",
      "5A",
      "5B",
      "5C",
      "5D",
      "5E",
      "5F",
      "60",
      "61",
      "62",
      "63",
      "64",
      "65",
      "66",
      "67",
      "68",
      "69",
      "6A",
      "6B",
      "6C",
      "6D",
      "6E",
      "6F",
      "70",
      "71",
      "72",
      "73",
      "74",
      "75",
      "76",
      "77",
      "78",
      "79",
      "7A",
      "7B",
      "7C",
      "7D",
      "7E",
      "7F",
      "80",
      "81",
      "82",
      "83",
      "84",
      "85",
      "86",
      "87",
      "88",
      "89",
      "8A",
      "8B",
      "8C",
      "8D",
      "8E",
      "8F",
      "90",
      "91",
      "92",
      "93",
      "94",
      "95",
      "96",
      "97",
      "98",
      "99",
      "9A",
      "9B",
      "9C",
      "9D",
      "9E",
      "9F",
      "A0",
      "A1",
      "A2",
      "A3",
      "A4",
      "A5",
      "A6",
      "A7",
      "A8",
      "A9",
      "AA",
      "AB",
      "AC",
      "AD",
      "AE",
      "AF",
      "B0",
      "B1",
      "B2",
      "B3",
      "B4",
      "B5",
      "B6",
      "B7",
      "B8",
      "B9",
      "BA",
      "BB",
      "BC",
      "BD",
      "BE",
      "BF",
      "C0",
      "C1",
      "C2",
      "C3",
      "C4",
      "C5",
      "C6",
      "C7",
      "C8",
      "C9",
      "CA",
      "CB",
      "CC",
      "CD",
      "CE",
      "CF",
      "D0",
      "D1",
      "D2",
      "D3",
      "D4",
      "D5",
      "D6",
      "D7",
      "D8",
      "D9",
      "DA",
      "DB",
      "DC",
      "DD",
      "DE",
      "DF",
      "E0",
      "E1",
      "E2",
      "E3",
      "E4",
      "E5",
      "E6",
      "E7",
      "E8",
      "E9",
      "EA",
      "EB",
      "EC",
      "ED",
      "EE",
      "EF",
      "F0",
      "F1",
      "F2",
      "F3",
      "F4",
      "F5",
      "F6",
      "F7",
      "F8",
      "F9",
      "FA",
      "FB",
      "FC",
      "FD",
      "FE",
      "FF"
    ];
    var base64chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".split("");
    var base64codes = [];
    base64chars.forEach((char) => {
      base64codes.push(char.charCodeAt(0));
    });
    exports.utf8 = {
      encode(chars) {
        const bytes = [];
        chars.forEach((char) => {
          if (char >= 0 && char <= 127) {
            bytes.push(char);
          } else if (char <= 2047) {
            bytes.push(192 + (char >> 6 & mask[5]));
            bytes.push(128 + (char & mask[6]));
          } else if (char < 55296 || char > 57343 && char <= 65535) {
            bytes.push(224 + (char >> 12 & mask[4]));
            bytes.push(128 + (char >> 6 & mask[6]));
            bytes.push(128 + (char & mask[6]));
          } else if (char >= 65536 && char <= 1114111) {
            const u3 = char >> 16 & mask[5];
            bytes.push(240 + (u3 >> 2));
            bytes.push(128 + ((u3 & mask[2]) << 4) + (char >> 12 & mask[4]));
            bytes.push(128 + (char >> 6 & mask[6]));
            bytes.push(128 + (char & mask[6]));
          } else {
            throw new RangeError(`utf8.encode: character out of range: char: ${char}`);
          }
        });
        return Buffer3.from(bytes);
      },
      decode(buf, bom) {
        function bytes2(b12, b22) {
          if ((b22 & 192) !== 128) {
            return TRAILING;
          }
          const x2 = ((b12 & mask[5]) << 6) + (b22 & mask[6]);
          if (x2 < 128) {
            return NON_SHORTEST;
          }
          return x2;
        }
        function bytes3(b12, b22, b32) {
          if ((b32 & 192) !== 128 || (b22 & 192) !== 128) {
            return TRAILING;
          }
          const x2 = ((b12 & mask[4]) << 12) + ((b22 & mask[6]) << 6) + (b32 & mask[6]);
          if (x2 < 2048) {
            return NON_SHORTEST;
          }
          if (x2 >= 55296 && x2 <= 57343) {
            return RANGE;
          }
          return x2;
        }
        function bytes4(b12, b22, b32, b4) {
          if ((b4 & 192) !== 128 || (b32 & 192) !== 128 || (b22 & 192) !== 128) {
            return TRAILING;
          }
          const x2 = (((b12 & mask[3]) << 2) + (b22 >> 4 & mask[2]) << 16) + ((b22 & mask[4]) << 12) + ((b32 & mask[6]) << 6) + (b4 & mask[6]);
          if (x2 < 65536) {
            return NON_SHORTEST;
          }
          if (x2 > 1114111) {
            return RANGE;
          }
          return x2;
        }
        let c3;
        let b1;
        let i1;
        let i2;
        let i3;
        let inc;
        const len = buf.length;
        let i4 = bom ? 3 : 0;
        const chars = [];
        while (i4 < len) {
          b1 = buf[i4];
          c3 = ILL_FORMED;
          const TRUE = true;
          while (TRUE) {
            if (b1 >= 0 && b1 <= 127) {
              c3 = b1;
              inc = 1;
              break;
            }
            i1 = i4 + 1;
            if (i1 < len && b1 >= 194 && b1 <= 223) {
              c3 = bytes2(b1, buf[i1]);
              inc = 2;
              break;
            }
            i2 = i4 + 2;
            if (i2 < len && b1 >= 224 && b1 <= 239) {
              c3 = bytes3(b1, buf[i1], buf[i2]);
              inc = 3;
              break;
            }
            i3 = i4 + 3;
            if (i3 < len && b1 >= 240 && b1 <= 244) {
              c3 = bytes4(b1, buf[i1], buf[i2], buf[i3]);
              inc = 4;
              break;
            }
            break;
          }
          if (c3 > 1114111) {
            const at2 = `byte[${i4}]`;
            if (c3 === ILL_FORMED) {
              throw new RangeError(`utf8.decode: ill-formed UTF8 byte sequence found at: ${at2}`);
            }
            if (c3 === TRAILING) {
              throw new RangeError(`utf8.decode: illegal trailing byte found at: ${at2}`);
            }
            if (c3 === RANGE) {
              throw new RangeError(`utf8.decode: code point out of range found at: ${at2}`);
            }
            if (c3 === NON_SHORTEST) {
              throw new RangeError(`utf8.decode: non-shortest form found at: ${at2}`);
            }
            throw new RangeError(`utf8.decode: unrecognized error found at: ${at2}`);
          }
          chars.push(c3);
          i4 += inc;
        }
        return chars;
      }
    };
    exports.utf16be = {
      encode(chars) {
        const bytes = [];
        let char;
        let h;
        let l3;
        for (let i2 = 0; i2 < chars.length; i2 += 1) {
          char = chars[i2];
          if (char >= 0 && char <= 55295 || char >= 57344 && char <= 65535) {
            bytes.push(char >> 8 & mask[8]);
            bytes.push(char & mask[8]);
          } else if (char >= 65536 && char <= 1114111) {
            l3 = char - 65536;
            h = 55296 + (l3 >> 10);
            l3 = 56320 + (l3 & mask[10]);
            bytes.push(h >> 8 & mask[8]);
            bytes.push(h & mask[8]);
            bytes.push(l3 >> 8 & mask[8]);
            bytes.push(l3 & mask[8]);
          } else {
            throw new RangeError(`utf16be.encode: UTF16BE value out of range: char[${i2}]: ${char}`);
          }
        }
        return Buffer3.from(bytes);
      },
      decode(buf, bom) {
        if (buf.length % 2 > 0) {
          throw new RangeError(`utf16be.decode: data length must be even multiple of 2: length: ${buf.length}`);
        }
        const chars = [];
        const len = buf.length;
        let i2 = bom ? 2 : 0;
        let j3 = 0;
        let c3;
        let inc;
        let i1;
        let i3;
        let high;
        let low;
        while (i2 < len) {
          const TRUE = true;
          while (TRUE) {
            i1 = i2 + 1;
            if (i1 < len) {
              high = (buf[i2] << 8) + buf[i1];
              if (high < 55296 || high > 57343) {
                c3 = high;
                inc = 2;
                break;
              }
              i3 = i2 + 3;
              if (i3 < len) {
                low = (buf[i2 + 2] << 8) + buf[i3];
                if (high <= 56319 && low >= 56320 && low <= 57343) {
                  c3 = 65536 + (high - 55296 << 10) + (low - 56320);
                  inc = 4;
                  break;
                }
              }
            }
            throw new RangeError(`utf16be.decode: ill-formed UTF16BE byte sequence found: byte[${i2}]`);
          }
          chars[j3++] = c3;
          i2 += inc;
        }
        return chars;
      }
    };
    exports.utf16le = {
      encode(chars) {
        const bytes = [];
        let char;
        let h;
        let l3;
        for (let i2 = 0; i2 < chars.length; i2 += 1) {
          char = chars[i2];
          if (char >= 0 && char <= 55295 || char >= 57344 && char <= 65535) {
            bytes.push(char & mask[8]);
            bytes.push(char >> 8 & mask[8]);
          } else if (char >= 65536 && char <= 1114111) {
            l3 = char - 65536;
            h = 55296 + (l3 >> 10);
            l3 = 56320 + (l3 & mask[10]);
            bytes.push(h & mask[8]);
            bytes.push(h >> 8 & mask[8]);
            bytes.push(l3 & mask[8]);
            bytes.push(l3 >> 8 & mask[8]);
          } else {
            throw new RangeError(`utf16le.encode: UTF16LE value out of range: char[${i2}]: ${char}`);
          }
        }
        return Buffer3.from(bytes);
      },
      decode(buf, bom) {
        if (buf.length % 2 > 0) {
          throw new RangeError(`utf16le.decode: data length must be even multiple of 2: length: ${buf.length}`);
        }
        const chars = [];
        const len = buf.length;
        let i2 = bom ? 2 : 0;
        let j3 = 0;
        let c3;
        let inc;
        let i1;
        let i3;
        let high;
        let low;
        while (i2 < len) {
          const TRUE = true;
          while (TRUE) {
            i1 = i2 + 1;
            if (i1 < len) {
              high = (buf[i1] << 8) + buf[i2];
              if (high < 55296 || high > 57343) {
                c3 = high;
                inc = 2;
                break;
              }
              i3 = i2 + 3;
              if (i3 < len) {
                low = (buf[i3] << 8) + buf[i2 + 2];
                if (high <= 56319 && low >= 56320 && low <= 57343) {
                  c3 = 65536 + (high - 55296 << 10) + (low - 56320);
                  inc = 4;
                  break;
                }
              }
            }
            throw new RangeError(`utf16le.decode: ill-formed UTF16LE byte sequence found: byte[${i2}]`);
          }
          chars[j3++] = c3;
          i2 += inc;
        }
        return chars;
      }
    };
    exports.utf32be = {
      encode(chars) {
        const buf = Buffer3.alloc(chars.length * 4);
        let i2 = 0;
        chars.forEach((char) => {
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32be.encode: UTF32BE character code out of range: char[${i2 / 4}]: ${char}`);
          }
          buf[i2++] = char >> 24 & mask[8];
          buf[i2++] = char >> 16 & mask[8];
          buf[i2++] = char >> 8 & mask[8];
          buf[i2++] = char & mask[8];
        });
        return buf;
      },
      decode(buf, bom) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`utf32be.decode: UTF32BE byte length must be even multiple of 4: length: ${buf.length}`);
        }
        const chars = [];
        let i2 = bom ? 4 : 0;
        for (; i2 < buf.length; i2 += 4) {
          const char = (buf[i2] << 24) + (buf[i2 + 1] << 16) + (buf[i2 + 2] << 8) + buf[i2 + 3];
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32be.decode: UTF32BE character code out of range: char[${i2 / 4}]: ${char}`);
          }
          chars.push(char);
        }
        return chars;
      }
    };
    exports.utf32le = {
      encode(chars) {
        const buf = Buffer3.alloc(chars.length * 4);
        let i2 = 0;
        chars.forEach((char) => {
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i2 / 4}]: ${char}`);
          }
          buf[i2++] = char & mask[8];
          buf[i2++] = char >> 8 & mask[8];
          buf[i2++] = char >> 16 & mask[8];
          buf[i2++] = char >> 24 & mask[8];
        });
        return buf;
      },
      decode(buf, bom) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`utf32be.decode: UTF32LE byte length must be even multiple of 4: length: ${buf.length}`);
        }
        const chars = [];
        let i2 = bom ? 4 : 0;
        for (; i2 < buf.length; i2 += 4) {
          const char = (buf[i2 + 3] << 24) + (buf[i2 + 2] << 16) + (buf[i2 + 1] << 8) + buf[i2];
          if (char >= 55296 && char <= 57343 || char > 1114111) {
            throw new RangeError(`utf32le.encode: UTF32LE character code out of range: char[${i2 / 4}]: ${char}`);
          }
          chars.push(char);
        }
        return chars;
      }
    };
    exports.uint7 = {
      encode(chars) {
        const buf = Buffer3.alloc(chars.length);
        for (let i2 = 0; i2 < chars.length; i2 += 1) {
          if (chars[i2] > 127) {
            throw new RangeError(`uint7.encode: UINT7 character code out of range: char[${i2}]: ${chars[i2]}`);
          }
          buf[i2] = chars[i2];
        }
        return buf;
      },
      decode(buf) {
        const chars = [];
        for (let i2 = 0; i2 < buf.length; i2 += 1) {
          if (buf[i2] > 127) {
            throw new RangeError(`uint7.decode: UINT7 character code out of range: byte[${i2}]: ${buf[i2]}`);
          }
          chars[i2] = buf[i2];
        }
        return chars;
      }
    };
    exports.uint8 = {
      encode(chars) {
        const buf = Buffer3.alloc(chars.length);
        for (let i2 = 0; i2 < chars.length; i2 += 1) {
          if (chars[i2] > 255) {
            throw new RangeError(`uint8.encode: UINT8 character code out of range: char[${i2}]: ${chars[i2]}`);
          }
          buf[i2] = chars[i2];
        }
        return buf;
      },
      decode(buf) {
        const chars = [];
        for (let i2 = 0; i2 < buf.length; i2 += 1) {
          chars[i2] = buf[i2];
        }
        return chars;
      }
    };
    exports.uint16be = {
      encode(chars) {
        const buf = Buffer3.alloc(chars.length * 2);
        let i2 = 0;
        chars.forEach((char) => {
          if (char > 65535) {
            throw new RangeError(`uint16be.encode: UINT16BE character code out of range: char[${i2 / 2}]: ${char}`);
          }
          buf[i2++] = char >> 8 & mask[8];
          buf[i2++] = char & mask[8];
        });
        return buf;
      },
      decode(buf) {
        if (buf.length % 2 > 0) {
          throw new RangeError(`uint16be.decode: UINT16BE byte length must be even multiple of 2: length: ${buf.length}`);
        }
        const chars = [];
        for (let i2 = 0; i2 < buf.length; i2 += 2) {
          chars.push((buf[i2] << 8) + buf[i2 + 1]);
        }
        return chars;
      }
    };
    exports.uint16le = {
      encode(chars) {
        const buf = Buffer3.alloc(chars.length * 2);
        let i2 = 0;
        chars.forEach((char) => {
          if (char > 65535) {
            throw new RangeError(`uint16le.encode: UINT16LE character code out of range: char[${i2 / 2}]: ${char}`);
          }
          buf[i2++] = char & mask[8];
          buf[i2++] = char >> 8 & mask[8];
        });
        return buf;
      },
      decode(buf) {
        if (buf.length % 2 > 0) {
          throw new RangeError(`uint16le.decode: UINT16LE byte length must be even multiple of 2: length: ${buf.length}`);
        }
        const chars = [];
        for (let i2 = 0; i2 < buf.length; i2 += 2) {
          chars.push((buf[i2 + 1] << 8) + buf[i2]);
        }
        return chars;
      }
    };
    exports.uint32be = {
      encode(chars) {
        const buf = Buffer3.alloc(chars.length * 4);
        let i2 = 0;
        chars.forEach((char) => {
          buf[i2++] = char >> 24 & mask[8];
          buf[i2++] = char >> 16 & mask[8];
          buf[i2++] = char >> 8 & mask[8];
          buf[i2++] = char & mask[8];
        });
        return buf;
      },
      decode(buf) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`uint32be.decode: UINT32BE byte length must be even multiple of 4: length: ${buf.length}`);
        }
        const chars = [];
        for (let i2 = 0; i2 < buf.length; i2 += 4) {
          chars.push((buf[i2] << 24) + (buf[i2 + 1] << 16) + (buf[i2 + 2] << 8) + buf[i2 + 3]);
        }
        return chars;
      }
    };
    exports.uint32le = {
      encode(chars) {
        const buf = Buffer3.alloc(chars.length * 4);
        let i2 = 0;
        chars.forEach((char) => {
          buf[i2++] = char & mask[8];
          buf[i2++] = char >> 8 & mask[8];
          buf[i2++] = char >> 16 & mask[8];
          buf[i2++] = char >> 24 & mask[8];
        });
        return buf;
      },
      decode(buf) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`uint32le.decode: UINT32LE byte length must be even multiple of 4: length: ${buf.length}`);
        }
        const chars = [];
        for (let i2 = 0; i2 < buf.length; i2 += 4) {
          chars.push((buf[i2 + 3] << 24) + (buf[i2 + 2] << 16) + (buf[i2 + 1] << 8) + buf[i2]);
        }
        return chars;
      }
    };
    exports.string = {
      encode(chars) {
        return exports.utf16le.encode(chars).toString("utf16le");
      },
      decode(str) {
        return exports.utf16le.decode(Buffer3.from(str, "utf16le"), 0);
      }
    };
    exports.escaped = {
      // Encodes an Array of 32-bit integers into ESCAPED format.
      encode(chars) {
        const bytes = [];
        for (let i2 = 0; i2 < chars.length; i2 += 1) {
          const char = chars[i2];
          if (char === 96) {
            bytes.push(char);
            bytes.push(char);
          } else if (char === 10) {
            bytes.push(char);
          } else if (char >= 32 && char <= 126) {
            bytes.push(char);
          } else {
            let str = "";
            if (char >= 0 && char <= 31) {
              str += `\`x${ascii[char]}`;
            } else if (char >= 127 && char <= 255) {
              str += `\`x${ascii[char]}`;
            } else if (char >= 256 && char <= 65535) {
              str += `\`u${ascii[char >> 8 & mask[8]]}${ascii[char & mask[8]]}`;
            } else if (char >= 65536 && char <= 4294967295) {
              str += "`u{";
              const digit = char >> 24 & mask[8];
              if (digit > 0) {
                str += ascii[digit];
              }
              str += `${ascii[char >> 16 & mask[8]] + ascii[char >> 8 & mask[8]] + ascii[char & mask[8]]}}`;
            } else {
              throw new Error("escape.encode(char): char > 0xffffffff not allowed");
            }
            const buf = Buffer3.from(str);
            buf.forEach((b4) => {
              bytes.push(b4);
            });
          }
        }
        return Buffer3.from(bytes);
      },
      // Decodes ESCAPED format from a Buffer of bytes to an Array of 32-bit integers.
      decode(buf) {
        function isHex(hex3) {
          if (hex3 >= 48 && hex3 <= 57 || hex3 >= 65 && hex3 <= 70 || hex3 >= 97 && hex3 <= 102) {
            return true;
          }
          return false;
        }
        function getx(i3, len2, bufArg) {
          const ret2 = { char: null, nexti: i3 + 2, error: true };
          if (i3 + 1 < len2) {
            if (isHex(bufArg[i3]) && isHex(bufArg[i3 + 1])) {
              const str = String.fromCodePoint(bufArg[i3], bufArg[i3 + 1]);
              ret2.char = parseInt(str, 16);
              if (!Number.isNaN(ret2.char)) {
                ret2.error = false;
              }
            }
          }
          return ret2;
        }
        function getu(i3, len2, bufArg) {
          const ret2 = { char: null, nexti: i3 + 4, error: true };
          if (i3 + 3 < len2) {
            if (isHex(bufArg[i3]) && isHex(bufArg[i3 + 1]) && isHex(bufArg[i3 + 2]) && isHex(bufArg[i3 + 3])) {
              const str = String.fromCodePoint(bufArg[i3], bufArg[i3 + 1], bufArg[i3 + 2], bufArg[i3 + 3]);
              ret2.char = parseInt(str, 16);
              if (!Number.isNaN(ret2.char)) {
                ret2.error = false;
              }
            }
          }
          return ret2;
        }
        function getU(i3, len2, bufArg) {
          const ret2 = { char: null, nexti: i3 + 4, error: true };
          let str = "";
          while (i3 < len2 && isHex(bufArg[i3])) {
            str += String.fromCodePoint(bufArg[i3]);
            i3 += 1;
          }
          ret2.char = parseInt(str, 16);
          if (bufArg[i3] === 125 && !Number.isNaN(ret2.char)) {
            ret2.error = false;
          }
          ret2.nexti = i3 + 1;
          return ret2;
        }
        const chars = [];
        const len = buf.length;
        let i1;
        let ret;
        let error;
        let i2 = 0;
        while (i2 < len) {
          const TRUE = true;
          while (TRUE) {
            error = true;
            if (buf[i2] !== 96) {
              chars.push(buf[i2]);
              i2 += 1;
              error = false;
              break;
            }
            i1 = i2 + 1;
            if (i1 >= len) {
              break;
            }
            if (buf[i1] === 96) {
              chars.push(96);
              i2 += 2;
              error = false;
              break;
            }
            if (buf[i1] === 120) {
              ret = getx(i1 + 1, len, buf);
              if (ret.error) {
                break;
              }
              chars.push(ret.char);
              i2 = ret.nexti;
              error = false;
              break;
            }
            if (buf[i1] === 117) {
              if (buf[i1 + 1] === 123) {
                ret = getU(i1 + 2, len, buf);
                if (ret.error) {
                  break;
                }
                chars.push(ret.char);
                i2 = ret.nexti;
                error = false;
                break;
              }
              ret = getu(i1 + 1, len, buf);
              if (ret.error) {
                break;
              }
              chars.push(ret.char);
              i2 = ret.nexti;
              error = false;
              break;
            }
            break;
          }
          if (error) {
            throw new Error(`escaped.decode: ill-formed escape sequence at buf[${i2}]`);
          }
        }
        return chars;
      }
    };
    var CR = 13;
    var LF = 10;
    exports.lineEnds = {
      crlf(chars) {
        const lfchars = [];
        let i2 = 0;
        while (i2 < chars.length) {
          switch (chars[i2]) {
            case CR:
              if (i2 + 1 < chars.length && chars[i2 + 1] === LF) {
                i2 += 2;
              } else {
                i2 += 1;
              }
              lfchars.push(CR);
              lfchars.push(LF);
              break;
            case LF:
              lfchars.push(CR);
              lfchars.push(LF);
              i2 += 1;
              break;
            default:
              lfchars.push(chars[i2]);
              i2 += 1;
              break;
          }
        }
        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {
          lfchars.push(CR);
          lfchars.push(LF);
        }
        return lfchars;
      },
      lf(chars) {
        const lfchars = [];
        let i2 = 0;
        while (i2 < chars.length) {
          switch (chars[i2]) {
            case CR:
              if (i2 + 1 < chars.length && chars[i2 + 1] === LF) {
                i2 += 2;
              } else {
                i2 += 1;
              }
              lfchars.push(LF);
              break;
            case LF:
              lfchars.push(LF);
              i2 += 1;
              break;
            default:
              lfchars.push(chars[i2]);
              i2 += 1;
              break;
          }
        }
        if (lfchars.length > 0 && lfchars[lfchars.length - 1] !== LF) {
          lfchars.push(LF);
        }
        return lfchars;
      }
    };
    exports.base64 = {
      encode(buf) {
        if (buf.length === 0) {
          return Buffer3.alloc(0);
        }
        let i2;
        let j3;
        let n2;
        let tail = buf.length % 3;
        tail = tail > 0 ? 3 - tail : 0;
        let units = (buf.length + tail) / 3;
        const base642 = Buffer3.alloc(units * 4);
        if (tail > 0) {
          units -= 1;
        }
        i2 = 0;
        j3 = 0;
        for (let u3 = 0; u3 < units; u3 += 1) {
          n2 = buf[i2++] << 16;
          n2 += buf[i2++] << 8;
          n2 += buf[i2++];
          base642[j3++] = base64codes[n2 >> 18 & mask[6]];
          base642[j3++] = base64codes[n2 >> 12 & mask[6]];
          base642[j3++] = base64codes[n2 >> 6 & mask[6]];
          base642[j3++] = base64codes[n2 & mask[6]];
        }
        if (tail === 0) {
          return base642;
        }
        if (tail === 1) {
          n2 = buf[i2++] << 16;
          n2 += buf[i2] << 8;
          base642[j3++] = base64codes[n2 >> 18 & mask[6]];
          base642[j3++] = base64codes[n2 >> 12 & mask[6]];
          base642[j3++] = base64codes[n2 >> 6 & mask[6]];
          base642[j3] = base64codes[64];
          return base642;
        }
        if (tail === 2) {
          n2 = buf[i2] << 16;
          base642[j3++] = base64codes[n2 >> 18 & mask[6]];
          base642[j3++] = base64codes[n2 >> 12 & mask[6]];
          base642[j3++] = base64codes[64];
          base642[j3] = base64codes[64];
          return base642;
        }
        return void 0;
      },
      decode(codes) {
        function validate14(buf2) {
          const chars = [];
          let tail2 = 0;
          for (let i3 = 0; i3 < buf2.length; i3 += 1) {
            const char = buf2[i3];
            const TRUE = true;
            while (TRUE) {
              if (char === 32 || char === 9 || char === 10 || char === 13) {
                break;
              }
              if (char >= 65 && char <= 90) {
                chars.push(char - 65);
                break;
              }
              if (char >= 97 && char <= 122) {
                chars.push(char - 71);
                break;
              }
              if (char >= 48 && char <= 57) {
                chars.push(char + 4);
                break;
              }
              if (char === 43) {
                chars.push(62);
                break;
              }
              if (char === 47) {
                chars.push(63);
                break;
              }
              if (char === 61) {
                chars.push(64);
                tail2 += 1;
                break;
              }
              throw new RangeError(`base64.decode: invalid character buf[${i3}]: ${char}`);
            }
          }
          if (chars.length % 4 > 0) {
            throw new RangeError(`base64.decode: string length not integral multiple of 4: ${chars.length}`);
          }
          switch (tail2) {
            case 0:
              break;
            case 1:
              if (chars[chars.length - 1] !== 64) {
                throw new RangeError("base64.decode: one tail character found: not last character");
              }
              break;
            case 2:
              if (chars[chars.length - 1] !== 64 || chars[chars.length - 2] !== 64) {
                throw new RangeError("base64.decode: two tail characters found: not last characters");
              }
              break;
            default:
              throw new RangeError(`base64.decode: more than two tail characters found: ${tail2}`);
          }
          return { tail: tail2, buf: Buffer3.from(chars) };
        }
        if (codes.length === 0) {
          return Buffer3.alloc(0);
        }
        const val = validate14(codes);
        const { tail } = val;
        const base642 = val.buf;
        let i2;
        let j3;
        let n2;
        let units = base642.length / 4;
        const buf = Buffer3.alloc(units * 3 - tail);
        if (tail > 0) {
          units -= 1;
        }
        j3 = 0;
        i2 = 0;
        for (let u3 = 0; u3 < units; u3 += 1) {
          n2 = base642[i2++] << 18;
          n2 += base642[i2++] << 12;
          n2 += base642[i2++] << 6;
          n2 += base642[i2++];
          buf[j3++] = n2 >> 16 & mask[8];
          buf[j3++] = n2 >> 8 & mask[8];
          buf[j3++] = n2 & mask[8];
        }
        if (tail === 1) {
          n2 = base642[i2++] << 18;
          n2 += base642[i2++] << 12;
          n2 += base642[i2] << 6;
          buf[j3++] = n2 >> 16 & mask[8];
          buf[j3] = n2 >> 8 & mask[8];
        }
        if (tail === 2) {
          n2 = base642[i2++] << 18;
          n2 += base642[i2++] << 12;
          buf[j3] = n2 >> 16 & mask[8];
        }
        return buf;
      },
      // Converts a base 64 Buffer of bytes to a JavaScript string with line breaks.
      toString(buf) {
        if (buf.length % 4 > 0) {
          throw new RangeError(`base64.toString: input buffer length not multiple of 4: ${buf.length}`);
        }
        let str = "";
        let lineLen = 0;
        function buildLine(c1, c22, c3, c4) {
          switch (lineLen) {
            case 76:
              str += `\r
${c1}${c22}${c3}${c4}`;
              lineLen = 4;
              break;
            case 75:
              str += `${c1}\r
${c22}${c3}${c4}`;
              lineLen = 3;
              break;
            case 74:
              str += `${c1 + c22}\r
${c3}${c4}`;
              lineLen = 2;
              break;
            case 73:
              str += `${c1 + c22 + c3}\r
${c4}`;
              lineLen = 1;
              break;
            default:
              str += c1 + c22 + c3 + c4;
              lineLen += 4;
              break;
          }
        }
        function validate14(c3) {
          if (c3 >= 65 && c3 <= 90) {
            return true;
          }
          if (c3 >= 97 && c3 <= 122) {
            return true;
          }
          if (c3 >= 48 && c3 <= 57) {
            return true;
          }
          if (c3 === 43) {
            return true;
          }
          if (c3 === 47) {
            return true;
          }
          if (c3 === 61) {
            return true;
          }
          return false;
        }
        for (let i2 = 0; i2 < buf.length; i2 += 4) {
          for (let j3 = i2; j3 < i2 + 4; j3 += 1) {
            if (!validate14(buf[j3])) {
              throw new RangeError(`base64.toString: buf[${j3}]: ${buf[j3]} : not valid base64 character code`);
            }
          }
          buildLine(
            String.fromCharCode(buf[i2]),
            String.fromCharCode(buf[i2 + 1]),
            String.fromCharCode(buf[i2 + 2]),
            String.fromCharCode(buf[i2 + 3])
          );
        }
        return str;
      }
    };
  }
});

// node_modules/apg-js/src/apg-conv-api/converter.js
var require_converter = __commonJS({
  "node_modules/apg-js/src/apg-conv-api/converter.js"(exports) {
    "use strict;";
    var { Buffer: Buffer3 } = require_buffer();
    var trans = require_transformers();
    var UTF8 = "UTF8";
    var UTF16 = "UTF16";
    var UTF16BE = "UTF16BE";
    var UTF16LE = "UTF16LE";
    var UTF32 = "UTF32";
    var UTF32BE = "UTF32BE";
    var UTF32LE = "UTF32LE";
    var UINT7 = "UINT7";
    var ASCII = "ASCII";
    var BINARY = "BINARY";
    var UINT8 = "UINT8";
    var UINT16 = "UINT16";
    var UINT16LE = "UINT16LE";
    var UINT16BE = "UINT16BE";
    var UINT32 = "UINT32";
    var UINT32LE = "UINT32LE";
    var UINT32BE = "UINT32BE";
    var ESCAPED = "ESCAPED";
    var STRING = "STRING";
    var bom8 = function bom82(src) {
      src.type = UTF8;
      const buf = src.data;
      src.bom = 0;
      if (buf.length >= 3) {
        if (buf[0] === 239 && buf[1] === 187 && buf[2] === 191) {
          src.bom = 3;
        }
      }
    };
    var bom16 = function bom162(src) {
      const buf = src.data;
      src.bom = 0;
      switch (src.type) {
        case UTF16:
          src.type = UTF16BE;
          if (buf.length >= 2) {
            if (buf[0] === 254 && buf[1] === 255) {
              src.bom = 2;
            } else if (buf[0] === 255 && buf[1] === 254) {
              src.type = UTF16LE;
              src.bom = 2;
            }
          }
          break;
        case UTF16BE:
          src.type = UTF16BE;
          if (buf.length >= 2) {
            if (buf[0] === 254 && buf[1] === 255) {
              src.bom = 2;
            } else if (buf[0] === 255 && buf[1] === 254) {
              throw new TypeError(`src type: "${UTF16BE}" specified but BOM is for "${UTF16LE}"`);
            }
          }
          break;
        case UTF16LE:
          src.type = UTF16LE;
          if (buf.length >= 0) {
            if (buf[0] === 254 && buf[1] === 255) {
              throw new TypeError(`src type: "${UTF16LE}" specified but BOM is for "${UTF16BE}"`);
            } else if (buf[0] === 255 && buf[1] === 254) {
              src.bom = 2;
            }
          }
          break;
        default:
          throw new TypeError(`UTF16 BOM: src type "${src.type}" unrecognized`);
      }
    };
    var bom32 = function bom322(src) {
      const buf = src.data;
      src.bom = 0;
      switch (src.type) {
        case UTF32:
          src.type = UTF32BE;
          if (buf.length >= 4) {
            if (buf[0] === 0 && buf[1] === 0 && buf[2] === 254 && buf[3] === 255) {
              src.bom = 4;
            }
            if (buf[0] === 255 && buf[1] === 254 && buf[2] === 0 && buf[3] === 0) {
              src.type = UTF32LE;
              src.bom = 4;
            }
          }
          break;
        case UTF32BE:
          src.type = UTF32BE;
          if (buf.length >= 4) {
            if (buf[0] === 0 && buf[1] === 0 && buf[2] === 254 && buf[3] === 255) {
              src.bom = 4;
            }
            if (buf[0] === 255 && buf[1] === 254 && buf[2] === 0 && buf[3] === 0) {
              throw new TypeError(`src type: ${UTF32BE} specified but BOM is for ${UTF32LE}"`);
            }
          }
          break;
        case UTF32LE:
          src.type = UTF32LE;
          if (buf.length >= 4) {
            if (buf[0] === 0 && buf[1] === 0 && buf[2] === 254 && buf[3] === 255) {
              throw new TypeError(`src type: "${UTF32LE}" specified but BOM is for "${UTF32BE}"`);
            }
            if (buf[0] === 255 && buf[1] === 254 && buf[2] === 0 && buf[3] === 0) {
              src.bom = 4;
            }
          }
          break;
        default:
          throw new TypeError(`UTF32 BOM: src type "${src.type}" unrecognized`);
      }
    };
    var validateSrc = function validateSrc2(type6, data) {
      function getType(typeArg) {
        const ret2 = {
          type: "",
          base64: false
        };
        const rx = /^(base64:)?([a-zA-Z0-9]+)$/i;
        const result = rx.exec(typeArg);
        if (result) {
          if (result[2]) {
            ret2.type = result[2].toUpperCase();
          }
          if (result[1]) {
            ret2.base64 = true;
          }
        }
        return ret2;
      }
      const ret = getType(type6.toUpperCase());
      if (ret.base64) {
        if (ret.type === STRING) {
          throw new TypeError(`type: "${type6} "BASE64:" prefix not allowed with type ${STRING}`);
        }
        if (Buffer3.isBuffer(data)) {
          ret.data = trans.base64.decode(data);
        } else if (typeof data === "string") {
          const buf = Buffer3.from(data, "ascii");
          ret.data = trans.base64.decode(buf);
        } else {
          throw new TypeError(`type: "${type6} unrecognized data type: typeof(data): ${typeof data}`);
        }
      } else {
        ret.data = data;
      }
      switch (ret.type) {
        case UTF8:
          bom8(ret);
          break;
        case UTF16:
        case UTF16BE:
        case UTF16LE:
          bom16(ret);
          break;
        case UTF32:
        case UTF32BE:
        case UTF32LE:
          bom32(ret);
          break;
        case UINT16:
          ret.type = UINT16BE;
          break;
        case UINT32:
          ret.type = UINT32BE;
          break;
        case ASCII:
          ret.type = UINT7;
          break;
        case BINARY:
          ret.type = UINT8;
          break;
        case UINT7:
        case UINT8:
        case UINT16LE:
        case UINT16BE:
        case UINT32LE:
        case UINT32BE:
        case STRING:
        case ESCAPED:
          break;
        default:
          throw new TypeError(`type: "${type6}" not recognized`);
      }
      if (ret.type === STRING) {
        if (typeof ret.data !== "string") {
          throw new TypeError(`type: "${type6}" but data is not a string`);
        }
      } else if (!Buffer3.isBuffer(ret.data)) {
        throw new TypeError(`type: "${type6}" but data is not a Buffer`);
      }
      return ret;
    };
    var validateDst = function validateDst2(type6, chars) {
      function getType(typeArg) {
        let fix;
        let rem;
        const ret2 = {
          crlf: false,
          lf: false,
          base64: false,
          type: ""
        };
        const TRUE = true;
        while (TRUE) {
          rem = typeArg;
          fix = typeArg.slice(0, 5);
          if (fix === "CRLF:") {
            ret2.crlf = true;
            rem = typeArg.slice(5);
            break;
          }
          fix = typeArg.slice(0, 3);
          if (fix === "LF:") {
            ret2.lf = true;
            rem = typeArg.slice(3);
            break;
          }
          break;
        }
        fix = rem.split(":");
        if (fix.length === 1) {
          ret2.type = fix[0];
        } else if (fix.length === 2 && fix[1] === "BASE64") {
          ret2.base64 = true;
          ret2.type = fix[0];
        }
        return ret2;
      }
      if (!Array.isArray(chars)) {
        throw new TypeError(`dst chars: not array: "${typeof chars}`);
      }
      if (typeof type6 !== "string") {
        throw new TypeError(`dst type: not string: "${typeof type6}`);
      }
      const ret = getType(type6.toUpperCase());
      switch (ret.type) {
        case UTF8:
        case UTF16BE:
        case UTF16LE:
        case UTF32BE:
        case UTF32LE:
        case UINT7:
        case UINT8:
        case UINT16LE:
        case UINT16BE:
        case UINT32LE:
        case UINT32BE:
        case ESCAPED:
          break;
        case STRING:
          if (ret.base64) {
            throw new TypeError(`":BASE64" suffix not allowed with type ${STRING}`);
          }
          break;
        case ASCII:
          ret.type = UINT7;
          break;
        case BINARY:
          ret.type = UINT8;
          break;
        case UTF16:
          ret.type = UTF16BE;
          break;
        case UTF32:
          ret.type = UTF32BE;
          break;
        case UINT16:
          ret.type = UINT16BE;
          break;
        case UINT32:
          ret.type = UINT32BE;
          break;
        default:
          throw new TypeError(`dst type unrecognized: "${type6}" : must have form [crlf:|lf:]type[:base64]`);
      }
      return ret;
    };
    var encode9 = function encode10(type6, chars) {
      switch (type6) {
        case UTF8:
          return trans.utf8.encode(chars);
        case UTF16BE:
          return trans.utf16be.encode(chars);
        case UTF16LE:
          return trans.utf16le.encode(chars);
        case UTF32BE:
          return trans.utf32be.encode(chars);
        case UTF32LE:
          return trans.utf32le.encode(chars);
        case UINT7:
          return trans.uint7.encode(chars);
        case UINT8:
          return trans.uint8.encode(chars);
        case UINT16BE:
          return trans.uint16be.encode(chars);
        case UINT16LE:
          return trans.uint16le.encode(chars);
        case UINT32BE:
          return trans.uint32be.encode(chars);
        case UINT32LE:
          return trans.uint32le.encode(chars);
        case STRING:
          return trans.string.encode(chars);
        case ESCAPED:
          return trans.escaped.encode(chars);
        default:
          throw new TypeError(`encode type "${type6}" not recognized`);
      }
    };
    var decode4 = function decode5(src) {
      switch (src.type) {
        case UTF8:
          return trans.utf8.decode(src.data, src.bom);
        case UTF16LE:
          return trans.utf16le.decode(src.data, src.bom);
        case UTF16BE:
          return trans.utf16be.decode(src.data, src.bom);
        case UTF32BE:
          return trans.utf32be.decode(src.data, src.bom);
        case UTF32LE:
          return trans.utf32le.decode(src.data, src.bom);
        case UINT7:
          return trans.uint7.decode(src.data);
        case UINT8:
          return trans.uint8.decode(src.data);
        case UINT16BE:
          return trans.uint16be.decode(src.data);
        case UINT16LE:
          return trans.uint16le.decode(src.data);
        case UINT32BE:
          return trans.uint32be.decode(src.data);
        case UINT32LE:
          return trans.uint32le.decode(src.data);
        case STRING:
          return trans.string.decode(src.data);
        case ESCAPED:
          return trans.escaped.decode(src.data);
        default:
          throw new TypeError(`decode type "${src.type}" not recognized`);
      }
    };
    exports.decode = function exportsDecode(type6, data) {
      const src = validateSrc(type6, data);
      return decode4(src);
    };
    exports.encode = function exportsEncode(type6, chars) {
      let c3;
      let buf;
      const dst = validateDst(type6, chars);
      if (dst.crlf) {
        c3 = trans.lineEnds.crlf(chars);
        buf = encode9(dst.type, c3);
      } else if (dst.lf) {
        c3 = trans.lineEnds.lf(chars);
        buf = encode9(dst.type, c3);
      } else {
        buf = encode9(dst.type, chars);
      }
      if (dst.base64) {
        buf = trans.base64.encode(buf);
      }
      return buf;
    };
    var convert = function convert2(srcType, srcData, dstType) {
      return exports.encode(dstType, exports.decode(srcType, srcData));
    };
    exports.convert = convert;
  }
});

// node_modules/apg-js/src/apg-lib/emitcss.js
var require_emitcss = __commonJS({
  "node_modules/apg-js/src/apg-lib/emitcss.js"(exports, module) {
    module.exports = function emittcss() {
      return "/* This file automatically generated by jsonToless() and LESS. */\n.apg-mono {\n  font-family: monospace;\n}\n.apg-active {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-match {\n  font-weight: bold;\n  color: #264BFF;\n}\n.apg-empty {\n  font-weight: bold;\n  color: #0fbd0f;\n}\n.apg-nomatch {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-lh-match {\n  font-weight: bold;\n  color: #1A97BA;\n}\n.apg-lb-match {\n  font-weight: bold;\n  color: #5F1687;\n}\n.apg-remainder {\n  font-weight: bold;\n  color: #999999;\n}\n.apg-ctrl-char {\n  font-weight: bolder;\n  font-style: italic;\n  font-size: 0.6em;\n}\n.apg-line-end {\n  font-weight: bold;\n  color: #000000;\n}\n.apg-error {\n  font-weight: bold;\n  color: #FF4000;\n}\n.apg-phrase {\n  color: #000000;\n  background-color: #8caae6;\n}\n.apg-empty-phrase {\n  color: #0fbd0f;\n}\ntable.apg-state {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th,\ntable.apg-state td {\n  text-align: left;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-state th:nth-last-child(2),\ntable.apg-state td:nth-last-child(2) {\n  text-align: right;\n}\ntable.apg-state caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-stats {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats th,\ntable.apg-stats td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-stats caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-trace th,\ntable.apg-trace td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-trace th:last-child,\ntable.apg-trace th:nth-last-child(2),\ntable.apg-trace td:last-child,\ntable.apg-trace td:nth-last-child(2) {\n  text-align: left;\n}\ntable.apg-grammar {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-grammar th,\ntable.apg-grammar td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-grammar th:last-child,\ntable.apg-grammar td:last-child {\n  text-align: left;\n}\ntable.apg-rules {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-rules th,\ntable.apg-rules td {\n  text-align: right;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-rules a {\n  color: #003399 !important;\n}\ntable.apg-rules a:hover {\n  color: #8caae6 !important;\n}\ntable.apg-attrs {\n  font-family: monospace;\n  margin-top: 5px;\n  font-size: 11px;\n  line-height: 130%;\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs caption {\n  font-size: 125%;\n  line-height: 130%;\n  font-weight: bold;\n  text-align: left;\n}\ntable.apg-attrs th,\ntable.apg-attrs td {\n  text-align: center;\n  border: 1px solid black;\n  border-collapse: collapse;\n}\ntable.apg-attrs th:nth-child(1),\ntable.apg-attrs th:nth-child(2),\ntable.apg-attrs th:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs td:nth-child(1),\ntable.apg-attrs td:nth-child(2),\ntable.apg-attrs td:nth-child(3) {\n  text-align: right;\n}\ntable.apg-attrs a {\n  color: #003399 !important;\n}\ntable.apg-attrs a:hover {\n  color: #8caae6 !important;\n}\n";
    };
  }
});

// node_modules/apg-js/src/apg-lib/utilities.js
var require_utilities = __commonJS({
  "node_modules/apg-js/src/apg-lib/utilities.js"(exports) {
    var style2 = require_style();
    var converter = require_converter();
    var emitCss = require_emitcss();
    var id3 = require_identifiers();
    var thisFileName = "utilities.js: ";
    var getBounds = function(length2, begArg, len) {
      let end;
      let beg = begArg;
      const TRUE = true;
      while (TRUE) {
        if (length2 <= 0) {
          beg = 0;
          end = 0;
          break;
        }
        if (typeof beg !== "number") {
          beg = 0;
          end = length2;
          break;
        }
        if (beg >= length2) {
          beg = length2;
          end = length2;
          break;
        }
        if (typeof len !== "number") {
          end = length2;
          break;
        }
        end = beg + len;
        if (end > length2) {
          end = length2;
          break;
        }
        break;
      }
      return {
        beg,
        end
      };
    };
    exports.htmlToPage = function(html, titleArg) {
      let title;
      if (typeof html !== "string") {
        throw new Error(`${thisFileName}htmlToPage: input HTML is not a string`);
      }
      if (typeof titleArg !== "string") {
        title = "htmlToPage";
      } else {
        title = titleArg;
      }
      let page = "";
      page += "<!DOCTYPE html>\n";
      page += '<html lang="en">\n';
      page += "<head>\n";
      page += '<meta charset="utf-8">\n';
      page += `<title>${title}</title>
`;
      page += "<style>\n";
      page += emitCss();
      page += "</style>\n";
      page += "</head>\n<body>\n";
      page += `<p>${/* @__PURE__ */ new Date()}</p>
`;
      page += html;
      page += "</body>\n</html>\n";
      return page;
    };
    exports.parserResultToHtml = function(result, caption) {
      let cap = null;
      if (typeof caption === "string" && caption !== "") {
        cap = caption;
      }
      let success;
      let state;
      if (result.success === true) {
        success = `<span class="${style2.CLASS_MATCH}">true</span>`;
      } else {
        success = `<span class="${style2.CLASS_NOMATCH}">false</span>`;
      }
      if (result.state === id3.EMPTY) {
        state = `<span class="${style2.CLASS_EMPTY}">EMPTY</span>`;
      } else if (result.state === id3.MATCH) {
        state = `<span class="${style2.CLASS_MATCH}">MATCH</span>`;
      } else if (result.state === id3.NOMATCH) {
        state = `<span class="${style2.CLASS_NOMATCH}">NOMATCH</span>`;
      } else {
        state = `<span class="${style2.CLASS_NOMATCH}">unrecognized</span>`;
      }
      let html = "";
      html += `<table class="${style2.CLASS_STATE}">
`;
      if (cap) {
        html += `<caption>${cap}</caption>
`;
      }
      html += "<tr><th>state item</th><th>value</th><th>description</th></tr>\n";
      html += `<tr><td>parser success</td><td>${success}</td>
`;
      html += `<td><span class="${style2.CLASS_MATCH}">true</span> if the parse succeeded,
`;
      html += ` <span class="${style2.CLASS_NOMATCH}">false</span> otherwise`;
      html += "<br><i>NOTE: for success, entire string must be matched</i></td></tr>\n";
      html += `<tr><td>parser state</td><td>${state}</td>
`;
      html += `<td><span class="${style2.CLASS_EMPTY}">EMPTY</span>, `;
      html += `<span class="${style2.CLASS_MATCH}">MATCH</span> or 
`;
      html += `<span class="${style2.CLASS_NOMATCH}">NOMATCH</span></td></tr>
`;
      html += `<tr><td>string length</td><td>${result.length}</td><td>length of the input (sub)string</td></tr>
`;
      html += `<tr><td>matched length</td><td>${result.matched}</td><td>number of input string characters matched</td></tr>
`;
      html += `<tr><td>max matched</td><td>${result.maxMatched}</td><td>maximum number of input string characters matched</td></tr>
`;
      html += `<tr><td>max tree depth</td><td>${result.maxTreeDepth}</td><td>maximum depth of the parse tree reached</td></tr>
`;
      html += `<tr><td>node hits</td><td>${result.nodeHits}</td><td>number of parse tree node hits (opcode function calls)</td></tr>
`;
      html += `<tr><td>input length</td><td>${result.inputLength}</td><td>length of full input string</td></tr>
`;
      html += `<tr><td>sub-string begin</td><td>${result.subBegin}</td><td>sub-string first character index</td></tr>
`;
      html += `<tr><td>sub-string end</td><td>${result.subEnd}</td><td>sub-string end-of-string index</td></tr>
`;
      html += `<tr><td>sub-string length</td><td>${result.subLength}</td><td>sub-string length</td></tr>
`;
      html += "</table>\n";
      return html;
    };
    exports.charsToString = function(chars, phraseIndex, phraseLength) {
      let beg;
      let end;
      if (typeof phraseIndex === "number") {
        if (phraseIndex >= chars.length) {
          return "";
        }
        beg = phraseIndex < 0 ? 0 : phraseIndex;
      } else {
        beg = 0;
      }
      if (typeof phraseLength === "number") {
        if (phraseLength <= 0) {
          return "";
        }
        end = phraseLength > chars.length - beg ? chars.length : beg + phraseLength;
      } else {
        end = chars.length;
      }
      if (beg < end) {
        return converter.encode("UTF16LE", chars.slice(beg, end)).toString("utf16le");
      }
      return "";
    };
    exports.stringToChars = function(string) {
      return converter.decode("STRING", string);
    };
    exports.opcodeToString = function(type6) {
      let ret = "unknown";
      switch (type6) {
        case id3.ALT:
          ret = "ALT";
          break;
        case id3.CAT:
          ret = "CAT";
          break;
        case id3.RNM:
          ret = "RNM";
          break;
        case id3.UDT:
          ret = "UDT";
          break;
        case id3.AND:
          ret = "AND";
          break;
        case id3.NOT:
          ret = "NOT";
          break;
        case id3.REP:
          ret = "REP";
          break;
        case id3.TRG:
          ret = "TRG";
          break;
        case id3.TBS:
          ret = "TBS";
          break;
        case id3.TLS:
          ret = "TLS";
          break;
        case id3.BKR:
          ret = "BKR";
          break;
        case id3.BKA:
          ret = "BKA";
          break;
        case id3.BKN:
          ret = "BKN";
          break;
        case id3.ABG:
          ret = "ABG";
          break;
        case id3.AEN:
          ret = "AEN";
          break;
        default:
          throw new Error("unrecognized opcode");
      }
      return ret;
    };
    exports.stateToString = function(state) {
      let ret = "unknown";
      switch (state) {
        case id3.ACTIVE:
          ret = "ACTIVE";
          break;
        case id3.MATCH:
          ret = "MATCH";
          break;
        case id3.EMPTY:
          ret = "EMPTY";
          break;
        case id3.NOMATCH:
          ret = "NOMATCH";
          break;
        default:
          throw new Error("unrecognized state");
      }
      return ret;
    };
    exports.asciiChars = [
      "NUL",
      "SOH",
      "STX",
      "ETX",
      "EOT",
      "ENQ",
      "ACK",
      "BEL",
      "BS",
      "TAB",
      "LF",
      "VT",
      "FF",
      "CR",
      "SO",
      "SI",
      "DLE",
      "DC1",
      "DC2",
      "DC3",
      "DC4",
      "NAK",
      "SYN",
      "ETB",
      "CAN",
      "EM",
      "SUB",
      "ESC",
      "FS",
      "GS",
      "RS",
      "US",
      "&nbsp;",
      "!",
      "&#34;",
      "#",
      "$",
      "%",
      "&#38;",
      "&#39;",
      "(",
      ")",
      "*",
      "+",
      ",",
      "-",
      ".",
      "/",
      "0",
      "1",
      "2",
      "3",
      "4",
      "5",
      "6",
      "7",
      "8",
      "9",
      ":",
      ";",
      "&#60;",
      "=",
      "&#62;",
      "?",
      "@",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z",
      "[",
      "&#92;",
      "]",
      "^",
      "_",
      "`",
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "{",
      "|",
      "}",
      "~",
      "DEL"
    ];
    exports.charToHex = function(char) {
      let ch = char.toString(16).toUpperCase();
      switch (ch.length) {
        case 1:
        case 3:
        case 7:
          ch = `0${ch}`;
          break;
        case 2:
        case 6:
          ch = `00${ch}`;
          break;
        case 4:
          break;
        case 5:
          ch = `000${ch}`;
          break;
        default:
          throw new Error("unrecognized option");
      }
      return ch;
    };
    exports.charsToDec = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToDec: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += chars[bounds.beg];
        for (let i2 = bounds.beg + 1; i2 < bounds.end; i2 += 1) {
          ret += `,${chars[i2]}`;
        }
      }
      return ret;
    };
    exports.charsToHex = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += `\\x${exports.charToHex(chars[bounds.beg])}`;
        for (let i2 = bounds.beg + 1; i2 < bounds.end; i2 += 1) {
          ret += `,\\x${exports.charToHex(chars[i2])}`;
        }
      }
      return ret;
    };
    exports.charsToHtmlEntities = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToHex: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        for (let i2 = bounds.beg; i2 < bounds.end; i2 += 1) {
          ret += `&#x${chars[i2].toString(16)};`;
        }
      }
      return ret;
    };
    function isUnicode(char) {
      if (char >= 55296 && char <= 57343) {
        return false;
      }
      if (char > 1114111) {
        return false;
      }
      return true;
    }
    exports.charsToUnicode = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToUnicode: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        for (let i2 = bounds.beg; i2 < bounds.end; i2 += 1) {
          if (isUnicode(chars[i2])) {
            ret += `&#${chars[i2]};`;
          } else {
            ret += ` U+${exports.charToHex(chars[i2])}`;
          }
        }
      }
      return ret;
    };
    exports.charsToJsUnicode = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToJsUnicode: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      if (bounds.end > bounds.beg) {
        ret += `\\u${exports.charToHex(chars[bounds.beg])}`;
        for (let i2 = bounds.beg + 1; i2 < bounds.end; i2 += 1) {
          ret += `,\\u${exports.charToHex(chars[i2])}`;
        }
      }
      return ret;
    };
    exports.charsToAscii = function(chars, beg, len) {
      let ret = "";
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToAscii: input must be an array of integers`);
      }
      const bounds = getBounds(chars.length, beg, len);
      for (let i2 = bounds.beg; i2 < bounds.end; i2 += 1) {
        const char = chars[i2];
        if (char >= 32 && char <= 126) {
          ret += String.fromCharCode(char);
        } else {
          ret += `\\x${exports.charToHex(char)}`;
        }
      }
      return ret;
    };
    exports.charsToAsciiHtml = function(chars, beg, len) {
      if (!Array.isArray(chars)) {
        throw new Error(`${thisFileName}charsToAsciiHtml: input must be an array of integers`);
      }
      let html = "";
      let char;
      const bounds = getBounds(chars.length, beg, len);
      for (let i2 = bounds.beg; i2 < bounds.end; i2 += 1) {
        char = chars[i2];
        if (char < 32 || char === 127) {
          html += `<span class="${style2.CLASS_CTRLCHAR}">${exports.asciiChars[char]}</span>`;
        } else if (char > 127) {
          html += `<span class="${style2.CLASS_CTRLCHAR}">U+${exports.charToHex(char)}</span>`;
        } else {
          html += exports.asciiChars[char];
        }
      }
      return html;
    };
    exports.stringToAsciiHtml = function(str) {
      const chars = converter.decode("STRING", str);
      return this.charsToAsciiHtml(chars);
    };
  }
});

// node_modules/apg-js/src/apg-lib/ast.js
var require_ast = __commonJS({
  "node_modules/apg-js/src/apg-lib/ast.js"(exports, module) {
    module.exports = function exportsAst() {
      const id3 = require_identifiers();
      const utils2 = require_utilities();
      const thisFileName = "ast.js: ";
      const that2 = this;
      let rules = null;
      let udts = null;
      let chars = null;
      let nodeCount = 0;
      const nodesDefined = [];
      const nodeCallbacks = [];
      const stack = [];
      const records = [];
      this.callbacks = [];
      this.astObject = "astObject";
      this.init = function init2(rulesIn, udtsIn, charsIn) {
        stack.length = 0;
        records.length = 0;
        nodesDefined.length = 0;
        nodeCount = 0;
        rules = rulesIn;
        udts = udtsIn;
        chars = charsIn;
        let i2;
        const list = [];
        for (i2 = 0; i2 < rules.length; i2 += 1) {
          list.push(rules[i2].lower);
        }
        for (i2 = 0; i2 < udts.length; i2 += 1) {
          list.push(udts[i2].lower);
        }
        nodeCount = rules.length + udts.length;
        for (i2 = 0; i2 < nodeCount; i2 += 1) {
          nodesDefined[i2] = false;
          nodeCallbacks[i2] = null;
        }
        for (const index5 in that2.callbacks) {
          const lower = index5.toLowerCase();
          i2 = list.indexOf(lower);
          if (i2 < 0) {
            throw new Error(`${thisFileName}init: node '${index5}' not a rule or udt name`);
          }
          if (typeof that2.callbacks[index5] === "function") {
            nodesDefined[i2] = true;
            nodeCallbacks[i2] = that2.callbacks[index5];
          }
          if (that2.callbacks[index5] === true) {
            nodesDefined[i2] = true;
          }
        }
      };
      this.ruleDefined = function ruleDefined(index5) {
        return nodesDefined[index5] !== false;
      };
      this.udtDefined = function udtDefined(index5) {
        return nodesDefined[rules.length + index5] !== false;
      };
      this.down = function down(callbackIndex, name) {
        const thisIndex = records.length;
        stack.push(thisIndex);
        records.push({
          name,
          thisIndex,
          thatIndex: null,
          state: id3.SEM_PRE,
          callbackIndex,
          phraseIndex: null,
          phraseLength: null,
          stack: stack.length
        });
        return thisIndex;
      };
      this.up = function up(callbackIndex, name, phraseIndex, phraseLength) {
        const thisIndex = records.length;
        const thatIndex = stack.pop();
        records.push({
          name,
          thisIndex,
          thatIndex,
          state: id3.SEM_POST,
          callbackIndex,
          phraseIndex,
          phraseLength,
          stack: stack.length
        });
        records[thatIndex].thatIndex = thisIndex;
        records[thatIndex].phraseIndex = phraseIndex;
        records[thatIndex].phraseLength = phraseLength;
        return thisIndex;
      };
      this.translate = function translate(data) {
        let ret;
        let callback;
        let record;
        for (let i2 = 0; i2 < records.length; i2 += 1) {
          record = records[i2];
          callback = nodeCallbacks[record.callbackIndex];
          if (record.state === id3.SEM_PRE) {
            if (callback !== null) {
              ret = callback(id3.SEM_PRE, chars, record.phraseIndex, record.phraseLength, data);
              if (ret === id3.SEM_SKIP) {
                i2 = record.thatIndex;
              }
            }
          } else if (callback !== null) {
            callback(id3.SEM_POST, chars, record.phraseIndex, record.phraseLength, data);
          }
        }
      };
      this.setLength = function setLength(length2) {
        records.length = length2;
        if (length2 > 0) {
          stack.length = records[length2 - 1].stack;
        } else {
          stack.length = 0;
        }
      };
      this.getLength = function getLength() {
        return records.length;
      };
      function indent(n2) {
        let ret = "";
        for (let i2 = 0; i2 < n2; i2 += 1) {
          ret += " ";
        }
        return ret;
      }
      this.toXml = function toSml(modeArg) {
        let display = utils2.charsToDec;
        let caption = "decimal integer character codes";
        if (typeof modeArg === "string" && modeArg.length >= 3) {
          const mode3 = modeArg.slice(0, 3).toLowerCase();
          if (mode3 === "asc") {
            display = utils2.charsToAscii;
            caption = "ASCII for printing characters, hex for non-printing";
          } else if (mode3 === "hex") {
            display = utils2.charsToHex;
            caption = "hexadecimal integer character codes";
          } else if (mode3 === "uni") {
            display = utils2.charsToUnicode;
            caption = "Unicode UTF-32 integer character codes";
          }
        }
        let xml = "";
        let depth = 0;
        xml += '<?xml version="1.0" encoding="utf-8"?>\n';
        xml += `<root nodes="${records.length / 2}" characters="${chars.length}">
`;
        xml += `<!-- input string, ${caption} -->
`;
        xml += indent(depth + 2);
        xml += display(chars);
        xml += "\n";
        records.forEach((rec) => {
          if (rec.state === id3.SEM_PRE) {
            depth += 1;
            xml += indent(depth);
            xml += `<node name="${rec.name}" index="${rec.phraseIndex}" length="${rec.phraseLength}">
`;
            xml += indent(depth + 2);
            xml += display(chars, rec.phraseIndex, rec.phraseLength);
            xml += "\n";
          } else {
            xml += indent(depth);
            xml += `</node><!-- name="${rec.name}" -->
`;
            depth -= 1;
          }
        });
        xml += "</root>\n";
        return xml;
      };
      this.phrases = function phrases() {
        const obj = {};
        let i2;
        let record;
        for (i2 = 0; i2 < records.length; i2 += 1) {
          record = records[i2];
          if (record.state === id3.SEM_PRE) {
            if (!Array.isArray(obj[record.name])) {
              obj[record.name] = [];
            }
            obj[record.name].push({
              index: record.phraseIndex,
              length: record.phraseLength
            });
          }
        }
        return obj;
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/circular-buffer.js
var require_circular_buffer = __commonJS({
  "node_modules/apg-js/src/apg-lib/circular-buffer.js"(exports, module) {
    module.exports = function exportsCircularBuffer() {
      "use strict;";
      const thisFileName = "circular-buffer.js: ";
      let itemIndex = -1;
      let maxListSize = 0;
      this.init = function init2(size5) {
        if (typeof size5 !== "number" || size5 <= 0) {
          throw new Error(`${thisFileName}init: circular buffer size must an integer > 0`);
        }
        maxListSize = Math.ceil(size5);
        itemIndex = -1;
      };
      this.increment = function increment() {
        itemIndex += 1;
        return (itemIndex + maxListSize) % maxListSize;
      };
      this.maxSize = function maxSize() {
        return maxListSize;
      };
      this.items = function items() {
        return itemIndex + 1;
      };
      this.getListIndex = function getListIndex(item) {
        if (itemIndex === -1) {
          return -1;
        }
        if (item < 0 || item > itemIndex) {
          return -1;
        }
        if (itemIndex - item >= maxListSize) {
          return -1;
        }
        return (item + maxListSize) % maxListSize;
      };
      this.forEach = function forEach2(fn2) {
        if (itemIndex === -1) {
          return;
        }
        if (itemIndex < maxListSize) {
          for (let i2 = 0; i2 <= itemIndex; i2 += 1) {
            fn2(i2, i2);
          }
          return;
        }
        for (let i2 = itemIndex - maxListSize + 1; i2 <= itemIndex; i2 += 1) {
          const listIndex = (i2 + maxListSize) % maxListSize;
          fn2(listIndex, i2);
        }
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/parser.js
var require_parser = __commonJS({
  "node_modules/apg-js/src/apg-lib/parser.js"(exports, module) {
    module.exports = function parser() {
      const id3 = require_identifiers();
      const utils2 = require_utilities();
      const thisFileName = "parser.js: ";
      const thisThis = this;
      let opExecute;
      this.ast = null;
      this.stats = null;
      this.trace = null;
      this.callbacks = [];
      let opcodes = null;
      let chars = null;
      let charsBegin;
      let charsLength;
      let charsEnd;
      let lookAround;
      let treeDepth = 0;
      let maxTreeDepth = 0;
      let nodeHits = 0;
      let ruleCallbacks = null;
      let udtCallbacks = null;
      let rules = null;
      let udts = null;
      let syntaxData = null;
      let maxMatched = 0;
      let limitTreeDepth = Infinity;
      let limitNodeHits = Infinity;
      const evaluateRule = function evaluateRule2(ruleIndex, phraseIndex, sysData) {
        const functionName = `${thisFileName}evaluateRule(): `;
        if (ruleIndex >= rules.length) {
          throw new Error(`${functionName}rule index: ${ruleIndex} out of range`);
        }
        if (phraseIndex >= charsEnd) {
          throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);
        }
        const { length: length2 } = opcodes;
        opcodes.push({
          type: id3.RNM,
          index: ruleIndex
        });
        opExecute(length2, phraseIndex, sysData);
        opcodes.pop();
      };
      const evaluateUdt = function(udtIndex, phraseIndex, sysData) {
        const functionName = `${thisFileName}evaluateUdt(): `;
        if (udtIndex >= udts.length) {
          throw new Error(`${functionName}udt index: ${udtIndex} out of range`);
        }
        if (phraseIndex >= charsEnd) {
          throw new Error(`${functionName}phrase index: ${phraseIndex} out of range`);
        }
        const { length: length2 } = opcodes;
        opcodes.push({
          type: id3.UDT,
          empty: udts[udtIndex].empty,
          index: udtIndex
        });
        opExecute(length2, phraseIndex, sysData);
        opcodes.pop();
      };
      const clear = function() {
        treeDepth = 0;
        maxTreeDepth = 0;
        nodeHits = 0;
        maxMatched = 0;
        lookAround = [
          {
            lookAround: id3.LOOKAROUND_NONE,
            anchor: 0,
            charsEnd: 0,
            charsLength: 0
          }
        ];
        rules = null;
        udts = null;
        chars = null;
        charsBegin = 0;
        charsLength = 0;
        charsEnd = 0;
        ruleCallbacks = null;
        udtCallbacks = null;
        syntaxData = null;
        opcodes = null;
      };
      const backRef = function() {
        const stack = [];
        const init2 = function() {
          const obj = {};
          rules.forEach((rule) => {
            if (rule.isBkr) {
              obj[rule.lower] = null;
            }
          });
          if (udts.length > 0) {
            udts.forEach((udt) => {
              if (udt.isBkr) {
                obj[udt.lower] = null;
              }
            });
          }
          stack.push(obj);
        };
        const copy = function() {
          const top = stack[stack.length - 1];
          const obj = {};
          for (const name in top) {
            obj[name] = top[name];
          }
          return obj;
        };
        this.push = function push() {
          stack.push(copy());
        };
        this.pop = function pop(lengthArg) {
          let length2 = lengthArg;
          if (!length2) {
            length2 = stack.length - 1;
          }
          if (length2 < 1 || length2 > stack.length) {
            throw new Error(`${thisFileName}backRef.pop(): bad length: ${length2}`);
          }
          stack.length = length2;
          return stack[stack.length - 1];
        };
        this.length = function length2() {
          return stack.length;
        };
        this.savePhrase = function savePhrase(name, index5, length2) {
          stack[stack.length - 1][name] = {
            phraseIndex: index5,
            phraseLength: length2
          };
        };
        this.getPhrase = function(name) {
          return stack[stack.length - 1][name];
        };
        init2();
      };
      const systemData = function systemData2() {
        const thisData = this;
        this.state = id3.ACTIVE;
        this.phraseLength = 0;
        this.ruleIndex = 0;
        this.udtIndex = 0;
        this.lookAround = lookAround[lookAround.length - 1];
        this.uFrame = new backRef();
        this.pFrame = new backRef();
        this.evaluateRule = evaluateRule;
        this.evaluateUdt = evaluateUdt;
        this.refresh = function refresh() {
          thisData.state = id3.ACTIVE;
          thisData.phraseLength = 0;
          thisData.lookAround = lookAround[lookAround.length - 1];
        };
      };
      const lookAroundValue = function lookAroundValue2() {
        return lookAround[lookAround.length - 1];
      };
      const inLookAround = function inLookAround2() {
        return lookAround.length > 1;
      };
      const inLookBehind = function() {
        return lookAround[lookAround.length - 1].lookAround === id3.LOOKAROUND_BEHIND;
      };
      const initializeAst = function() {
        const functionName = `${thisFileName}initializeAst(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.ast === void 0) {
            thisThis.ast = null;
            break;
          }
          if (thisThis.ast === null) {
            break;
          }
          if (thisThis.ast.astObject !== "astObject") {
            throw new Error(`${functionName}ast object not recognized`);
          }
          break;
        }
        if (thisThis.ast !== null) {
          thisThis.ast.init(rules, udts, chars);
        }
      };
      const initializeTrace = function() {
        const functionName = `${thisFileName}initializeTrace(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.trace === void 0) {
            thisThis.trace = null;
            break;
          }
          if (thisThis.trace === null) {
            break;
          }
          if (thisThis.trace.traceObject !== "traceObject") {
            throw new Error(`${functionName}trace object not recognized`);
          }
          break;
        }
        if (thisThis.trace !== null) {
          thisThis.trace.init(rules, udts, chars);
        }
      };
      const initializeStats = function() {
        const functionName = `${thisFileName}initializeStats(): `;
        const TRUE = true;
        while (TRUE) {
          if (thisThis.stats === void 0) {
            thisThis.stats = null;
            break;
          }
          if (thisThis.stats === null) {
            break;
          }
          if (thisThis.stats.statsObject !== "statsObject") {
            throw new Error(`${functionName}stats object not recognized`);
          }
          break;
        }
        if (thisThis.stats !== null) {
          thisThis.stats.init(rules, udts);
        }
      };
      const initializeGrammar = function(grammar) {
        const functionName = `${thisFileName}initializeGrammar(): `;
        if (!grammar) {
          throw new Error(`${functionName}grammar object undefined`);
        }
        if (grammar.grammarObject !== "grammarObject") {
          throw new Error(`${functionName}bad grammar object`);
        }
        rules = grammar.rules;
        udts = grammar.udts;
      };
      const initializeStartRule = function(startRule) {
        const functionName = `${thisFileName}initializeStartRule(): `;
        let start = null;
        if (typeof startRule === "number") {
          if (startRule >= rules.length) {
            throw new Error(`${functionName}start rule index too large: max: ${rules.length}: index: ${startRule}`);
          }
          start = startRule;
        } else if (typeof startRule === "string") {
          const lower = startRule.toLowerCase();
          for (let i2 = 0; i2 < rules.length; i2 += 1) {
            if (lower === rules[i2].lower) {
              start = rules[i2].index;
              break;
            }
          }
          if (start === null) {
            throw new Error(`${functionName}start rule name '${startRule}' not recognized`);
          }
        } else {
          throw new Error(`${functionName}type of start rule '${typeof startRule}' not recognized`);
        }
        return start;
      };
      const initializeInputChars = function initializeInputChars2(inputArg, begArg, lenArg) {
        const functionName = `${thisFileName}initializeInputChars(): `;
        let input = inputArg;
        let beg = begArg;
        let len = lenArg;
        if (input === void 0) {
          throw new Error(`${functionName}input string is undefined`);
        }
        if (input === null) {
          throw new Error(`${functionName}input string is null`);
        }
        if (typeof input === "string") {
          input = utils2.stringToChars(input);
        } else if (!Array.isArray(input)) {
          throw new Error(`${functionName}input string is not a string or array`);
        }
        if (input.length > 0) {
          if (typeof input[0] !== "number") {
            throw new Error(`${functionName}input string not an array of integers`);
          }
        }
        if (typeof beg !== "number") {
          beg = 0;
        } else {
          beg = Math.floor(beg);
          if (beg < 0 || beg > input.length) {
            throw new Error(`${functionName}input beginning index out of range: ${beg}`);
          }
        }
        if (typeof len !== "number") {
          len = input.length - beg;
        } else {
          len = Math.floor(len);
          if (len < 0 || len > input.length - beg) {
            throw new Error(`${functionName}input length out of range: ${len}`);
          }
        }
        chars = input;
        charsBegin = beg;
        charsLength = len;
        charsEnd = charsBegin + charsLength;
      };
      const initializeCallbacks = function() {
        const functionName = `${thisFileName}initializeCallbacks(): `;
        let i2;
        ruleCallbacks = [];
        udtCallbacks = [];
        for (i2 = 0; i2 < rules.length; i2 += 1) {
          ruleCallbacks[i2] = null;
        }
        for (i2 = 0; i2 < udts.length; i2 += 1) {
          udtCallbacks[i2] = null;
        }
        let func;
        const list = [];
        for (i2 = 0; i2 < rules.length; i2 += 1) {
          list.push(rules[i2].lower);
        }
        for (i2 = 0; i2 < udts.length; i2 += 1) {
          list.push(udts[i2].lower);
        }
        for (const index5 in thisThis.callbacks) {
          i2 = list.indexOf(index5.toLowerCase());
          if (i2 < 0) {
            throw new Error(`${functionName}syntax callback '${index5}' not a rule or udt name`);
          }
          func = thisThis.callbacks[index5];
          if (!func) {
            func = null;
          }
          if (typeof func === "function" || func === null) {
            if (i2 < rules.length) {
              ruleCallbacks[i2] = func;
            } else {
              udtCallbacks[i2 - rules.length] = func;
            }
          } else {
            throw new Error(
              `${functionName}syntax callback[${index5}] must be function reference or 'false' (false/null/undefined/etc.)`
            );
          }
        }
        for (i2 = 0; i2 < udts.length; i2 += 1) {
          if (udtCallbacks[i2] === null) {
            throw new Error(
              `${functionName}all UDT callbacks must be defined. UDT callback[${udts[i2].lower}] not a function reference`
            );
          }
        }
      };
      this.setMaxTreeDepth = function(depth) {
        if (typeof depth !== "number") {
          throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);
        }
        limitTreeDepth = Math.floor(depth);
        if (limitTreeDepth <= 0) {
          throw new Error(`parser: max tree depth must be integer > 0: ${depth}`);
        }
      };
      this.setMaxNodeHits = function(hits) {
        if (typeof hits !== "number") {
          throw new Error(`parser: max node hits must be integer > 0: ${hits}`);
        }
        limitNodeHits = Math.floor(hits);
        if (limitNodeHits <= 0) {
          throw new Error(`parser: max node hits must be integer > 0: ${hits}`);
        }
      };
      const privateParse = function(grammar, startRuleArg, callbackData) {
        let success;
        const functionName = `${thisFileName}parse(): `;
        initializeGrammar(grammar);
        const startRule = initializeStartRule(startRuleArg);
        initializeCallbacks();
        initializeTrace();
        initializeStats();
        initializeAst();
        const sysData = new systemData();
        if (!(callbackData === void 0 || callbackData === null)) {
          syntaxData = callbackData;
        }
        opcodes = [
          {
            type: id3.RNM,
            index: startRule
          }
        ];
        opExecute(0, charsBegin, sysData);
        opcodes = null;
        switch (sysData.state) {
          case id3.ACTIVE:
            throw new Error(`${functionName}final state should never be 'ACTIVE'`);
          case id3.NOMATCH:
            success = false;
            break;
          case id3.EMPTY:
          case id3.MATCH:
            if (sysData.phraseLength === charsLength) {
              success = true;
            } else {
              success = false;
            }
            break;
          default:
            throw new Error("unrecognized state");
        }
        return {
          success,
          state: sysData.state,
          length: charsLength,
          matched: sysData.phraseLength,
          maxMatched,
          maxTreeDepth,
          nodeHits,
          inputLength: chars.length,
          subBegin: charsBegin,
          subEnd: charsEnd,
          subLength: charsLength
        };
      };
      this.parseSubstring = function parseSubstring(grammar, startRule, inputChars, inputIndex, inputLength, callbackData) {
        clear();
        initializeInputChars(inputChars, inputIndex, inputLength);
        return privateParse(grammar, startRule, callbackData);
      };
      this.parse = function parse3(grammar, startRule, inputChars, callbackData) {
        clear();
        initializeInputChars(inputChars, 0, inputChars.length);
        return privateParse(grammar, startRule, callbackData);
      };
      const opALT = function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        for (let i2 = 0; i2 < op.children.length; i2 += 1) {
          opExecute(op.children[i2], phraseIndex, sysData);
          if (sysData.state !== id3.NOMATCH) {
            break;
          }
        }
      };
      const opCAT = function(opIndex, phraseIndex, sysData) {
        let success;
        let astLength;
        let catCharIndex;
        let catPhrase;
        const op = opcodes[opIndex];
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catPhrase = 0;
        for (let i2 = 0; i2 < op.children.length; i2 += 1) {
          opExecute(op.children[i2], catCharIndex, sysData);
          if (sysData.state === id3.NOMATCH) {
            success = false;
            break;
          } else {
            catCharIndex += sysData.phraseLength;
            catPhrase += sysData.phraseLength;
          }
        }
        if (success) {
          sysData.state = catPhrase === 0 ? id3.EMPTY : id3.MATCH;
          sysData.phraseLength = catPhrase;
        } else {
          sysData.state = id3.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      };
      const opREP = function(opIndex, phraseIndex, sysData) {
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        if (op.max === 0) {
          sysData.state = id3.EMPTY;
          sysData.phraseLength = 0;
          return;
        }
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        const TRUE = true;
        while (TRUE) {
          if (repCharIndex >= charsEnd) {
            break;
          }
          opExecute(opIndex + 1, repCharIndex, sysData);
          if (sysData.state === id3.NOMATCH) {
            break;
          }
          if (sysData.state === id3.EMPTY) {
            break;
          }
          repCount += 1;
          repPhrase += sysData.phraseLength;
          repCharIndex += sysData.phraseLength;
          if (repCount === op.max) {
            break;
          }
        }
        if (sysData.state === id3.EMPTY) {
          sysData.state = repPhrase === 0 ? id3.EMPTY : id3.MATCH;
          sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
          sysData.state = repPhrase === 0 ? id3.EMPTY : id3.MATCH;
          sysData.phraseLength = repPhrase;
        } else {
          sysData.state = id3.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      };
      const validateRnmCallbackResult = function(rule, sysData, charsLeft, down) {
        if (sysData.phraseLength > charsLeft) {
          let str = `${thisFileName}opRNM(${rule.name}): callback function error: `;
          str += `sysData.phraseLength: ${sysData.phraseLength}`;
          str += ` must be <= remaining chars: ${charsLeft}`;
          throw new Error(str);
        }
        switch (sysData.state) {
          case id3.ACTIVE:
            if (down !== true) {
              throw new Error(
                `${thisFileName}opRNM(${rule.name}): callback function return error. ACTIVE state not allowed.`
              );
            }
            break;
          case id3.EMPTY:
            sysData.phraseLength = 0;
            break;
          case id3.MATCH:
            if (sysData.phraseLength === 0) {
              sysData.state = id3.EMPTY;
            }
            break;
          case id3.NOMATCH:
            sysData.phraseLength = 0;
            break;
          default:
            throw new Error(
              `${thisFileName}opRNM(${rule.name}): callback function return error. Unrecognized return state: ${sysData.state}`
            );
        }
      };
      const opRNM = function(opIndex, phraseIndex, sysData) {
        let astLength;
        let astDefined;
        let savedOpcodes;
        let ulen;
        let plen;
        let saveFrame;
        const op = opcodes[opIndex];
        const rule = rules[op.index];
        const callback = ruleCallbacks[rule.index];
        const notLookAround = !inLookAround();
        if (notLookAround) {
          astDefined = thisThis.ast && thisThis.ast.ruleDefined(op.index);
          if (astDefined) {
            astLength = thisThis.ast.getLength();
            thisThis.ast.down(op.index, rules[op.index].name);
          }
          ulen = sysData.uFrame.length();
          plen = sysData.pFrame.length();
          sysData.uFrame.push();
          sysData.pFrame.push();
          saveFrame = sysData.pFrame;
          sysData.pFrame = new backRef();
        }
        if (callback === null) {
          savedOpcodes = opcodes;
          opcodes = rule.opcodes;
          opExecute(0, phraseIndex, sysData);
          opcodes = savedOpcodes;
        } else {
          const charsLeft = charsEnd - phraseIndex;
          sysData.ruleIndex = rule.index;
          callback(sysData, chars, phraseIndex, syntaxData);
          validateRnmCallbackResult(rule, sysData, charsLeft, true);
          if (sysData.state === id3.ACTIVE) {
            savedOpcodes = opcodes;
            opcodes = rule.opcodes;
            opExecute(0, phraseIndex, sysData);
            opcodes = savedOpcodes;
            sysData.ruleIndex = rule.index;
            callback(sysData, chars, phraseIndex, syntaxData);
            validateRnmCallbackResult(rule, sysData, charsLeft, false);
          }
        }
        if (notLookAround) {
          if (astDefined) {
            if (sysData.state === id3.NOMATCH) {
              thisThis.ast.setLength(astLength);
            } else {
              thisThis.ast.up(op.index, rule.name, phraseIndex, sysData.phraseLength);
            }
          }
          sysData.pFrame = saveFrame;
          if (sysData.state === id3.NOMATCH) {
            sysData.uFrame.pop(ulen);
            sysData.pFrame.pop(plen);
          } else if (rule.isBkr) {
            sysData.pFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);
            sysData.uFrame.savePhrase(rule.lower, phraseIndex, sysData.phraseLength);
          }
        }
      };
      const validateUdtCallbackResult = function(udt, sysData, charsLeft) {
        if (sysData.phraseLength > charsLeft) {
          let str = `${thisFileName}opUDT(${udt.name}): callback function error: `;
          str += `sysData.phraseLength: ${sysData.phraseLength}`;
          str += ` must be <= remaining chars: ${charsLeft}`;
          throw new Error(str);
        }
        switch (sysData.state) {
          case id3.ACTIVE:
            throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. ACTIVE state not allowed.`);
          case id3.EMPTY:
            if (udt.empty === false) {
              throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);
            } else {
              sysData.phraseLength = 0;
            }
            break;
          case id3.MATCH:
            if (sysData.phraseLength === 0) {
              if (udt.empty === false) {
                throw new Error(`${thisFileName}opUDT(${udt.name}): callback function return error. May not return EMPTY.`);
              } else {
                sysData.state = id3.EMPTY;
              }
            }
            break;
          case id3.NOMATCH:
            sysData.phraseLength = 0;
            break;
          default:
            throw new Error(
              `${thisFileName}opUDT(${udt.name}): callback function return error. Unrecognized return state: ${sysData.state}`
            );
        }
      };
      const opUDT = function(opIndex, phraseIndex, sysData) {
        let astLength;
        let astIndex;
        let astDefined;
        let ulen;
        let plen;
        let saveFrame;
        const op = opcodes[opIndex];
        const udt = udts[op.index];
        sysData.UdtIndex = udt.index;
        const notLookAround = !inLookAround();
        if (notLookAround) {
          astDefined = thisThis.ast && thisThis.ast.udtDefined(op.index);
          if (astDefined) {
            astIndex = rules.length + op.index;
            astLength = thisThis.ast.getLength();
            thisThis.ast.down(astIndex, udt.name);
          }
          ulen = sysData.uFrame.length();
          plen = sysData.pFrame.length();
          sysData.uFrame.push();
          sysData.pFrame.push();
          saveFrame = sysData.pFrame;
          sysData.pFrame = new backRef();
        }
        const charsLeft = charsEnd - phraseIndex;
        udtCallbacks[op.index](sysData, chars, phraseIndex, syntaxData);
        validateUdtCallbackResult(udt, sysData, charsLeft);
        if (notLookAround) {
          if (astDefined) {
            if (sysData.state === id3.NOMATCH) {
              thisThis.ast.setLength(astLength);
            } else {
              thisThis.ast.up(astIndex, udt.name, phraseIndex, sysData.phraseLength);
            }
          }
          sysData.pFrame = saveFrame;
          if (sysData.state === id3.NOMATCH) {
            sysData.uFrame.pop(ulen);
            sysData.pFrame.pop(plen);
          } else if (udt.isBkr) {
            sysData.pFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);
            sysData.uFrame.savePhrase(udt.lower, phraseIndex, sysData.phraseLength);
          }
        }
      };
      const opAND = function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id3.LOOKAROUND_AHEAD,
          anchor: phraseIndex,
          charsEnd,
          charsLength
        });
        charsEnd = chars.length;
        charsLength = chars.length - charsBegin;
        opExecute(opIndex + 1, phraseIndex, sysData);
        const pop = lookAround.pop();
        charsEnd = pop.charsEnd;
        charsLength = pop.charsLength;
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id3.EMPTY:
            sysData.state = id3.EMPTY;
            break;
          case id3.MATCH:
            sysData.state = id3.EMPTY;
            break;
          case id3.NOMATCH:
            sysData.state = id3.NOMATCH;
            break;
          default:
            throw new Error(`opAND: invalid state ${sysData.state}`);
        }
      };
      const opNOT = function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id3.LOOKAROUND_AHEAD,
          anchor: phraseIndex,
          charsEnd,
          charsLength
        });
        charsEnd = chars.length;
        charsLength = chars.length - charsBegin;
        opExecute(opIndex + 1, phraseIndex, sysData);
        const pop = lookAround.pop();
        charsEnd = pop.charsEnd;
        charsLength = pop.charsLength;
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id3.EMPTY:
          case id3.MATCH:
            sysData.state = id3.NOMATCH;
            break;
          case id3.NOMATCH:
            sysData.state = id3.EMPTY;
            break;
          default:
            throw new Error(`opNOT: invalid state ${sysData.state}`);
        }
      };
      const opTRG = function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        sysData.state = id3.NOMATCH;
        if (phraseIndex < charsEnd) {
          if (op.min <= chars[phraseIndex] && chars[phraseIndex] <= op.max) {
            sysData.state = id3.MATCH;
            sysData.phraseLength = 1;
          }
        }
      };
      const opTBS = function(opIndex, phraseIndex, sysData) {
        let i2;
        const op = opcodes[opIndex];
        const len = op.string.length;
        sysData.state = id3.NOMATCH;
        if (phraseIndex + len <= charsEnd) {
          for (i2 = 0; i2 < len; i2 += 1) {
            if (chars[phraseIndex + i2] !== op.string[i2]) {
              return;
            }
          }
          sysData.state = id3.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opTLS = function(opIndex, phraseIndex, sysData) {
        let i2;
        let code;
        const op = opcodes[opIndex];
        sysData.state = id3.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
          sysData.state = id3.EMPTY;
          return;
        }
        if (phraseIndex + len <= charsEnd) {
          for (i2 = 0; i2 < len; i2 += 1) {
            code = chars[phraseIndex + i2];
            if (code >= 65 && code <= 90) {
              code += 32;
            }
            if (code !== op.string[i2]) {
              return;
            }
          }
          sysData.state = id3.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opABG = function(opIndex, phraseIndex, sysData) {
        sysData.state = id3.NOMATCH;
        sysData.phraseLength = 0;
        sysData.state = phraseIndex === 0 ? id3.EMPTY : id3.NOMATCH;
      };
      const opAEN = function(opIndex, phraseIndex, sysData) {
        sysData.state = id3.NOMATCH;
        sysData.phraseLength = 0;
        sysData.state = phraseIndex === chars.length ? id3.EMPTY : id3.NOMATCH;
      };
      const opBKR = function(opIndex, phraseIndex, sysData) {
        let i2;
        let code;
        let lmcode;
        let lower;
        const op = opcodes[opIndex];
        sysData.state = id3.NOMATCH;
        if (op.index < rules.length) {
          lower = rules[op.index].lower;
        } else {
          lower = udts[op.index - rules.length].lower;
        }
        const frame2 = op.bkrMode === id3.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);
        const insensitive = op.bkrCase === id3.BKR_MODE_CI;
        if (frame2 === null) {
          return;
        }
        const lmIndex = frame2.phraseIndex;
        const len = frame2.phraseLength;
        if (len === 0) {
          sysData.state = id3.EMPTY;
          return;
        }
        if (phraseIndex + len <= charsEnd) {
          if (insensitive) {
            for (i2 = 0; i2 < len; i2 += 1) {
              code = chars[phraseIndex + i2];
              lmcode = chars[lmIndex + i2];
              if (code >= 65 && code <= 90) {
                code += 32;
              }
              if (lmcode >= 65 && lmcode <= 90) {
                lmcode += 32;
              }
              if (code !== lmcode) {
                return;
              }
            }
            sysData.state = id3.MATCH;
            sysData.phraseLength = len;
          } else {
            for (i2 = 0; i2 < len; i2 += 1) {
              code = chars[phraseIndex + i2];
              lmcode = chars[lmIndex + i2];
              if (code !== lmcode) {
                return;
              }
            }
          }
          sysData.state = id3.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opBKA = function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id3.LOOKAROUND_BEHIND,
          anchor: phraseIndex
        });
        opExecute(opIndex + 1, phraseIndex, sysData);
        lookAround.pop();
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id3.EMPTY:
            sysData.state = id3.EMPTY;
            break;
          case id3.MATCH:
            sysData.state = id3.EMPTY;
            break;
          case id3.NOMATCH:
            sysData.state = id3.NOMATCH;
            break;
          default:
            throw new Error(`opBKA: invalid state ${sysData.state}`);
        }
      };
      const opBKN = function(opIndex, phraseIndex, sysData) {
        lookAround.push({
          lookAround: id3.LOOKAROUND_BEHIND,
          anchor: phraseIndex
        });
        opExecute(opIndex + 1, phraseIndex, sysData);
        lookAround.pop();
        sysData.phraseLength = 0;
        switch (sysData.state) {
          case id3.EMPTY:
          case id3.MATCH:
            sysData.state = id3.NOMATCH;
            break;
          case id3.NOMATCH:
            sysData.state = id3.EMPTY;
            break;
          default:
            throw new Error(`opBKN: invalid state ${sysData.state}`);
        }
      };
      const opCATBehind = function(opIndex, phraseIndex, sysData) {
        let success;
        let astLength;
        let catCharIndex;
        let catMatched;
        const op = opcodes[opIndex];
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        success = true;
        catCharIndex = phraseIndex;
        catMatched = 0;
        for (let i2 = op.children.length - 1; i2 >= 0; i2 -= 1) {
          opExecute(op.children[i2], catCharIndex, sysData);
          catCharIndex -= sysData.phraseLength;
          catMatched += sysData.phraseLength;
          if (sysData.state === id3.NOMATCH) {
            success = false;
            break;
          }
        }
        if (success) {
          sysData.state = catMatched === 0 ? id3.EMPTY : id3.MATCH;
          sysData.phraseLength = catMatched;
        } else {
          sysData.state = id3.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      };
      const opREPBehind = function(opIndex, phraseIndex, sysData) {
        let astLength;
        let repCharIndex;
        let repPhrase;
        let repCount;
        const op = opcodes[opIndex];
        repCharIndex = phraseIndex;
        repPhrase = 0;
        repCount = 0;
        const ulen = sysData.uFrame.length();
        const plen = sysData.pFrame.length();
        if (thisThis.ast) {
          astLength = thisThis.ast.getLength();
        }
        const TRUE = true;
        while (TRUE) {
          if (repCharIndex <= 0) {
            break;
          }
          opExecute(opIndex + 1, repCharIndex, sysData);
          if (sysData.state === id3.NOMATCH) {
            break;
          }
          if (sysData.state === id3.EMPTY) {
            break;
          }
          repCount += 1;
          repPhrase += sysData.phraseLength;
          repCharIndex -= sysData.phraseLength;
          if (repCount === op.max) {
            break;
          }
        }
        if (sysData.state === id3.EMPTY) {
          sysData.state = repPhrase === 0 ? id3.EMPTY : id3.MATCH;
          sysData.phraseLength = repPhrase;
        } else if (repCount >= op.min) {
          sysData.state = repPhrase === 0 ? id3.EMPTY : id3.MATCH;
          sysData.phraseLength = repPhrase;
        } else {
          sysData.state = id3.NOMATCH;
          sysData.phraseLength = 0;
          sysData.uFrame.pop(ulen);
          sysData.pFrame.pop(plen);
          if (thisThis.ast) {
            thisThis.ast.setLength(astLength);
          }
        }
      };
      const opTRGBehind = function(opIndex, phraseIndex, sysData) {
        const op = opcodes[opIndex];
        sysData.state = id3.NOMATCH;
        sysData.phraseLength = 0;
        if (phraseIndex > 0) {
          const char = chars[phraseIndex - 1];
          if (op.min <= char && char <= op.max) {
            sysData.state = id3.MATCH;
            sysData.phraseLength = 1;
          }
        }
      };
      const opTBSBehind = function(opIndex, phraseIndex, sysData) {
        let i2;
        const op = opcodes[opIndex];
        sysData.state = id3.NOMATCH;
        const len = op.string.length;
        const beg = phraseIndex - len;
        if (beg >= 0) {
          for (i2 = 0; i2 < len; i2 += 1) {
            if (chars[beg + i2] !== op.string[i2]) {
              return;
            }
          }
          sysData.state = id3.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opTLSBehind = function(opIndex, phraseIndex, sysData) {
        let char;
        const op = opcodes[opIndex];
        sysData.state = id3.NOMATCH;
        const len = op.string.length;
        if (len === 0) {
          sysData.state = id3.EMPTY;
          return;
        }
        const beg = phraseIndex - len;
        if (beg >= 0) {
          for (let i2 = 0; i2 < len; i2 += 1) {
            char = chars[beg + i2];
            if (char >= 65 && char <= 90) {
              char += 32;
            }
            if (char !== op.string[i2]) {
              return;
            }
          }
          sysData.state = id3.MATCH;
          sysData.phraseLength = len;
        }
      };
      const opBKRBehind = function(opIndex, phraseIndex, sysData) {
        let i2;
        let code;
        let lmcode;
        let lower;
        const op = opcodes[opIndex];
        sysData.state = id3.NOMATCH;
        sysData.phraseLength = 0;
        if (op.index < rules.length) {
          lower = rules[op.index].lower;
        } else {
          lower = udts[op.index - rules.length].lower;
        }
        const frame2 = op.bkrMode === id3.BKR_MODE_PM ? sysData.pFrame.getPhrase(lower) : sysData.uFrame.getPhrase(lower);
        const insensitive = op.bkrCase === id3.BKR_MODE_CI;
        if (frame2 === null) {
          return;
        }
        const lmIndex = frame2.phraseIndex;
        const len = frame2.phraseLength;
        if (len === 0) {
          sysData.state = id3.EMPTY;
          sysData.phraseLength = 0;
          return;
        }
        const beg = phraseIndex - len;
        if (beg >= 0) {
          if (insensitive) {
            for (i2 = 0; i2 < len; i2 += 1) {
              code = chars[beg + i2];
              lmcode = chars[lmIndex + i2];
              if (code >= 65 && code <= 90) {
                code += 32;
              }
              if (lmcode >= 65 && lmcode <= 90) {
                lmcode += 32;
              }
              if (code !== lmcode) {
                return;
              }
            }
            sysData.state = id3.MATCH;
            sysData.phraseLength = len;
          } else {
            for (i2 = 0; i2 < len; i2 += 1) {
              code = chars[beg + i2];
              lmcode = chars[lmIndex + i2];
              if (code !== lmcode) {
                return;
              }
            }
          }
          sysData.state = id3.MATCH;
          sysData.phraseLength = len;
        }
      };
      opExecute = function opExecuteFunc(opIndex, phraseIndex, sysData) {
        let ret = true;
        const op = opcodes[opIndex];
        nodeHits += 1;
        if (nodeHits > limitNodeHits) {
          throw new Error(`parser: maximum number of node hits exceeded: ${limitNodeHits}`);
        }
        treeDepth += 1;
        if (treeDepth > maxTreeDepth) {
          maxTreeDepth = treeDepth;
          if (maxTreeDepth > limitTreeDepth) {
            throw new Error(`parser: maximum parse tree depth exceeded: ${limitTreeDepth}`);
          }
        }
        sysData.refresh();
        if (thisThis.trace !== null) {
          const lk = lookAroundValue();
          thisThis.trace.down(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);
        }
        if (inLookBehind()) {
          switch (op.type) {
            case id3.ALT:
              opALT(opIndex, phraseIndex, sysData);
              break;
            case id3.CAT:
              opCATBehind(opIndex, phraseIndex, sysData);
              break;
            case id3.REP:
              opREPBehind(opIndex, phraseIndex, sysData);
              break;
            case id3.RNM:
              opRNM(opIndex, phraseIndex, sysData);
              break;
            case id3.UDT:
              opUDT(opIndex, phraseIndex, sysData);
              break;
            case id3.AND:
              opAND(opIndex, phraseIndex, sysData);
              break;
            case id3.NOT:
              opNOT(opIndex, phraseIndex, sysData);
              break;
            case id3.TRG:
              opTRGBehind(opIndex, phraseIndex, sysData);
              break;
            case id3.TBS:
              opTBSBehind(opIndex, phraseIndex, sysData);
              break;
            case id3.TLS:
              opTLSBehind(opIndex, phraseIndex, sysData);
              break;
            case id3.BKR:
              opBKRBehind(opIndex, phraseIndex, sysData);
              break;
            case id3.BKA:
              opBKA(opIndex, phraseIndex, sysData);
              break;
            case id3.BKN:
              opBKN(opIndex, phraseIndex, sysData);
              break;
            case id3.ABG:
              opABG(opIndex, phraseIndex, sysData);
              break;
            case id3.AEN:
              opAEN(opIndex, phraseIndex, sysData);
              break;
            default:
              ret = false;
              break;
          }
        } else {
          switch (op.type) {
            case id3.ALT:
              opALT(opIndex, phraseIndex, sysData);
              break;
            case id3.CAT:
              opCAT(opIndex, phraseIndex, sysData);
              break;
            case id3.REP:
              opREP(opIndex, phraseIndex, sysData);
              break;
            case id3.RNM:
              opRNM(opIndex, phraseIndex, sysData);
              break;
            case id3.UDT:
              opUDT(opIndex, phraseIndex, sysData);
              break;
            case id3.AND:
              opAND(opIndex, phraseIndex, sysData);
              break;
            case id3.NOT:
              opNOT(opIndex, phraseIndex, sysData);
              break;
            case id3.TRG:
              opTRG(opIndex, phraseIndex, sysData);
              break;
            case id3.TBS:
              opTBS(opIndex, phraseIndex, sysData);
              break;
            case id3.TLS:
              opTLS(opIndex, phraseIndex, sysData);
              break;
            case id3.BKR:
              opBKR(opIndex, phraseIndex, sysData);
              break;
            case id3.BKA:
              opBKA(opIndex, phraseIndex, sysData);
              break;
            case id3.BKN:
              opBKN(opIndex, phraseIndex, sysData);
              break;
            case id3.ABG:
              opABG(opIndex, phraseIndex, sysData);
              break;
            case id3.AEN:
              opAEN(opIndex, phraseIndex, sysData);
              break;
            default:
              ret = false;
              break;
          }
        }
        if (!inLookAround() && phraseIndex + sysData.phraseLength > maxMatched) {
          maxMatched = phraseIndex + sysData.phraseLength;
        }
        if (thisThis.stats !== null) {
          thisThis.stats.collect(op, sysData);
        }
        if (thisThis.trace !== null) {
          const lk = lookAroundValue();
          thisThis.trace.up(op, sysData.state, phraseIndex, sysData.phraseLength, lk.anchor, lk.lookAround);
        }
        treeDepth -= 1;
        return ret;
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/stats.js
var require_stats = __commonJS({
  "node_modules/apg-js/src/apg-lib/stats.js"(exports, module) {
    module.exports = function statsFunc() {
      const id3 = require_identifiers();
      const utils2 = require_utilities();
      const style2 = require_style();
      const thisFileName = "stats.js: ";
      let rules = [];
      let udts = [];
      const stats = [];
      let totals;
      const ruleStats = [];
      const udtStats = [];
      this.statsObject = "statsObject";
      const nameId = "stats";
      const sortAlpha = function sortAlpha2(lhs, rhs) {
        if (lhs.lower < rhs.lower) {
          return -1;
        }
        if (lhs.lower > rhs.lower) {
          return 1;
        }
        return 0;
      };
      const sortHits = function sortHits2(lhs, rhs) {
        if (lhs.total < rhs.total) {
          return 1;
        }
        if (lhs.total > rhs.total) {
          return -1;
        }
        return sortAlpha(lhs, rhs);
      };
      const sortIndex = function sortIndex2(lhs, rhs) {
        if (lhs.index < rhs.index) {
          return -1;
        }
        if (lhs.index > rhs.index) {
          return 1;
        }
        return 0;
      };
      const EmptyStat = function EmptyStat2() {
        this.empty = 0;
        this.match = 0;
        this.nomatch = 0;
        this.total = 0;
      };
      const clear = function clear2() {
        stats.length = 0;
        totals = new EmptyStat();
        stats[id3.ALT] = new EmptyStat();
        stats[id3.CAT] = new EmptyStat();
        stats[id3.REP] = new EmptyStat();
        stats[id3.RNM] = new EmptyStat();
        stats[id3.TRG] = new EmptyStat();
        stats[id3.TBS] = new EmptyStat();
        stats[id3.TLS] = new EmptyStat();
        stats[id3.UDT] = new EmptyStat();
        stats[id3.AND] = new EmptyStat();
        stats[id3.NOT] = new EmptyStat();
        stats[id3.BKR] = new EmptyStat();
        stats[id3.BKA] = new EmptyStat();
        stats[id3.BKN] = new EmptyStat();
        stats[id3.ABG] = new EmptyStat();
        stats[id3.AEN] = new EmptyStat();
        ruleStats.length = 0;
        for (let i2 = 0; i2 < rules.length; i2 += 1) {
          ruleStats.push({
            empty: 0,
            match: 0,
            nomatch: 0,
            total: 0,
            name: rules[i2].name,
            lower: rules[i2].lower,
            index: rules[i2].index
          });
        }
        if (udts.length > 0) {
          udtStats.length = 0;
          for (let i2 = 0; i2 < udts.length; i2 += 1) {
            udtStats.push({
              empty: 0,
              match: 0,
              nomatch: 0,
              total: 0,
              name: udts[i2].name,
              lower: udts[i2].lower,
              index: udts[i2].index
            });
          }
        }
      };
      const incStat = function incStat2(stat, state) {
        stat.total += 1;
        switch (state) {
          case id3.EMPTY:
            stat.empty += 1;
            break;
          case id3.MATCH:
            stat.match += 1;
            break;
          case id3.NOMATCH:
            stat.nomatch += 1;
            break;
          default:
            throw new Error(`${thisFileName}collect(): incStat(): unrecognized state: ${state}`);
        }
      };
      const displayRow = function displayRow2(name, stat) {
        let html = "";
        html += "<tr>";
        html += `<td class="${style2.CLASS_ACTIVE}">${name}</td>`;
        html += `<td class="${style2.CLASS_EMPTY}">${stat.empty}</td>`;
        html += `<td class="${style2.CLASS_MATCH}">${stat.match}</td>`;
        html += `<td class="${style2.CLASS_NOMATCH}">${stat.nomatch}</td>`;
        html += `<td class="${style2.CLASS_ACTIVE}">${stat.total}</td>`;
        html += "</tr>\n";
        return html;
      };
      const displayOpsOnly = function displayOpsOnly2() {
        let html = "";
        html += displayRow("ALT", stats[id3.ALT]);
        html += displayRow("CAT", stats[id3.CAT]);
        html += displayRow("REP", stats[id3.REP]);
        html += displayRow("RNM", stats[id3.RNM]);
        html += displayRow("TRG", stats[id3.TRG]);
        html += displayRow("TBS", stats[id3.TBS]);
        html += displayRow("TLS", stats[id3.TLS]);
        html += displayRow("UDT", stats[id3.UDT]);
        html += displayRow("AND", stats[id3.AND]);
        html += displayRow("NOT", stats[id3.NOT]);
        html += displayRow("BKR", stats[id3.BKR]);
        html += displayRow("BKA", stats[id3.BKA]);
        html += displayRow("BKN", stats[id3.BKN]);
        html += displayRow("ABG", stats[id3.ABG]);
        html += displayRow("AEN", stats[id3.AEN]);
        html += displayRow("totals", totals);
        return html;
      };
      const displayRules = function displayRules2() {
        let html = "";
        html += "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n";
        html += "<tr><th>rules</th><th></th><th></th><th></th><th></th></tr>\n";
        for (let i2 = 0; i2 < rules.length; i2 += 1) {
          if (ruleStats[i2].total > 0) {
            html += "<tr>";
            html += `<td class="${style2.CLASS_ACTIVE}">${ruleStats[i2].name}</td>`;
            html += `<td class="${style2.CLASS_EMPTY}">${ruleStats[i2].empty}</td>`;
            html += `<td class="${style2.CLASS_MATCH}">${ruleStats[i2].match}</td>`;
            html += `<td class="${style2.CLASS_NOMATCH}">${ruleStats[i2].nomatch}</td>`;
            html += `<td class="${style2.CLASS_ACTIVE}">${ruleStats[i2].total}</td>`;
            html += "</tr>\n";
          }
        }
        if (udts.length > 0) {
          html += "<tr><th></th><th></th><th></th><th></th><th></th></tr>\n";
          html += "<tr><th>udts</th><th></th><th></th><th></th><th></th></tr>\n";
          for (let i2 = 0; i2 < udts.length; i2 += 1) {
            if (udtStats[i2].total > 0) {
              html += "<tr>";
              html += `<td class="${style2.CLASS_ACTIVE}">${udtStats[i2].name}</td>`;
              html += `<td class="${style2.CLASS_EMPTY}">${udtStats[i2].empty}</td>`;
              html += `<td class="${style2.CLASS_MATCH}">${udtStats[i2].match}</td>`;
              html += `<td class="${style2.CLASS_NOMATCH}">${udtStats[i2].nomatch}</td>`;
              html += `<td class="${style2.CLASS_ACTIVE}">${udtStats[i2].total}</td>`;
              html += "</tr>\n";
            }
          }
        }
        return html;
      };
      this.validate = function validate14(name) {
        let ret = false;
        if (typeof name === "string" && nameId === name) {
          ret = true;
        }
        return ret;
      };
      this.init = function init2(inputRules, inputUdts) {
        rules = inputRules;
        udts = inputUdts;
        clear();
      };
      this.collect = function collect(op, result) {
        incStat(totals, result.state, result.phraseLength);
        incStat(stats[op.type], result.state, result.phraseLength);
        if (op.type === id3.RNM) {
          incStat(ruleStats[op.index], result.state, result.phraseLength);
        }
        if (op.type === id3.UDT) {
          incStat(udtStats[op.index], result.state, result.phraseLength);
        }
      };
      this.toHtml = function toHtml(type6, caption) {
        let html = "";
        html += `<table class="${style2.CLASS_STATS}">
`;
        if (typeof caption === "string") {
          html += `<caption>${caption}</caption>
`;
        }
        html += `<tr><th class="${style2.CLASS_ACTIVE}">ops</th>
`;
        html += `<th class="${style2.CLASS_EMPTY}">EMPTY</th>
`;
        html += `<th class="${style2.CLASS_MATCH}">MATCH</th>
`;
        html += `<th class="${style2.CLASS_NOMATCH}">NOMATCH</th>
`;
        html += `<th class="${style2.CLASS_ACTIVE}">totals</th></tr>
`;
        const test3 = true;
        while (test3) {
          if (type6 === void 0) {
            html += displayOpsOnly();
            break;
          }
          if (type6 === null) {
            html += displayOpsOnly();
            break;
          }
          if (type6 === "ops") {
            html += displayOpsOnly();
            break;
          }
          if (type6 === "index") {
            ruleStats.sort(sortIndex);
            if (udtStats.length > 0) {
              udtStats.sort(sortIndex);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          if (type6 === "hits") {
            ruleStats.sort(sortHits);
            if (udtStats.length > 0) {
              udtStats.sort(sortIndex);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          if (type6 === "alpha") {
            ruleStats.sort(sortAlpha);
            if (udtStats.length > 0) {
              udtStats.sort(sortAlpha);
            }
            html += displayOpsOnly();
            html += displayRules();
            break;
          }
          break;
        }
        html += "</table>\n";
        return html;
      };
      this.toHtmlPage = function toHtmlPage(type6, caption, title) {
        return utils2.htmlToPage(this.toHtml(type6, caption), title);
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/trace.js
var require_trace = __commonJS({
  "node_modules/apg-js/src/apg-lib/trace.js"(exports, module) {
    module.exports = function exportTrace() {
      const utils2 = require_utilities();
      const style2 = require_style();
      const circular = new (require_circular_buffer())();
      const id3 = require_identifiers();
      const thisFileName = "trace.js: ";
      const that2 = this;
      const MODE_HEX = 16;
      const MODE_DEC = 10;
      const MODE_ASCII = 8;
      const MODE_UNICODE = 32;
      const MAX_PHRASE = 80;
      const MAX_TLS = 5;
      const records = [];
      let maxRecords = 5e3;
      let lastRecord = -1;
      let filteredRecords = 0;
      let treeDepth = 0;
      const recordStack = [];
      let chars = null;
      let rules = null;
      let udts = null;
      const operatorFilter = [];
      const ruleFilter = [];
      const PHRASE_END = `<span class="${style2.CLASS_LINEEND}">&bull;</span>`;
      const PHRASE_CONTINUE = `<span class="${style2.CLASS_LINEEND}">&hellip;</span>`;
      const PHRASE_EMPTY = `<span class="${style2.CLASS_EMPTY}">&#120634;</span>`;
      const initOperatorFilter = function() {
        const setOperators = function(set) {
          operatorFilter[id3.ALT] = set;
          operatorFilter[id3.CAT] = set;
          operatorFilter[id3.REP] = set;
          operatorFilter[id3.TLS] = set;
          operatorFilter[id3.TBS] = set;
          operatorFilter[id3.TRG] = set;
          operatorFilter[id3.AND] = set;
          operatorFilter[id3.NOT] = set;
          operatorFilter[id3.BKR] = set;
          operatorFilter[id3.BKA] = set;
          operatorFilter[id3.BKN] = set;
          operatorFilter[id3.ABG] = set;
          operatorFilter[id3.AEN] = set;
        };
        let items = 0;
        for (const name in that2.filter.operators) {
          items += 1;
        }
        if (items === 0) {
          setOperators(false);
          return;
        }
        for (const name in that2.filter.operators) {
          const upper = name.toUpperCase();
          if (upper === "<ALL>") {
            setOperators(true);
            return;
          }
          if (upper === "<NONE>") {
            setOperators(false);
            return;
          }
        }
        setOperators(false);
        for (const name in that2.filter.operators) {
          const upper = name.toUpperCase();
          if (upper === "ALT") {
            operatorFilter[id3.ALT] = that2.filter.operators[name] === true;
          } else if (upper === "CAT") {
            operatorFilter[id3.CAT] = that2.filter.operators[name] === true;
          } else if (upper === "REP") {
            operatorFilter[id3.REP] = that2.filter.operators[name] === true;
          } else if (upper === "AND") {
            operatorFilter[id3.AND] = that2.filter.operators[name] === true;
          } else if (upper === "NOT") {
            operatorFilter[id3.NOT] = that2.filter.operators[name] === true;
          } else if (upper === "TLS") {
            operatorFilter[id3.TLS] = that2.filter.operators[name] === true;
          } else if (upper === "TBS") {
            operatorFilter[id3.TBS] = that2.filter.operators[name] === true;
          } else if (upper === "TRG") {
            operatorFilter[id3.TRG] = that2.filter.operators[name] === true;
          } else if (upper === "BKR") {
            operatorFilter[id3.BKR] = that2.filter.operators[name] === true;
          } else if (upper === "BKA") {
            operatorFilter[id3.BKA] = that2.filter.operators[name] === true;
          } else if (upper === "BKN") {
            operatorFilter[id3.BKN] = that2.filter.operators[name] === true;
          } else if (upper === "ABG") {
            operatorFilter[id3.ABG] = that2.filter.operators[name] === true;
          } else if (upper === "AEN") {
            operatorFilter[id3.AEN] = that2.filter.operators[name] === true;
          } else {
            throw new Error(
              `${thisFileName}initOpratorFilter: '${name}' not a valid operator name. Must be <all>, <none>, alt, cat, rep, tls, tbs, trg, and, not, bkr, bka or bkn`
            );
          }
        }
      };
      const initRuleFilter = function() {
        const setRules = function(set) {
          operatorFilter[id3.RNM] = set;
          operatorFilter[id3.UDT] = set;
          const count = rules.length + udts.length;
          ruleFilter.length = 0;
          for (let i3 = 0; i3 < count; i3 += 1) {
            ruleFilter.push(set);
          }
        };
        let items;
        let i2;
        const list = [];
        for (i2 = 0; i2 < rules.length; i2 += 1) {
          list.push(rules[i2].lower);
        }
        for (i2 = 0; i2 < udts.length; i2 += 1) {
          list.push(udts[i2].lower);
        }
        ruleFilter.length = 0;
        items = 0;
        for (const name in that2.filter.rules) {
          items += 1;
        }
        if (items === 0) {
          setRules(true);
          return;
        }
        for (const name in that2.filter.rules) {
          const lower = name.toLowerCase();
          if (lower === "<all>") {
            setRules(true);
            return;
          }
          if (lower === "<none>") {
            setRules(false);
            return;
          }
        }
        setRules(false);
        operatorFilter[id3.RNM] = true;
        operatorFilter[id3.UDT] = true;
        for (const name in that2.filter.rules) {
          const lower = name.toLowerCase();
          i2 = list.indexOf(lower);
          if (i2 < 0) {
            throw new Error(`${thisFileName}initRuleFilter: '${name}' not a valid rule or udt name`);
          }
          ruleFilter[i2] = that2.filter.rules[name] === true;
        }
      };
      this.traceObject = "traceObject";
      this.filter = {
        operators: [],
        rules: []
      };
      this.setMaxRecords = function(max, last) {
        lastRecord = -1;
        if (typeof max === "number" && max > 0) {
          maxRecords = Math.ceil(max);
        } else {
          maxRecords = 0;
          return;
        }
        if (typeof last === "number") {
          lastRecord = Math.floor(last);
          if (lastRecord < 0) {
            lastRecord = -1;
          }
        }
      };
      this.getMaxRecords = function() {
        return maxRecords;
      };
      this.getLastRecord = function() {
        return lastRecord;
      };
      this.init = function(rulesIn, udtsIn, charsIn) {
        records.length = 0;
        recordStack.length = 0;
        filteredRecords = 0;
        treeDepth = 0;
        chars = charsIn;
        rules = rulesIn;
        udts = udtsIn;
        initOperatorFilter();
        initRuleFilter();
        circular.init(maxRecords);
      };
      const filterOps = function(op) {
        let ret = false;
        if (op.type === id3.RNM) {
          if (operatorFilter[op.type] && ruleFilter[op.index]) {
            ret = true;
          } else {
            ret = false;
          }
        } else if (op.type === id3.UDT) {
          if (operatorFilter[op.type] && ruleFilter[rules.length + op.index]) {
            ret = true;
          } else {
            ret = false;
          }
        } else {
          ret = operatorFilter[op.type];
        }
        return ret;
      };
      const filterRecords = function(record) {
        if (lastRecord === -1) {
          return true;
        }
        if (record <= lastRecord) {
          return true;
        }
        return false;
      };
      this.down = function(op, state, offset, length2, anchor, lookAround) {
        if (filterRecords(filteredRecords) && filterOps(op)) {
          recordStack.push(filteredRecords);
          records[circular.increment()] = {
            dirUp: false,
            depth: treeDepth,
            thisLine: filteredRecords,
            thatLine: void 0,
            opcode: op,
            state,
            phraseIndex: offset,
            phraseLength: length2,
            lookAnchor: anchor,
            lookAround
          };
          filteredRecords += 1;
          treeDepth += 1;
        }
      };
      this.up = function(op, state, offset, length2, anchor, lookAround) {
        if (filterRecords(filteredRecords) && filterOps(op)) {
          const thisLine = filteredRecords;
          const thatLine = recordStack.pop();
          const thatRecord = circular.getListIndex(thatLine);
          if (thatRecord !== -1) {
            records[thatRecord].thatLine = thisLine;
          }
          treeDepth -= 1;
          records[circular.increment()] = {
            dirUp: true,
            depth: treeDepth,
            thisLine,
            thatLine,
            opcode: op,
            state,
            phraseIndex: offset,
            phraseLength: length2,
            lookAnchor: anchor,
            lookAround
          };
          filteredRecords += 1;
        }
      };
      const toTreeObj = function() {
        function nodeOpcode(node2, opcode) {
          let name;
          let casetype;
          let modetype;
          if (opcode) {
            node2.op = { id: opcode.type, name: utils2.opcodeToString(opcode.type) };
            node2.opData = void 0;
            switch (opcode.type) {
              case id3.RNM:
                node2.opData = rules[opcode.index].name;
                break;
              case id3.UDT:
                node2.opData = udts[opcode.index].name;
                break;
              case id3.BKR:
                if (opcode.index < rules.length) {
                  name = rules[opcode.index].name;
                } else {
                  name = udts[opcode.index - rules.length].name;
                }
                casetype = opcode.bkrCase === id3.BKR_MODE_CI ? "%i" : "%s";
                modetype = opcode.bkrMode === id3.BKR_MODE_UM ? "%u" : "%p";
                node2.opData = `\\\\${casetype}${modetype}${name}`;
                break;
              case id3.TLS:
                node2.opData = [];
                for (let i2 = 0; i2 < opcode.string.length; i2 += 1) {
                  node2.opData.push(opcode.string[i2]);
                }
                break;
              case id3.TBS:
                node2.opData = [];
                for (let i2 = 0; i2 < opcode.string.length; i2 += 1) {
                  node2.opData.push(opcode.string[i2]);
                }
                break;
              case id3.TRG:
                node2.opData = [opcode.min, opcode.max];
                break;
              case id3.REP:
                node2.opData = [opcode.min, opcode.max];
                break;
              default:
                throw new Error("unrecognized opcode");
            }
          } else {
            node2.op = { id: void 0, name: void 0 };
            node2.opData = void 0;
          }
        }
        function nodePhrase(state, index5, length2) {
          if (state === id3.MATCH) {
            return {
              index: index5,
              length: length2
            };
          }
          if (state === id3.NOMATCH) {
            return {
              index: index5,
              length: 0
            };
          }
          if (state === id3.EMPTY) {
            return {
              index: index5,
              length: 0
            };
          }
          return null;
        }
        let nodeId = -1;
        function nodeDown(parent2, record2, depth2) {
          const node2 = {
            // eslint-disable-next-line no-plusplus
            id: nodeId++,
            branch: -1,
            parent: parent2,
            up: false,
            down: false,
            depth: depth2,
            children: []
          };
          if (record2) {
            node2.down = true;
            node2.state = { id: record2.state, name: utils2.stateToString(record2.state) };
            node2.phrase = null;
            nodeOpcode(node2, record2.opcode);
          } else {
            node2.state = { id: void 0, name: void 0 };
            node2.phrase = nodePhrase();
            nodeOpcode(node2, void 0);
          }
          return node2;
        }
        function nodeUp(node2, record2) {
          if (record2) {
            node2.up = true;
            node2.state = { id: record2.state, name: utils2.stateToString(record2.state) };
            node2.phrase = nodePhrase(record2.state, record2.phraseIndex, record2.phraseLength);
            if (!node2.down) {
              nodeOpcode(node2, record2.opcode);
            }
          }
        }
        let leafNodes = 0;
        let depth = -1;
        let branchCount = 1;
        function walk(node2) {
          depth += 1;
          node2.branch = branchCount;
          if (depth > treeDepth) {
            treeDepth = depth;
          }
          if (node2.children.length === 0) {
            leafNodes += 1;
          } else {
            for (let i2 = 0; i2 < node2.children.length; i2 += 1) {
              if (i2 > 0) {
                branchCount += 1;
              }
              node2.children[i2].leftMost = false;
              node2.children[i2].rightMost = false;
              if (node2.leftMost) {
                node2.children[i2].leftMost = i2 === 0;
              }
              if (node2.rightMost) {
                node2.children[i2].rightMost = i2 === node2.children.length - 1;
              }
              walk(node2.children[i2]);
            }
          }
          depth -= 1;
        }
        function display(node2, offset) {
          let name;
          const obj2 = {};
          obj2.id = node2.id;
          obj2.branch = node2.branch;
          obj2.leftMost = node2.leftMost;
          obj2.rightMost = node2.rightMost;
          name = node2.state.name ? node2.state.name : "ACTIVE";
          obj2.state = { id: node2.state.id, name };
          name = node2.op.name ? node2.op.name : "?";
          obj2.op = { id: node2.op.id, name };
          if (typeof node2.opData === "string") {
            obj2.opData = node2.opData;
          } else if (Array.isArray(node2.opData)) {
            obj2.opData = [];
            for (let i2 = 0; i2 < node2.opData.length; i2 += 1) {
              obj2.opData[i2] = node2.opData[i2];
            }
          } else {
            obj2.opData = void 0;
          }
          if (node2.phrase) {
            obj2.phrase = { index: node2.phrase.index, length: node2.phrase.length };
          } else {
            obj2.phrase = null;
          }
          obj2.depth = node2.depth;
          obj2.children = [];
          for (let i2 = 0; i2 < node2.children.length; i2 += 1) {
            const c3 = i2 !== node2.children.length - 1;
            obj2.children[i2] = display(node2.children[i2], offset, c3);
          }
          return obj2;
        }
        const branch = [];
        let root2;
        let node;
        let parent;
        let record;
        let firstRecord = true;
        const dummy = nodeDown(null, null, -1);
        branch.push(dummy);
        node = dummy;
        circular.forEach((lineIndex) => {
          record = records[lineIndex];
          if (firstRecord) {
            firstRecord = false;
            if (record.depth > 0) {
              const num = record.dirUp ? record.depth + 1 : record.depth;
              for (let i2 = 0; i2 < num; i2 += 1) {
                parent = node;
                node = nodeDown(node, null, i2);
                branch.push(node);
                parent.children.push(node);
              }
            }
          }
          if (record.dirUp) {
            node = branch.pop();
            nodeUp(node, record);
            node = branch[branch.length - 1];
          } else {
            parent = node;
            node = nodeDown(node, record, record.depth);
            branch.push(node);
            parent.children.push(node);
          }
        });
        while (branch.length > 1) {
          node = branch.pop();
          nodeUp(node, null);
        }
        if (dummy.children.length === 0) {
          throw new Error("trace.toTree(): parse tree has no nodes");
        }
        if (branch.length === 0) {
          throw new Error("trace.toTree(): integrity check: dummy root node disappeared?");
        }
        root2 = dummy.children[0];
        let prev = root2;
        while (root2 && !root2.down && !root2.up) {
          prev = root2;
          root2 = root2.children[0];
        }
        root2 = prev;
        root2.leftMost = true;
        root2.rightMost = true;
        walk(root2);
        root2.branch = 0;
        const obj = {};
        obj.string = [];
        for (let i2 = 0; i2 < chars.length; i2 += 1) {
          obj.string[i2] = chars[i2];
        }
        obj.rules = [];
        for (let i2 = 0; i2 < rules.length; i2 += 1) {
          obj.rules[i2] = rules[i2].name;
        }
        obj.udts = [];
        for (let i2 = 0; i2 < udts.length; i2 += 1) {
          obj.udts[i2] = udts[i2].name;
        }
        obj.id = {};
        obj.id.ALT = { id: id3.ALT, name: "ALT" };
        obj.id.CAT = { id: id3.CAT, name: "CAT" };
        obj.id.REP = { id: id3.REP, name: "REP" };
        obj.id.RNM = { id: id3.RNM, name: "RNM" };
        obj.id.TLS = { id: id3.TLS, name: "TLS" };
        obj.id.TBS = { id: id3.TBS, name: "TBS" };
        obj.id.TRG = { id: id3.TRG, name: "TRG" };
        obj.id.UDT = { id: id3.UDT, name: "UDT" };
        obj.id.AND = { id: id3.AND, name: "AND" };
        obj.id.NOT = { id: id3.NOT, name: "NOT" };
        obj.id.BKR = { id: id3.BKR, name: "BKR" };
        obj.id.BKA = { id: id3.BKA, name: "BKA" };
        obj.id.BKN = { id: id3.BKN, name: "BKN" };
        obj.id.ABG = { id: id3.ABG, name: "ABG" };
        obj.id.AEN = { id: id3.AEN, name: "AEN" };
        obj.id.ACTIVE = { id: id3.ACTIVE, name: "ACTIVE" };
        obj.id.MATCH = { id: id3.MATCH, name: "MATCH" };
        obj.id.EMPTY = { id: id3.EMPTY, name: "EMPTY" };
        obj.id.NOMATCH = { id: id3.NOMATCH, name: "NOMATCH" };
        obj.treeDepth = treeDepth;
        obj.leafNodes = leafNodes;
        let branchesIncomplete;
        if (root2.down) {
          if (root2.up) {
            branchesIncomplete = "none";
          } else {
            branchesIncomplete = "right";
          }
        } else if (root2.up) {
          branchesIncomplete = "left";
        } else {
          branchesIncomplete = "both";
        }
        obj.branchesIncomplete = branchesIncomplete;
        obj.tree = display(root2, root2.depth, false);
        return obj;
      };
      this.toTree = function(stringify2) {
        const obj = toTreeObj();
        if (stringify2) {
          return JSON.stringify(obj);
        }
        return obj;
      };
      this.toHtmlPage = function(mode3, caption, title) {
        return utils2.htmlToPage(this.toHtml(mode3, caption), title);
      };
      const htmlHeader = function(mode3, caption) {
        let modeName;
        switch (mode3) {
          case MODE_HEX:
            modeName = "hexadecimal";
            break;
          case MODE_DEC:
            modeName = "decimal";
            break;
          case MODE_ASCII:
            modeName = "ASCII";
            break;
          case MODE_UNICODE:
            modeName = "UNICODE";
            break;
          default:
            throw new Error(`${thisFileName}htmlHeader: unrecognized mode: ${mode3}`);
        }
        let header = "";
        header += `<p>display mode: ${modeName}</p>
`;
        header += `<table class="${style2.CLASS_TRACE}">
`;
        if (typeof caption === "string") {
          header += `<caption>${caption}</caption>`;
        }
        return header;
      };
      const htmlFooter = function() {
        let footer = "";
        footer += "</table>\n";
        footer += `<p class="${style2.CLASS_MONOSPACE}">legend:<br>
`;
        footer += "(a)&nbsp;-&nbsp;line number<br>\n";
        footer += "(b)&nbsp;-&nbsp;matching line number<br>\n";
        footer += "(c)&nbsp;-&nbsp;phrase offset<br>\n";
        footer += "(d)&nbsp;-&nbsp;phrase length<br>\n";
        footer += "(e)&nbsp;-&nbsp;tree depth<br>\n";
        footer += "(f)&nbsp;-&nbsp;operator state<br>\n";
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_ACTIVE}">&darr;</span>&nbsp;&nbsp;phrase opened<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_MATCH}">&uarr;M</span> phrase matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_EMPTY}">&uarr;E</span> empty phrase matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_NOMATCH}">&uarr;N</span> phrase not matched<br>
`;
        footer += "operator&nbsp;-&nbsp;ALT, CAT, REP, RNM, TRG, TLS, TBS<sup>&dagger;</sup>, UDT, AND, NOT, BKA, BKN, BKR, ABG, AEN<sup>&Dagger;</sup><br>\n";
        footer += `phrase&nbsp;&nbsp;&nbsp;-&nbsp;up to ${MAX_PHRASE} characters of the phrase being matched<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_MATCH}">matched characters</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_LOOKAHEAD}">matched characters in look ahead mode</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_LOOKBEHIND}">matched characters in look behind mode</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_REMAINDER}">remainder characters(not yet examined by parser)</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;<span class="${style2.CLASS_CTRLCHAR}">control characters, TAB, LF, CR, etc. (ASCII mode only)</span><br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_EMPTY} empty string<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_END} end of input string<br>
`;
        footer += `&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;-&nbsp;${PHRASE_CONTINUE} input string display truncated<br>
`;
        footer += "</p>\n";
        footer += `<p class="${style2.CLASS_MONOSPACE}">
`;
        footer += "<sup>&dagger;</sup>original ABNF operators:<br>\n";
        footer += "ALT - alternation<br>\n";
        footer += "CAT - concatenation<br>\n";
        footer += "REP - repetition<br>\n";
        footer += "RNM - rule name<br>\n";
        footer += "TRG - terminal range<br>\n";
        footer += "TLS - terminal literal string (case insensitive)<br>\n";
        footer += "TBS - terminal binary string (case sensitive)<br>\n";
        footer += "<br>\n";
        footer += "<sup>&Dagger;</sup>super set SABNF operators:<br>\n";
        footer += "UDT - user-defined terminal<br>\n";
        footer += "AND - positive look ahead<br>\n";
        footer += "NOT - negative look ahead<br>\n";
        footer += "BKA - positive look behind<br>\n";
        footer += "BKN - negative look behind<br>\n";
        footer += "BKR - back reference<br>\n";
        footer += "ABG - anchor - begin of input string<br>\n";
        footer += "AEN - anchor - end of input string<br>\n";
        footer += "</p>\n";
        return footer;
      };
      this.indent = function(depth) {
        let html = "";
        for (let i2 = 0; i2 < depth; i2 += 1) {
          html += ".";
        }
        return html;
      };
      const displayTrg = function(mode3, op) {
        let html = "";
        if (op.type === id3.TRG) {
          if (mode3 === MODE_HEX || mode3 === MODE_UNICODE) {
            let hex3 = op.min.toString(16).toUpperCase();
            if (hex3.length % 2 !== 0) {
              hex3 = `0${hex3}`;
            }
            html += mode3 === MODE_HEX ? "%x" : "U+";
            html += hex3;
            hex3 = op.max.toString(16).toUpperCase();
            if (hex3.length % 2 !== 0) {
              hex3 = `0${hex3}`;
            }
            html += `&ndash;${hex3}`;
          } else {
            html = `%d${op.min.toString(10)}&ndash;${op.max.toString(10)}`;
          }
        }
        return html;
      };
      const displayRep = function(mode3, op) {
        let html = "";
        if (op.type === id3.REP) {
          if (mode3 === MODE_HEX) {
            let hex3 = op.min.toString(16).toUpperCase();
            if (hex3.length % 2 !== 0) {
              hex3 = `0${hex3}`;
            }
            html = `x${hex3}`;
            if (op.max < Infinity) {
              hex3 = op.max.toString(16).toUpperCase();
              if (hex3.length % 2 !== 0) {
                hex3 = `0${hex3}`;
              }
            } else {
              hex3 = "inf";
            }
            html += `&ndash;${hex3}`;
          } else if (op.max < Infinity) {
            html = `${op.min.toString(10)}&ndash;${op.max.toString(10)}`;
          } else {
            html = `${op.min.toString(10)}&ndash;inf`;
          }
        }
        return html;
      };
      const displayTbs = function(mode3, op) {
        let html = "";
        if (op.type === id3.TBS) {
          const len = Math.min(op.string.length, MAX_TLS * 2);
          if (mode3 === MODE_HEX || mode3 === MODE_UNICODE) {
            html += mode3 === MODE_HEX ? "%x" : "U+";
            for (let i2 = 0; i2 < len; i2 += 1) {
              let hex3;
              if (i2 > 0) {
                html += ".";
              }
              hex3 = op.string[i2].toString(16).toUpperCase();
              if (hex3.length % 2 !== 0) {
                hex3 = `0${hex3}`;
              }
              html += hex3;
            }
          } else {
            html = "%d";
            for (let i2 = 0; i2 < len; i2 += 1) {
              if (i2 > 0) {
                html += ".";
              }
              html += op.string[i2].toString(10);
            }
          }
          if (len < op.string.length) {
            html += PHRASE_CONTINUE;
          }
        }
        return html;
      };
      const displayTls = function(mode3, op) {
        let html = "";
        if (op.type === id3.TLS) {
          const len = Math.min(op.string.length, MAX_TLS);
          if (mode3 === MODE_HEX || mode3 === MODE_DEC) {
            let charu;
            let charl;
            let base3;
            if (mode3 === MODE_HEX) {
              html = "%x";
              base3 = 16;
            } else {
              html = "%d";
              base3 = 10;
            }
            for (let i2 = 0; i2 < len; i2 += 1) {
              if (i2 > 0) {
                html += ".";
              }
              charl = op.string[i2];
              if (charl >= 97 && charl <= 122) {
                charu = charl - 32;
                html += `${charu.toString(base3)}/${charl.toString(base3)}`.toUpperCase();
              } else if (charl >= 65 && charl <= 90) {
                charu = charl;
                charl += 32;
                html += `${charu.toString(base3)}/${charl.toString(base3)}`.toUpperCase();
              } else {
                html += charl.toString(base3).toUpperCase();
              }
            }
            if (len < op.string.length) {
              html += PHRASE_CONTINUE;
            }
          } else {
            html = '"';
            for (let i2 = 0; i2 < len; i2 += 1) {
              html += utils2.asciiChars[op.string[i2]];
            }
            if (len < op.string.length) {
              html += PHRASE_CONTINUE;
            }
            html += '"';
          }
        }
        return html;
      };
      const subPhrase = function(mode3, charsArg, index5, length2, prev) {
        if (length2 === 0) {
          return "";
        }
        let phrase = "";
        const comma = prev ? "," : "";
        switch (mode3) {
          case MODE_HEX:
            phrase = comma + utils2.charsToHex(charsArg, index5, length2);
            break;
          case MODE_DEC:
            if (prev) {
              return `,${utils2.charsToDec(charsArg, index5, length2)}`;
            }
            phrase = comma + utils2.charsToDec(charsArg, index5, length2);
            break;
          case MODE_UNICODE:
            phrase = utils2.charsToUnicode(charsArg, index5, length2);
            break;
          case MODE_ASCII:
          default:
            phrase = utils2.charsToAsciiHtml(charsArg, index5, length2);
            break;
        }
        return phrase;
      };
      const displayBehind = function(mode3, charsArg, state, index5, length2, anchor) {
        let html = "";
        let beg1;
        let len1;
        let beg2;
        let len2;
        let lastchar = PHRASE_END;
        const spanBehind = `<span class="${style2.CLASS_LOOKBEHIND}">`;
        const spanRemainder = `<span class="${style2.CLASS_REMAINDER}">`;
        const spanend = "</span>";
        let prev = false;
        switch (state) {
          case id3.EMPTY:
            html += PHRASE_EMPTY;
          case id3.NOMATCH:
          case id3.MATCH:
          case id3.ACTIVE:
            beg1 = index5 - length2;
            len1 = anchor - beg1;
            beg2 = anchor;
            len2 = charsArg.length - beg2;
            break;
          default:
            throw new Error("unrecognized state");
        }
        lastchar = PHRASE_END;
        if (len1 > MAX_PHRASE) {
          len1 = MAX_PHRASE;
          lastchar = PHRASE_CONTINUE;
          len2 = 0;
        } else if (len1 + len2 > MAX_PHRASE) {
          lastchar = PHRASE_CONTINUE;
          len2 = MAX_PHRASE - len1;
        }
        if (len1 > 0) {
          html += spanBehind;
          html += subPhrase(mode3, charsArg, beg1, len1, prev);
          html += spanend;
          prev = true;
        }
        if (len2 > 0) {
          html += spanRemainder;
          html += subPhrase(mode3, charsArg, beg2, len2, prev);
          html += spanend;
        }
        return html + lastchar;
      };
      const displayForward = function(mode3, charsArg, state, index5, length2, spanAhead) {
        let html = "";
        let beg1;
        let len1;
        let beg2;
        let len2;
        let lastchar = PHRASE_END;
        const spanRemainder = `<span class="${style2.CLASS_REMAINDER}">`;
        const spanend = "</span>";
        let prev = false;
        switch (state) {
          case id3.EMPTY:
            html += PHRASE_EMPTY;
          case id3.NOMATCH:
          case id3.ACTIVE:
            beg1 = index5;
            len1 = 0;
            beg2 = index5;
            len2 = charsArg.length - beg2;
            break;
          case id3.MATCH:
            beg1 = index5;
            len1 = length2;
            beg2 = index5 + len1;
            len2 = charsArg.length - beg2;
            break;
          default:
            throw new Error("unrecognized state");
        }
        lastchar = PHRASE_END;
        if (len1 > MAX_PHRASE) {
          len1 = MAX_PHRASE;
          lastchar = PHRASE_CONTINUE;
          len2 = 0;
        } else if (len1 + len2 > MAX_PHRASE) {
          lastchar = PHRASE_CONTINUE;
          len2 = MAX_PHRASE - len1;
        }
        if (len1 > 0) {
          html += spanAhead;
          html += subPhrase(mode3, charsArg, beg1, len1, prev);
          html += spanend;
          prev = true;
        }
        if (len2 > 0) {
          html += spanRemainder;
          html += subPhrase(mode3, charsArg, beg2, len2, prev);
          html += spanend;
        }
        return html + lastchar;
      };
      const displayAhead = function(mode3, charsArg, state, index5, length2) {
        const spanAhead = `<span class="${style2.CLASS_LOOKAHEAD}">`;
        return displayForward(mode3, charsArg, state, index5, length2, spanAhead);
      };
      const displayNone = function(mode3, charsArg, state, index5, length2) {
        const spanAhead = `<span class="${style2.CLASS_MATCH}">`;
        return displayForward(mode3, charsArg, state, index5, length2, spanAhead);
      };
      const htmlTable = function(mode3) {
        if (rules === null) {
          return "";
        }
        let html = "";
        let thisLine;
        let thatLine;
        let lookAhead;
        let lookBehind;
        let lookAround;
        let anchor;
        html += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>";
        html += "<th>operator</th><th>phrase</th></tr>\n";
        circular.forEach((lineIndex) => {
          const line = records[lineIndex];
          thisLine = line.thisLine;
          thatLine = line.thatLine !== void 0 ? line.thatLine : "--";
          lookAhead = false;
          lookBehind = false;
          lookAround = false;
          if (line.lookAround === id3.LOOKAROUND_AHEAD) {
            lookAhead = true;
            lookAround = true;
            anchor = line.lookAnchor;
          }
          if (line.opcode.type === id3.AND || line.opcode.type === id3.NOT) {
            lookAhead = true;
            lookAround = true;
            anchor = line.phraseIndex;
          }
          if (line.lookAround === id3.LOOKAROUND_BEHIND) {
            lookBehind = true;
            lookAround = true;
            anchor = line.lookAnchor;
          }
          if (line.opcode.type === id3.BKA || line.opcode.type === id3.BKN) {
            lookBehind = true;
            lookAround = true;
            anchor = line.phraseIndex;
          }
          html += "<tr>";
          html += `<td>${thisLine}</td><td>${thatLine}</td>`;
          html += `<td>${line.phraseIndex}</td>`;
          html += `<td>${line.phraseLength}</td>`;
          html += `<td>${line.depth}</td>`;
          html += "<td>";
          switch (line.state) {
            case id3.ACTIVE:
              html += `<span class="${style2.CLASS_ACTIVE}">&darr;&nbsp;</span>`;
              break;
            case id3.MATCH:
              html += `<span class="${style2.CLASS_MATCH}">&uarr;M</span>`;
              break;
            case id3.NOMATCH:
              html += `<span class="${style2.CLASS_NOMATCH}">&uarr;N</span>`;
              break;
            case id3.EMPTY:
              html += `<span class="${style2.CLASS_EMPTY}">&uarr;E</span>`;
              break;
            default:
              html += `<span class="${style2.CLASS_ACTIVE}">--</span>`;
              break;
          }
          html += "</td>";
          html += "<td>";
          html += that2.indent(line.depth);
          if (lookAhead) {
            html += `<span class="${style2.CLASS_LOOKAHEAD}">`;
          } else if (lookBehind) {
            html += `<span class="${style2.CLASS_LOOKBEHIND}">`;
          }
          html += utils2.opcodeToString(line.opcode.type);
          if (line.opcode.type === id3.RNM) {
            html += `(${rules[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id3.BKR) {
            const casetype = line.opcode.bkrCase === id3.BKR_MODE_CI ? "%i" : "%s";
            const modetype = line.opcode.bkrMode === id3.BKR_MODE_UM ? "%u" : "%p";
            html += `(\\${casetype}${modetype}${rules[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id3.UDT) {
            html += `(${udts[line.opcode.index].name}) `;
          }
          if (line.opcode.type === id3.TRG) {
            html += `(${displayTrg(mode3, line.opcode)}) `;
          }
          if (line.opcode.type === id3.TBS) {
            html += `(${displayTbs(mode3, line.opcode)}) `;
          }
          if (line.opcode.type === id3.TLS) {
            html += `(${displayTls(mode3, line.opcode)}) `;
          }
          if (line.opcode.type === id3.REP) {
            html += `(${displayRep(mode3, line.opcode)}) `;
          }
          if (lookAround) {
            html += "</span>";
          }
          html += "</td>";
          html += "<td>";
          if (lookBehind) {
            html += displayBehind(mode3, chars, line.state, line.phraseIndex, line.phraseLength, anchor);
          } else if (lookAhead) {
            html += displayAhead(mode3, chars, line.state, line.phraseIndex, line.phraseLength);
          } else {
            html += displayNone(mode3, chars, line.state, line.phraseIndex, line.phraseLength);
          }
          html += "</td></tr>\n";
        });
        html += "<tr><th>(a)</th><th>(b)</th><th>(c)</th><th>(d)</th><th>(e)</th><th>(f)</th>";
        html += "<th>operator</th><th>phrase</th></tr>\n";
        html += "</table>\n";
        return html;
      };
      this.toHtml = function(modearg, caption) {
        let mode3 = MODE_ASCII;
        if (typeof modearg === "string" && modearg.length >= 3) {
          const modein = modearg.toLowerCase().slice(0, 3);
          if (modein === "hex") {
            mode3 = MODE_HEX;
          } else if (modein === "dec") {
            mode3 = MODE_DEC;
          } else if (modein === "uni") {
            mode3 = MODE_UNICODE;
          }
        }
        let html = "";
        html += htmlHeader(mode3, caption);
        html += htmlTable(mode3);
        html += htmlFooter();
        return html;
      };
    };
  }
});

// node_modules/apg-js/src/apg-lib/node-exports.js
var require_node_exports = __commonJS({
  "node_modules/apg-js/src/apg-lib/node-exports.js"(exports, module) {
    module.exports = {
      ast: require_ast(),
      circular: require_circular_buffer(),
      ids: require_identifiers(),
      parser: require_parser(),
      stats: require_stats(),
      trace: require_trace(),
      utils: require_utilities(),
      emitcss: require_emitcss(),
      style: require_style()
    };
  }
});

// node_modules/apg-js/src/apg-api/scanner-grammar.js
var require_scanner_grammar = __commonJS({
  "node_modules/apg-js/src/apg-api/scanner-grammar.js"(exports, module) {
    module.exports = function grammar() {
      this.grammarObject = "grammarObject";
      this.rules = [];
      this.rules[0] = { name: "file", lower: "file", index: 0, isBkr: false };
      this.rules[1] = { name: "line", lower: "line", index: 1, isBkr: false };
      this.rules[2] = { name: "line-text", lower: "line-text", index: 2, isBkr: false };
      this.rules[3] = { name: "last-line", lower: "last-line", index: 3, isBkr: false };
      this.rules[4] = { name: "valid", lower: "valid", index: 4, isBkr: false };
      this.rules[5] = { name: "invalid", lower: "invalid", index: 5, isBkr: false };
      this.rules[6] = { name: "end", lower: "end", index: 6, isBkr: false };
      this.rules[7] = { name: "CRLF", lower: "crlf", index: 7, isBkr: false };
      this.rules[8] = { name: "LF", lower: "lf", index: 8, isBkr: false };
      this.rules[9] = { name: "CR", lower: "cr", index: 9, isBkr: false };
      this.udts = [];
      this.rules[0].opcodes = [];
      this.rules[0].opcodes[0] = { type: 2, children: [1, 3] };
      this.rules[0].opcodes[1] = { type: 3, min: 0, max: Infinity };
      this.rules[0].opcodes[2] = { type: 4, index: 1 };
      this.rules[0].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[0].opcodes[4] = { type: 4, index: 3 };
      this.rules[1].opcodes = [];
      this.rules[1].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[1].opcodes[1] = { type: 4, index: 2 };
      this.rules[1].opcodes[2] = { type: 4, index: 6 };
      this.rules[2].opcodes = [];
      this.rules[2].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[2].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[2].opcodes[2] = { type: 4, index: 4 };
      this.rules[2].opcodes[3] = { type: 4, index: 5 };
      this.rules[3].opcodes = [];
      this.rules[3].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[3].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[3].opcodes[2] = { type: 4, index: 4 };
      this.rules[3].opcodes[3] = { type: 4, index: 5 };
      this.rules[4].opcodes = [];
      this.rules[4].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[4].opcodes[1] = { type: 5, min: 32, max: 126 };
      this.rules[4].opcodes[2] = { type: 6, string: [9] };
      this.rules[5].opcodes = [];
      this.rules[5].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[5].opcodes[1] = { type: 5, min: 0, max: 8 };
      this.rules[5].opcodes[2] = { type: 5, min: 11, max: 12 };
      this.rules[5].opcodes[3] = { type: 5, min: 14, max: 31 };
      this.rules[5].opcodes[4] = { type: 5, min: 127, max: 4294967295 };
      this.rules[6].opcodes = [];
      this.rules[6].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[6].opcodes[1] = { type: 4, index: 7 };
      this.rules[6].opcodes[2] = { type: 4, index: 8 };
      this.rules[6].opcodes[3] = { type: 4, index: 9 };
      this.rules[7].opcodes = [];
      this.rules[7].opcodes[0] = { type: 6, string: [13, 10] };
      this.rules[8].opcodes = [];
      this.rules[8].opcodes[0] = { type: 6, string: [10] };
      this.rules[9].opcodes = [];
      this.rules[9].opcodes[0] = { type: 6, string: [13] };
      this.toString = function toString7() {
        let str = "";
        str += "file = *line [last-line]\n";
        str += "line = line-text end\n";
        str += "line-text = *(valid/invalid)\n";
        str += "last-line = 1*(valid/invalid)\n";
        str += "valid = %d32-126 / %d9\n";
        str += "invalid = %d0-8 / %d11-12 /%d14-31 / %x7f-ffffffff\n";
        str += "end = CRLF / LF / CR\n";
        str += "CRLF = %d13.10\n";
        str += "LF = %d10\n";
        str += "CR = %d13\n";
        return str;
      };
    };
  }
});

// node_modules/apg-js/src/apg-api/scanner-callbacks.js
var require_scanner_callbacks = __commonJS({
  "node_modules/apg-js/src/apg-api/scanner-callbacks.js"(exports) {
    var ids = require_identifiers();
    var utils2 = require_utilities();
    function semLine(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endLength = 0;
        data.textLength = 0;
        data.invalidCount = 0;
      } else {
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount,
          textLength: data.textLength,
          endType: data.endType,
          invalidChars: data.invalidCount
        });
      }
      return ids.SEM_OK;
    }
    function semLineText(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.textLength = phraseCount;
      }
      return ids.SEM_OK;
    }
    function semLastLine(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endLength = 0;
        data.textLength = 0;
        data.invalidCount = 0;
      } else if (data.strict) {
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount,
          textLength: phraseCount,
          endType: "none",
          invalidChars: data.invalidCount
        });
        data.errors.push({
          line: data.lineNo,
          char: phraseIndex + phraseCount,
          msg: "no line end on last line - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
        });
      } else {
        chars.push(10);
        data.lines.push({
          lineNo: data.lines.length,
          beginChar: phraseIndex,
          length: phraseCount + 1,
          textLength: phraseCount,
          endType: "LF",
          invalidChars: data.invalidCount
        });
      }
      return ids.SEM_OK;
    }
    function semInvalid(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.errors.push({
          line: data.lineNo,
          char: phraseIndex,
          msg: `invalid character found '\\x${utils2.charToHex(chars[phraseIndex])}'`
        });
      }
      return ids.SEM_OK;
    }
    function semEnd(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_POST) {
        data.lineNo += 1;
      }
      return ids.SEM_OK;
    }
    function semLF(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "LF";
        if (data.strict) {
          data.errors.push({
            line: data.lineNo,
            char: phraseIndex,
            msg: "line end character LF(\\n, \\x0A) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
          });
        }
      }
      return ids.SEM_OK;
    }
    function semCR(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "CR";
        if (data.strict) {
          data.errors.push({
            line: data.lineNo,
            char: phraseIndex,
            msg: "line end character CR(\\r, \\x0D) - strict ABNF specifies CRLF(\\r\\n, \\x0D\\x0A)"
          });
        }
      }
      return ids.SEM_OK;
    }
    function semCRLF(state, chars, phraseIndex, phraseCount, data) {
      if (state === ids.SEM_PRE) {
        data.endType = "CRLF";
      }
      return ids.SEM_OK;
    }
    var callbacks = [];
    callbacks.line = semLine;
    callbacks["line-text"] = semLineText;
    callbacks["last-line"] = semLastLine;
    callbacks.invalid = semInvalid;
    callbacks.end = semEnd;
    callbacks.lf = semLF;
    callbacks.cr = semCR;
    callbacks.crlf = semCRLF;
    exports.callbacks = callbacks;
  }
});

// node_modules/apg-js/src/apg-api/scanner.js
var require_scanner = __commonJS({
  "node_modules/apg-js/src/apg-api/scanner.js"(exports, module) {
    module.exports = function exfn(chars, errors, strict, trace) {
      const thisFileName = "scanner.js: ";
      const apglib = require_node_exports();
      const grammar = new (require_scanner_grammar())();
      const { callbacks } = require_scanner_callbacks();
      const lines = [];
      const parser = new apglib.parser();
      parser.ast = new apglib.ast();
      parser.ast.callbacks = callbacks;
      if (trace) {
        if (trace.traceObject !== "traceObject") {
          throw new TypeError(`${thisFileName}trace argument is not a trace object`);
        }
        parser.trace = trace;
      }
      const test3 = parser.parse(grammar, "file", chars);
      if (test3.success !== true) {
        errors.push({
          line: 0,
          char: 0,
          msg: "syntax analysis error analyzing input SABNF grammar"
        });
        return;
      }
      const data = {
        lines,
        lineNo: 0,
        errors,
        strict: !!strict
      };
      parser.ast.translate(data);
      return lines;
    };
  }
});

// node_modules/apg-js/src/apg-api/syntax-callbacks.js
var require_syntax_callbacks = __commonJS({
  "node_modules/apg-js/src/apg-api/syntax-callbacks.js"(exports, module) {
    module.exports = function exfn() {
      const thisFileName = "syntax-callbacks.js: ";
      const apglib = require_node_exports();
      const id3 = apglib.ids;
      let topAlt;
      const synFile = function synFile2(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            data.altStack = [];
            data.repCount = 0;
            break;
          case id3.EMPTY:
            data.errors.push({
              line: 0,
              char: 0,
              msg: "grammar file is empty"
            });
            break;
          case id3.MATCH:
            if (data.ruleCount === 0) {
              data.errors.push({
                line: 0,
                char: 0,
                msg: "no rules defined"
              });
            }
            break;
          case id3.NOMATCH:
            throw new Error(`${thisFileName}synFile: grammar file NOMATCH: design error: should never happen.`);
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synRule = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            data.altStack.length = 0;
            topAlt = {
              groupOpen: null,
              groupError: false,
              optionOpen: null,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          case id3.EMPTY:
            throw new Error(`${thisFileName}synRule: EMPTY: rule cannot be empty`);
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            data.ruleCount += 1;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synRuleError = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Unrecognized SABNF line. Invalid rule, comment or blank line."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synRuleNameError = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Rule names must be alphanum and begin with alphabetic character."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synDefinedAsError = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Expected '=' or '=/'. Not found."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synAndOp = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "AND operator(&) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synNotOp = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "NOT operator(!) found - strict ABNF specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synBkaOp = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Positive look-behind operator(&&) found - strict ABNF specified."
              });
            } else if (data.lite) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Positive look-behind operator(&&) found - apg-lite specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synBknOp = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Negative look-behind operator(!!) found - strict ABNF specified."
              });
            } else if (data.lite) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Negative look-behind operator(!!) found - apg-lite specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synAbgOp = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Beginning of string anchor(%^) found - strict ABNF specified."
              });
            } else if (data.lite) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Beginning of string anchor(%^) found - apg-lite specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synAenOp = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "End of string anchor(%$) found - strict ABNF specified."
              });
            } else if (data.lite) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "End of string anchor(%$) found - apg-lite specified."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synBkrOp = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.strict) {
              const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Back reference operator(${name}) found - strict ABNF specified.`
              });
            } else if (data.lite) {
              const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Back reference operator(${name}) found - apg-lite specified.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synUdtOp = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.strict) {
              const name = apglib.utils.charsToString(chars, phraseIndex, result.phraseLength);
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `UDT operator found(${name}) - strict ABNF specified.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synTlsOpen = function(result, chars, phraseIndex) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            topAlt.tlsOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synTlsString = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            data.stringTabChar = false;
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in literal string (see 'quoted-string' definition, RFC 7405.)"
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synStringTab = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            data.stringTabChar = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synTlsClose = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.tlsOpen),
              char: topAlt.tlsOpen,
              msg: 'Case-insensitive literal string("...") opened but not closed.'
            });
            topAlt.basicError = true;
            topAlt.tlsOpen = null;
            break;
          case id3.MATCH:
            topAlt.tlsOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synClsOpen = function(result, chars, phraseIndex) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            topAlt.clsOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synClsString = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            data.stringTabChar = false;
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in literal string."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synClsClose = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.clsOpen),
              char: topAlt.clsOpen,
              msg: "Case-sensitive literal string('...') opened but not closed."
            });
            topAlt.clsOpen = null;
            topAlt.basicError = true;
            break;
          case id3.MATCH:
            if (data.strict) {
              data.errors.push({
                line: data.findLine(data.lines, topAlt.clsOpen),
                char: topAlt.clsOpen,
                msg: "Case-sensitive string operator('...') found - strict ABNF specified."
              });
            }
            topAlt.clsOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synProsValOpen = function(result, chars, phraseIndex) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            topAlt.prosValOpen = phraseIndex;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synProsValString = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            data.stringTabChar = false;
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (data.stringTabChar !== false) {
              data.errors.push({
                line: data.findLine(data.lines, data.stringTabChar),
                char: data.stringTabChar,
                msg: "Tab character (\\t, x09) not allowed in prose value string."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synProsValClose = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.prosValOpen),
              char: topAlt.prosValOpen,
              msg: "Prose value operator(<...>) opened but not closed."
            });
            topAlt.basicError = true;
            topAlt.prosValOpen = null;
            break;
          case id3.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.prosValOpen),
              char: topAlt.prosValOpen,
              msg: "Prose value operator(<...>) found. The ABNF syntax is valid, but a parser cannot be generated from this grammar."
            });
            topAlt.prosValOpen = null;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synGroupOpen = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            topAlt = {
              groupOpen: phraseIndex,
              groupError: false,
              optionOpen: null,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synGroupClose = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.groupOpen),
              char: topAlt.groupOpen,
              msg: 'Group "(...)" opened but not closed.'
            });
            topAlt = data.altStack.pop();
            topAlt.groupError = true;
            break;
          case id3.MATCH:
            topAlt = data.altStack.pop();
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synOptionOpen = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            topAlt = {
              groupOpen: null,
              groupError: false,
              optionOpen: phraseIndex,
              optionError: false,
              tlsOpen: null,
              clsOpen: null,
              prosValOpen: null,
              basicError: false
            };
            data.altStack.push(topAlt);
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synOptionClose = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            data.errors.push({
              line: data.findLine(data.lines, topAlt.optionOpen),
              char: topAlt.optionOpen,
              msg: 'Option "[...]" opened but not closed.'
            });
            topAlt = data.altStack.pop();
            topAlt.optionError = true;
            break;
          case id3.MATCH:
            topAlt = data.altStack.pop();
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synBasicElementError = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (topAlt.basicError === false) {
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: "Unrecognized SABNF element."
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synLineEnd = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            if (result.phraseLength === 1 && data.strict) {
              const end = chars[phraseIndex] === 13 ? "CR" : "LF";
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Line end '${end}' found - strict ABNF specified, only CRLF allowed.`
              });
            }
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synLineEndError = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            break;
          case id3.MATCH:
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: "Unrecognized grammar element or characters."
            });
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      const synRepetition = function(result, chars, phraseIndex, data) {
        switch (result.state) {
          case id3.ACTIVE:
            break;
          case id3.EMPTY:
            break;
          case id3.NOMATCH:
            data.repCount += 1;
            break;
          case id3.MATCH:
            data.repCount += 1;
            break;
          default:
            throw new Error(`${thisFileName}synFile: unrecognized case.`);
        }
      };
      this.callbacks = [];
      this.callbacks.andop = synAndOp;
      this.callbacks.basicelementerr = synBasicElementError;
      this.callbacks.clsclose = synClsClose;
      this.callbacks.clsopen = synClsOpen;
      this.callbacks.clsstring = synClsString;
      this.callbacks.definedaserror = synDefinedAsError;
      this.callbacks.file = synFile;
      this.callbacks.groupclose = synGroupClose;
      this.callbacks.groupopen = synGroupOpen;
      this.callbacks.lineenderror = synLineEndError;
      this.callbacks.lineend = synLineEnd;
      this.callbacks.notop = synNotOp;
      this.callbacks.optionclose = synOptionClose;
      this.callbacks.optionopen = synOptionOpen;
      this.callbacks.prosvalclose = synProsValClose;
      this.callbacks.prosvalopen = synProsValOpen;
      this.callbacks.prosvalstring = synProsValString;
      this.callbacks.repetition = synRepetition;
      this.callbacks.rule = synRule;
      this.callbacks.ruleerror = synRuleError;
      this.callbacks.rulenameerror = synRuleNameError;
      this.callbacks.stringtab = synStringTab;
      this.callbacks.tlsclose = synTlsClose;
      this.callbacks.tlsopen = synTlsOpen;
      this.callbacks.tlsstring = synTlsString;
      this.callbacks.udtop = synUdtOp;
      this.callbacks.bkaop = synBkaOp;
      this.callbacks.bknop = synBknOp;
      this.callbacks.bkrop = synBkrOp;
      this.callbacks.abgop = synAbgOp;
      this.callbacks.aenop = synAenOp;
    };
  }
});

// node_modules/apg-js/src/apg-api/semantic-callbacks.js
var require_semantic_callbacks = __commonJS({
  "node_modules/apg-js/src/apg-api/semantic-callbacks.js"(exports, module) {
    module.exports = function exfn() {
      const apglib = require_node_exports();
      const id3 = apglib.ids;
      const NameList = function NameList2() {
        this.names = [];
        this.add = function add4(name) {
          let ret = -1;
          const find = this.get(name);
          if (find === -1) {
            ret = {
              name,
              lower: name.toLowerCase(),
              index: this.names.length
            };
            this.names.push(ret);
          }
          return ret;
        };
        this.get = function get(name) {
          let ret = -1;
          const lower = name.toLowerCase();
          for (let i2 = 0; i2 < this.names.length; i2 += 1) {
            if (this.names[i2].lower === lower) {
              ret = this.names[i2];
              break;
            }
          }
          return ret;
        };
      };
      const decnum = function decnum2(chars, beg, len) {
        let num = 0;
        for (let i2 = beg; i2 < beg + len; i2 += 1) {
          num = 10 * num + chars[i2] - 48;
        }
        return num;
      };
      const binnum = function binnum2(chars, beg, len) {
        let num = 0;
        for (let i2 = beg; i2 < beg + len; i2 += 1) {
          num = 2 * num + chars[i2] - 48;
        }
        return num;
      };
      const hexnum = function hexnum2(chars, beg, len) {
        let num = 0;
        for (let i2 = beg; i2 < beg + len; i2 += 1) {
          let digit = chars[i2];
          if (digit >= 48 && digit <= 57) {
            digit -= 48;
          } else if (digit >= 65 && digit <= 70) {
            digit -= 55;
          } else if (digit >= 97 && digit <= 102) {
            digit -= 87;
          } else {
            throw new Error("hexnum out of range");
          }
          num = 16 * num + digit;
        }
        return num;
      };
      function semFile(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.ruleNames = new NameList();
          data.udtNames = new NameList();
          data.rules = [];
          data.udts = [];
          data.rulesLineMap = [];
          data.opcodes = [];
          data.altStack = [];
          data.topStack = null;
          data.topRule = null;
        } else if (state === id3.SEM_POST) {
          let nameObj;
          data.rules.forEach((rule) => {
            rule.isBkr = false;
            rule.opcodes.forEach((op) => {
              if (op.type === id3.RNM) {
                nameObj = data.ruleNames.get(op.index.name);
                if (nameObj === -1) {
                  data.errors.push({
                    line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),
                    char: op.index.phraseIndex,
                    msg: `Rule name '${op.index.name}' used but not defined.`
                  });
                  op.index = -1;
                } else {
                  op.index = nameObj.index;
                }
              }
            });
          });
          data.udts.forEach((udt) => {
            udt.isBkr = false;
          });
          data.rules.forEach((rule) => {
            rule.opcodes.forEach((op) => {
              if (op.type === id3.BKR) {
                rule.hasBkr = true;
                nameObj = data.ruleNames.get(op.index.name);
                if (nameObj !== -1) {
                  data.rules[nameObj.index].isBkr = true;
                  op.index = nameObj.index;
                } else {
                  nameObj = data.udtNames.get(op.index.name);
                  if (nameObj !== -1) {
                    data.udts[nameObj.index].isBkr = true;
                    op.index = data.rules.length + nameObj.index;
                  } else {
                    data.errors.push({
                      line: data.findLine(data.lines, op.index.phraseIndex, data.charsLength),
                      char: op.index.phraseIndex,
                      msg: `Back reference name '${op.index.name}' refers to undefined rule or unamed UDT.`
                    });
                    op.index = -1;
                  }
                }
              }
            });
          });
        }
        return ret;
      }
      function semRule(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.altStack.length = 0;
          data.topStack = null;
          data.rulesLineMap.push({
            line: data.findLine(data.lines, phraseIndex, data.charsLength),
            char: phraseIndex
          });
        }
        return ret;
      }
      function semRuleLookup(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.ruleName = "";
          data.definedas = "";
        } else if (state === id3.SEM_POST) {
          let ruleName;
          if (data.definedas === "=") {
            ruleName = data.ruleNames.add(data.ruleName);
            if (ruleName === -1) {
              data.definedas = null;
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Rule name '${data.ruleName}' previously defined.`
              });
            } else {
              data.topRule = {
                name: ruleName.name,
                lower: ruleName.lower,
                opcodes: [],
                index: ruleName.index
              };
              data.rules.push(data.topRule);
              data.opcodes = data.topRule.opcodes;
            }
          } else {
            ruleName = data.ruleNames.get(data.ruleName);
            if (ruleName === -1) {
              data.definedas = null;
              data.errors.push({
                line: data.findLine(data.lines, phraseIndex, data.charsLength),
                char: phraseIndex,
                msg: `Rule name '${data.ruleName}' for incremental alternate not previously defined.`
              });
            } else {
              data.topRule = data.rules[ruleName.index];
              data.opcodes = data.topRule.opcodes;
            }
          }
        }
        return ret;
      }
      function semAlternation(state, chars, phraseIndex, phraseCount, data) {
        let ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          const TRUE = true;
          while (TRUE) {
            if (data.definedas === null) {
              ret = id3.SEM_SKIP;
              break;
            }
            if (data.topStack === null) {
              if (data.definedas === "=") {
                data.topStack = {
                  alt: {
                    type: id3.ALT,
                    children: []
                  },
                  cat: null
                };
                data.altStack.push(data.topStack);
                data.opcodes.push(data.topStack.alt);
                break;
              }
              data.topStack = {
                alt: data.opcodes[0],
                cat: null
              };
              data.altStack.push(data.topStack);
              break;
            }
            data.topStack = {
              alt: {
                type: id3.ALT,
                children: []
              },
              cat: null
            };
            data.altStack.push(data.topStack);
            data.opcodes.push(data.topStack.alt);
            break;
          }
        } else if (state === id3.SEM_POST) {
          data.altStack.pop();
          if (data.altStack.length > 0) {
            data.topStack = data.altStack[data.altStack.length - 1];
          } else {
            data.topStack = null;
          }
        }
        return ret;
      }
      function semConcatenation(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.topStack.alt.children.push(data.opcodes.length);
          data.topStack.cat = {
            type: id3.CAT,
            children: []
          };
          data.opcodes.push(data.topStack.cat);
        } else if (state === id3.SEM_POST) {
          data.topStack.cat = null;
        }
        return ret;
      }
      function semRepetition(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.topStack.cat.children.push(data.opcodes.length);
        }
        return ret;
      }
      function semOptionOpen(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.REP,
            min: 0,
            max: 1,
            char: phraseIndex
          });
        }
        return ret;
      }
      function semRuleName(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.ruleName = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semDefined(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.definedas = "=";
        }
        return ret;
      }
      function semIncAlt(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.definedas = "=/";
        }
        return ret;
      }
      function semRepOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.min = 0;
          data.max = Infinity;
          data.topRep = {
            type: id3.REP,
            min: 0,
            max: Infinity
          };
          data.opcodes.push(data.topRep);
        } else if (state === id3.SEM_POST) {
          if (data.min > data.max) {
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: `repetition min cannot be greater than max: min: ${data.min}: max: ${data.max}`
            });
          }
          data.topRep.min = data.min;
          data.topRep.max = data.max;
        }
        return ret;
      }
      function semRepMin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.min = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semRepMax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semRepMinMax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
          data.min = data.max;
        }
        return ret;
      }
      function semAndOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.AND
          });
        }
        return ret;
      }
      function semNotOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.NOT
          });
        }
        return ret;
      }
      function semRnmOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.RNM,
            /* NOTE: this is temporary info, index will be replaced with integer later. */
            /* Probably not the best coding practice but here you go. */
            index: {
              phraseIndex,
              name: apglib.utils.charsToString(chars, phraseIndex, phraseCount)
            }
          });
        }
        return ret;
      }
      function semAbgOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.ABG
          });
        }
        return ret;
      }
      function semAenOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.AEN
          });
        }
        return ret;
      }
      function semBkaOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.BKA
          });
        }
        return ret;
      }
      function semBknOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.BKN
          });
        }
        return ret;
      }
      function semBkrOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.ci = true;
          data.cs = false;
          data.um = true;
          data.pm = false;
        } else if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.BKR,
            bkrCase: data.cs === true ? id3.BKR_MODE_CS : id3.BKR_MODE_CI,
            bkrMode: data.pm === true ? id3.BKR_MODE_PM : id3.BKR_MODE_UM,
            /* NOTE: this is temporary info, index will be replaced with integer later. */
            /* Probably not the best coding practice but here you go. */
            index: {
              phraseIndex: data.bkrname.phraseIndex,
              name: apglib.utils.charsToString(chars, data.bkrname.phraseIndex, data.bkrname.phraseLength)
            }
          });
        }
        return ret;
      }
      function semBkrCi(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.ci = true;
        }
        return ret;
      }
      function semBkrCs(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.cs = true;
        }
        return ret;
      }
      function semBkrUm(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.um = true;
        }
        return ret;
      }
      function semBkrPm(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.pm = true;
        }
        return ret;
      }
      function semBkrName(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.bkrname = {
            phraseIndex,
            phraseLength: phraseCount
          };
        }
        return ret;
      }
      function semUdtEmpty(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
          let udtName = data.udtNames.add(name);
          if (udtName === -1) {
            udtName = data.udtNames.get(name);
            if (udtName === -1) {
              throw new Error("semUdtEmpty: name look up error");
            }
          } else {
            data.udts.push({
              name: udtName.name,
              lower: udtName.lower,
              index: udtName.index,
              empty: true
            });
          }
          data.opcodes.push({
            type: id3.UDT,
            empty: true,
            index: udtName.index
          });
        }
        return ret;
      }
      function semUdtNonEmpty(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          const name = apglib.utils.charsToString(chars, phraseIndex, phraseCount);
          let udtName = data.udtNames.add(name);
          if (udtName === -1) {
            udtName = data.udtNames.get(name);
            if (udtName === -1) {
              throw new Error("semUdtNonEmpty: name look up error");
            }
          } else {
            data.udts.push({
              name: udtName.name,
              lower: udtName.lower,
              index: udtName.index,
              empty: false
            });
          }
          data.opcodes.push({
            type: id3.UDT,
            empty: false,
            index: udtName.index,
            syntax: null,
            semantic: null
          });
        }
        return ret;
      }
      function semTlsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.tlscase = true;
        }
        return ret;
      }
      function semTlsCase(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          if (phraseCount > 0 && (chars[phraseIndex + 1] === 83 || chars[phraseIndex + 1] === 115)) {
            data.tlscase = false;
          }
        }
        return ret;
      }
      function semTlsString(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          if (data.tlscase) {
            const str = chars.slice(phraseIndex, phraseIndex + phraseCount);
            for (let i2 = 0; i2 < str.length; i2 += 1) {
              if (str[i2] >= 65 && str[i2] <= 90) {
                str[i2] += 32;
              }
            }
            data.opcodes.push({
              type: id3.TLS,
              string: str
            });
          } else {
            data.opcodes.push({
              type: id3.TBS,
              string: chars.slice(phraseIndex, phraseIndex + phraseCount)
            });
          }
        }
        return ret;
      }
      function semClsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          if (phraseCount <= 2) {
            data.opcodes.push({
              type: id3.TLS,
              string: []
            });
          } else {
            data.opcodes.push({
              type: id3.TBS,
              string: chars.slice(phraseIndex + 1, phraseIndex + phraseCount - 1)
            });
          }
        }
        return ret;
      }
      function semTbsOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.tbsstr = [];
        } else if (state === id3.SEM_POST) {
          data.opcodes.push({
            type: id3.TBS,
            string: data.tbsstr
          });
        }
        return ret;
      }
      function semTrgOp(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_PRE) {
          data.min = 0;
          data.max = 0;
        } else if (state === id3.SEM_POST) {
          if (data.min > data.max) {
            data.errors.push({
              line: data.findLine(data.lines, phraseIndex, data.charsLength),
              char: phraseIndex,
              msg: `TRG, (%dmin-max), min cannot be greater than max: min: ${data.min}: max: ${data.max}`
            });
          }
          data.opcodes.push({
            type: id3.TRG,
            min: data.min,
            max: data.max
          });
        }
        return ret;
      }
      function semDmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.min = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semDmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.max = decnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semBmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.min = binnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semBmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.max = binnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semXmin(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.min = hexnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semXmax(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.max = hexnum(chars, phraseIndex, phraseCount);
        }
        return ret;
      }
      function semDstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.tbsstr.push(decnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      function semBstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.tbsstr.push(binnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      function semXstring(state, chars, phraseIndex, phraseCount, data) {
        const ret = id3.SEM_OK;
        if (state === id3.SEM_POST) {
          data.tbsstr.push(hexnum(chars, phraseIndex, phraseCount));
        }
        return ret;
      }
      this.callbacks = [];
      this.callbacks.abgop = semAbgOp;
      this.callbacks.aenop = semAenOp;
      this.callbacks.alternation = semAlternation;
      this.callbacks.andop = semAndOp;
      this.callbacks.bmax = semBmax;
      this.callbacks.bmin = semBmin;
      this.callbacks.bkaop = semBkaOp;
      this.callbacks.bknop = semBknOp;
      this.callbacks.bkrop = semBkrOp;
      this.callbacks["bkr-name"] = semBkrName;
      this.callbacks.bstring = semBstring;
      this.callbacks.clsop = semClsOp;
      this.callbacks.ci = semBkrCi;
      this.callbacks.cs = semBkrCs;
      this.callbacks.um = semBkrUm;
      this.callbacks.pm = semBkrPm;
      this.callbacks.concatenation = semConcatenation;
      this.callbacks.defined = semDefined;
      this.callbacks.dmax = semDmax;
      this.callbacks.dmin = semDmin;
      this.callbacks.dstring = semDstring;
      this.callbacks.file = semFile;
      this.callbacks.incalt = semIncAlt;
      this.callbacks.notop = semNotOp;
      this.callbacks.optionopen = semOptionOpen;
      this.callbacks["rep-max"] = semRepMax;
      this.callbacks["rep-min"] = semRepMin;
      this.callbacks["rep-min-max"] = semRepMinMax;
      this.callbacks.repetition = semRepetition;
      this.callbacks.repop = semRepOp;
      this.callbacks.rnmop = semRnmOp;
      this.callbacks.rule = semRule;
      this.callbacks.rulelookup = semRuleLookup;
      this.callbacks.rulename = semRuleName;
      this.callbacks.tbsop = semTbsOp;
      this.callbacks.tlscase = semTlsCase;
      this.callbacks.tlsstring = semTlsString;
      this.callbacks.tlsop = semTlsOp;
      this.callbacks.trgop = semTrgOp;
      this.callbacks["udt-empty"] = semUdtEmpty;
      this.callbacks["udt-non-empty"] = semUdtNonEmpty;
      this.callbacks.xmax = semXmax;
      this.callbacks.xmin = semXmin;
      this.callbacks.xstring = semXstring;
    };
  }
});

// node_modules/apg-js/src/apg-api/sabnf-grammar.js
var require_sabnf_grammar = __commonJS({
  "node_modules/apg-js/src/apg-api/sabnf-grammar.js"(exports, module) {
    module.exports = function grammar() {
      this.grammarObject = "grammarObject";
      this.rules = [];
      this.rules[0] = { name: "File", lower: "file", index: 0, isBkr: false };
      this.rules[1] = { name: "BlankLine", lower: "blankline", index: 1, isBkr: false };
      this.rules[2] = { name: "Rule", lower: "rule", index: 2, isBkr: false };
      this.rules[3] = { name: "RuleLookup", lower: "rulelookup", index: 3, isBkr: false };
      this.rules[4] = { name: "RuleNameTest", lower: "rulenametest", index: 4, isBkr: false };
      this.rules[5] = { name: "RuleName", lower: "rulename", index: 5, isBkr: false };
      this.rules[6] = { name: "RuleNameError", lower: "rulenameerror", index: 6, isBkr: false };
      this.rules[7] = { name: "DefinedAsTest", lower: "definedastest", index: 7, isBkr: false };
      this.rules[8] = { name: "DefinedAsError", lower: "definedaserror", index: 8, isBkr: false };
      this.rules[9] = { name: "DefinedAs", lower: "definedas", index: 9, isBkr: false };
      this.rules[10] = { name: "Defined", lower: "defined", index: 10, isBkr: false };
      this.rules[11] = { name: "IncAlt", lower: "incalt", index: 11, isBkr: false };
      this.rules[12] = { name: "RuleError", lower: "ruleerror", index: 12, isBkr: false };
      this.rules[13] = { name: "LineEndError", lower: "lineenderror", index: 13, isBkr: false };
      this.rules[14] = { name: "Alternation", lower: "alternation", index: 14, isBkr: false };
      this.rules[15] = { name: "Concatenation", lower: "concatenation", index: 15, isBkr: false };
      this.rules[16] = { name: "Repetition", lower: "repetition", index: 16, isBkr: false };
      this.rules[17] = { name: "Modifier", lower: "modifier", index: 17, isBkr: false };
      this.rules[18] = { name: "Predicate", lower: "predicate", index: 18, isBkr: false };
      this.rules[19] = { name: "BasicElement", lower: "basicelement", index: 19, isBkr: false };
      this.rules[20] = { name: "BasicElementErr", lower: "basicelementerr", index: 20, isBkr: false };
      this.rules[21] = { name: "Group", lower: "group", index: 21, isBkr: false };
      this.rules[22] = { name: "GroupError", lower: "grouperror", index: 22, isBkr: false };
      this.rules[23] = { name: "GroupOpen", lower: "groupopen", index: 23, isBkr: false };
      this.rules[24] = { name: "GroupClose", lower: "groupclose", index: 24, isBkr: false };
      this.rules[25] = { name: "Option", lower: "option", index: 25, isBkr: false };
      this.rules[26] = { name: "OptionError", lower: "optionerror", index: 26, isBkr: false };
      this.rules[27] = { name: "OptionOpen", lower: "optionopen", index: 27, isBkr: false };
      this.rules[28] = { name: "OptionClose", lower: "optionclose", index: 28, isBkr: false };
      this.rules[29] = { name: "RnmOp", lower: "rnmop", index: 29, isBkr: false };
      this.rules[30] = { name: "BkrOp", lower: "bkrop", index: 30, isBkr: false };
      this.rules[31] = { name: "bkrModifier", lower: "bkrmodifier", index: 31, isBkr: false };
      this.rules[32] = { name: "cs", lower: "cs", index: 32, isBkr: false };
      this.rules[33] = { name: "ci", lower: "ci", index: 33, isBkr: false };
      this.rules[34] = { name: "um", lower: "um", index: 34, isBkr: false };
      this.rules[35] = { name: "pm", lower: "pm", index: 35, isBkr: false };
      this.rules[36] = { name: "bkr-name", lower: "bkr-name", index: 36, isBkr: false };
      this.rules[37] = { name: "rname", lower: "rname", index: 37, isBkr: false };
      this.rules[38] = { name: "uname", lower: "uname", index: 38, isBkr: false };
      this.rules[39] = { name: "ename", lower: "ename", index: 39, isBkr: false };
      this.rules[40] = { name: "UdtOp", lower: "udtop", index: 40, isBkr: false };
      this.rules[41] = { name: "udt-non-empty", lower: "udt-non-empty", index: 41, isBkr: false };
      this.rules[42] = { name: "udt-empty", lower: "udt-empty", index: 42, isBkr: false };
      this.rules[43] = { name: "RepOp", lower: "repop", index: 43, isBkr: false };
      this.rules[44] = { name: "AltOp", lower: "altop", index: 44, isBkr: false };
      this.rules[45] = { name: "CatOp", lower: "catop", index: 45, isBkr: false };
      this.rules[46] = { name: "StarOp", lower: "starop", index: 46, isBkr: false };
      this.rules[47] = { name: "AndOp", lower: "andop", index: 47, isBkr: false };
      this.rules[48] = { name: "NotOp", lower: "notop", index: 48, isBkr: false };
      this.rules[49] = { name: "BkaOp", lower: "bkaop", index: 49, isBkr: false };
      this.rules[50] = { name: "BknOp", lower: "bknop", index: 50, isBkr: false };
      this.rules[51] = { name: "AbgOp", lower: "abgop", index: 51, isBkr: false };
      this.rules[52] = { name: "AenOp", lower: "aenop", index: 52, isBkr: false };
      this.rules[53] = { name: "TrgOp", lower: "trgop", index: 53, isBkr: false };
      this.rules[54] = { name: "TbsOp", lower: "tbsop", index: 54, isBkr: false };
      this.rules[55] = { name: "TlsOp", lower: "tlsop", index: 55, isBkr: false };
      this.rules[56] = { name: "TlsCase", lower: "tlscase", index: 56, isBkr: false };
      this.rules[57] = { name: "TlsOpen", lower: "tlsopen", index: 57, isBkr: false };
      this.rules[58] = { name: "TlsClose", lower: "tlsclose", index: 58, isBkr: false };
      this.rules[59] = { name: "TlsString", lower: "tlsstring", index: 59, isBkr: false };
      this.rules[60] = { name: "StringTab", lower: "stringtab", index: 60, isBkr: false };
      this.rules[61] = { name: "ClsOp", lower: "clsop", index: 61, isBkr: false };
      this.rules[62] = { name: "ClsOpen", lower: "clsopen", index: 62, isBkr: false };
      this.rules[63] = { name: "ClsClose", lower: "clsclose", index: 63, isBkr: false };
      this.rules[64] = { name: "ClsString", lower: "clsstring", index: 64, isBkr: false };
      this.rules[65] = { name: "ProsVal", lower: "prosval", index: 65, isBkr: false };
      this.rules[66] = { name: "ProsValOpen", lower: "prosvalopen", index: 66, isBkr: false };
      this.rules[67] = { name: "ProsValString", lower: "prosvalstring", index: 67, isBkr: false };
      this.rules[68] = { name: "ProsValClose", lower: "prosvalclose", index: 68, isBkr: false };
      this.rules[69] = { name: "rep-min", lower: "rep-min", index: 69, isBkr: false };
      this.rules[70] = { name: "rep-min-max", lower: "rep-min-max", index: 70, isBkr: false };
      this.rules[71] = { name: "rep-max", lower: "rep-max", index: 71, isBkr: false };
      this.rules[72] = { name: "rep-num", lower: "rep-num", index: 72, isBkr: false };
      this.rules[73] = { name: "dString", lower: "dstring", index: 73, isBkr: false };
      this.rules[74] = { name: "xString", lower: "xstring", index: 74, isBkr: false };
      this.rules[75] = { name: "bString", lower: "bstring", index: 75, isBkr: false };
      this.rules[76] = { name: "Dec", lower: "dec", index: 76, isBkr: false };
      this.rules[77] = { name: "Hex", lower: "hex", index: 77, isBkr: false };
      this.rules[78] = { name: "Bin", lower: "bin", index: 78, isBkr: false };
      this.rules[79] = { name: "dmin", lower: "dmin", index: 79, isBkr: false };
      this.rules[80] = { name: "dmax", lower: "dmax", index: 80, isBkr: false };
      this.rules[81] = { name: "bmin", lower: "bmin", index: 81, isBkr: false };
      this.rules[82] = { name: "bmax", lower: "bmax", index: 82, isBkr: false };
      this.rules[83] = { name: "xmin", lower: "xmin", index: 83, isBkr: false };
      this.rules[84] = { name: "xmax", lower: "xmax", index: 84, isBkr: false };
      this.rules[85] = { name: "dnum", lower: "dnum", index: 85, isBkr: false };
      this.rules[86] = { name: "bnum", lower: "bnum", index: 86, isBkr: false };
      this.rules[87] = { name: "xnum", lower: "xnum", index: 87, isBkr: false };
      this.rules[88] = { name: "alphanum", lower: "alphanum", index: 88, isBkr: false };
      this.rules[89] = { name: "owsp", lower: "owsp", index: 89, isBkr: false };
      this.rules[90] = { name: "wsp", lower: "wsp", index: 90, isBkr: false };
      this.rules[91] = { name: "space", lower: "space", index: 91, isBkr: false };
      this.rules[92] = { name: "comment", lower: "comment", index: 92, isBkr: false };
      this.rules[93] = { name: "LineEnd", lower: "lineend", index: 93, isBkr: false };
      this.rules[94] = { name: "LineContinue", lower: "linecontinue", index: 94, isBkr: false };
      this.udts = [];
      this.rules[0].opcodes = [];
      this.rules[0].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[0].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[0].opcodes[2] = { type: 4, index: 1 };
      this.rules[0].opcodes[3] = { type: 4, index: 2 };
      this.rules[0].opcodes[4] = { type: 4, index: 12 };
      this.rules[1].opcodes = [];
      this.rules[1].opcodes[0] = { type: 2, children: [1, 5, 7] };
      this.rules[1].opcodes[1] = { type: 3, min: 0, max: Infinity };
      this.rules[1].opcodes[2] = { type: 1, children: [3, 4] };
      this.rules[1].opcodes[3] = { type: 6, string: [32] };
      this.rules[1].opcodes[4] = { type: 6, string: [9] };
      this.rules[1].opcodes[5] = { type: 3, min: 0, max: 1 };
      this.rules[1].opcodes[6] = { type: 4, index: 92 };
      this.rules[1].opcodes[7] = { type: 4, index: 93 };
      this.rules[2].opcodes = [];
      this.rules[2].opcodes[0] = { type: 2, children: [1, 2, 3, 4] };
      this.rules[2].opcodes[1] = { type: 4, index: 3 };
      this.rules[2].opcodes[2] = { type: 4, index: 89 };
      this.rules[2].opcodes[3] = { type: 4, index: 14 };
      this.rules[2].opcodes[4] = { type: 1, children: [5, 8] };
      this.rules[2].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[2].opcodes[6] = { type: 4, index: 89 };
      this.rules[2].opcodes[7] = { type: 4, index: 93 };
      this.rules[2].opcodes[8] = { type: 2, children: [9, 10] };
      this.rules[2].opcodes[9] = { type: 4, index: 13 };
      this.rules[2].opcodes[10] = { type: 4, index: 93 };
      this.rules[3].opcodes = [];
      this.rules[3].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[3].opcodes[1] = { type: 4, index: 4 };
      this.rules[3].opcodes[2] = { type: 4, index: 89 };
      this.rules[3].opcodes[3] = { type: 4, index: 7 };
      this.rules[4].opcodes = [];
      this.rules[4].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[4].opcodes[1] = { type: 4, index: 5 };
      this.rules[4].opcodes[2] = { type: 4, index: 6 };
      this.rules[5].opcodes = [];
      this.rules[5].opcodes[0] = { type: 4, index: 88 };
      this.rules[6].opcodes = [];
      this.rules[6].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[6].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[6].opcodes[2] = { type: 5, min: 33, max: 60 };
      this.rules[6].opcodes[3] = { type: 5, min: 62, max: 126 };
      this.rules[7].opcodes = [];
      this.rules[7].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[7].opcodes[1] = { type: 4, index: 9 };
      this.rules[7].opcodes[2] = { type: 4, index: 8 };
      this.rules[8].opcodes = [];
      this.rules[8].opcodes[0] = { type: 3, min: 1, max: 2 };
      this.rules[8].opcodes[1] = { type: 5, min: 33, max: 126 };
      this.rules[9].opcodes = [];
      this.rules[9].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[9].opcodes[1] = { type: 4, index: 11 };
      this.rules[9].opcodes[2] = { type: 4, index: 10 };
      this.rules[10].opcodes = [];
      this.rules[10].opcodes[0] = { type: 6, string: [61] };
      this.rules[11].opcodes = [];
      this.rules[11].opcodes[0] = { type: 6, string: [61, 47] };
      this.rules[12].opcodes = [];
      this.rules[12].opcodes[0] = { type: 2, children: [1, 6] };
      this.rules[12].opcodes[1] = { type: 3, min: 1, max: Infinity };
      this.rules[12].opcodes[2] = { type: 1, children: [3, 4, 5] };
      this.rules[12].opcodes[3] = { type: 5, min: 32, max: 126 };
      this.rules[12].opcodes[4] = { type: 6, string: [9] };
      this.rules[12].opcodes[5] = { type: 4, index: 94 };
      this.rules[12].opcodes[6] = { type: 4, index: 93 };
      this.rules[13].opcodes = [];
      this.rules[13].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[13].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[13].opcodes[2] = { type: 5, min: 32, max: 126 };
      this.rules[13].opcodes[3] = { type: 6, string: [9] };
      this.rules[13].opcodes[4] = { type: 4, index: 94 };
      this.rules[14].opcodes = [];
      this.rules[14].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[14].opcodes[1] = { type: 4, index: 15 };
      this.rules[14].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[14].opcodes[3] = { type: 2, children: [4, 5, 6] };
      this.rules[14].opcodes[4] = { type: 4, index: 89 };
      this.rules[14].opcodes[5] = { type: 4, index: 44 };
      this.rules[14].opcodes[6] = { type: 4, index: 15 };
      this.rules[15].opcodes = [];
      this.rules[15].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[15].opcodes[1] = { type: 4, index: 16 };
      this.rules[15].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[15].opcodes[3] = { type: 2, children: [4, 5] };
      this.rules[15].opcodes[4] = { type: 4, index: 45 };
      this.rules[15].opcodes[5] = { type: 4, index: 16 };
      this.rules[16].opcodes = [];
      this.rules[16].opcodes[0] = { type: 2, children: [1, 3] };
      this.rules[16].opcodes[1] = { type: 3, min: 0, max: 1 };
      this.rules[16].opcodes[2] = { type: 4, index: 17 };
      this.rules[16].opcodes[3] = { type: 1, children: [4, 5, 6, 7] };
      this.rules[16].opcodes[4] = { type: 4, index: 21 };
      this.rules[16].opcodes[5] = { type: 4, index: 25 };
      this.rules[16].opcodes[6] = { type: 4, index: 19 };
      this.rules[16].opcodes[7] = { type: 4, index: 20 };
      this.rules[17].opcodes = [];
      this.rules[17].opcodes[0] = { type: 1, children: [1, 5] };
      this.rules[17].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[17].opcodes[2] = { type: 4, index: 18 };
      this.rules[17].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[17].opcodes[4] = { type: 4, index: 43 };
      this.rules[17].opcodes[5] = { type: 4, index: 43 };
      this.rules[18].opcodes = [];
      this.rules[18].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[18].opcodes[1] = { type: 4, index: 49 };
      this.rules[18].opcodes[2] = { type: 4, index: 50 };
      this.rules[18].opcodes[3] = { type: 4, index: 47 };
      this.rules[18].opcodes[4] = { type: 4, index: 48 };
      this.rules[19].opcodes = [];
      this.rules[19].opcodes[0] = { type: 1, children: [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] };
      this.rules[19].opcodes[1] = { type: 4, index: 40 };
      this.rules[19].opcodes[2] = { type: 4, index: 29 };
      this.rules[19].opcodes[3] = { type: 4, index: 53 };
      this.rules[19].opcodes[4] = { type: 4, index: 54 };
      this.rules[19].opcodes[5] = { type: 4, index: 55 };
      this.rules[19].opcodes[6] = { type: 4, index: 61 };
      this.rules[19].opcodes[7] = { type: 4, index: 30 };
      this.rules[19].opcodes[8] = { type: 4, index: 51 };
      this.rules[19].opcodes[9] = { type: 4, index: 52 };
      this.rules[19].opcodes[10] = { type: 4, index: 65 };
      this.rules[20].opcodes = [];
      this.rules[20].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[20].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[20].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[20].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[20].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[20].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[21].opcodes = [];
      this.rules[21].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[21].opcodes[1] = { type: 4, index: 23 };
      this.rules[21].opcodes[2] = { type: 4, index: 14 };
      this.rules[21].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[21].opcodes[4] = { type: 4, index: 24 };
      this.rules[21].opcodes[5] = { type: 4, index: 22 };
      this.rules[22].opcodes = [];
      this.rules[22].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[22].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[22].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[22].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[22].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[22].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[23].opcodes = [];
      this.rules[23].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[23].opcodes[1] = { type: 6, string: [40] };
      this.rules[23].opcodes[2] = { type: 4, index: 89 };
      this.rules[24].opcodes = [];
      this.rules[24].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[24].opcodes[1] = { type: 4, index: 89 };
      this.rules[24].opcodes[2] = { type: 6, string: [41] };
      this.rules[25].opcodes = [];
      this.rules[25].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[25].opcodes[1] = { type: 4, index: 27 };
      this.rules[25].opcodes[2] = { type: 4, index: 14 };
      this.rules[25].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[25].opcodes[4] = { type: 4, index: 28 };
      this.rules[25].opcodes[5] = { type: 4, index: 26 };
      this.rules[26].opcodes = [];
      this.rules[26].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[26].opcodes[1] = { type: 1, children: [2, 3, 4, 5] };
      this.rules[26].opcodes[2] = { type: 5, min: 33, max: 40 };
      this.rules[26].opcodes[3] = { type: 5, min: 42, max: 46 };
      this.rules[26].opcodes[4] = { type: 5, min: 48, max: 92 };
      this.rules[26].opcodes[5] = { type: 5, min: 94, max: 126 };
      this.rules[27].opcodes = [];
      this.rules[27].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[27].opcodes[1] = { type: 6, string: [91] };
      this.rules[27].opcodes[2] = { type: 4, index: 89 };
      this.rules[28].opcodes = [];
      this.rules[28].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[28].opcodes[1] = { type: 4, index: 89 };
      this.rules[28].opcodes[2] = { type: 6, string: [93] };
      this.rules[29].opcodes = [];
      this.rules[29].opcodes[0] = { type: 4, index: 88 };
      this.rules[30].opcodes = [];
      this.rules[30].opcodes[0] = { type: 2, children: [1, 2, 4] };
      this.rules[30].opcodes[1] = { type: 6, string: [92] };
      this.rules[30].opcodes[2] = { type: 3, min: 0, max: 1 };
      this.rules[30].opcodes[3] = { type: 4, index: 31 };
      this.rules[30].opcodes[4] = { type: 4, index: 36 };
      this.rules[31].opcodes = [];
      this.rules[31].opcodes[0] = { type: 1, children: [1, 7, 13, 19] };
      this.rules[31].opcodes[1] = { type: 2, children: [2, 3] };
      this.rules[31].opcodes[2] = { type: 4, index: 32 };
      this.rules[31].opcodes[3] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[4] = { type: 1, children: [5, 6] };
      this.rules[31].opcodes[5] = { type: 4, index: 34 };
      this.rules[31].opcodes[6] = { type: 4, index: 35 };
      this.rules[31].opcodes[7] = { type: 2, children: [8, 9] };
      this.rules[31].opcodes[8] = { type: 4, index: 33 };
      this.rules[31].opcodes[9] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[10] = { type: 1, children: [11, 12] };
      this.rules[31].opcodes[11] = { type: 4, index: 34 };
      this.rules[31].opcodes[12] = { type: 4, index: 35 };
      this.rules[31].opcodes[13] = { type: 2, children: [14, 15] };
      this.rules[31].opcodes[14] = { type: 4, index: 34 };
      this.rules[31].opcodes[15] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[16] = { type: 1, children: [17, 18] };
      this.rules[31].opcodes[17] = { type: 4, index: 32 };
      this.rules[31].opcodes[18] = { type: 4, index: 33 };
      this.rules[31].opcodes[19] = { type: 2, children: [20, 21] };
      this.rules[31].opcodes[20] = { type: 4, index: 35 };
      this.rules[31].opcodes[21] = { type: 3, min: 0, max: 1 };
      this.rules[31].opcodes[22] = { type: 1, children: [23, 24] };
      this.rules[31].opcodes[23] = { type: 4, index: 32 };
      this.rules[31].opcodes[24] = { type: 4, index: 33 };
      this.rules[32].opcodes = [];
      this.rules[32].opcodes[0] = { type: 6, string: [37, 115] };
      this.rules[33].opcodes = [];
      this.rules[33].opcodes[0] = { type: 6, string: [37, 105] };
      this.rules[34].opcodes = [];
      this.rules[34].opcodes[0] = { type: 6, string: [37, 117] };
      this.rules[35].opcodes = [];
      this.rules[35].opcodes[0] = { type: 6, string: [37, 112] };
      this.rules[36].opcodes = [];
      this.rules[36].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[36].opcodes[1] = { type: 4, index: 38 };
      this.rules[36].opcodes[2] = { type: 4, index: 39 };
      this.rules[36].opcodes[3] = { type: 4, index: 37 };
      this.rules[37].opcodes = [];
      this.rules[37].opcodes[0] = { type: 4, index: 88 };
      this.rules[38].opcodes = [];
      this.rules[38].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[38].opcodes[1] = { type: 6, string: [117, 95] };
      this.rules[38].opcodes[2] = { type: 4, index: 88 };
      this.rules[39].opcodes = [];
      this.rules[39].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[39].opcodes[1] = { type: 6, string: [101, 95] };
      this.rules[39].opcodes[2] = { type: 4, index: 88 };
      this.rules[40].opcodes = [];
      this.rules[40].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[40].opcodes[1] = { type: 4, index: 42 };
      this.rules[40].opcodes[2] = { type: 4, index: 41 };
      this.rules[41].opcodes = [];
      this.rules[41].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[41].opcodes[1] = { type: 6, string: [117, 95] };
      this.rules[41].opcodes[2] = { type: 4, index: 88 };
      this.rules[42].opcodes = [];
      this.rules[42].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[42].opcodes[1] = { type: 6, string: [101, 95] };
      this.rules[42].opcodes[2] = { type: 4, index: 88 };
      this.rules[43].opcodes = [];
      this.rules[43].opcodes[0] = { type: 1, children: [1, 5, 8, 11, 12] };
      this.rules[43].opcodes[1] = { type: 2, children: [2, 3, 4] };
      this.rules[43].opcodes[2] = { type: 4, index: 69 };
      this.rules[43].opcodes[3] = { type: 4, index: 46 };
      this.rules[43].opcodes[4] = { type: 4, index: 71 };
      this.rules[43].opcodes[5] = { type: 2, children: [6, 7] };
      this.rules[43].opcodes[6] = { type: 4, index: 69 };
      this.rules[43].opcodes[7] = { type: 4, index: 46 };
      this.rules[43].opcodes[8] = { type: 2, children: [9, 10] };
      this.rules[43].opcodes[9] = { type: 4, index: 46 };
      this.rules[43].opcodes[10] = { type: 4, index: 71 };
      this.rules[43].opcodes[11] = { type: 4, index: 46 };
      this.rules[43].opcodes[12] = { type: 4, index: 70 };
      this.rules[44].opcodes = [];
      this.rules[44].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[44].opcodes[1] = { type: 6, string: [47] };
      this.rules[44].opcodes[2] = { type: 4, index: 89 };
      this.rules[45].opcodes = [];
      this.rules[45].opcodes[0] = { type: 4, index: 90 };
      this.rules[46].opcodes = [];
      this.rules[46].opcodes[0] = { type: 6, string: [42] };
      this.rules[47].opcodes = [];
      this.rules[47].opcodes[0] = { type: 6, string: [38] };
      this.rules[48].opcodes = [];
      this.rules[48].opcodes[0] = { type: 6, string: [33] };
      this.rules[49].opcodes = [];
      this.rules[49].opcodes[0] = { type: 6, string: [38, 38] };
      this.rules[50].opcodes = [];
      this.rules[50].opcodes[0] = { type: 6, string: [33, 33] };
      this.rules[51].opcodes = [];
      this.rules[51].opcodes[0] = { type: 6, string: [37, 94] };
      this.rules[52].opcodes = [];
      this.rules[52].opcodes[0] = { type: 6, string: [37, 36] };
      this.rules[53].opcodes = [];
      this.rules[53].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[53].opcodes[1] = { type: 6, string: [37] };
      this.rules[53].opcodes[2] = { type: 1, children: [3, 8, 13] };
      this.rules[53].opcodes[3] = { type: 2, children: [4, 5, 6, 7] };
      this.rules[53].opcodes[4] = { type: 4, index: 76 };
      this.rules[53].opcodes[5] = { type: 4, index: 79 };
      this.rules[53].opcodes[6] = { type: 6, string: [45] };
      this.rules[53].opcodes[7] = { type: 4, index: 80 };
      this.rules[53].opcodes[8] = { type: 2, children: [9, 10, 11, 12] };
      this.rules[53].opcodes[9] = { type: 4, index: 77 };
      this.rules[53].opcodes[10] = { type: 4, index: 83 };
      this.rules[53].opcodes[11] = { type: 6, string: [45] };
      this.rules[53].opcodes[12] = { type: 4, index: 84 };
      this.rules[53].opcodes[13] = { type: 2, children: [14, 15, 16, 17] };
      this.rules[53].opcodes[14] = { type: 4, index: 78 };
      this.rules[53].opcodes[15] = { type: 4, index: 81 };
      this.rules[53].opcodes[16] = { type: 6, string: [45] };
      this.rules[53].opcodes[17] = { type: 4, index: 82 };
      this.rules[54].opcodes = [];
      this.rules[54].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[54].opcodes[1] = { type: 6, string: [37] };
      this.rules[54].opcodes[2] = { type: 1, children: [3, 10, 17] };
      this.rules[54].opcodes[3] = { type: 2, children: [4, 5, 6] };
      this.rules[54].opcodes[4] = { type: 4, index: 76 };
      this.rules[54].opcodes[5] = { type: 4, index: 73 };
      this.rules[54].opcodes[6] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[7] = { type: 2, children: [8, 9] };
      this.rules[54].opcodes[8] = { type: 6, string: [46] };
      this.rules[54].opcodes[9] = { type: 4, index: 73 };
      this.rules[54].opcodes[10] = { type: 2, children: [11, 12, 13] };
      this.rules[54].opcodes[11] = { type: 4, index: 77 };
      this.rules[54].opcodes[12] = { type: 4, index: 74 };
      this.rules[54].opcodes[13] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[14] = { type: 2, children: [15, 16] };
      this.rules[54].opcodes[15] = { type: 6, string: [46] };
      this.rules[54].opcodes[16] = { type: 4, index: 74 };
      this.rules[54].opcodes[17] = { type: 2, children: [18, 19, 20] };
      this.rules[54].opcodes[18] = { type: 4, index: 78 };
      this.rules[54].opcodes[19] = { type: 4, index: 75 };
      this.rules[54].opcodes[20] = { type: 3, min: 0, max: Infinity };
      this.rules[54].opcodes[21] = { type: 2, children: [22, 23] };
      this.rules[54].opcodes[22] = { type: 6, string: [46] };
      this.rules[54].opcodes[23] = { type: 4, index: 75 };
      this.rules[55].opcodes = [];
      this.rules[55].opcodes[0] = { type: 2, children: [1, 2, 3, 4] };
      this.rules[55].opcodes[1] = { type: 4, index: 56 };
      this.rules[55].opcodes[2] = { type: 4, index: 57 };
      this.rules[55].opcodes[3] = { type: 4, index: 59 };
      this.rules[55].opcodes[4] = { type: 4, index: 58 };
      this.rules[56].opcodes = [];
      this.rules[56].opcodes[0] = { type: 3, min: 0, max: 1 };
      this.rules[56].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[56].opcodes[2] = { type: 7, string: [37, 105] };
      this.rules[56].opcodes[3] = { type: 7, string: [37, 115] };
      this.rules[57].opcodes = [];
      this.rules[57].opcodes[0] = { type: 6, string: [34] };
      this.rules[58].opcodes = [];
      this.rules[58].opcodes[0] = { type: 6, string: [34] };
      this.rules[59].opcodes = [];
      this.rules[59].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[59].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[59].opcodes[2] = { type: 5, min: 32, max: 33 };
      this.rules[59].opcodes[3] = { type: 5, min: 35, max: 126 };
      this.rules[59].opcodes[4] = { type: 4, index: 60 };
      this.rules[60].opcodes = [];
      this.rules[60].opcodes[0] = { type: 6, string: [9] };
      this.rules[61].opcodes = [];
      this.rules[61].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[61].opcodes[1] = { type: 4, index: 62 };
      this.rules[61].opcodes[2] = { type: 4, index: 64 };
      this.rules[61].opcodes[3] = { type: 4, index: 63 };
      this.rules[62].opcodes = [];
      this.rules[62].opcodes[0] = { type: 6, string: [39] };
      this.rules[63].opcodes = [];
      this.rules[63].opcodes[0] = { type: 6, string: [39] };
      this.rules[64].opcodes = [];
      this.rules[64].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[64].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[64].opcodes[2] = { type: 5, min: 32, max: 38 };
      this.rules[64].opcodes[3] = { type: 5, min: 40, max: 126 };
      this.rules[64].opcodes[4] = { type: 4, index: 60 };
      this.rules[65].opcodes = [];
      this.rules[65].opcodes[0] = { type: 2, children: [1, 2, 3] };
      this.rules[65].opcodes[1] = { type: 4, index: 66 };
      this.rules[65].opcodes[2] = { type: 4, index: 67 };
      this.rules[65].opcodes[3] = { type: 4, index: 68 };
      this.rules[66].opcodes = [];
      this.rules[66].opcodes[0] = { type: 6, string: [60] };
      this.rules[67].opcodes = [];
      this.rules[67].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[67].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[67].opcodes[2] = { type: 5, min: 32, max: 61 };
      this.rules[67].opcodes[3] = { type: 5, min: 63, max: 126 };
      this.rules[67].opcodes[4] = { type: 4, index: 60 };
      this.rules[68].opcodes = [];
      this.rules[68].opcodes[0] = { type: 6, string: [62] };
      this.rules[69].opcodes = [];
      this.rules[69].opcodes[0] = { type: 4, index: 72 };
      this.rules[70].opcodes = [];
      this.rules[70].opcodes[0] = { type: 4, index: 72 };
      this.rules[71].opcodes = [];
      this.rules[71].opcodes[0] = { type: 4, index: 72 };
      this.rules[72].opcodes = [];
      this.rules[72].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[72].opcodes[1] = { type: 5, min: 48, max: 57 };
      this.rules[73].opcodes = [];
      this.rules[73].opcodes[0] = { type: 4, index: 85 };
      this.rules[74].opcodes = [];
      this.rules[74].opcodes[0] = { type: 4, index: 87 };
      this.rules[75].opcodes = [];
      this.rules[75].opcodes[0] = { type: 4, index: 86 };
      this.rules[76].opcodes = [];
      this.rules[76].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[76].opcodes[1] = { type: 6, string: [68] };
      this.rules[76].opcodes[2] = { type: 6, string: [100] };
      this.rules[77].opcodes = [];
      this.rules[77].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[77].opcodes[1] = { type: 6, string: [88] };
      this.rules[77].opcodes[2] = { type: 6, string: [120] };
      this.rules[78].opcodes = [];
      this.rules[78].opcodes[0] = { type: 1, children: [1, 2] };
      this.rules[78].opcodes[1] = { type: 6, string: [66] };
      this.rules[78].opcodes[2] = { type: 6, string: [98] };
      this.rules[79].opcodes = [];
      this.rules[79].opcodes[0] = { type: 4, index: 85 };
      this.rules[80].opcodes = [];
      this.rules[80].opcodes[0] = { type: 4, index: 85 };
      this.rules[81].opcodes = [];
      this.rules[81].opcodes[0] = { type: 4, index: 86 };
      this.rules[82].opcodes = [];
      this.rules[82].opcodes[0] = { type: 4, index: 86 };
      this.rules[83].opcodes = [];
      this.rules[83].opcodes[0] = { type: 4, index: 87 };
      this.rules[84].opcodes = [];
      this.rules[84].opcodes[0] = { type: 4, index: 87 };
      this.rules[85].opcodes = [];
      this.rules[85].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[85].opcodes[1] = { type: 5, min: 48, max: 57 };
      this.rules[86].opcodes = [];
      this.rules[86].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[86].opcodes[1] = { type: 5, min: 48, max: 49 };
      this.rules[87].opcodes = [];
      this.rules[87].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[87].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[87].opcodes[2] = { type: 5, min: 48, max: 57 };
      this.rules[87].opcodes[3] = { type: 5, min: 65, max: 70 };
      this.rules[87].opcodes[4] = { type: 5, min: 97, max: 102 };
      this.rules[88].opcodes = [];
      this.rules[88].opcodes[0] = { type: 2, children: [1, 4] };
      this.rules[88].opcodes[1] = { type: 1, children: [2, 3] };
      this.rules[88].opcodes[2] = { type: 5, min: 97, max: 122 };
      this.rules[88].opcodes[3] = { type: 5, min: 65, max: 90 };
      this.rules[88].opcodes[4] = { type: 3, min: 0, max: Infinity };
      this.rules[88].opcodes[5] = { type: 1, children: [6, 7, 8, 9] };
      this.rules[88].opcodes[6] = { type: 5, min: 97, max: 122 };
      this.rules[88].opcodes[7] = { type: 5, min: 65, max: 90 };
      this.rules[88].opcodes[8] = { type: 5, min: 48, max: 57 };
      this.rules[88].opcodes[9] = { type: 6, string: [45] };
      this.rules[89].opcodes = [];
      this.rules[89].opcodes[0] = { type: 3, min: 0, max: Infinity };
      this.rules[89].opcodes[1] = { type: 4, index: 91 };
      this.rules[90].opcodes = [];
      this.rules[90].opcodes[0] = { type: 3, min: 1, max: Infinity };
      this.rules[90].opcodes[1] = { type: 4, index: 91 };
      this.rules[91].opcodes = [];
      this.rules[91].opcodes[0] = { type: 1, children: [1, 2, 3, 4] };
      this.rules[91].opcodes[1] = { type: 6, string: [32] };
      this.rules[91].opcodes[2] = { type: 6, string: [9] };
      this.rules[91].opcodes[3] = { type: 4, index: 92 };
      this.rules[91].opcodes[4] = { type: 4, index: 94 };
      this.rules[92].opcodes = [];
      this.rules[92].opcodes[0] = { type: 2, children: [1, 2] };
      this.rules[92].opcodes[1] = { type: 6, string: [59] };
      this.rules[92].opcodes[2] = { type: 3, min: 0, max: Infinity };
      this.rules[92].opcodes[3] = { type: 1, children: [4, 5] };
      this.rules[92].opcodes[4] = { type: 5, min: 32, max: 126 };
      this.rules[92].opcodes[5] = { type: 6, string: [9] };
      this.rules[93].opcodes = [];
      this.rules[93].opcodes[0] = { type: 1, children: [1, 2, 3] };
      this.rules[93].opcodes[1] = { type: 6, string: [13, 10] };
      this.rules[93].opcodes[2] = { type: 6, string: [10] };
      this.rules[93].opcodes[3] = { type: 6, string: [13] };
      this.rules[94].opcodes = [];
      this.rules[94].opcodes[0] = { type: 2, children: [1, 5] };
      this.rules[94].opcodes[1] = { type: 1, children: [2, 3, 4] };
      this.rules[94].opcodes[2] = { type: 6, string: [13, 10] };
      this.rules[94].opcodes[3] = { type: 6, string: [10] };
      this.rules[94].opcodes[4] = { type: 6, string: [13] };
      this.rules[94].opcodes[5] = { type: 1, children: [6, 7] };
      this.rules[94].opcodes[6] = { type: 6, string: [32] };
      this.rules[94].opcodes[7] = { type: 6, string: [9] };
      this.toString = function toString7() {
        let str = "";
        str += ";\n";
        str += "; ABNF for JavaScript APG 2.0 SABNF\n";
        str += "; RFC 5234 with some restrictions and additions.\n";
        str += "; Updated 11/24/2015 for RFC 7405 case-sensitive literal string notation\n";
        str += ';  - accepts %s"string" as a case-sensitive string\n';
        str += ';  - accepts %i"string" as a case-insensitive string\n';
        str += ';  - accepts "string" as a case-insensitive string\n';
        str += ";\n";
        str += "; Some restrictions:\n";
        str += ";   1. Rules must begin at first character of each line.\n";
        str += ";      Indentations on first rule and rules thereafter are not allowed.\n";
        str += ";   2. Relaxed line endings. CRLF, LF or CR are accepted as valid line ending.\n";
        str += ";   3. Prose values, i.e. <prose value>, are accepted as valid grammar syntax.\n";
        str += ";      However, a working parser cannot be generated from them.\n";
        str += ";\n";
        str += "; Super set (SABNF) additions:\n";
        str += ";   1. Look-ahead (syntactic predicate) operators are accepted as element prefixes.\n";
        str += ";      & is the positive look-ahead operator, succeeds and backtracks if the look-ahead phrase is found\n";
        str += ";      ! is the negative look-ahead operator, succeeds and backtracks if the look-ahead phrase is NOT found\n";
        str += ";      e.g. &%d13 or &rule or !(A / B)\n";
        str += ";   2. User-Defined Terminals (UDT) of the form, u_name and e_name are accepted.\n";
        str += ";      'name' is alpha followed by alpha/num/hyphen just like a rule name.\n";
        str += ";      u_name may be used as an element but no rule definition is given.\n";
        str += ";      e.g. rule = A / u_myUdt\n";
        str += ';           A = "a"\n';
        str += ";      would be a valid grammar.\n";
        str += ";   3. Case-sensitive, single-quoted strings are accepted.\n";
        str += ";      e.g. 'abc' would be equivalent to %d97.98.99\n";
        str += ';      (kept for backward compatibility, but superseded by %s"abc")  \n';
        str += "; New 12/26/2015\n";
        str += ";   4. Look-behind operators are accepted as element prefixes.\n";
        str += ";      && is the positive look-behind operator, succeeds and backtracks if the look-behind phrase is found\n";
        str += ";      !! is the negative look-behind operator, succeeds and backtracks if the look-behind phrase is NOT found\n";
        str += ";      e.g. &&%d13 or &&rule or !!(A / B)\n";
        str += ";   5. Back reference operators, i.e. \\rulename, are accepted.\n";
        str += ";      A back reference operator acts like a TLS or TBS terminal except that the phrase it attempts\n";
        str += ";      to match is a phrase previously matched by the rule 'rulename'.\n";
        str += ";      There are two modes of previous phrase matching - the parent-frame mode and the universal mode.\n";
        str += ";      In universal mode, \\rulename matches the last match to 'rulename' regardless of where it was found.\n";
        str += ";      In parent-frame mode, \\rulename matches only the last match found on the parent's frame or parse tree level.\n";
        str += ";      Back reference modifiers can be used to specify case and mode.\n";
        str += ";      \\A defaults to case-insensitive and universal mode, e.g. \\A === \\%i%uA\n";
        str += ";      Modifiers %i and %s determine case-insensitive and case-sensitive mode, respectively.\n";
        str += ";      Modifiers %u and %p determine universal mode and parent frame mode, respectively.\n";
        str += ";      Case and mode modifiers can appear in any order, e.g. \\%s%pA === \\%p%sA. \n";
        str += ";   7. String begin anchor, ABG(%^) matches the beginning of the input string location.\n";
        str += ";      Returns EMPTY or NOMATCH. Never consumes any characters.\n";
        str += ";   8. String end anchor, AEN(%$) matches the end of the input string location.\n";
        str += ";      Returns EMPTY or NOMATCH. Never consumes any characters.\n";
        str += ";\n";
        str += "File            = *(BlankLine / Rule / RuleError)\n";
        str += "BlankLine       = *(%d32/%d9) [comment] LineEnd\n";
        str += "Rule            = RuleLookup owsp Alternation ((owsp LineEnd)\n";
        str += "                / (LineEndError LineEnd))\n";
        str += "RuleLookup      = RuleNameTest owsp DefinedAsTest\n";
        str += "RuleNameTest    = RuleName/RuleNameError\n";
        str += "RuleName        = alphanum\n";
        str += "RuleNameError   = 1*(%d33-60/%d62-126)\n";
        str += "DefinedAsTest   = DefinedAs / DefinedAsError\n";
        str += "DefinedAsError  = 1*2%d33-126\n";
        str += "DefinedAs       = IncAlt / Defined\n";
        str += "Defined         = %d61\n";
        str += "IncAlt          = %d61.47\n";
        str += "RuleError       = 1*(%d32-126 / %d9  / LineContinue) LineEnd\n";
        str += "LineEndError    = 1*(%d32-126 / %d9  / LineContinue)\n";
        str += "Alternation     = Concatenation *(owsp AltOp Concatenation)\n";
        str += "Concatenation   = Repetition *(CatOp Repetition)\n";
        str += "Repetition      = [Modifier] (Group / Option / BasicElement / BasicElementErr)\n";
        str += "Modifier        = (Predicate [RepOp])\n";
        str += "                / RepOp\n";
        str += "Predicate       = BkaOp\n";
        str += "                / BknOp\n";
        str += "                / AndOp\n";
        str += "                / NotOp\n";
        str += "BasicElement    = UdtOp\n";
        str += "                / RnmOp\n";
        str += "                / TrgOp\n";
        str += "                / TbsOp\n";
        str += "                / TlsOp\n";
        str += "                / ClsOp\n";
        str += "                / BkrOp\n";
        str += "                / AbgOp\n";
        str += "                / AenOp\n";
        str += "                / ProsVal\n";
        str += "BasicElementErr = 1*(%d33-40/%d42-46/%d48-92/%d94-126)\n";
        str += "Group           = GroupOpen  Alternation (GroupClose / GroupError)\n";
        str += "GroupError      = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\n";
        str += "GroupOpen       = %d40 owsp\n";
        str += "GroupClose      = owsp %d41\n";
        str += "Option          = OptionOpen Alternation (OptionClose / OptionError)\n";
        str += "OptionError     = 1*(%d33-40/%d42-46/%d48-92/%d94-126) ; same as BasicElementErr\n";
        str += "OptionOpen      = %d91 owsp\n";
        str += "OptionClose     = owsp %d93\n";
        str += "RnmOp           = alphanum\n";
        str += "BkrOp           = %d92 [bkrModifier] bkr-name\n";
        str += "bkrModifier     = (cs [um / pm]) / (ci [um / pm]) / (um [cs /ci]) / (pm [cs / ci])\n";
        str += "cs              = '%s'\n";
        str += "ci              = '%i'\n";
        str += "um              = '%u'\n";
        str += "pm              = '%p'\n";
        str += "bkr-name        = uname / ename / rname\n";
        str += "rname           = alphanum\n";
        str += "uname           = %d117.95 alphanum\n";
        str += "ename           = %d101.95 alphanum\n";
        str += "UdtOp           = udt-empty\n";
        str += "                / udt-non-empty\n";
        str += "udt-non-empty   = %d117.95 alphanum\n";
        str += "udt-empty       = %d101.95 alphanum\n";
        str += "RepOp           = (rep-min StarOp rep-max)\n";
        str += "                / (rep-min StarOp)\n";
        str += "                / (StarOp rep-max)\n";
        str += "                / StarOp\n";
        str += "                / rep-min-max\n";
        str += "AltOp           = %d47 owsp\n";
        str += "CatOp           = wsp\n";
        str += "StarOp          = %d42\n";
        str += "AndOp           = %d38\n";
        str += "NotOp           = %d33\n";
        str += "BkaOp           = %d38.38\n";
        str += "BknOp           = %d33.33\n";
        str += "AbgOp           = %d37.94\n";
        str += "AenOp           = %d37.36\n";
        str += "TrgOp           = %d37 ((Dec dmin %d45 dmax) / (Hex xmin %d45 xmax) / (Bin bmin %d45 bmax))\n";
        str += "TbsOp           = %d37 ((Dec dString *(%d46 dString)) / (Hex xString *(%d46 xString)) / (Bin bString *(%d46 bString)))\n";
        str += "TlsOp           = TlsCase TlsOpen TlsString TlsClose\n";
        str += 'TlsCase         = ["%i" / "%s"]\n';
        str += "TlsOpen         = %d34\n";
        str += "TlsClose        = %d34\n";
        str += "TlsString       = *(%d32-33/%d35-126/StringTab)\n";
        str += "StringTab       = %d9\n";
        str += "ClsOp           = ClsOpen ClsString ClsClose\n";
        str += "ClsOpen         = %d39\n";
        str += "ClsClose        = %d39\n";
        str += "ClsString       = *(%d32-38/%d40-126/StringTab)\n";
        str += "ProsVal         = ProsValOpen ProsValString ProsValClose\n";
        str += "ProsValOpen     = %d60\n";
        str += "ProsValString   = *(%d32-61/%d63-126/StringTab)\n";
        str += "ProsValClose    = %d62\n";
        str += "rep-min         = rep-num\n";
        str += "rep-min-max     = rep-num\n";
        str += "rep-max         = rep-num\n";
        str += "rep-num         = 1*(%d48-57)\n";
        str += "dString         = dnum\n";
        str += "xString         = xnum\n";
        str += "bString         = bnum\n";
        str += "Dec             = (%d68/%d100)\n";
        str += "Hex             = (%d88/%d120)\n";
        str += "Bin             = (%d66/%d98)\n";
        str += "dmin            = dnum\n";
        str += "dmax            = dnum\n";
        str += "bmin            = bnum\n";
        str += "bmax            = bnum\n";
        str += "xmin            = xnum\n";
        str += "xmax            = xnum\n";
        str += "dnum            = 1*(%d48-57)\n";
        str += "bnum            = 1*%d48-49\n";
        str += "xnum            = 1*(%d48-57 / %d65-70 / %d97-102)\n";
        str += ";\n";
        str += "; Basics\n";
        str += "alphanum        = (%d97-122/%d65-90) *(%d97-122/%d65-90/%d48-57/%d45)\n";
        str += "owsp            = *space\n";
        str += "wsp             = 1*space\n";
        str += "space           = %d32\n";
        str += "                / %d9\n";
        str += "                / comment\n";
        str += "                / LineContinue\n";
        str += "comment         = %d59 *(%d32-126 / %d9)\n";
        str += "LineEnd         = %d13.10\n";
        str += "                / %d10\n";
        str += "                / %d13\n";
        str += "LineContinue    = (%d13.10 / %d10 / %d13) (%d32 / %d9)\n";
        return str;
      };
    };
  }
});

// node_modules/apg-js/src/apg-api/parser.js
var require_parser2 = __commonJS({
  "node_modules/apg-js/src/apg-api/parser.js"(exports, module) {
    module.exports = function exportParser() {
      const thisFileName = "parser: ";
      const ApgLib = require_node_exports();
      const id3 = ApgLib.ids;
      const syn = new (require_syntax_callbacks())();
      const sem = new (require_semantic_callbacks())();
      const sabnfGrammar = new (require_sabnf_grammar())();
      const parser = new ApgLib.parser();
      parser.ast = new ApgLib.ast();
      parser.callbacks = syn.callbacks;
      parser.ast.callbacks = sem.callbacks;
      const findLine = function findLine2(lines, charIndex, charLength) {
        if (charIndex < 0 || charIndex >= charLength) {
          return -1;
        }
        for (let i2 = 0; i2 < lines.length; i2 += 1) {
          if (charIndex >= lines[i2].beginChar && charIndex < lines[i2].beginChar + lines[i2].length) {
            return i2;
          }
        }
        return -1;
      };
      const translateIndex = function translateIndex2(map, index5) {
        let ret = -1;
        if (index5 < map.length) {
          for (let i2 = index5; i2 < map.length; i2 += 1) {
            if (map[i2] !== null) {
              ret = map[i2];
              break;
            }
          }
        }
        return ret;
      };
      const reduceOpcodes = function reduceOpcodes2(rules) {
        rules.forEach((rule) => {
          const opcodes = [];
          const map = [];
          let reducedIndex = 0;
          rule.opcodes.forEach((op) => {
            if (op.type === id3.ALT && op.children.length === 1) {
              map.push(null);
            } else if (op.type === id3.CAT && op.children.length === 1) {
              map.push(null);
            } else if (op.type === id3.REP && op.min === 1 && op.max === 1) {
              map.push(null);
            } else {
              map.push(reducedIndex);
              opcodes.push(op);
              reducedIndex += 1;
            }
          });
          map.push(reducedIndex);
          opcodes.forEach((op) => {
            if (op.type === id3.ALT || op.type === id3.CAT) {
              for (let i2 = 0; i2 < op.children.length; i2 += 1) {
                op.children[i2] = translateIndex(map, op.children[i2]);
              }
            }
          });
          rule.opcodes = opcodes;
        });
      };
      this.syntax = function syntax(chars, lines, errors, strict, lite, trace) {
        if (trace) {
          if (trace.traceObject !== "traceObject") {
            throw new TypeError(`${thisFileName}trace argument is not a trace object`);
          }
          parser.trace = trace;
        }
        const data = {};
        data.errors = errors;
        data.strict = !!strict;
        data.lite = !!lite;
        data.lines = lines;
        data.findLine = findLine;
        data.charsLength = chars.length;
        data.ruleCount = 0;
        const result = parser.parse(sabnfGrammar, "file", chars, data);
        if (!result.success) {
          errors.push({
            line: 0,
            char: 0,
            msg: "syntax analysis of input grammar failed"
          });
        }
      };
      this.semantic = function semantic(chars, lines, errors) {
        const data = {};
        data.errors = errors;
        data.lines = lines;
        data.findLine = findLine;
        data.charsLength = chars.length;
        parser.ast.translate(data);
        if (errors.length) {
          return null;
        }
        reduceOpcodes(data.rules);
        return {
          rules: data.rules,
          udts: data.udts,
          lineMap: data.rulesLineMap
        };
      };
      this.generateSource = function generateSource(chars, lines, rules, udts, config) {
        let source = "";
        let typescript = false;
        let lite = false;
        if (config) {
          if (config.typescript) {
            typescript = true;
            lite = false;
          } else if (config.lite) {
            typescript = false;
            lite = true;
          }
        }
        let i2;
        let bkrname;
        let bkrlower;
        let opcodeCount = 0;
        let charCodeMin = Infinity;
        let charCodeMax = 0;
        const ruleNames = [];
        const udtNames = [];
        let alt = 0;
        let cat = 0;
        let rnm = 0;
        let udt = 0;
        let rep = 0;
        let and = 0;
        let not = 0;
        let tls = 0;
        let tbs = 0;
        let trg = 0;
        let bkr = 0;
        let bka = 0;
        let bkn = 0;
        let abg = 0;
        let aen = 0;
        rules.forEach((rule) => {
          ruleNames.push(rule.lower);
          opcodeCount += rule.opcodes.length;
          rule.opcodes.forEach((op) => {
            switch (op.type) {
              case id3.ALT:
                alt += 1;
                break;
              case id3.CAT:
                cat += 1;
                break;
              case id3.RNM:
                rnm += 1;
                break;
              case id3.UDT:
                udt += 1;
                break;
              case id3.REP:
                rep += 1;
                break;
              case id3.AND:
                and += 1;
                break;
              case id3.NOT:
                not += 1;
                break;
              case id3.BKA:
                bka += 1;
                break;
              case id3.BKN:
                bkn += 1;
                break;
              case id3.BKR:
                bkr += 1;
                break;
              case id3.ABG:
                abg += 1;
                break;
              case id3.AEN:
                aen += 1;
                break;
              case id3.TLS:
                tls += 1;
                for (i2 = 0; i2 < op.string.length; i2 += 1) {
                  if (op.string[i2] < charCodeMin) {
                    charCodeMin = op.string[i2];
                  }
                  if (op.string[i2] > charCodeMax) {
                    charCodeMax = op.string[i2];
                  }
                }
                break;
              case id3.TBS:
                tbs += 1;
                for (i2 = 0; i2 < op.string.length; i2 += 1) {
                  if (op.string[i2] < charCodeMin) {
                    charCodeMin = op.string[i2];
                  }
                  if (op.string[i2] > charCodeMax) {
                    charCodeMax = op.string[i2];
                  }
                }
                break;
              case id3.TRG:
                trg += 1;
                if (op.min < charCodeMin) {
                  charCodeMin = op.min;
                }
                if (op.max > charCodeMax) {
                  charCodeMax = op.max;
                }
                break;
              default:
                throw new Error("generateSource: unrecognized opcode");
            }
          });
        });
        ruleNames.sort();
        if (udts.length > 0) {
          udts.forEach((udtFunc) => {
            udtNames.push(udtFunc.lower);
          });
          udtNames.sort();
        }
        source += "// copyright: Copyright (c) 2024 Lowell D. Thomas, all rights reserved<br>\n";
        source += "//   license: BSD-2-Clause (https://opensource.org/licenses/BSD-2-Clause)<br>\n";
        source += "//\n";
        source += "// Generated by apg-js, Version 4.4.0 [apg-js](https://github.com/ldthomas/apg-js)\n";
        if (config) {
          if (config.funcName) {
            source += `const ${config.funcName} = function grammar(){
`;
          } else if (typescript) {
            source += "export function grammar(){\n";
          } else if (lite) {
            source += "export default function grammar(){\n";
          } else {
            source += `module.exports = function grammar(){
`;
          }
        } else {
          source += `module.exports = function grammar(){
`;
        }
        source += "  // ```\n";
        source += "  // SUMMARY\n";
        source += `  //      rules = ${rules.length}
`;
        source += `  //       udts = ${udts.length}
`;
        source += `  //    opcodes = ${opcodeCount}
`;
        source += "  //        ---   ABNF original opcodes\n";
        source += `  //        ALT = ${alt}
`;
        source += `  //        CAT = ${cat}
`;
        source += `  //        REP = ${rep}
`;
        source += `  //        RNM = ${rnm}
`;
        source += `  //        TLS = ${tls}
`;
        source += `  //        TBS = ${tbs}
`;
        source += `  //        TRG = ${trg}
`;
        source += "  //        ---   SABNF superset opcodes\n";
        source += `  //        UDT = ${udt}
`;
        source += `  //        AND = ${and}
`;
        source += `  //        NOT = ${not}
`;
        if (!lite) {
          source += `  //        BKA = ${bka}
`;
          source += `  //        BKN = ${bkn}
`;
          source += `  //        BKR = ${bkr}
`;
          source += `  //        ABG = ${abg}
`;
          source += `  //        AEN = ${aen}
`;
        }
        source += "  // characters = [";
        if (tls + tbs + trg === 0) {
          source += " none defined ]";
        } else {
          source += `${charCodeMin} - ${charCodeMax}]`;
        }
        if (udt > 0) {
          source += " + user defined";
        }
        source += "\n";
        source += "  // ```\n";
        source += "  /* OBJECT IDENTIFIER (for internal parser use) */\n";
        source += "  this.grammarObject = 'grammarObject';\n";
        source += "\n";
        source += "  /* RULES */\n";
        source += "  this.rules = [];\n";
        rules.forEach((rule, ii) => {
          let thisRule = "  this.rules[";
          thisRule += ii;
          thisRule += "] = { name: '";
          thisRule += rule.name;
          thisRule += "', lower: '";
          thisRule += rule.lower;
          thisRule += "', index: ";
          thisRule += rule.index;
          thisRule += ", isBkr: ";
          thisRule += rule.isBkr;
          thisRule += " };\n";
          source += thisRule;
        });
        source += "\n";
        source += "  /* UDTS */\n";
        source += "  this.udts = [];\n";
        if (udts.length > 0) {
          udts.forEach((udtFunc, ii) => {
            let thisUdt = "  this.udts[";
            thisUdt += ii;
            thisUdt += "] = { name: '";
            thisUdt += udtFunc.name;
            thisUdt += "', lower: '";
            thisUdt += udtFunc.lower;
            thisUdt += "', index: ";
            thisUdt += udtFunc.index;
            thisUdt += ", empty: ";
            thisUdt += udtFunc.empty;
            thisUdt += ", isBkr: ";
            thisUdt += udtFunc.isBkr;
            thisUdt += " };\n";
            source += thisUdt;
          });
        }
        source += "\n";
        source += "  /* OPCODES */\n";
        rules.forEach((rule, ruleIndex) => {
          if (ruleIndex > 0) {
            source += "\n";
          }
          source += `  /* ${rule.name} */
`;
          source += `  this.rules[${ruleIndex}].opcodes = [];
`;
          rule.opcodes.forEach((op, opIndex) => {
            let prefix;
            switch (op.type) {
              case id3.ALT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, children: [${op.children.toString()}] };// ALT
`;
                break;
              case id3.CAT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, children: [${op.children.toString()}] };// CAT
`;
                break;
              case id3.RNM:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, index: ${op.index} };// RNM(${rules[op.index].name})
`;
                break;
              case id3.BKR:
                if (op.index >= rules.length) {
                  bkrname = udts[op.index - rules.length].name;
                  bkrlower = udts[op.index - rules.length].lower;
                } else {
                  bkrname = rules[op.index].name;
                  bkrlower = rules[op.index].lower;
                }
                prefix = "%i";
                if (op.bkrCase === id3.BKR_MODE_CS) {
                  prefix = "%s";
                }
                if (op.bkrMode === id3.BKR_MODE_UM) {
                  prefix += "%u";
                } else {
                  prefix += "%p";
                }
                bkrname = prefix + bkrname;
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, index: ${op.index}, lower: '${bkrlower}', bkrCase: ${op.bkrCase}, bkrMode: ${op.bkrMode} };// BKR(\\${bkrname})
`;
                break;
              case id3.UDT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, empty: ${op.empty}, index: ${op.index} };// UDT(${udts[op.index].name})
`;
                break;
              case id3.REP:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, min: ${op.min}, max: ${op.max} };// REP
`;
                break;
              case id3.AND:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// AND
`;
                break;
              case id3.NOT:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// NOT
`;
                break;
              case id3.ABG:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// ABG(%^)
`;
                break;
              case id3.AEN:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// AEN(%$)
`;
                break;
              case id3.BKA:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// BKA
`;
                break;
              case id3.BKN:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type} };// BKN
`;
                break;
              case id3.TLS:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, string: [${op.string.toString()}] };// TLS
`;
                break;
              case id3.TBS:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, string: [${op.string.toString()}] };// TBS
`;
                break;
              case id3.TRG:
                source += `  this.rules[${ruleIndex}].opcodes[${opIndex}] = { type: ${op.type}, min: ${op.min}, max: ${op.max} };// TRG
`;
                break;
              default:
                throw new Error("parser.js: ~143: unrecognized opcode");
            }
          });
        });
        source += "\n";
        source += "  // The `toString()` function will display the original grammar file(s) that produced these opcodes.\n";
        source += "  this.toString = function toString(){\n";
        source += '    let str = "";\n';
        let str;
        lines.forEach((line) => {
          const end = line.beginChar + line.length;
          str = "";
          source += '    str += "';
          for (let ii = line.beginChar; ii < end; ii += 1) {
            switch (chars[ii]) {
              case 9:
                str = " ";
                break;
              case 10:
                str = "\\n";
                break;
              case 13:
                str = "\\r";
                break;
              case 34:
                str = '\\"';
                break;
              case 92:
                str = "\\\\";
                break;
              default:
                str = String.fromCharCode(chars[ii]);
                break;
            }
            source += str;
          }
          source += '";\n';
        });
        source += "    return str;\n";
        source += "  }\n";
        source += "}\n";
        return source;
      };
      this.generateObject = function generateObject(stringArg, rules, udts) {
        const obj = {};
        const ruleNames = [];
        const udtNames = [];
        const string = stringArg.slice(0);
        obj.grammarObject = "grammarObject";
        rules.forEach((rule) => {
          ruleNames.push(rule.lower);
        });
        ruleNames.sort();
        if (udts.length > 0) {
          udts.forEach((udtFunc) => {
            udtNames.push(udtFunc.lower);
          });
          udtNames.sort();
        }
        obj.callbacks = [];
        ruleNames.forEach((name) => {
          obj.callbacks[name] = false;
        });
        if (udts.length > 0) {
          udtNames.forEach((name) => {
            obj.callbacks[name] = false;
          });
        }
        obj.rules = rules;
        obj.udts = udts;
        obj.toString = function toStringFunc() {
          return string;
        };
        return obj;
      };
    };
  }
});

// node_modules/apg-js/src/apg-api/rule-attributes.js
var require_rule_attributes = __commonJS({
  "node_modules/apg-js/src/apg-api/rule-attributes.js"(exports, module) {
    module.exports = function exportRuleAttributes() {
      const id3 = require_identifiers();
      const thisFile = "rule-attributes.js";
      let state = null;
      function isEmptyOnly(attr) {
        if (attr.left || attr.nested || attr.right || attr.cyclic) {
          return false;
        }
        return attr.empty;
      }
      function isRecursive(attr) {
        if (attr.left || attr.nested || attr.right || attr.cyclic) {
          return true;
        }
        return false;
      }
      function isCatNested(attrs, count) {
        let i2 = 0;
        let j3 = 0;
        let k4 = 0;
        for (i2 = 0; i2 < count; i2 += 1) {
          if (attrs[i2].nested) {
            return true;
          }
        }
        for (i2 = 0; i2 < count; i2 += 1) {
          if (attrs[i2].right && !attrs[i2].leaf) {
            for (j3 = i2 + 1; j3 < count; j3 += 1) {
              if (!isEmptyOnly(attrs[j3])) {
                return true;
              }
            }
          }
        }
        for (i2 = count - 1; i2 >= 0; i2 -= 1) {
          if (attrs[i2].left && !attrs[i2].leaf) {
            for (j3 = i2 - 1; j3 >= 0; j3 -= 1) {
              if (!isEmptyOnly(attrs[j3])) {
                return true;
              }
            }
          }
        }
        for (i2 = 0; i2 < count; i2 += 1) {
          if (!attrs[i2].empty && !isRecursive(attrs[i2])) {
            for (j3 = i2 + 1; j3 < count; j3 += 1) {
              if (isRecursive(attrs[j3])) {
                for (k4 = j3 + 1; k4 < count; k4 += 1) {
                  if (!attrs[k4].empty && !isRecursive(attrs[k4])) {
                    return true;
                  }
                }
              }
            }
          }
        }
        return false;
      }
      function isCatCyclic(attrs, count) {
        for (let i2 = 0; i2 < count; i2 += 1) {
          if (!attrs[i2].cyclic) {
            return false;
          }
        }
        return true;
      }
      function isCatLeft(attrs, count) {
        for (let i2 = 0; i2 < count; i2 += 1) {
          if (attrs[i2].left) {
            return true;
          }
          if (!attrs[i2].empty) {
            return false;
          }
        }
        return false;
      }
      function isCatRight(attrs, count) {
        for (let i2 = count - 1; i2 >= 0; i2 -= 1) {
          if (attrs[i2].right) {
            return true;
          }
          if (!attrs[i2].empty) {
            return false;
          }
        }
        return false;
      }
      function isCatEmpty(attrs, count) {
        for (let i2 = 0; i2 < count; i2 += 1) {
          if (!attrs[i2].empty) {
            return false;
          }
        }
        return true;
      }
      function isCatFinite(attrs, count) {
        for (let i2 = 0; i2 < count; i2 += 1) {
          if (!attrs[i2].finite) {
            return false;
          }
        }
        return true;
      }
      function cat(stateArg, opcodes, opIndex, iAttr) {
        let i2 = 0;
        const opCat = opcodes[opIndex];
        const count = opCat.children.length;
        const childAttrs = [];
        for (i2 = 0; i2 < count; i2 += 1) {
          childAttrs.push(stateArg.attrGen());
        }
        for (i2 = 0; i2 < count; i2 += 1) {
          opEval(stateArg, opcodes, opCat.children[i2], childAttrs[i2]);
        }
        iAttr.left = isCatLeft(childAttrs, count);
        iAttr.right = isCatRight(childAttrs, count);
        iAttr.nested = isCatNested(childAttrs, count);
        iAttr.empty = isCatEmpty(childAttrs, count);
        iAttr.finite = isCatFinite(childAttrs, count);
        iAttr.cyclic = isCatCyclic(childAttrs, count);
      }
      function alt(stateArg, opcodes, opIndex, iAttr) {
        let i2 = 0;
        const opAlt = opcodes[opIndex];
        const count = opAlt.children.length;
        const childAttrs = [];
        for (i2 = 0; i2 < count; i2 += 1) {
          childAttrs.push(stateArg.attrGen());
        }
        for (i2 = 0; i2 < count; i2 += 1) {
          opEval(stateArg, opcodes, opAlt.children[i2], childAttrs[i2]);
        }
        iAttr.left = false;
        iAttr.right = false;
        iAttr.nested = false;
        iAttr.empty = false;
        iAttr.finite = false;
        iAttr.cyclic = false;
        for (i2 = 0; i2 < count; i2 += 1) {
          if (childAttrs[i2].left) {
            iAttr.left = true;
          }
          if (childAttrs[i2].nested) {
            iAttr.nested = true;
          }
          if (childAttrs[i2].right) {
            iAttr.right = true;
          }
          if (childAttrs[i2].empty) {
            iAttr.empty = true;
          }
          if (childAttrs[i2].finite) {
            iAttr.finite = true;
          }
          if (childAttrs[i2].cyclic) {
            iAttr.cyclic = true;
          }
        }
      }
      function bkr(stateArg, opcodes, opIndex, iAttr) {
        const opBkr = opcodes[opIndex];
        if (opBkr.index >= stateArg.ruleCount) {
          iAttr.empty = stateArg.udts[opBkr.index - stateArg.ruleCount].empty;
          iAttr.finite = true;
        } else {
          ruleAttrsEval(stateArg, opBkr.index, iAttr);
          iAttr.left = false;
          iAttr.nested = false;
          iAttr.right = false;
          iAttr.cyclic = false;
        }
      }
      function opEval(stateArg, opcodes, opIndex, iAttr) {
        stateArg.attrInit(iAttr);
        const opi = opcodes[opIndex];
        switch (opi.type) {
          case id3.ALT:
            alt(stateArg, opcodes, opIndex, iAttr);
            break;
          case id3.CAT:
            cat(stateArg, opcodes, opIndex, iAttr);
            break;
          case id3.REP:
            opEval(stateArg, opcodes, opIndex + 1, iAttr);
            if (opi.min === 0) {
              iAttr.empty = true;
              iAttr.finite = true;
            }
            break;
          case id3.RNM:
            ruleAttrsEval(stateArg, opcodes[opIndex].index, iAttr);
            break;
          case id3.BKR:
            bkr(stateArg, opcodes, opIndex, iAttr);
            break;
          case id3.AND:
          case id3.NOT:
          case id3.BKA:
          case id3.BKN:
            opEval(stateArg, opcodes, opIndex + 1, iAttr);
            iAttr.empty = true;
            break;
          case id3.TLS:
            iAttr.empty = !opcodes[opIndex].string.length;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id3.TBS:
          case id3.TRG:
            iAttr.empty = false;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id3.UDT:
            iAttr.empty = opi.empty;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          case id3.ABG:
          case id3.AEN:
            iAttr.empty = true;
            iAttr.finite = true;
            iAttr.cyclic = false;
            break;
          default:
            throw new Error(`unknown opcode type: ${opi}`);
        }
      }
      function ruleAttrsEval(stateArg, ruleIndex, iAttr) {
        const attri = stateArg.attrsWorking[ruleIndex];
        if (attri.isComplete) {
          stateArg.attrCopy(iAttr, attri);
        } else if (!attri.isOpen) {
          attri.isOpen = true;
          opEval(stateArg, attri.rule.opcodes, 0, iAttr);
          attri.left = iAttr.left;
          attri.right = iAttr.right;
          attri.nested = iAttr.nested;
          attri.empty = iAttr.empty;
          attri.finite = iAttr.finite;
          attri.cyclic = iAttr.cyclic;
          attri.leaf = false;
          attri.isOpen = false;
          attri.isComplete = true;
        } else if (ruleIndex === stateArg.startRule) {
          if (ruleIndex === stateArg.startRule) {
            iAttr.left = true;
            iAttr.right = true;
            iAttr.cyclic = true;
            iAttr.leaf = true;
          }
        } else {
          iAttr.finite = true;
        }
      }
      const ruleAttributes = (stateArg) => {
        state = stateArg;
        let i2 = 0;
        let j3 = 0;
        const iAttr = state.attrGen();
        for (i2 = 0; i2 < state.ruleCount; i2 += 1) {
          for (j3 = 0; j3 < state.ruleCount; j3 += 1) {
            state.attrInit(state.attrsWorking[j3]);
          }
          state.startRule = i2;
          ruleAttrsEval(state, i2, iAttr);
          state.attrCopy(state.attrs[i2], state.attrsWorking[i2]);
        }
        state.attributesComplete = true;
        let attri = null;
        for (i2 = 0; i2 < state.ruleCount; i2 += 1) {
          attri = state.attrs[i2];
          if (attri.left || !attri.finite || attri.cyclic) {
            const temp = state.attrGen(attri.rule);
            state.attrCopy(temp, attri);
            state.attrsErrors.push(temp);
            state.attrsErrorCount += 1;
          }
        }
      };
      const truth = (val) => val ? "t" : "f";
      const tError = (val) => val ? "e" : "f";
      const fError = (val) => val ? "t" : "e";
      const showAttr = (seq, index5, attr, dep) => {
        let str = `${seq}:${index5}:`;
        str += `${tError(attr.left)} `;
        str += `${truth(attr.nested)} `;
        str += `${truth(attr.right)} `;
        str += `${tError(attr.cyclic)} `;
        str += `${fError(attr.finite)} `;
        str += `${truth(attr.empty)}:`;
        str += `${state.typeToString(dep.recursiveType)}:`;
        str += dep.recursiveType === id3.ATTR_MR ? dep.groupNumber : "-";
        str += `:${attr.rule.name}
`;
        return str;
      };
      const showLegend = () => {
        let str = "LEGEND - t=true, f=false, e=error\n";
        str += "sequence:rule index:left nested right cyclic finite empty:type:group number:rule name\n";
        return str;
      };
      const showAttributeErrors = () => {
        let attri = null;
        let depi = null;
        let str = "";
        str += "RULE ATTRIBUTES WITH ERRORS\n";
        str += showLegend();
        if (state.attrsErrorCount) {
          for (let i2 = 0; i2 < state.attrsErrorCount; i2 += 1) {
            attri = state.attrsErrors[i2];
            depi = state.ruleDeps[attri.rule.index];
            str += showAttr(i2, attri.rule.index, attri, depi);
          }
        } else {
          str += "<none>\n";
        }
        return str;
      };
      const show = (type6) => {
        let i2 = 0;
        let ii = 0;
        let attri = null;
        let depi = null;
        let str = "";
        let { ruleIndexes } = state;
        if (type6 === 97) {
          ruleIndexes = state.ruleAlphaIndexes;
        } else if (type6 === 116) {
          ruleIndexes = state.ruleTypeIndexes;
        }
        for (i2 = 0; i2 < state.ruleCount; i2 += 1) {
          ii = ruleIndexes[i2];
          attri = state.attrs[ii];
          depi = state.ruleDeps[ii];
          str += showAttr(i2, ii, attri, depi);
        }
        return str;
      };
      const showAttributes = (order3 = "index") => {
        if (!state.attributesComplete) {
          throw new Error(`${thisFile}:showAttributes: attributes not available`);
        }
        let str = "";
        const leader = "RULE ATTRIBUTES\n";
        if (order3.charCodeAt(0) === 97) {
          str += "alphabetical by rule name\n";
          str += leader;
          str += showLegend();
          str += show(97);
        } else if (order3.charCodeAt(0) === 116) {
          str += "ordered by rule type\n";
          str += leader;
          str += showLegend();
          str += show(116);
        } else {
          str += "ordered by rule index\n";
          str += leader;
          str += showLegend();
          str += show();
        }
        return str;
      };
      return { ruleAttributes, showAttributes, showAttributeErrors };
    }();
  }
});

// node_modules/apg-js/src/apg-api/rule-dependencies.js
var require_rule_dependencies = __commonJS({
  "node_modules/apg-js/src/apg-api/rule-dependencies.js"(exports, module) {
    module.exports = (() => {
      const id3 = require_identifiers();
      let state = null;
      const scan = (ruleCount, ruleDeps, index5, isScanned) => {
        let i2 = 0;
        let j3 = 0;
        const rdi = ruleDeps[index5];
        isScanned[index5] = true;
        const op = rdi.rule.opcodes;
        for (i2 = 0; i2 < op.length; i2 += 1) {
          const opi = op[i2];
          if (opi.type === id3.RNM) {
            rdi.refersTo[opi.index] = true;
            if (!isScanned[opi.index]) {
              scan(ruleCount, ruleDeps, opi.index, isScanned);
            }
            for (j3 = 0; j3 < ruleCount; j3 += 1) {
              if (ruleDeps[opi.index].refersTo[j3]) {
                rdi.refersTo[j3] = true;
              }
            }
          } else if (opi.type === id3.UDT) {
            rdi.refersToUdt[opi.index] = true;
          } else if (opi.type === id3.BKR) {
            if (opi.index < ruleCount) {
              rdi.refersTo[opi.index] = true;
              if (!isScanned[opi.index]) {
                scan(ruleCount, ruleDeps, opi.index, isScanned);
              }
            } else {
              rdi.refersToUdt[ruleCount - opi.index] = true;
            }
          }
        }
      };
      const ruleDependencies = (stateArg) => {
        state = stateArg;
        let i2 = 0;
        let j3 = 0;
        let groupCount = 0;
        let rdi = null;
        let rdj = null;
        let newGroup = false;
        state.dependenciesComplete = false;
        const isScanned = state.falseArray(state.ruleCount);
        for (i2 = 0; i2 < state.ruleCount; i2 += 1) {
          state.falsifyArray(isScanned);
          scan(state.ruleCount, state.ruleDeps, i2, isScanned);
        }
        for (i2 = 0; i2 < state.ruleCount; i2 += 1) {
          for (j3 = 0; j3 < state.ruleCount; j3 += 1) {
            if (i2 !== j3) {
              if (state.ruleDeps[j3].refersTo[i2]) {
                state.ruleDeps[i2].referencedBy[j3] = true;
              }
            }
          }
        }
        for (i2 = 0; i2 < state.ruleCount; i2 += 1) {
          state.ruleDeps[i2].recursiveType = id3.ATTR_N;
          if (state.ruleDeps[i2].refersTo[i2]) {
            state.ruleDeps[i2].recursiveType = id3.ATTR_R;
          }
        }
        groupCount = -1;
        for (i2 = 0; i2 < state.ruleCount; i2 += 1) {
          rdi = state.ruleDeps[i2];
          if (rdi.recursiveType === id3.ATTR_R) {
            newGroup = true;
            for (j3 = 0; j3 < state.ruleCount; j3 += 1) {
              if (i2 !== j3) {
                rdj = state.ruleDeps[j3];
                if (rdj.recursiveType === id3.ATTR_R) {
                  if (rdi.refersTo[j3] && rdj.refersTo[i2]) {
                    if (newGroup) {
                      groupCount += 1;
                      rdi.recursiveType = id3.ATTR_MR;
                      rdi.groupNumber = groupCount;
                      newGroup = false;
                    }
                    rdj.recursiveType = id3.ATTR_MR;
                    rdj.groupNumber = groupCount;
                  }
                }
              }
            }
          }
        }
        state.isMutuallyRecursive = groupCount > -1;
        state.ruleAlphaIndexes.sort(state.compRulesAlpha);
        state.ruleTypeIndexes.sort(state.compRulesAlpha);
        state.ruleTypeIndexes.sort(state.compRulesType);
        if (state.isMutuallyRecursive) {
          state.ruleTypeIndexes.sort(state.compRulesGroup);
        }
        if (state.udtCount) {
          state.udtAlphaIndexes.sort(state.compUdtsAlpha);
        }
        state.dependenciesComplete = true;
      };
      const show = (type6 = null) => {
        let i2 = 0;
        let j3 = 0;
        let count = 0;
        let startSeg = 0;
        const maxRule = state.ruleCount - 1;
        const maxUdt = state.udtCount - 1;
        const lineLength = 100;
        let str = "";
        let pre = "";
        const toArrow = "=> ";
        const byArrow = "<= ";
        let first = false;
        let rdi = null;
        let { ruleIndexes } = state;
        let { udtIndexes } = state;
        if (type6 === 97) {
          ruleIndexes = state.ruleAlphaIndexes;
          udtIndexes = state.udtAlphaIndexes;
        } else if (type6 === 116) {
          ruleIndexes = state.ruleTypeIndexes;
          udtIndexes = state.udtAlphaIndexes;
        }
        for (i2 = 0; i2 < state.ruleCount; i2 += 1) {
          rdi = state.ruleDeps[ruleIndexes[i2]];
          pre = `${ruleIndexes[i2]}:${state.typeToString(rdi.recursiveType)}:`;
          if (state.isMutuallyRecursive) {
            pre += rdi.groupNumber > -1 ? rdi.groupNumber : "-";
            pre += ":";
          }
          pre += " ";
          str += `${pre + state.rules[ruleIndexes[i2]].name}
`;
          first = true;
          count = 0;
          startSeg = str.length;
          str += pre;
          for (j3 = 0; j3 < state.ruleCount; j3 += 1) {
            if (rdi.refersTo[ruleIndexes[j3]]) {
              if (first) {
                str += toArrow;
                first = false;
                str += state.ruleDeps[ruleIndexes[j3]].rule.name;
              } else {
                str += `, ${state.ruleDeps[ruleIndexes[j3]].rule.name}`;
              }
              count += 1;
            }
            if (str.length - startSeg > lineLength && j3 !== maxRule) {
              str += `
${pre}${toArrow}`;
              startSeg = str.length;
            }
          }
          if (state.udtCount) {
            for (j3 = 0; j3 < state.udtCount; j3 += 1) {
              if (rdi.refersToUdt[udtIndexes[j3]]) {
                if (first) {
                  str += toArrow;
                  first = false;
                  str += state.udts[udtIndexes[j3]].name;
                } else {
                  str += `, ${state.udts[udtIndexes[j3]].name}`;
                }
                count += 1;
              }
              if (str.length - startSeg > lineLength && j3 !== maxUdt) {
                str += `
${pre}${toArrow}`;
                startSeg = str.length;
              }
            }
          }
          if (count === 0) {
            str += "=> <none>\n";
          }
          if (first === false) {
            str += "\n";
          }
          first = true;
          count = 0;
          startSeg = str.length;
          str += pre;
          for (j3 = 0; j3 < state.ruleCount; j3 += 1) {
            if (rdi.referencedBy[ruleIndexes[j3]]) {
              if (first) {
                str += byArrow;
                first = false;
                str += state.ruleDeps[ruleIndexes[j3]].rule.name;
              } else {
                str += `, ${state.ruleDeps[ruleIndexes[j3]].rule.name}`;
              }
              count += 1;
            }
            if (str.length - startSeg > lineLength && j3 !== maxRule) {
              str += `
${pre}${toArrow}`;
              startSeg = str.length;
            }
          }
          if (count === 0) {
            str += "<= <none>\n";
          }
          if (first === false) {
            str += "\n";
          }
          str += "\n";
        }
        return str;
      };
      const showRuleDependencies = (order3 = "index") => {
        let str = "RULE DEPENDENCIES(index:type:[group number:])\n";
        str += "=> refers to rule names\n";
        str += "<= referenced by rule names\n";
        if (!state.dependenciesComplete) {
          return str;
        }
        if (order3.charCodeAt(0) === 97) {
          str += "alphabetical by rule name\n";
          str += show(97);
        } else if (order3.charCodeAt(0) === 116) {
          str += "ordered by rule type\n";
          str += show(116);
        } else {
          str += "ordered by rule index\n";
          str += show(null);
        }
        return str;
      };
      return { ruleDependencies, showRuleDependencies };
    })();
  }
});

// node_modules/apg-js/src/apg-api/attributes.js
var require_attributes = __commonJS({
  "node_modules/apg-js/src/apg-api/attributes.js"(exports, module) {
    module.exports = function exportAttributes() {
      const id3 = require_identifiers();
      const { ruleAttributes, showAttributes, showAttributeErrors } = require_rule_attributes();
      const { ruleDependencies, showRuleDependencies } = require_rule_dependencies();
      class State2 {
        constructor(rules, udts) {
          this.rules = rules;
          this.udts = udts;
          this.ruleCount = rules.length;
          this.udtCount = udts.length;
          this.startRule = 0;
          this.dependenciesComplete = false;
          this.attributesComplete = false;
          this.isMutuallyRecursive = false;
          this.ruleIndexes = this.indexArray(this.ruleCount);
          this.ruleAlphaIndexes = this.indexArray(this.ruleCount);
          this.ruleTypeIndexes = this.indexArray(this.ruleCount);
          this.udtIndexes = this.indexArray(this.udtCount);
          this.udtAlphaIndexes = this.indexArray(this.udtCount);
          this.attrsErrorCount = 0;
          this.attrs = [];
          this.attrsErrors = [];
          this.attrsWorking = [];
          this.ruleDeps = [];
          for (let i2 = 0; i2 < this.ruleCount; i2 += 1) {
            this.attrs.push(this.attrGen(this.rules[i2]));
            this.attrsWorking.push(this.attrGen(this.rules[i2]));
            this.ruleDeps.push(this.rdGen(rules[i2], this.ruleCount, this.udtCount));
          }
          this.compRulesAlpha = this.compRulesAlpha.bind(this);
          this.compUdtsAlpha = this.compUdtsAlpha.bind(this);
          this.compRulesType = this.compRulesType.bind(this);
          this.compRulesGroup = this.compRulesGroup.bind(this);
        }
        // eslint-disable-next-line class-methods-use-this
        attrGen(rule) {
          return {
            left: false,
            nested: false,
            right: false,
            empty: false,
            finite: false,
            cyclic: false,
            leaf: false,
            isOpen: false,
            isComplete: false,
            rule
          };
        }
        // eslint-disable-next-line class-methods-use-this
        attrInit(attr) {
          attr.left = false;
          attr.nested = false;
          attr.right = false;
          attr.empty = false;
          attr.finite = false;
          attr.cyclic = false;
          attr.leaf = false;
          attr.isOpen = false;
          attr.isComplete = false;
        }
        attrCopy(dst, src) {
          dst.left = src.left;
          dst.nested = src.nested;
          dst.right = src.right;
          dst.empty = src.empty;
          dst.finite = src.finite;
          dst.cyclic = src.cyclic;
          dst.leaf = src.leaf;
          dst.isOpen = src.isOpen;
          dst.isComplete = src.isComplete;
          dst.rule = src.rule;
        }
        rdGen(rule, ruleCount, udtCount) {
          const ret = {
            rule,
            recursiveType: id3.ATTR_N,
            groupNumber: -1,
            refersTo: this.falseArray(ruleCount),
            refersToUdt: this.falseArray(udtCount),
            referencedBy: this.falseArray(ruleCount)
          };
          return ret;
        }
        typeToString(recursiveType) {
          switch (recursiveType) {
            case id3.ATTR_N:
              return " N";
            case id3.ATTR_R:
              return " R";
            case id3.ATTR_MR:
              return "MR";
            default:
              return "UNKNOWN";
          }
        }
        falseArray(length2) {
          const ret = [];
          if (length2 > 0) {
            for (let i2 = 0; i2 < length2; i2 += 1) {
              ret.push(false);
            }
          }
          return ret;
        }
        falsifyArray(a3) {
          for (let i2 = 0; i2 < a3.length; i2 += 1) {
            a3[i2] = false;
          }
        }
        indexArray(length2) {
          const ret = [];
          if (length2 > 0) {
            for (let i2 = 0; i2 < length2; i2 += 1) {
              ret.push(i2);
            }
          }
          return ret;
        }
        compRulesAlpha(left, right) {
          if (this.rules[left].lower < this.rules[right].lower) {
            return -1;
          }
          if (this.rules[left].lower > this.rules[right].lower) {
            return 1;
          }
          return 0;
        }
        compUdtsAlpha(left, right) {
          if (this.udts[left].lower < this.udts[right].lower) {
            return -1;
          }
          if (this.udts[left].lower > this.udts[right].lower) {
            return 1;
          }
          return 0;
        }
        compRulesType(left, right) {
          if (this.ruleDeps[left].recursiveType < this.ruleDeps[right].recursiveType) {
            return -1;
          }
          if (this.ruleDeps[left].recursiveType > this.ruleDeps[right].recursiveType) {
            return 1;
          }
          return 0;
        }
        compRulesGroup(left, right) {
          if (this.ruleDeps[left].recursiveType === id3.ATTR_MR && this.ruleDeps[right].recursiveType === id3.ATTR_MR) {
            if (this.ruleDeps[left].groupNumber < this.ruleDeps[right].groupNumber) {
              return -1;
            }
            if (this.ruleDeps[left].groupNumber > this.ruleDeps[right].groupNumber) {
              return 1;
            }
          }
          return 0;
        }
      }
      const attributes = function attributes2(rules = [], udts = [], lineMap = [], errors = []) {
        const state = new State2(rules, udts);
        ruleDependencies(state);
        ruleAttributes(state);
        if (state.attrsErrorCount) {
          errors.push({ line: 0, char: 0, msg: `${state.attrsErrorCount} attribute errors` });
        }
        return state.attrsErrorCount;
      };
      return { attributes, showAttributes, showAttributeErrors, showRuleDependencies };
    }();
  }
});

// node_modules/apg-js/src/apg-api/show-rules.js
var require_show_rules = __commonJS({
  "node_modules/apg-js/src/apg-api/show-rules.js"(exports, module) {
    module.exports = /* @__PURE__ */ function exfn() {
      const thisFileName = "show-rules.js";
      const showRules = function showRules2(rulesIn = [], udtsIn = [], order3 = "index") {
        const thisFuncName = "showRules";
        let alphaArray = [];
        let udtAlphaArray = [];
        const indexArray = [];
        const udtIndexArray = [];
        const rules = rulesIn;
        const udts = udtsIn;
        const ruleCount = rulesIn.length;
        const udtCount = udtsIn.length;
        let str = "RULE/UDT NAMES";
        let i2;
        function compRulesAlpha(left, right) {
          if (rules[left].lower < rules[right].lower) {
            return -1;
          }
          if (rules[left].lower > rules[right].lower) {
            return 1;
          }
          return 0;
        }
        function compUdtsAlpha(left, right) {
          if (udts[left].lower < udts[right].lower) {
            return -1;
          }
          if (udts[left].lower > udts[right].lower) {
            return 1;
          }
          return 0;
        }
        if (!(Array.isArray(rulesIn) && rulesIn.length)) {
          throw new Error(`${thisFileName}:${thisFuncName}: rules arg must be array with length > 0`);
        }
        if (!Array.isArray(udtsIn)) {
          throw new Error(`${thisFileName}:${thisFuncName}: udts arg must be array`);
        }
        for (i2 = 0; i2 < ruleCount; i2 += 1) {
          indexArray.push(i2);
        }
        alphaArray = indexArray.slice(0);
        alphaArray.sort(compRulesAlpha);
        if (udtCount) {
          for (i2 = 0; i2 < udtCount; i2 += 1) {
            udtIndexArray.push(i2);
          }
          udtAlphaArray = udtIndexArray.slice(0);
          udtAlphaArray.sort(compUdtsAlpha);
        }
        if (order3.charCodeAt(0) === 97) {
          str += " - alphabetical by rule/UDT name\n";
          for (i2 = 0; i2 < ruleCount; i2 += 1) {
            str += `${i2}: ${alphaArray[i2]}: ${rules[alphaArray[i2]].name}
`;
          }
          if (udtCount) {
            for (i2 = 0; i2 < udtCount; i2 += 1) {
              str += `${i2}: ${udtAlphaArray[i2]}: ${udts[udtAlphaArray[i2]].name}
`;
            }
          }
        } else {
          str += " - ordered by rule/UDT index\n";
          for (i2 = 0; i2 < ruleCount; i2 += 1) {
            str += `${i2}: ${rules[i2].name}
`;
          }
          if (udtCount) {
            for (i2 = 0; i2 < udtCount; i2 += 1) {
              str += `${i2}: ${udts[i2].name}
`;
            }
          }
        }
        return str;
      };
      return showRules;
    }();
  }
});

// node_modules/apg-js/src/apg-api/api.js
var require_api = __commonJS({
  "node_modules/apg-js/src/apg-api/api.js"(exports, module) {
    module.exports = function api(src) {
      const { Buffer: Buffer3 } = require_buffer();
      const thisFileName = "api.js: ";
      const thisObject = this;
      const apglib = require_node_exports();
      const converter = require_converter();
      const scanner = require_scanner();
      const parser = new (require_parser2())();
      const { attributes, showAttributes, showAttributeErrors, showRuleDependencies } = require_attributes();
      const showRules = require_show_rules();
      const abnfToHtml = function abnfToHtml2(chars, beg, len) {
        const NORMAL = 0;
        const CONTROL = 1;
        const INVALID = 2;
        const CONTROL_BEG = `<span class="${apglib.style.CLASS_CTRLCHAR}">`;
        const CONTROL_END = "</span>";
        const INVALID_BEG = `<span class="${apglib.style.CLASS_NOMATCH}">`;
        const INVALID_END = "</span>";
        let end;
        let html = "";
        const TRUE = true;
        while (TRUE) {
          if (!Array.isArray(chars) || chars.length === 0) {
            break;
          }
          if (typeof beg !== "number") {
            throw new Error("abnfToHtml: beg must be type number");
          }
          if (beg >= chars.length) {
            break;
          }
          if (typeof len !== "number" || beg + len >= chars.length) {
            end = chars.length;
          } else {
            end = beg + len;
          }
          let state = NORMAL;
          for (let i2 = beg; i2 < end; i2 += 1) {
            const ch = chars[i2];
            if (ch >= 32 && ch <= 126) {
              if (state === CONTROL) {
                html += CONTROL_END;
                state = NORMAL;
              } else if (state === INVALID) {
                html += INVALID_END;
                state = NORMAL;
              }
              switch (ch) {
                case 32:
                  html += "&nbsp;";
                  break;
                case 60:
                  html += "&lt;";
                  break;
                case 62:
                  html += "&gt;";
                  break;
                case 38:
                  html += "&amp;";
                  break;
                case 34:
                  html += "&quot;";
                  break;
                case 39:
                  html += "&#039;";
                  break;
                case 92:
                  html += "&#092;";
                  break;
                default:
                  html += String.fromCharCode(ch);
                  break;
              }
            } else if (ch === 9 || ch === 10 || ch === 13) {
              if (state === NORMAL) {
                html += CONTROL_BEG;
                state = CONTROL;
              } else if (state === INVALID) {
                html += INVALID_END + CONTROL_BEG;
                state = CONTROL;
              }
              if (ch === 9) {
                html += "TAB";
              }
              if (ch === 10) {
                html += "LF";
              }
              if (ch === 13) {
                html += "CR";
              }
            } else {
              if (state === NORMAL) {
                html += INVALID_BEG;
                state = INVALID;
              } else if (state === CONTROL) {
                html += CONTROL_END + INVALID_BEG;
                state = INVALID;
              }
              html += `\\x${apglib.utils.charToHex(ch)}`;
            }
          }
          if (state === INVALID) {
            html += INVALID_END;
          }
          if (state === CONTROL) {
            html += CONTROL_END;
          }
          break;
        }
        return html;
      };
      const abnfToAscii = function abnfToAscii2(chars, beg, len) {
        let str = "";
        for (let i2 = beg; i2 < beg + len; i2 += 1) {
          const ch = chars[i2];
          if (ch >= 32 && ch <= 126) {
            str += String.fromCharCode(ch);
          } else {
            switch (ch) {
              case 9:
                str += "\\t";
                break;
              case 10:
                str += "\\n";
                break;
              case 13:
                str += "\\r";
                break;
              default:
                str += "\\unknown";
                break;
            }
          }
        }
        return str;
      };
      const linesToAscii = function linesToAscii2(lines) {
        let str = "Annotated Input Grammar";
        lines.forEach((val) => {
          str += "\n";
          str += `line no: ${val.lineNo}`;
          str += ` : char index: ${val.beginChar}`;
          str += ` : length: ${val.length}`;
          str += ` : abnf: ${abnfToAscii(thisObject.chars, val.beginChar, val.length)}`;
        });
        str += "\n";
        return str;
      };
      const linesToHtml = function linesToHtml2(lines) {
        let html = "";
        html += `<table class="${apglib.style.CLASS_GRAMMAR}">
`;
        const title = "Annotated Input Grammar";
        html += `<caption>${title}</caption>
`;
        html += "<tr>";
        html += "<th>line<br>no.</th><th>first<br>char</th><th><br>length</th><th><br>text</th>";
        html += "</tr>\n";
        lines.forEach((val) => {
          html += "<tr>";
          html += `<td>${val.lineNo}`;
          html += `</td><td>${val.beginChar}`;
          html += `</td><td>${val.length}`;
          html += `</td><td>${abnfToHtml(thisObject.chars, val.beginChar, val.length)}`;
          html += "</td>";
          html += "</tr>\n";
        });
        html += "</table>\n";
        return html;
      };
      const errorsToHtml = function errorsToHtml2(errors, lines, chars, title) {
        const [style2] = apglib;
        let html = "";
        const errorArrow = `<span class="${style2.CLASS_NOMATCH}">&raquo;</span>`;
        html += `<p><table class="${style2.CLASS_GRAMMAR}">
`;
        if (title && typeof title === "string") {
          html += `<caption>${title}</caption>
`;
        }
        html += "<tr><th>line<br>no.</th><th>line<br>offset</th><th>error<br>offset</th><th><br>text</th></tr>\n";
        errors.forEach((val) => {
          let line;
          let relchar;
          let beg;
          let end;
          let text;
          let prefix = "";
          let suffix = "";
          if (lines.length === 0) {
            text = errorArrow;
            relchar = 0;
          } else {
            line = lines[val.line];
            beg = line.beginChar;
            if (val.char > beg) {
              prefix = abnfToHtml(chars, beg, val.char - beg);
            }
            beg = val.char;
            end = line.beginChar + line.length;
            if (beg < end) {
              suffix = abnfToHtml(chars, beg, end - beg);
            }
            text = prefix + errorArrow + suffix;
            relchar = val.char - line.beginChar;
            html += "<tr>";
            html += `<td>${val.line}</td><td>${line.beginChar}</td><td>${relchar}</td><td>${text}</td>`;
            html += "</tr>\n";
            html += "<tr>";
            html += `<td colspan="3"></td><td>&uarr;:&nbsp;${apglib.utils.stringToAsciiHtml(val.msg)}</td>`;
            html += "</tr>\n";
          }
        });
        html += "</table></p>\n";
        return html;
      };
      const errorsToAscii = function errorsToAscii2(errors, lines, chars) {
        let str;
        let line;
        let beg;
        let len;
        str = "";
        errors.forEach((error) => {
          line = lines[error.line];
          str += `${line.lineNo}: `;
          str += `${line.beginChar}: `;
          str += `${error.char - line.beginChar}: `;
          beg = line.beginChar;
          len = error.char - line.beginChar;
          str += abnfToAscii(chars, beg, len);
          str += " >> ";
          beg = error.char;
          len = line.beginChar + line.length - error.char;
          str += abnfToAscii(chars, beg, len);
          str += "\n";
          str += `${line.lineNo}: `;
          str += `${line.beginChar}: `;
          str += `${error.char - line.beginChar}: `;
          str += "error: ";
          str += error.msg;
          str += "\n";
        });
        return str;
      };
      let isScanned = false;
      let isParsed = false;
      let isTranslated = false;
      let haveAttributes = false;
      let attributeErrors = 0;
      let lineMap;
      this.errors = [];
      if (Buffer3.isBuffer(src)) {
        this.chars = converter.decode("BINARY", src);
      } else if (Array.isArray(src)) {
        this.chars = src.slice();
      } else if (typeof src === "string") {
        this.chars = converter.decode("STRING", src);
      } else {
        throw new Error(`${thisFileName}input source is not a string, byte Buffer or character array`);
      }
      this.sabnf = converter.encode("STRING", this.chars);
      this.scan = function scan(strict, trace) {
        this.lines = scanner(this.chars, this.errors, strict, trace);
        isScanned = true;
      };
      this.parse = function parse3(strict, lite, trace) {
        if (!isScanned) {
          throw new Error(`${thisFileName}grammar not scanned`);
        }
        parser.syntax(this.chars, this.lines, this.errors, strict, lite, trace);
        isParsed = true;
      };
      this.translate = function translate() {
        if (!isParsed) {
          throw new Error(`${thisFileName}grammar not scanned and parsed`);
        }
        const ret = parser.semantic(this.chars, this.lines, this.errors);
        if (this.errors.length === 0) {
          this.rules = ret.rules;
          this.udts = ret.udts;
          lineMap = ret.lineMap;
          isTranslated = true;
        }
      };
      this.attributes = function attrs() {
        if (!isTranslated) {
          throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);
        }
        attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);
        haveAttributes = true;
        return attributeErrors;
      };
      this.generate = function generate(strict) {
        this.lines = scanner(this.chars, this.errors, strict);
        if (this.errors.length) {
          return;
        }
        parser.syntax(this.chars, this.lines, this.errors, strict);
        if (this.errors.length) {
          return;
        }
        const ret = parser.semantic(this.chars, this.lines, this.errors);
        if (this.errors.length) {
          return;
        }
        this.rules = ret.rules;
        this.udts = ret.udts;
        lineMap = ret.lineMap;
        attributeErrors = attributes(this.rules, this.udts, lineMap, this.errors);
        haveAttributes = true;
      };
      this.displayRules = function displayRules(order3 = "index") {
        if (!isTranslated) {
          throw new Error(`${thisFileName}grammar not scanned, parsed and translated`);
        }
        return showRules(this.rules, this.udts, order3);
      };
      this.displayRuleDependencies = function displayRuleDependencies(order3 = "index") {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        return showRuleDependencies(order3);
      };
      this.displayAttributes = function displayAttributes(order3 = "index") {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          showAttributeErrors(order3);
        }
        return showAttributes(order3);
      };
      this.displayAttributeErrors = function displayAttributeErrors() {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}no attributes - must be preceeded by call to attributes()`);
        }
        return showAttributeErrors();
      };
      this.toSource = function toSource(config = void 0) {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);
        }
        return parser.generateSource(this.chars, this.lines, this.rules, this.udts, config);
      };
      this.toObject = function toObject() {
        if (!haveAttributes) {
          throw new Error(`${thisFileName}can't generate parser source - must be preceeded by call to attributes()`);
        }
        if (attributeErrors) {
          throw new Error(`${thisFileName}can't generate parser source - attributes have ${attributeErrors} errors`);
        }
        return parser.generateObject(this.sabnf, this.rules, this.udts);
      };
      this.errorsToAscii = function errorsToAsciiFunc() {
        return errorsToAscii(this.errors, this.lines, this.chars);
      };
      this.errorsToHtml = function errorsToHtmlFunc(title) {
        return errorsToHtml(this.errors, this.lines, this.chars, title);
      };
      this.linesToAscii = function linesToAsciiFunc() {
        return linesToAscii(this.lines);
      };
      this.linesToHtml = function linesToHtmlFunc() {
        return linesToHtml(this.lines);
      };
    };
  }
});

// node_modules/@spruceid/siwe-parser/dist/utils.js
var require_utils4 = __commonJS({
  "node_modules/@spruceid/siwe-parser/dist/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseIntegerNumber = exports.isEIP55Address = void 0;
    var sha3_1 = require_sha3();
    var utils_1 = require_utils();
    var isEIP55Address = (address) => {
      if (address.length != 42) {
        return false;
      }
      const lowerAddress = `${address}`.toLowerCase().replace("0x", "");
      const hash8 = (0, utils_1.bytesToHex)((0, sha3_1.keccak_256)(lowerAddress));
      let ret = "0x";
      for (let i2 = 0; i2 < lowerAddress.length; i2++) {
        if (parseInt(hash8[i2], 16) >= 8) {
          ret += lowerAddress[i2].toUpperCase();
        } else {
          ret += lowerAddress[i2];
        }
      }
      return address === ret;
    };
    exports.isEIP55Address = isEIP55Address;
    var parseIntegerNumber = (number2) => {
      const parsed = parseInt(number2);
      if (isNaN(parsed))
        throw new Error("Invalid number.");
      if (parsed === Infinity)
        throw new Error("Invalid number.");
      return parsed;
    };
    exports.parseIntegerNumber = parseIntegerNumber;
  }
});

// node_modules/@spruceid/siwe-parser/dist/abnf.js
var require_abnf = __commonJS({
  "node_modules/@spruceid/siwe-parser/dist/abnf.js"(exports) {
    "use strict";
    var __importDefault2 = exports && exports.__importDefault || function(mod2) {
      return mod2 && mod2.__esModule ? mod2 : { "default": mod2 };
    };
    var _a2;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsedMessage = void 0;
    var api_1 = __importDefault2(require_api());
    var node_exports_1 = __importDefault2(require_node_exports());
    var utils_1 = require_utils4();
    var GRAMMAR = `
sign-in-with-ethereum =
    [ scheme "://" ] domain %s" wants you to sign in with your Ethereum account:" LF
    address LF
    LF
    [ statement LF ]
    LF
    %s"URI: " URI LF
    %s"Version: " version LF
    %s"Chain ID: " chain-id LF
    %s"Nonce: " nonce LF
    %s"Issued At: " issued-at
    [ LF %s"Expiration Time: " expiration-time ]
    [ LF %s"Not Before: " not-before ]
    [ LF %s"Request ID: " request-id ]
    [ LF %s"Resources:"
    resources ]

domain = authority

address = "0x" 40*40HEXDIG
    ; Must also conform to captilization
    ; checksum encoding specified in EIP-55
    ; where applicable (EOAs).

statement = 1*( reserved / unreserved / " " )
    ; The purpose is to exclude LF (line breaks).

version = "1"

nonce = 8*( ALPHA / DIGIT )

issued-at = date-time
expiration-time = date-time
not-before = date-time

request-id = *pchar

chain-id = 1*DIGIT
    ; See EIP-155 for valid CHAIN_IDs.

resources = *( LF resource )

resource = "- " URI

; ------------------------------------------------------------------------------
; RFC 3986

URI           = scheme ":" hier-part [ "?" query ] [ "#" fragment ]

hier-part     = "//" authority path-abempty
              / path-absolute
              / path-rootless
              / path-empty

scheme        = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )

authority     = [ userinfo "@" ] host [ ":" port ]
userinfo      = *( unreserved / pct-encoded / sub-delims / ":" )
host          = IP-literal / IPv4address / reg-name
port          = *DIGIT

IP-literal    = "[" ( IPv6address / IPvFuture  ) "]"

IPvFuture     = "v" 1*HEXDIG "." 1*( unreserved / sub-delims / ":" )

IPv6address   =                            6( h16 ":" ) ls32
              /                       "::" 5( h16 ":" ) ls32
              / [               h16 ] "::" 4( h16 ":" ) ls32
              / [ *1( h16 ":" ) h16 ] "::" 3( h16 ":" ) ls32
              / [ *2( h16 ":" ) h16 ] "::" 2( h16 ":" ) ls32
              / [ *3( h16 ":" ) h16 ] "::"    h16 ":"   ls32
              / [ *4( h16 ":" ) h16 ] "::"              ls32
              / [ *5( h16 ":" ) h16 ] "::"              h16
              / [ *6( h16 ":" ) h16 ] "::"

h16           = 1*4HEXDIG
ls32          = ( h16 ":" h16 ) / IPv4address
IPv4address   = dec-octet "." dec-octet "." dec-octet "." dec-octet
dec-octet     = DIGIT                 ; 0-9
                 / %x31-39 DIGIT         ; 10-99
                 / "1" 2DIGIT            ; 100-199
                 / "2" %x30-34 DIGIT     ; 200-249
                 / "25" %x30-35          ; 250-255

reg-name      = *( unreserved / pct-encoded / sub-delims )

path-abempty  = *( "/" segment )
path-absolute = "/" [ segment-nz *( "/" segment ) ]
path-rootless = segment-nz *( "/" segment )
path-empty    = 0pchar

segment       = *pchar
segment-nz    = 1*pchar

pchar         = unreserved / pct-encoded / sub-delims / ":" / "@"

query         = *( pchar / "/" / "?" )

fragment      = *( pchar / "/" / "?" )

pct-encoded   = "%" HEXDIG HEXDIG

unreserved    = ALPHA / DIGIT / "-" / "." / "_" / "~"
reserved      = gen-delims / sub-delims
gen-delims    = ":" / "/" / "?" / "#" / "[" / "]" / "@"
sub-delims    = "!" / "$" / "&" / "'" / "(" / ")"
              / "*" / "+" / "," / ";" / "="

; ------------------------------------------------------------------------------
; RFC 3339

date-fullyear   = 4DIGIT
date-month      = 2DIGIT  ; 01-12
date-mday       = 2DIGIT  ; 01-28, 01-29, 01-30, 01-31 based on
                          ; month/year
time-hour       = 2DIGIT  ; 00-23
time-minute     = 2DIGIT  ; 00-59
time-second     = 2DIGIT  ; 00-58, 00-59, 00-60 based on leap second
                          ; rules
time-secfrac    = "." 1*DIGIT
time-numoffset  = ("+" / "-") time-hour ":" time-minute
time-offset     = "Z" / time-numoffset

partial-time    = time-hour ":" time-minute ":" time-second
                  [time-secfrac]
full-date       = date-fullyear "-" date-month "-" date-mday
full-time       = partial-time time-offset

date-time       = full-date "T" full-time

; ------------------------------------------------------------------------------
; RFC 5234

ALPHA          =  %x41-5A / %x61-7A   ; A-Z / a-z
LF             =  %x0A
                  ; linefeed
DIGIT          =  %x30-39
                  ; 0-9
HEXDIG         =  DIGIT / "A" / "B" / "C" / "D" / "E" / "F"
`;
    var GrammarApi = class {
      static generateApi() {
        const api = new api_1.default(GRAMMAR);
        api.generate();
        if (api.errors.length) {
          console.error(api.errorsToAscii());
          console.error(api.linesToAscii());
          console.log(api.displayAttributeErrors());
          throw new Error(`ABNF grammar has errors`);
        }
        return api.toObject();
      }
    };
    _a2 = GrammarApi;
    GrammarApi.grammarObj = _a2.generateApi();
    var ParsedMessage = class {
      constructor(msg) {
        const parser = new node_exports_1.default.parser();
        parser.ast = new node_exports_1.default.ast();
        const id3 = node_exports_1.default.ids;
        const scheme = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE && phraseIndex === 0) {
            data.scheme = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks.scheme = scheme;
        const domain = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.domain = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks.domain = domain;
        const address = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.address = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks.address = address;
        const statement = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.statement = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks.statement = statement;
        const uri = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            if (!data.uri) {
              data.uri = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
            }
          }
          return ret;
        };
        parser.ast.callbacks.uri = uri;
        const version7 = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.version = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks.version = version7;
        const chainId = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.chainId = (0, utils_1.parseIntegerNumber)(node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength));
          }
          return ret;
        };
        parser.ast.callbacks["chain-id"] = chainId;
        const nonce = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.nonce = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks.nonce = nonce;
        const issuedAt = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.issuedAt = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks["issued-at"] = issuedAt;
        const expirationTime = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.expirationTime = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks["expiration-time"] = expirationTime;
        const notBefore = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.notBefore = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks["not-before"] = notBefore;
        const requestId = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.requestId = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength);
          }
          return ret;
        };
        parser.ast.callbacks["request-id"] = requestId;
        const resources = function(state, chars, phraseIndex, phraseLength, data) {
          const ret = id3.SEM_OK;
          if (state === id3.SEM_PRE) {
            data.resources = node_exports_1.default.utils.charsToString(chars, phraseIndex, phraseLength).slice(3).split("\n- ");
          }
          return ret;
        };
        parser.ast.callbacks.resources = resources;
        const result = parser.parse(GrammarApi.grammarObj, "sign-in-with-ethereum", msg);
        if (!result.success) {
          throw new Error(`Invalid message: ${JSON.stringify(result)}`);
        }
        const elements = {};
        parser.ast.translate(elements);
        for (const [key, value] of Object.entries(elements)) {
          this[key] = value;
        }
        if (this.domain.length === 0) {
          throw new Error("Domain cannot be empty.");
        }
        if (!(0, utils_1.isEIP55Address)(this.address)) {
          throw new Error("Address not conformant to EIP-55.");
        }
      }
    };
    exports.ParsedMessage = ParsedMessage;
  }
});

// node_modules/@spruceid/siwe-parser/dist/parsers.js
var require_parsers = __commonJS({
  "node_modules/@spruceid/siwe-parser/dist/parsers.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding2(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ParsedMessage = void 0;
    var abnf_1 = require_abnf();
    Object.defineProperty(exports, "ParsedMessage", { enumerable: true, get: function() {
      return abnf_1.ParsedMessage;
    } });
    __exportStar2(require_utils4(), exports);
  }
});

// node_modules/valid-url/index.js
var require_valid_url = __commonJS({
  "node_modules/valid-url/index.js"(exports, module) {
    (function(module2) {
      "use strict";
      module2.exports.is_uri = is_iri;
      module2.exports.is_http_uri = is_http_iri;
      module2.exports.is_https_uri = is_https_iri;
      module2.exports.is_web_uri = is_web_iri;
      module2.exports.isUri = is_iri;
      module2.exports.isHttpUri = is_http_iri;
      module2.exports.isHttpsUri = is_https_iri;
      module2.exports.isWebUri = is_web_iri;
      var splitUri2 = function(uri) {
        var splitted = uri.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
        return splitted;
      };
      function is_iri(value) {
        if (!value) {
          return;
        }
        if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value)) return;
        if (/%[^0-9a-f]/i.test(value)) return;
        if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value)) return;
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path2 = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri2(value);
        scheme = splitted[1];
        authority = splitted[2];
        path2 = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!(scheme && scheme.length && path2.length >= 0)) return;
        if (authority && authority.length) {
          if (!(path2.length === 0 || /^\//.test(path2))) return;
        } else {
          if (/^\/\//.test(path2)) return;
        }
        if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase())) return;
        out += scheme + ":";
        if (authority && authority.length) {
          out += "//" + authority;
        }
        out += path2;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_http_iri(value, allowHttps) {
        if (!is_iri(value)) {
          return;
        }
        var splitted = [];
        var scheme = "";
        var authority = "";
        var path2 = "";
        var port = "";
        var query = "";
        var fragment = "";
        var out = "";
        splitted = splitUri2(value);
        scheme = splitted[1];
        authority = splitted[2];
        path2 = splitted[3];
        query = splitted[4];
        fragment = splitted[5];
        if (!scheme) return;
        if (allowHttps) {
          if (scheme.toLowerCase() != "https") return;
        } else {
          if (scheme.toLowerCase() != "http") return;
        }
        if (!authority) {
          return;
        }
        if (/:(\d+)$/.test(authority)) {
          port = authority.match(/:(\d+)$/)[0];
          authority = authority.replace(/:\d+$/, "");
        }
        out += scheme + ":";
        out += "//" + authority;
        if (port) {
          out += port;
        }
        out += path2;
        if (query && query.length) {
          out += "?" + query;
        }
        if (fragment && fragment.length) {
          out += "#" + fragment;
        }
        return out;
      }
      function is_https_iri(value) {
        return is_http_iri(value, true);
      }
      function is_web_iri(value) {
        return is_http_iri(value) || is_https_iri(value);
      }
    })(module);
  }
});

// node_modules/ethers/node_modules/tslib/tslib.es6.mjs
var tslib_es6_exports = {};
__export(tslib_es6_exports, {
  __addDisposableResource: () => __addDisposableResource,
  __assign: () => __assign2,
  __asyncDelegator: () => __asyncDelegator,
  __asyncGenerator: () => __asyncGenerator,
  __asyncValues: () => __asyncValues,
  __await: () => __await,
  __awaiter: () => __awaiter,
  __classPrivateFieldGet: () => __classPrivateFieldGet3,
  __classPrivateFieldIn: () => __classPrivateFieldIn,
  __classPrivateFieldSet: () => __classPrivateFieldSet,
  __createBinding: () => __createBinding,
  __decorate: () => __decorate,
  __disposeResources: () => __disposeResources,
  __esDecorate: () => __esDecorate,
  __exportStar: () => __exportStar,
  __extends: () => __extends2,
  __generator: () => __generator,
  __importDefault: () => __importDefault,
  __importStar: () => __importStar,
  __makeTemplateObject: () => __makeTemplateObject,
  __metadata: () => __metadata,
  __param: () => __param,
  __propKey: () => __propKey,
  __read: () => __read2,
  __rest: () => __rest2,
  __runInitializers: () => __runInitializers,
  __setFunctionName: () => __setFunctionName,
  __spread: () => __spread,
  __spreadArray: () => __spreadArray2,
  __spreadArrays: () => __spreadArrays,
  __values: () => __values2,
  default: () => tslib_es6_default
});
function __extends2(d2, b4) {
  if (typeof b4 !== "function" && b4 !== null)
    throw new TypeError("Class extends value " + String(b4) + " is not a constructor or null");
  extendStatics(d2, b4);
  function __() {
    this.constructor = d2;
  }
  d2.prototype = b4 === null ? Object.create(b4) : (__.prototype = b4.prototype, new __());
}
function __rest2(s2, e2) {
  var t2 = {};
  for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2) && e2.indexOf(p2) < 0)
    t2[p2] = s2[p2];
  if (s2 != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i2 = 0, p2 = Object.getOwnPropertySymbols(s2); i2 < p2.length; i2++) {
      if (e2.indexOf(p2[i2]) < 0 && Object.prototype.propertyIsEnumerable.call(s2, p2[i2]))
        t2[p2[i2]] = s2[p2[i2]];
    }
  return t2;
}
function __decorate(decorators, target, key, desc) {
  var c3 = arguments.length, r2 = c3 < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d2;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r2 = Reflect.decorate(decorators, target, key, desc);
  else for (var i2 = decorators.length - 1; i2 >= 0; i2--) if (d2 = decorators[i2]) r2 = (c3 < 3 ? d2(r2) : c3 > 3 ? d2(target, key, r2) : d2(target, key)) || r2;
  return c3 > 3 && r2 && Object.defineProperty(target, key, r2), r2;
}
function __param(paramIndex, decorator) {
  return function(target, key) {
    decorator(target, key, paramIndex);
  };
}
function __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
  function accept(f3) {
    if (f3 !== void 0 && typeof f3 !== "function") throw new TypeError("Function expected");
    return f3;
  }
  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
  var _2, done = false;
  for (var i2 = decorators.length - 1; i2 >= 0; i2--) {
    var context = {};
    for (var p2 in contextIn) context[p2] = p2 === "access" ? {} : contextIn[p2];
    for (var p2 in contextIn.access) context.access[p2] = contextIn.access[p2];
    context.addInitializer = function(f3) {
      if (done) throw new TypeError("Cannot add initializers after decoration has completed");
      extraInitializers.push(accept(f3 || null));
    };
    var result = (0, decorators[i2])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);
    if (kind === "accessor") {
      if (result === void 0) continue;
      if (result === null || typeof result !== "object") throw new TypeError("Object expected");
      if (_2 = accept(result.get)) descriptor.get = _2;
      if (_2 = accept(result.set)) descriptor.set = _2;
      if (_2 = accept(result.init)) initializers.unshift(_2);
    } else if (_2 = accept(result)) {
      if (kind === "field") initializers.unshift(_2);
      else descriptor[key] = _2;
    }
  }
  if (target) Object.defineProperty(target, contextIn.name, descriptor);
  done = true;
}
function __runInitializers(thisArg, initializers, value) {
  var useValue = arguments.length > 2;
  for (var i2 = 0; i2 < initializers.length; i2++) {
    value = useValue ? initializers[i2].call(thisArg, value) : initializers[i2].call(thisArg);
  }
  return useValue ? value : void 0;
}
function __propKey(x2) {
  return typeof x2 === "symbol" ? x2 : "".concat(x2);
}
function __setFunctionName(f3, name, prefix) {
  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";
  return Object.defineProperty(f3, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });
}
function __metadata(metadataKey, metadataValue) {
  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value) {
    return value instanceof P ? value : new P(function(resolve) {
      resolve(value);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value) {
      try {
        step2(generator.next(value));
      } catch (e2) {
        reject(e2);
      }
    }
    function rejected(value) {
      try {
        step2(generator["throw"](value));
      } catch (e2) {
        reject(e2);
      }
    }
    function step2(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step2((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _2 = { label: 0, sent: function() {
    if (t2[0] & 1) throw t2[1];
    return t2[1];
  }, trys: [], ops: [] }, f3, y2, t2, g3 = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);
  return g3.next = verb(0), g3["throw"] = verb(1), g3["return"] = verb(2), typeof Symbol === "function" && (g3[Symbol.iterator] = function() {
    return this;
  }), g3;
  function verb(n2) {
    return function(v2) {
      return step2([n2, v2]);
    };
  }
  function step2(op) {
    if (f3) throw new TypeError("Generator is already executing.");
    while (g3 && (g3 = 0, op[0] && (_2 = 0)), _2) try {
      if (f3 = 1, y2 && (t2 = op[0] & 2 ? y2["return"] : op[0] ? y2["throw"] || ((t2 = y2["return"]) && t2.call(y2), 0) : y2.next) && !(t2 = t2.call(y2, op[1])).done) return t2;
      if (y2 = 0, t2) op = [op[0] & 2, t2.value];
      switch (op[0]) {
        case 0:
        case 1:
          t2 = op;
          break;
        case 4:
          _2.label++;
          return { value: op[1], done: false };
        case 5:
          _2.label++;
          y2 = op[1];
          op = [0];
          continue;
        case 7:
          op = _2.ops.pop();
          _2.trys.pop();
          continue;
        default:
          if (!(t2 = _2.trys, t2 = t2.length > 0 && t2[t2.length - 1]) && (op[0] === 6 || op[0] === 2)) {
            _2 = 0;
            continue;
          }
          if (op[0] === 3 && (!t2 || op[1] > t2[0] && op[1] < t2[3])) {
            _2.label = op[1];
            break;
          }
          if (op[0] === 6 && _2.label < t2[1]) {
            _2.label = t2[1];
            t2 = op;
            break;
          }
          if (t2 && _2.label < t2[2]) {
            _2.label = t2[2];
            _2.ops.push(op);
            break;
          }
          if (t2[2]) _2.ops.pop();
          _2.trys.pop();
          continue;
      }
      op = body.call(thisArg, _2);
    } catch (e2) {
      op = [6, e2];
      y2 = 0;
    } finally {
      f3 = t2 = 0;
    }
    if (op[0] & 5) throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __exportStar(m3, o2) {
  for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(o2, p2)) __createBinding(o2, m3, p2);
}
function __values2(o2) {
  var s2 = typeof Symbol === "function" && Symbol.iterator, m3 = s2 && o2[s2], i2 = 0;
  if (m3) return m3.call(o2);
  if (o2 && typeof o2.length === "number") return {
    next: function() {
      if (o2 && i2 >= o2.length) o2 = void 0;
      return { value: o2 && o2[i2++], done: !o2 };
    }
  };
  throw new TypeError(s2 ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read2(o2, n2) {
  var m3 = typeof Symbol === "function" && o2[Symbol.iterator];
  if (!m3) return o2;
  var i2 = m3.call(o2), r2, ar2 = [], e2;
  try {
    while ((n2 === void 0 || n2-- > 0) && !(r2 = i2.next()).done) ar2.push(r2.value);
  } catch (error) {
    e2 = { error };
  } finally {
    try {
      if (r2 && !r2.done && (m3 = i2["return"])) m3.call(i2);
    } finally {
      if (e2) throw e2.error;
    }
  }
  return ar2;
}
function __spread() {
  for (var ar2 = [], i2 = 0; i2 < arguments.length; i2++)
    ar2 = ar2.concat(__read2(arguments[i2]));
  return ar2;
}
function __spreadArrays() {
  for (var s2 = 0, i2 = 0, il2 = arguments.length; i2 < il2; i2++) s2 += arguments[i2].length;
  for (var r2 = Array(s2), k4 = 0, i2 = 0; i2 < il2; i2++)
    for (var a3 = arguments[i2], j3 = 0, jl2 = a3.length; j3 < jl2; j3++, k4++)
      r2[k4] = a3[j3];
  return r2;
}
function __spreadArray2(to4, from26, pack) {
  if (pack || arguments.length === 2) for (var i2 = 0, l3 = from26.length, ar2; i2 < l3; i2++) {
    if (ar2 || !(i2 in from26)) {
      if (!ar2) ar2 = Array.prototype.slice.call(from26, 0, i2);
      ar2[i2] = from26[i2];
    }
  }
  return to4.concat(ar2 || Array.prototype.slice.call(from26));
}
function __await(v2) {
  return this instanceof __await ? (this.v = v2, this) : new __await(v2);
}
function __asyncGenerator(thisArg, _arguments, generator) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var g3 = generator.apply(thisArg, _arguments || []), i2, q3 = [];
  return i2 = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2;
  function awaitReturn(f3) {
    return function(v2) {
      return Promise.resolve(v2).then(f3, reject);
    };
  }
  function verb(n2, f3) {
    if (g3[n2]) {
      i2[n2] = function(v2) {
        return new Promise(function(a3, b4) {
          q3.push([n2, v2, a3, b4]) > 1 || resume(n2, v2);
        });
      };
      if (f3) i2[n2] = f3(i2[n2]);
    }
  }
  function resume(n2, v2) {
    try {
      step2(g3[n2](v2));
    } catch (e2) {
      settle2(q3[0][3], e2);
    }
  }
  function step2(r2) {
    r2.value instanceof __await ? Promise.resolve(r2.value.v).then(fulfill, reject) : settle2(q3[0][2], r2);
  }
  function fulfill(value) {
    resume("next", value);
  }
  function reject(value) {
    resume("throw", value);
  }
  function settle2(f3, v2) {
    if (f3(v2), q3.shift(), q3.length) resume(q3[0][0], q3[0][1]);
  }
}
function __asyncDelegator(o2) {
  var i2, p2;
  return i2 = {}, verb("next"), verb("throw", function(e2) {
    throw e2;
  }), verb("return"), i2[Symbol.iterator] = function() {
    return this;
  }, i2;
  function verb(n2, f3) {
    i2[n2] = o2[n2] ? function(v2) {
      return (p2 = !p2) ? { value: __await(o2[n2](v2)), done: false } : f3 ? f3(v2) : v2;
    } : f3;
  }
}
function __asyncValues(o2) {
  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
  var m3 = o2[Symbol.asyncIterator], i2;
  return m3 ? m3.call(o2) : (o2 = typeof __values2 === "function" ? __values2(o2) : o2[Symbol.iterator](), i2 = {}, verb("next"), verb("throw"), verb("return"), i2[Symbol.asyncIterator] = function() {
    return this;
  }, i2);
  function verb(n2) {
    i2[n2] = o2[n2] && function(v2) {
      return new Promise(function(resolve, reject) {
        v2 = o2[n2](v2), settle2(resolve, reject, v2.done, v2.value);
      });
    };
  }
  function settle2(resolve, reject, d2, v2) {
    Promise.resolve(v2).then(function(v3) {
      resolve({ value: v3, done: d2 });
    }, reject);
  }
}
function __makeTemplateObject(cooked, raw) {
  if (Object.defineProperty) {
    Object.defineProperty(cooked, "raw", { value: raw });
  } else {
    cooked.raw = raw;
  }
  return cooked;
}
function __importStar(mod2) {
  if (mod2 && mod2.__esModule) return mod2;
  var result = {};
  if (mod2 != null) {
    for (var k4 in mod2) if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4)) __createBinding(result, mod2, k4);
  }
  __setModuleDefault(result, mod2);
  return result;
}
function __importDefault(mod2) {
  return mod2 && mod2.__esModule ? mod2 : { default: mod2 };
}
function __classPrivateFieldGet3(receiver, state, kind, f3) {
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
}
function __classPrivateFieldSet(receiver, state, value, kind, f3) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
}
function __classPrivateFieldIn(state, receiver) {
  if (receiver === null || typeof receiver !== "object" && typeof receiver !== "function") throw new TypeError("Cannot use 'in' operator on non-object");
  return typeof state === "function" ? receiver === state : state.has(receiver);
}
function __addDisposableResource(env2, value, async) {
  if (value !== null && value !== void 0) {
    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");
    var dispose, inner;
    if (async) {
      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");
      dispose = value[Symbol.asyncDispose];
    }
    if (dispose === void 0) {
      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");
      dispose = value[Symbol.dispose];
      if (async) inner = dispose;
    }
    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");
    if (inner) dispose = function() {
      try {
        inner.call(this);
      } catch (e2) {
        return Promise.reject(e2);
      }
    };
    env2.stack.push({ value, dispose, async });
  } else if (async) {
    env2.stack.push({ async: true });
  }
  return value;
}
function __disposeResources(env2) {
  function fail(e2) {
    env2.error = env2.hasError ? new _SuppressedError(e2, env2.error, "An error was suppressed during disposal.") : e2;
    env2.hasError = true;
  }
  var r2, s2 = 0;
  function next() {
    while (r2 = env2.stack.pop()) {
      try {
        if (!r2.async && s2 === 1) return s2 = 0, env2.stack.push(r2), Promise.resolve().then(next);
        if (r2.dispose) {
          var result = r2.dispose.call(r2.value);
          if (r2.async) return s2 |= 2, Promise.resolve(result).then(next, function(e2) {
            fail(e2);
            return next();
          });
        } else s2 |= 1;
      } catch (e2) {
        fail(e2);
      }
    }
    if (s2 === 1) return env2.hasError ? Promise.reject(env2.error) : Promise.resolve();
    if (env2.hasError) throw env2.error;
  }
  return next();
}
var extendStatics, __assign2, __createBinding, __setModuleDefault, _SuppressedError, tslib_es6_default;
var init_tslib_es62 = __esm({
  "node_modules/ethers/node_modules/tslib/tslib.es6.mjs"() {
    extendStatics = function(d2, b4) {
      extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d3, b5) {
        d3.__proto__ = b5;
      } || function(d3, b5) {
        for (var p2 in b5) if (Object.prototype.hasOwnProperty.call(b5, p2)) d3[p2] = b5[p2];
      };
      return extendStatics(d2, b4);
    };
    __assign2 = function() {
      __assign2 = Object.assign || function __assign3(t2) {
        for (var s2, i2 = 1, n2 = arguments.length; i2 < n2; i2++) {
          s2 = arguments[i2];
          for (var p2 in s2) if (Object.prototype.hasOwnProperty.call(s2, p2)) t2[p2] = s2[p2];
        }
        return t2;
      };
      return __assign2.apply(this, arguments);
    };
    __createBinding = Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    };
    __setModuleDefault = Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    };
    _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function(error, suppressed, message) {
      var e2 = new Error(message);
      return e2.name = "SuppressedError", e2.error = error, e2.suppressed = suppressed, e2;
    };
    tslib_es6_default = {
      __extends: __extends2,
      __assign: __assign2,
      __rest: __rest2,
      __decorate,
      __param,
      __metadata,
      __awaiter,
      __generator,
      __createBinding,
      __exportStar,
      __values: __values2,
      __read: __read2,
      __spread,
      __spreadArrays,
      __spreadArray: __spreadArray2,
      __await,
      __asyncGenerator,
      __asyncDelegator,
      __asyncValues,
      __makeTemplateObject,
      __importStar,
      __importDefault,
      __classPrivateFieldGet: __classPrivateFieldGet3,
      __classPrivateFieldSet,
      __classPrivateFieldIn,
      __addDisposableResource,
      __disposeResources
    };
  }
});

// node_modules/ethers/lib.commonjs/_version.js
var require_version2 = __commonJS({
  "node_modules/ethers/lib.commonjs/_version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "6.13.7";
  }
});

// node_modules/ethers/lib.commonjs/utils/properties.js
var require_properties = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/properties.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.defineProperties = exports.resolveProperties = void 0;
    function checkType(value, type6, name) {
      const types3 = type6.split("|").map((t2) => t2.trim());
      for (let i2 = 0; i2 < types3.length; i2++) {
        switch (type6) {
          case "any":
            return;
          case "bigint":
          case "boolean":
          case "number":
          case "string":
            if (typeof value === type6) {
              return;
            }
        }
      }
      const error = new Error(`invalid value for type ${type6}`);
      error.code = "INVALID_ARGUMENT";
      error.argument = `value.${name}`;
      error.value = value;
      throw error;
    }
    async function resolveProperties(value) {
      const keys = Object.keys(value);
      const results2 = await Promise.all(keys.map((k4) => Promise.resolve(value[k4])));
      return results2.reduce((accum, v2, index5) => {
        accum[keys[index5]] = v2;
        return accum;
      }, {});
    }
    exports.resolveProperties = resolveProperties;
    function defineProperties(target, values, types3) {
      for (let key in values) {
        let value = values[key];
        const type6 = types3 ? types3[key] : null;
        if (type6) {
          checkType(value, type6, key);
        }
        Object.defineProperty(target, key, { enumerable: true, value, writable: false });
      }
    }
    exports.defineProperties = defineProperties;
  }
});

// node_modules/ethers/lib.commonjs/utils/errors.js
var require_errors = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.makeError = exports.isCallException = exports.isError = void 0;
    var _version_js_1 = require_version2();
    var properties_js_1 = require_properties();
    function stringify2(value) {
      if (value == null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return "[ " + value.map(stringify2).join(", ") + " ]";
      }
      if (value instanceof Uint8Array) {
        const HEX = "0123456789abcdef";
        let result = "0x";
        for (let i2 = 0; i2 < value.length; i2++) {
          result += HEX[value[i2] >> 4];
          result += HEX[value[i2] & 15];
        }
        return result;
      }
      if (typeof value === "object" && typeof value.toJSON === "function") {
        return stringify2(value.toJSON());
      }
      switch (typeof value) {
        case "boolean":
        case "symbol":
          return value.toString();
        case "bigint":
          return BigInt(value).toString();
        case "number":
          return value.toString();
        case "string":
          return JSON.stringify(value);
        case "object": {
          const keys = Object.keys(value);
          keys.sort();
          return "{ " + keys.map((k4) => `${stringify2(k4)}: ${stringify2(value[k4])}`).join(", ") + " }";
        }
      }
      return `[ COULD NOT SERIALIZE ]`;
    }
    function isError(error, code) {
      return error && error.code === code;
    }
    exports.isError = isError;
    function isCallException(error) {
      return isError(error, "CALL_EXCEPTION");
    }
    exports.isCallException = isCallException;
    function makeError(message, code, info) {
      let shortMessage = message;
      {
        const details = [];
        if (info) {
          if ("message" in info || "code" in info || "name" in info) {
            throw new Error(`value will overwrite populated values: ${stringify2(info)}`);
          }
          for (const key in info) {
            if (key === "shortMessage") {
              continue;
            }
            const value = info[key];
            details.push(key + "=" + stringify2(value));
          }
        }
        details.push(`code=${code}`);
        details.push(`version=${_version_js_1.version}`);
        if (details.length) {
          message += " (" + details.join(", ") + ")";
        }
      }
      let error;
      switch (code) {
        case "INVALID_ARGUMENT":
          error = new TypeError(message);
          break;
        case "NUMERIC_FAULT":
        case "BUFFER_OVERRUN":
          error = new RangeError(message);
          break;
        default:
          error = new Error(message);
      }
      (0, properties_js_1.defineProperties)(error, { code });
      if (info) {
        Object.assign(error, info);
      }
      if (error.shortMessage == null) {
        (0, properties_js_1.defineProperties)(error, { shortMessage });
      }
      return error;
    }
    exports.makeError = makeError;
    function assert9(check, message, code, info) {
      if (!check) {
        throw makeError(message, code, info);
      }
    }
    exports.assert = assert9;
    function assertArgument(check, message, name, value) {
      assert9(check, message, "INVALID_ARGUMENT", { argument: name, value });
    }
    exports.assertArgument = assertArgument;
    function assertArgumentCount(count, expectedCount, message) {
      if (message == null) {
        message = "";
      }
      if (message) {
        message = ": " + message;
      }
      assert9(count >= expectedCount, "missing argument" + message, "MISSING_ARGUMENT", {
        count,
        expectedCount
      });
      assert9(count <= expectedCount, "too many arguments" + message, "UNEXPECTED_ARGUMENT", {
        count,
        expectedCount
      });
    }
    exports.assertArgumentCount = assertArgumentCount;
    var _normalizeForms = ["NFD", "NFC", "NFKD", "NFKC"].reduce((accum, form2) => {
      try {
        if ("test".normalize(form2) !== "test") {
          throw new Error("bad");
        }
        ;
        if (form2 === "NFD") {
          const check = String.fromCharCode(233).normalize("NFD");
          const expected = String.fromCharCode(101, 769);
          if (check !== expected) {
            throw new Error("broken");
          }
        }
        accum.push(form2);
      } catch (error) {
      }
      return accum;
    }, []);
    function assertNormalize(form2) {
      assert9(_normalizeForms.indexOf(form2) >= 0, "platform missing String.prototype.normalize", "UNSUPPORTED_OPERATION", {
        operation: "String.prototype.normalize",
        info: { form: form2 }
      });
    }
    exports.assertNormalize = assertNormalize;
    function assertPrivate(givenGuard, guard, className) {
      if (className == null) {
        className = "";
      }
      if (givenGuard !== guard) {
        let method = className, operation = "new";
        if (className) {
          method += ".";
          operation += " " + className;
        }
        assert9(false, `private constructor; use ${method}from* methods`, "UNSUPPORTED_OPERATION", {
          operation
        });
      }
    }
    exports.assertPrivate = assertPrivate;
  }
});

// node_modules/ethers/lib.commonjs/utils/data.js
var require_data = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = void 0;
    var errors_js_1 = require_errors();
    function _getBytes(value, name, copy) {
      if (value instanceof Uint8Array) {
        if (copy) {
          return new Uint8Array(value);
        }
        return value;
      }
      if (typeof value === "string" && value.match(/^0x(?:[0-9a-f][0-9a-f])*$/i)) {
        const result = new Uint8Array((value.length - 2) / 2);
        let offset = 2;
        for (let i2 = 0; i2 < result.length; i2++) {
          result[i2] = parseInt(value.substring(offset, offset + 2), 16);
          offset += 2;
        }
        return result;
      }
      (0, errors_js_1.assertArgument)(false, "invalid BytesLike value", name || "value", value);
    }
    function getBytes(value, name) {
      return _getBytes(value, name, false);
    }
    exports.getBytes = getBytes;
    function getBytesCopy(value, name) {
      return _getBytes(value, name, true);
    }
    exports.getBytesCopy = getBytesCopy;
    function isHexString(value, length2) {
      if (typeof value !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
      }
      if (typeof length2 === "number" && value.length !== 2 + 2 * length2) {
        return false;
      }
      if (length2 === true && value.length % 2 !== 0) {
        return false;
      }
      return true;
    }
    exports.isHexString = isHexString;
    function isBytesLike(value) {
      return isHexString(value, true) || value instanceof Uint8Array;
    }
    exports.isBytesLike = isBytesLike;
    var HexCharacters = "0123456789abcdef";
    function hexlify(data) {
      const bytes = getBytes(data);
      let result = "0x";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        const v2 = bytes[i2];
        result += HexCharacters[(v2 & 240) >> 4] + HexCharacters[v2 & 15];
      }
      return result;
    }
    exports.hexlify = hexlify;
    function concat3(datas) {
      return "0x" + datas.map((d2) => hexlify(d2).substring(2)).join("");
    }
    exports.concat = concat3;
    function dataLength(data) {
      if (isHexString(data, true)) {
        return (data.length - 2) / 2;
      }
      return getBytes(data).length;
    }
    exports.dataLength = dataLength;
    function dataSlice(data, start, end) {
      const bytes = getBytes(data);
      if (end != null && end > bytes.length) {
        (0, errors_js_1.assert)(false, "cannot slice beyond data bounds", "BUFFER_OVERRUN", {
          buffer: bytes,
          length: bytes.length,
          offset: end
        });
      }
      return hexlify(bytes.slice(start == null ? 0 : start, end == null ? bytes.length : end));
    }
    exports.dataSlice = dataSlice;
    function stripZerosLeft(data) {
      let bytes = hexlify(data).substring(2);
      while (bytes.startsWith("00")) {
        bytes = bytes.substring(2);
      }
      return "0x" + bytes;
    }
    exports.stripZerosLeft = stripZerosLeft;
    function zeroPad(data, length2, left) {
      const bytes = getBytes(data);
      (0, errors_js_1.assert)(length2 >= bytes.length, "padding exceeds data length", "BUFFER_OVERRUN", {
        buffer: new Uint8Array(bytes),
        length: length2,
        offset: length2 + 1
      });
      const result = new Uint8Array(length2);
      result.fill(0);
      if (left) {
        result.set(bytes, length2 - bytes.length);
      } else {
        result.set(bytes, 0);
      }
      return hexlify(result);
    }
    function zeroPadValue(data, length2) {
      return zeroPad(data, length2, true);
    }
    exports.zeroPadValue = zeroPadValue;
    function zeroPadBytes(data, length2) {
      return zeroPad(data, length2, false);
    }
    exports.zeroPadBytes = zeroPadBytes;
  }
});

// node_modules/ethers/lib.commonjs/utils/maths.js
var require_maths = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/maths.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.getNumber = exports.toBigInt = exports.getUint = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = void 0;
    var data_js_1 = require_data();
    var errors_js_1 = require_errors();
    var BN_0 = BigInt(0);
    var BN_1 = BigInt(1);
    var maxValue = 9007199254740991;
    function fromTwos(_value, _width) {
      const value = getUint(_value, "value");
      const width = BigInt(getNumber(_width, "width"));
      (0, errors_js_1.assert)(value >> width === BN_0, "overflow", "NUMERIC_FAULT", {
        operation: "fromTwos",
        fault: "overflow",
        value: _value
      });
      if (value >> width - BN_1) {
        const mask2 = (BN_1 << width) - BN_1;
        return -((~value & mask2) + BN_1);
      }
      return value;
    }
    exports.fromTwos = fromTwos;
    function toTwos(_value, _width) {
      let value = getBigInt(_value, "value");
      const width = BigInt(getNumber(_width, "width"));
      const limit = BN_1 << width - BN_1;
      if (value < BN_0) {
        value = -value;
        (0, errors_js_1.assert)(value <= limit, "too low", "NUMERIC_FAULT", {
          operation: "toTwos",
          fault: "overflow",
          value: _value
        });
        const mask2 = (BN_1 << width) - BN_1;
        return (~value & mask2) + BN_1;
      } else {
        (0, errors_js_1.assert)(value < limit, "too high", "NUMERIC_FAULT", {
          operation: "toTwos",
          fault: "overflow",
          value: _value
        });
      }
      return value;
    }
    exports.toTwos = toTwos;
    function mask(_value, _bits) {
      const value = getUint(_value, "value");
      const bits = BigInt(getNumber(_bits, "bits"));
      return value & (BN_1 << bits) - BN_1;
    }
    exports.mask = mask;
    function getBigInt(value, name) {
      switch (typeof value) {
        case "bigint":
          return value;
        case "number":
          (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
          (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
          return BigInt(value);
        case "string":
          try {
            if (value === "") {
              throw new Error("empty string");
            }
            if (value[0] === "-" && value[1] !== "-") {
              return -BigInt(value.substring(1));
            }
            return BigInt(value);
          } catch (e2) {
            (0, errors_js_1.assertArgument)(false, `invalid BigNumberish string: ${e2.message}`, name || "value", value);
          }
      }
      (0, errors_js_1.assertArgument)(false, "invalid BigNumberish value", name || "value", value);
    }
    exports.getBigInt = getBigInt;
    function getUint(value, name) {
      const result = getBigInt(value, name);
      (0, errors_js_1.assert)(result >= BN_0, "unsigned value cannot be negative", "NUMERIC_FAULT", {
        fault: "overflow",
        operation: "getUint",
        value
      });
      return result;
    }
    exports.getUint = getUint;
    var Nibbles = "0123456789abcdef";
    function toBigInt2(value) {
      if (value instanceof Uint8Array) {
        let result = "0x0";
        for (const v2 of value) {
          result += Nibbles[v2 >> 4];
          result += Nibbles[v2 & 15];
        }
        return BigInt(result);
      }
      return getBigInt(value);
    }
    exports.toBigInt = toBigInt2;
    function getNumber(value, name) {
      switch (typeof value) {
        case "bigint":
          (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
          return Number(value);
        case "number":
          (0, errors_js_1.assertArgument)(Number.isInteger(value), "underflow", name || "value", value);
          (0, errors_js_1.assertArgument)(value >= -maxValue && value <= maxValue, "overflow", name || "value", value);
          return value;
        case "string":
          try {
            if (value === "") {
              throw new Error("empty string");
            }
            return getNumber(BigInt(value), name);
          } catch (e2) {
            (0, errors_js_1.assertArgument)(false, `invalid numeric string: ${e2.message}`, name || "value", value);
          }
      }
      (0, errors_js_1.assertArgument)(false, "invalid numeric value", name || "value", value);
    }
    exports.getNumber = getNumber;
    function toNumber2(value) {
      return getNumber(toBigInt2(value));
    }
    exports.toNumber = toNumber2;
    function toBeHex(_value, _width) {
      const value = getUint(_value, "value");
      let result = value.toString(16);
      if (_width == null) {
        if (result.length % 2) {
          result = "0" + result;
        }
      } else {
        const width = getNumber(_width, "width");
        (0, errors_js_1.assert)(width * 2 >= result.length, `value exceeds width (${width} bytes)`, "NUMERIC_FAULT", {
          operation: "toBeHex",
          fault: "overflow",
          value: _value
        });
        while (result.length < width * 2) {
          result = "0" + result;
        }
      }
      return "0x" + result;
    }
    exports.toBeHex = toBeHex;
    function toBeArray(_value) {
      const value = getUint(_value, "value");
      if (value === BN_0) {
        return new Uint8Array([]);
      }
      let hex3 = value.toString(16);
      if (hex3.length % 2) {
        hex3 = "0" + hex3;
      }
      const result = new Uint8Array(hex3.length / 2);
      for (let i2 = 0; i2 < result.length; i2++) {
        const offset = i2 * 2;
        result[i2] = parseInt(hex3.substring(offset, offset + 2), 16);
      }
      return result;
    }
    exports.toBeArray = toBeArray;
    function toQuantity(value) {
      let result = (0, data_js_1.hexlify)((0, data_js_1.isBytesLike)(value) ? value : toBeArray(value)).substring(2);
      while (result.startsWith("0")) {
        result = result.substring(1);
      }
      if (result === "") {
        result = "0";
      }
      return "0x" + result;
    }
    exports.toQuantity = toQuantity;
  }
});

// node_modules/ethers/lib.commonjs/utils/base58.js
var require_base58 = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/base58.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeBase58 = exports.encodeBase58 = void 0;
    var data_js_1 = require_data();
    var errors_js_1 = require_errors();
    var maths_js_1 = require_maths();
    var Alphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
    var Lookup = null;
    function getAlpha(letter) {
      if (Lookup == null) {
        Lookup = {};
        for (let i2 = 0; i2 < Alphabet.length; i2++) {
          Lookup[Alphabet[i2]] = BigInt(i2);
        }
      }
      const result = Lookup[letter];
      (0, errors_js_1.assertArgument)(result != null, `invalid base58 value`, "letter", letter);
      return result;
    }
    var BN_0 = BigInt(0);
    var BN_58 = BigInt(58);
    function encodeBase58(_value) {
      const bytes = (0, data_js_1.getBytes)(_value);
      let value = (0, maths_js_1.toBigInt)(bytes);
      let result = "";
      while (value) {
        result = Alphabet[Number(value % BN_58)] + result;
        value /= BN_58;
      }
      for (let i2 = 0; i2 < bytes.length; i2++) {
        if (bytes[i2]) {
          break;
        }
        result = Alphabet[0] + result;
      }
      return result;
    }
    exports.encodeBase58 = encodeBase58;
    function decodeBase58(value) {
      let result = BN_0;
      for (let i2 = 0; i2 < value.length; i2++) {
        result *= BN_58;
        result += getAlpha(value[i2]);
      }
      return result;
    }
    exports.decodeBase58 = decodeBase58;
  }
});

// node_modules/ethers/lib.commonjs/utils/base64-browser.js
var require_base64_browser = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/base64-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeBase64 = exports.decodeBase64 = void 0;
    var data_js_1 = require_data();
    function decodeBase64(textData) {
      textData = atob(textData);
      const data = new Uint8Array(textData.length);
      for (let i2 = 0; i2 < textData.length; i2++) {
        data[i2] = textData.charCodeAt(i2);
      }
      return (0, data_js_1.getBytes)(data);
    }
    exports.decodeBase64 = decodeBase64;
    function encodeBase64(_data) {
      const data = (0, data_js_1.getBytes)(_data);
      let textData = "";
      for (let i2 = 0; i2 < data.length; i2++) {
        textData += String.fromCharCode(data[i2]);
      }
      return btoa(textData);
    }
    exports.encodeBase64 = encodeBase64;
  }
});

// node_modules/ethers/lib.commonjs/utils/events.js
var require_events2 = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/events.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EventPayload = void 0;
    var properties_js_1 = require_properties();
    var _listener;
    var EventPayload = class {
      /**
       *  Create a new **EventPayload** for %%emitter%% with
       *  the %%listener%% and for %%filter%%.
       */
      constructor(emitter, listener, filter3) {
        /**
         *  The event filter.
         */
        __publicField(this, "filter");
        /**
         *  The **EventEmitterable**.
         */
        __publicField(this, "emitter");
        __privateAdd(this, _listener);
        __privateSet(this, _listener, listener);
        (0, properties_js_1.defineProperties)(this, { emitter, filter: filter3 });
      }
      /**
       *  Unregister the triggered listener for future events.
       */
      async removeListener() {
        if (__privateGet(this, _listener) == null) {
          return;
        }
        await this.emitter.off(this.filter, __privateGet(this, _listener));
      }
    };
    _listener = new WeakMap();
    exports.EventPayload = EventPayload;
  }
});

// node_modules/ethers/lib.commonjs/utils/utf8.js
var require_utf8 = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/utf8.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8CodePoints = exports.toUtf8String = exports.toUtf8Bytes = exports.Utf8ErrorFuncs = void 0;
    var data_js_1 = require_data();
    var errors_js_1 = require_errors();
    function errorFunc(reason, offset, bytes, output, badCodepoint) {
      (0, errors_js_1.assertArgument)(false, `invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
    }
    function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
      if (reason === "BAD_PREFIX" || reason === "UNEXPECTED_CONTINUE") {
        let i2 = 0;
        for (let o2 = offset + 1; o2 < bytes.length; o2++) {
          if (bytes[o2] >> 6 !== 2) {
            break;
          }
          i2++;
        }
        return i2;
      }
      if (reason === "OVERRUN") {
        return bytes.length - offset - 1;
      }
      return 0;
    }
    function replaceFunc(reason, offset, bytes, output, badCodepoint) {
      if (reason === "OVERLONG") {
        (0, errors_js_1.assertArgument)(typeof badCodepoint === "number", "invalid bad code point for replacement", "badCodepoint", badCodepoint);
        output.push(badCodepoint);
        return 0;
      }
      output.push(65533);
      return ignoreFunc(reason, offset, bytes, output, badCodepoint);
    }
    exports.Utf8ErrorFuncs = Object.freeze({
      error: errorFunc,
      ignore: ignoreFunc,
      replace: replaceFunc
    });
    function getUtf8CodePoints(_bytes, onError) {
      if (onError == null) {
        onError = exports.Utf8ErrorFuncs.error;
      }
      const bytes = (0, data_js_1.getBytes)(_bytes, "bytes");
      const result = [];
      let i2 = 0;
      while (i2 < bytes.length) {
        const c3 = bytes[i2++];
        if (c3 >> 7 === 0) {
          result.push(c3);
          continue;
        }
        let extraLength = null;
        let overlongMask = null;
        if ((c3 & 224) === 192) {
          extraLength = 1;
          overlongMask = 127;
        } else if ((c3 & 240) === 224) {
          extraLength = 2;
          overlongMask = 2047;
        } else if ((c3 & 248) === 240) {
          extraLength = 3;
          overlongMask = 65535;
        } else {
          if ((c3 & 192) === 128) {
            i2 += onError("UNEXPECTED_CONTINUE", i2 - 1, bytes, result);
          } else {
            i2 += onError("BAD_PREFIX", i2 - 1, bytes, result);
          }
          continue;
        }
        if (i2 - 1 + extraLength >= bytes.length) {
          i2 += onError("OVERRUN", i2 - 1, bytes, result);
          continue;
        }
        let res = c3 & (1 << 8 - extraLength - 1) - 1;
        for (let j3 = 0; j3 < extraLength; j3++) {
          let nextChar = bytes[i2];
          if ((nextChar & 192) != 128) {
            i2 += onError("MISSING_CONTINUE", i2, bytes, result);
            res = null;
            break;
          }
          ;
          res = res << 6 | nextChar & 63;
          i2++;
        }
        if (res === null) {
          continue;
        }
        if (res > 1114111) {
          i2 += onError("OUT_OF_RANGE", i2 - 1 - extraLength, bytes, result, res);
          continue;
        }
        if (res >= 55296 && res <= 57343) {
          i2 += onError("UTF16_SURROGATE", i2 - 1 - extraLength, bytes, result, res);
          continue;
        }
        if (res <= overlongMask) {
          i2 += onError("OVERLONG", i2 - 1 - extraLength, bytes, result, res);
          continue;
        }
        result.push(res);
      }
      return result;
    }
    function toUtf8Bytes(str, form2) {
      (0, errors_js_1.assertArgument)(typeof str === "string", "invalid string value", "str", str);
      if (form2 != null) {
        (0, errors_js_1.assertNormalize)(form2);
        str = str.normalize(form2);
      }
      let result = [];
      for (let i2 = 0; i2 < str.length; i2++) {
        const c3 = str.charCodeAt(i2);
        if (c3 < 128) {
          result.push(c3);
        } else if (c3 < 2048) {
          result.push(c3 >> 6 | 192);
          result.push(c3 & 63 | 128);
        } else if ((c3 & 64512) == 55296) {
          i2++;
          const c22 = str.charCodeAt(i2);
          (0, errors_js_1.assertArgument)(i2 < str.length && (c22 & 64512) === 56320, "invalid surrogate pair", "str", str);
          const pair = 65536 + ((c3 & 1023) << 10) + (c22 & 1023);
          result.push(pair >> 18 | 240);
          result.push(pair >> 12 & 63 | 128);
          result.push(pair >> 6 & 63 | 128);
          result.push(pair & 63 | 128);
        } else {
          result.push(c3 >> 12 | 224);
          result.push(c3 >> 6 & 63 | 128);
          result.push(c3 & 63 | 128);
        }
      }
      return new Uint8Array(result);
    }
    exports.toUtf8Bytes = toUtf8Bytes;
    function _toUtf8String(codePoints) {
      return codePoints.map((codePoint) => {
        if (codePoint <= 65535) {
          return String.fromCharCode(codePoint);
        }
        codePoint -= 65536;
        return String.fromCharCode((codePoint >> 10 & 1023) + 55296, (codePoint & 1023) + 56320);
      }).join("");
    }
    function toUtf8String(bytes, onError) {
      return _toUtf8String(getUtf8CodePoints(bytes, onError));
    }
    exports.toUtf8String = toUtf8String;
    function toUtf8CodePoints(str, form2) {
      return getUtf8CodePoints(toUtf8Bytes(str, form2));
    }
    exports.toUtf8CodePoints = toUtf8CodePoints;
  }
});

// node_modules/ethers/lib.commonjs/utils/geturl-browser.js
var require_geturl_browser = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/geturl-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getUrl = exports.createGetUrl = void 0;
    var errors_js_1 = require_errors();
    function createGetUrl(options) {
      async function getUrl3(req, _signal) {
        (0, errors_js_1.assert)(_signal == null || !_signal.cancelled, "request cancelled before sending", "CANCELLED");
        const protocol = req.url.split(":")[0].toLowerCase();
        (0, errors_js_1.assert)(protocol === "http" || protocol === "https", `unsupported protocol ${protocol}`, "UNSUPPORTED_OPERATION", {
          info: { protocol },
          operation: "request"
        });
        (0, errors_js_1.assert)(protocol === "https" || !req.credentials || req.allowInsecureAuthentication, "insecure authorized connections unsupported", "UNSUPPORTED_OPERATION", {
          operation: "request"
        });
        let error = null;
        const controller = new AbortController();
        const timer = setTimeout(() => {
          error = (0, errors_js_1.makeError)("request timeout", "TIMEOUT");
          controller.abort();
        }, req.timeout);
        if (_signal) {
          _signal.addListener(() => {
            error = (0, errors_js_1.makeError)("request cancelled", "CANCELLED");
            controller.abort();
          });
        }
        const init2 = {
          method: req.method,
          headers: new Headers(Array.from(req)),
          body: req.body || void 0,
          signal: controller.signal
        };
        let resp;
        try {
          resp = await fetch(req.url, init2);
        } catch (_error) {
          clearTimeout(timer);
          if (error) {
            throw error;
          }
          throw _error;
        }
        clearTimeout(timer);
        const headers = {};
        resp.headers.forEach((value, key) => {
          headers[key.toLowerCase()] = value;
        });
        const respBody = await resp.arrayBuffer();
        const body = respBody == null ? null : new Uint8Array(respBody);
        return {
          statusCode: resp.status,
          statusMessage: resp.statusText,
          headers,
          body
        };
      }
      return getUrl3;
    }
    exports.createGetUrl = createGetUrl;
    var defaultGetUrl = createGetUrl({});
    async function getUrl2(req, _signal) {
      return defaultGetUrl(req, _signal);
    }
    exports.getUrl = getUrl2;
  }
});

// node_modules/ethers/lib.commonjs/utils/fetch.js
var require_fetch = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/fetch.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchResponse = exports.FetchRequest = exports.FetchCancelSignal = void 0;
    var base64_js_1 = require_base64_browser();
    var data_js_1 = require_data();
    var errors_js_1 = require_errors();
    var properties_js_1 = require_properties();
    var utf8_js_1 = require_utf8();
    var geturl_js_1 = require_geturl_browser();
    var MAX_ATTEMPTS = 12;
    var SLOT_INTERVAL = 250;
    var defaultGetUrlFunc = (0, geturl_js_1.createGetUrl)();
    var reData = new RegExp("^data:([^;:]*)?(;base64)?,(.*)$", "i");
    var reIpfs = new RegExp("^ipfs://(ipfs/)?(.*)$", "i");
    var locked = false;
    async function dataGatewayFunc(url, signal) {
      try {
        const match = url.match(reData);
        if (!match) {
          throw new Error("invalid data");
        }
        return new FetchResponse(200, "OK", {
          "content-type": match[1] || "text/plain"
        }, match[2] ? (0, base64_js_1.decodeBase64)(match[3]) : unpercent(match[3]));
      } catch (error) {
        return new FetchResponse(599, "BAD REQUEST (invalid data: URI)", {}, null, new FetchRequest(url));
      }
    }
    function getIpfsGatewayFunc(baseUrl) {
      async function gatewayIpfs(url, signal) {
        try {
          const match = url.match(reIpfs);
          if (!match) {
            throw new Error("invalid link");
          }
          return new FetchRequest(`${baseUrl}${match[2]}`);
        } catch (error) {
          return new FetchResponse(599, "BAD REQUEST (invalid IPFS URI)", {}, null, new FetchRequest(url));
        }
      }
      return gatewayIpfs;
    }
    var Gateways = {
      "data": dataGatewayFunc,
      "ipfs": getIpfsGatewayFunc("https://gateway.ipfs.io/ipfs/")
    };
    var fetchSignals = /* @__PURE__ */ new WeakMap();
    var _listeners, _cancelled;
    var FetchCancelSignal = class {
      constructor(request) {
        __privateAdd(this, _listeners);
        __privateAdd(this, _cancelled);
        __privateSet(this, _listeners, []);
        __privateSet(this, _cancelled, false);
        fetchSignals.set(request, () => {
          if (__privateGet(this, _cancelled)) {
            return;
          }
          __privateSet(this, _cancelled, true);
          for (const listener of __privateGet(this, _listeners)) {
            setTimeout(() => {
              listener();
            }, 0);
          }
          __privateSet(this, _listeners, []);
        });
      }
      addListener(listener) {
        (0, errors_js_1.assert)(!__privateGet(this, _cancelled), "singal already cancelled", "UNSUPPORTED_OPERATION", {
          operation: "fetchCancelSignal.addCancelListener"
        });
        __privateGet(this, _listeners).push(listener);
      }
      get cancelled() {
        return __privateGet(this, _cancelled);
      }
      checkSignal() {
        (0, errors_js_1.assert)(!this.cancelled, "cancelled", "CANCELLED", {});
      }
    };
    _listeners = new WeakMap();
    _cancelled = new WeakMap();
    exports.FetchCancelSignal = FetchCancelSignal;
    function checkSignal(signal) {
      if (signal == null) {
        throw new Error("missing signal; should not happen");
      }
      signal.checkSignal();
      return signal;
    }
    var _allowInsecure, _gzip, _headers, _method, _timeout, _url, _body, _bodyType, _creds, _preflight, _process, _retry, _signal, _throttle, _getUrlFunc, _FetchRequest_instances, send_fn;
    var _FetchRequest = class _FetchRequest {
      /**
       *  Create a new FetchRequest instance with default values.
       *
       *  Once created, each property may be set before issuing a
       *  ``.send()`` to make the request.
       */
      constructor(url) {
        __privateAdd(this, _FetchRequest_instances);
        __privateAdd(this, _allowInsecure);
        __privateAdd(this, _gzip);
        __privateAdd(this, _headers);
        __privateAdd(this, _method);
        __privateAdd(this, _timeout);
        __privateAdd(this, _url);
        __privateAdd(this, _body);
        __privateAdd(this, _bodyType);
        __privateAdd(this, _creds);
        // Hooks
        __privateAdd(this, _preflight);
        __privateAdd(this, _process);
        __privateAdd(this, _retry);
        __privateAdd(this, _signal);
        __privateAdd(this, _throttle);
        __privateAdd(this, _getUrlFunc);
        __privateSet(this, _url, String(url));
        __privateSet(this, _allowInsecure, false);
        __privateSet(this, _gzip, true);
        __privateSet(this, _headers, {});
        __privateSet(this, _method, "");
        __privateSet(this, _timeout, 3e5);
        __privateSet(this, _throttle, {
          slotInterval: SLOT_INTERVAL,
          maxAttempts: MAX_ATTEMPTS
        });
        __privateSet(this, _getUrlFunc, null);
      }
      /**
       *  The fetch URL to request.
       */
      get url() {
        return __privateGet(this, _url);
      }
      set url(url) {
        __privateSet(this, _url, String(url));
      }
      /**
       *  The fetch body, if any, to send as the request body. //(default: null)//
       *
       *  When setting a body, the intrinsic ``Content-Type`` is automatically
       *  set and will be used if **not overridden** by setting a custom
       *  header.
       *
       *  If %%body%% is null, the body is cleared (along with the
       *  intrinsic ``Content-Type``).
       *
       *  If %%body%% is a string, the intrinsic ``Content-Type`` is set to
       *  ``text/plain``.
       *
       *  If %%body%% is a Uint8Array, the intrinsic ``Content-Type`` is set to
       *  ``application/octet-stream``.
       *
       *  If %%body%% is any other object, the intrinsic ``Content-Type`` is
       *  set to ``application/json``.
       */
      get body() {
        if (__privateGet(this, _body) == null) {
          return null;
        }
        return new Uint8Array(__privateGet(this, _body));
      }
      set body(body) {
        if (body == null) {
          __privateSet(this, _body, void 0);
          __privateSet(this, _bodyType, void 0);
        } else if (typeof body === "string") {
          __privateSet(this, _body, (0, utf8_js_1.toUtf8Bytes)(body));
          __privateSet(this, _bodyType, "text/plain");
        } else if (body instanceof Uint8Array) {
          __privateSet(this, _body, body);
          __privateSet(this, _bodyType, "application/octet-stream");
        } else if (typeof body === "object") {
          __privateSet(this, _body, (0, utf8_js_1.toUtf8Bytes)(JSON.stringify(body)));
          __privateSet(this, _bodyType, "application/json");
        } else {
          throw new Error("invalid body");
        }
      }
      /**
       *  Returns true if the request has a body.
       */
      hasBody() {
        return __privateGet(this, _body) != null;
      }
      /**
       *  The HTTP method to use when requesting the URI. If no method
       *  has been explicitly set, then ``GET`` is used if the body is
       *  null and ``POST`` otherwise.
       */
      get method() {
        if (__privateGet(this, _method)) {
          return __privateGet(this, _method);
        }
        if (this.hasBody()) {
          return "POST";
        }
        return "GET";
      }
      set method(method) {
        if (method == null) {
          method = "";
        }
        __privateSet(this, _method, String(method).toUpperCase());
      }
      /**
       *  The headers that will be used when requesting the URI. All
       *  keys are lower-case.
       *
       *  This object is a copy, so any changes will **NOT** be reflected
       *  in the ``FetchRequest``.
       *
       *  To set a header entry, use the ``setHeader`` method.
       */
      get headers() {
        const headers = Object.assign({}, __privateGet(this, _headers));
        if (__privateGet(this, _creds)) {
          headers["authorization"] = `Basic ${(0, base64_js_1.encodeBase64)((0, utf8_js_1.toUtf8Bytes)(__privateGet(this, _creds)))}`;
        }
        ;
        if (this.allowGzip) {
          headers["accept-encoding"] = "gzip";
        }
        if (headers["content-type"] == null && __privateGet(this, _bodyType)) {
          headers["content-type"] = __privateGet(this, _bodyType);
        }
        if (this.body) {
          headers["content-length"] = String(this.body.length);
        }
        return headers;
      }
      /**
       *  Get the header for %%key%%, ignoring case.
       */
      getHeader(key) {
        return this.headers[key.toLowerCase()];
      }
      /**
       *  Set the header for %%key%% to %%value%%. All values are coerced
       *  to a string.
       */
      setHeader(key, value) {
        __privateGet(this, _headers)[String(key).toLowerCase()] = String(value);
      }
      /**
       *  Clear all headers, resetting all intrinsic headers.
       */
      clearHeaders() {
        __privateSet(this, _headers, {});
      }
      [Symbol.iterator]() {
        const headers = this.headers;
        const keys = Object.keys(headers);
        let index5 = 0;
        return {
          next: () => {
            if (index5 < keys.length) {
              const key = keys[index5++];
              return {
                value: [key, headers[key]],
                done: false
              };
            }
            return { value: void 0, done: true };
          }
        };
      }
      /**
       *  The value that will be sent for the ``Authorization`` header.
       *
       *  To set the credentials, use the ``setCredentials`` method.
       */
      get credentials() {
        return __privateGet(this, _creds) || null;
      }
      /**
       *  Sets an ``Authorization`` for %%username%% with %%password%%.
       */
      setCredentials(username, password) {
        (0, errors_js_1.assertArgument)(!username.match(/:/), "invalid basic authentication username", "username", "[REDACTED]");
        __privateSet(this, _creds, `${username}:${password}`);
      }
      /**
       *  Enable and request gzip-encoded responses. The response will
       *  automatically be decompressed. //(default: true)//
       */
      get allowGzip() {
        return __privateGet(this, _gzip);
      }
      set allowGzip(value) {
        __privateSet(this, _gzip, !!value);
      }
      /**
       *  Allow ``Authentication`` credentials to be sent over insecure
       *  channels. //(default: false)//
       */
      get allowInsecureAuthentication() {
        return !!__privateGet(this, _allowInsecure);
      }
      set allowInsecureAuthentication(value) {
        __privateSet(this, _allowInsecure, !!value);
      }
      /**
       *  The timeout (in milliseconds) to wait for a complete response.
       *  //(default: 5 minutes)//
       */
      get timeout() {
        return __privateGet(this, _timeout);
      }
      set timeout(timeout) {
        (0, errors_js_1.assertArgument)(timeout >= 0, "timeout must be non-zero", "timeout", timeout);
        __privateSet(this, _timeout, timeout);
      }
      /**
       *  This function is called prior to each request, for example
       *  during a redirection or retry in case of server throttling.
       *
       *  This offers an opportunity to populate headers or update
       *  content before sending a request.
       */
      get preflightFunc() {
        return __privateGet(this, _preflight) || null;
      }
      set preflightFunc(preflight) {
        __privateSet(this, _preflight, preflight);
      }
      /**
       *  This function is called after each response, offering an
       *  opportunity to provide client-level throttling or updating
       *  response data.
       *
       *  Any error thrown in this causes the ``send()`` to throw.
       *
       *  To schedule a retry attempt (assuming the maximum retry limit
       *  has not been reached), use [[response.throwThrottleError]].
       */
      get processFunc() {
        return __privateGet(this, _process) || null;
      }
      set processFunc(process2) {
        __privateSet(this, _process, process2);
      }
      /**
       *  This function is called on each retry attempt.
       */
      get retryFunc() {
        return __privateGet(this, _retry) || null;
      }
      set retryFunc(retry) {
        __privateSet(this, _retry, retry);
      }
      /**
       *  This function is called to fetch content from HTTP and
       *  HTTPS URLs and is platform specific (e.g. nodejs vs
       *  browsers).
       *
       *  This is by default the currently registered global getUrl
       *  function, which can be changed using [[registerGetUrl]].
       *  If this has been set, setting is to ``null`` will cause
       *  this FetchRequest (and any future clones) to revert back to
       *  using the currently registered global getUrl function.
       *
       *  Setting this is generally not necessary, but may be useful
       *  for developers that wish to intercept requests or to
       *  configurege a proxy or other agent.
       */
      get getUrlFunc() {
        return __privateGet(this, _getUrlFunc) || defaultGetUrlFunc;
      }
      set getUrlFunc(value) {
        __privateSet(this, _getUrlFunc, value);
      }
      toString() {
        return `<FetchRequest method=${JSON.stringify(this.method)} url=${JSON.stringify(this.url)} headers=${JSON.stringify(this.headers)} body=${__privateGet(this, _body) ? (0, data_js_1.hexlify)(__privateGet(this, _body)) : "null"}>`;
      }
      /**
       *  Update the throttle parameters used to determine maximum
       *  attempts and exponential-backoff properties.
       */
      setThrottleParams(params) {
        if (params.slotInterval != null) {
          __privateGet(this, _throttle).slotInterval = params.slotInterval;
        }
        if (params.maxAttempts != null) {
          __privateGet(this, _throttle).maxAttempts = params.maxAttempts;
        }
      }
      /**
       *  Resolves to the response by sending the request.
       */
      send() {
        (0, errors_js_1.assert)(__privateGet(this, _signal) == null, "request already sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.send" });
        __privateSet(this, _signal, new FetchCancelSignal(this));
        return __privateMethod(this, _FetchRequest_instances, send_fn).call(this, 0, getTime() + this.timeout, 0, this, new FetchResponse(0, "", {}, null, this));
      }
      /**
       *  Cancels the inflight response, causing a ``CANCELLED``
       *  error to be rejected from the [[send]].
       */
      cancel() {
        (0, errors_js_1.assert)(__privateGet(this, _signal) != null, "request has not been sent", "UNSUPPORTED_OPERATION", { operation: "fetchRequest.cancel" });
        const signal = fetchSignals.get(this);
        if (!signal) {
          throw new Error("missing signal; should not happen");
        }
        signal();
      }
      /**
       *  Returns a new [[FetchRequest]] that represents the redirection
       *  to %%location%%.
       */
      redirect(location) {
        const current = this.url.split(":")[0].toLowerCase();
        const target = location.split(":")[0].toLowerCase();
        (0, errors_js_1.assert)(this.method === "GET" && (current !== "https" || target !== "http") && location.match(/^https?:/), `unsupported redirect`, "UNSUPPORTED_OPERATION", {
          operation: `redirect(${this.method} ${JSON.stringify(this.url)} => ${JSON.stringify(location)})`
        });
        const req = new _FetchRequest(location);
        req.method = "GET";
        req.allowGzip = this.allowGzip;
        req.timeout = this.timeout;
        __privateSet(req, _headers, Object.assign({}, __privateGet(this, _headers)));
        if (__privateGet(this, _body)) {
          __privateSet(req, _body, new Uint8Array(__privateGet(this, _body)));
        }
        __privateSet(req, _bodyType, __privateGet(this, _bodyType));
        return req;
      }
      /**
       *  Create a new copy of this request.
       */
      clone() {
        const clone = new _FetchRequest(this.url);
        __privateSet(clone, _method, __privateGet(this, _method));
        if (__privateGet(this, _body)) {
          __privateSet(clone, _body, __privateGet(this, _body));
        }
        __privateSet(clone, _bodyType, __privateGet(this, _bodyType));
        __privateSet(clone, _headers, Object.assign({}, __privateGet(this, _headers)));
        __privateSet(clone, _creds, __privateGet(this, _creds));
        if (this.allowGzip) {
          clone.allowGzip = true;
        }
        clone.timeout = this.timeout;
        if (this.allowInsecureAuthentication) {
          clone.allowInsecureAuthentication = true;
        }
        __privateSet(clone, _preflight, __privateGet(this, _preflight));
        __privateSet(clone, _process, __privateGet(this, _process));
        __privateSet(clone, _retry, __privateGet(this, _retry));
        __privateSet(clone, _throttle, Object.assign({}, __privateGet(this, _throttle)));
        __privateSet(clone, _getUrlFunc, __privateGet(this, _getUrlFunc));
        return clone;
      }
      /**
       *  Locks all static configuration for gateways and FetchGetUrlFunc
       *  registration.
       */
      static lockConfig() {
        locked = true;
      }
      /**
       *  Get the current Gateway function for %%scheme%%.
       */
      static getGateway(scheme) {
        return Gateways[scheme.toLowerCase()] || null;
      }
      /**
       *  Use the %%func%% when fetching URIs using %%scheme%%.
       *
       *  This method affects all requests globally.
       *
       *  If [[lockConfig]] has been called, no change is made and this
       *  throws.
       */
      static registerGateway(scheme, func) {
        scheme = scheme.toLowerCase();
        if (scheme === "http" || scheme === "https") {
          throw new Error(`cannot intercept ${scheme}; use registerGetUrl`);
        }
        if (locked) {
          throw new Error("gateways locked");
        }
        Gateways[scheme] = func;
      }
      /**
       *  Use %%getUrl%% when fetching URIs over HTTP and HTTPS requests.
       *
       *  This method affects all requests globally.
       *
       *  If [[lockConfig]] has been called, no change is made and this
       *  throws.
       */
      static registerGetUrl(getUrl2) {
        if (locked) {
          throw new Error("gateways locked");
        }
        defaultGetUrlFunc = getUrl2;
      }
      /**
       *  Creates a getUrl function that fetches content from HTTP and
       *  HTTPS URLs.
       *
       *  The available %%options%% are dependent on the platform
       *  implementation of the default getUrl function.
       *
       *  This is not generally something that is needed, but is useful
       *  when trying to customize simple behaviour when fetching HTTP
       *  content.
       */
      static createGetUrlFunc(options) {
        return (0, geturl_js_1.createGetUrl)(options);
      }
      /**
       *  Creates a function that can "fetch" data URIs.
       *
       *  Note that this is automatically done internally to support
       *  data URIs, so it is not necessary to register it.
       *
       *  This is not generally something that is needed, but may
       *  be useful in a wrapper to perfom custom data URI functionality.
       */
      static createDataGateway() {
        return dataGatewayFunc;
      }
      /**
       *  Creates a function that will fetch IPFS (unvalidated) from
       *  a custom gateway baseUrl.
       *
       *  The default IPFS gateway used internally is
       *  ``"https:/\/gateway.ipfs.io/ipfs/"``.
       */
      static createIpfsGatewayFunc(baseUrl) {
        return getIpfsGatewayFunc(baseUrl);
      }
    };
    _allowInsecure = new WeakMap();
    _gzip = new WeakMap();
    _headers = new WeakMap();
    _method = new WeakMap();
    _timeout = new WeakMap();
    _url = new WeakMap();
    _body = new WeakMap();
    _bodyType = new WeakMap();
    _creds = new WeakMap();
    _preflight = new WeakMap();
    _process = new WeakMap();
    _retry = new WeakMap();
    _signal = new WeakMap();
    _throttle = new WeakMap();
    _getUrlFunc = new WeakMap();
    _FetchRequest_instances = new WeakSet();
    send_fn = async function(attempt, expires, delay2, _request2, _response) {
      var _a2, _b, _c2;
      if (attempt >= __privateGet(this, _throttle).maxAttempts) {
        return _response.makeServerError("exceeded maximum retry limit");
      }
      (0, errors_js_1.assert)(getTime() <= expires, "timeout", "TIMEOUT", {
        operation: "request.send",
        reason: "timeout",
        request: _request2
      });
      if (delay2 > 0) {
        await wait(delay2);
      }
      let req = this.clone();
      const scheme = (req.url.split(":")[0] || "").toLowerCase();
      if (scheme in Gateways) {
        const result = await Gateways[scheme](req.url, checkSignal(__privateGet(_request2, _signal)));
        if (result instanceof FetchResponse) {
          let response2 = result;
          if (this.processFunc) {
            checkSignal(__privateGet(_request2, _signal));
            try {
              response2 = await this.processFunc(req, response2);
            } catch (error) {
              if (error.throttle == null || typeof error.stall !== "number") {
                response2.makeServerError("error in post-processing function", error).assertOk();
              }
            }
          }
          return response2;
        }
        req = result;
      }
      if (this.preflightFunc) {
        req = await this.preflightFunc(req);
      }
      const resp = await this.getUrlFunc(req, checkSignal(__privateGet(_request2, _signal)));
      let response = new FetchResponse(resp.statusCode, resp.statusMessage, resp.headers, resp.body, _request2);
      if (response.statusCode === 301 || response.statusCode === 302) {
        try {
          const location = response.headers.location || "";
          return __privateMethod(_a2 = req.redirect(location), _FetchRequest_instances, send_fn).call(_a2, attempt + 1, expires, 0, _request2, response);
        } catch (error) {
        }
        return response;
      } else if (response.statusCode === 429) {
        if (this.retryFunc == null || await this.retryFunc(req, response, attempt)) {
          const retryAfter = response.headers["retry-after"];
          let delay3 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          if (typeof retryAfter === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
            delay3 = parseInt(retryAfter);
          }
          return __privateMethod(_b = req.clone(), _FetchRequest_instances, send_fn).call(_b, attempt + 1, expires, delay3, _request2, response);
        }
      }
      if (this.processFunc) {
        checkSignal(__privateGet(_request2, _signal));
        try {
          response = await this.processFunc(req, response);
        } catch (error) {
          if (error.throttle == null || typeof error.stall !== "number") {
            response.makeServerError("error in post-processing function", error).assertOk();
          }
          let delay3 = __privateGet(this, _throttle).slotInterval * Math.trunc(Math.random() * Math.pow(2, attempt));
          ;
          if (error.stall >= 0) {
            delay3 = error.stall;
          }
          return __privateMethod(_c2 = req.clone(), _FetchRequest_instances, send_fn).call(_c2, attempt + 1, expires, delay3, _request2, response);
        }
      }
      return response;
    };
    var FetchRequest = _FetchRequest;
    exports.FetchRequest = FetchRequest;
    var _statusCode, _statusMessage, _headers2, _body2, _request, _error;
    var _FetchResponse = class _FetchResponse {
      constructor(statusCode, statusMessage, headers, body, request) {
        __privateAdd(this, _statusCode);
        __privateAdd(this, _statusMessage);
        __privateAdd(this, _headers2);
        __privateAdd(this, _body2);
        __privateAdd(this, _request);
        __privateAdd(this, _error);
        __privateSet(this, _statusCode, statusCode);
        __privateSet(this, _statusMessage, statusMessage);
        __privateSet(this, _headers2, Object.keys(headers).reduce((accum, k4) => {
          accum[k4.toLowerCase()] = String(headers[k4]);
          return accum;
        }, {}));
        __privateSet(this, _body2, body == null ? null : new Uint8Array(body));
        __privateSet(this, _request, request || null);
        __privateSet(this, _error, { message: "" });
      }
      toString() {
        return `<FetchResponse status=${this.statusCode} body=${__privateGet(this, _body2) ? (0, data_js_1.hexlify)(__privateGet(this, _body2)) : "null"}>`;
      }
      /**
       *  The response status code.
       */
      get statusCode() {
        return __privateGet(this, _statusCode);
      }
      /**
       *  The response status message.
       */
      get statusMessage() {
        return __privateGet(this, _statusMessage);
      }
      /**
       *  The response headers. All keys are lower-case.
       */
      get headers() {
        return Object.assign({}, __privateGet(this, _headers2));
      }
      /**
       *  The response body, or ``null`` if there was no body.
       */
      get body() {
        return __privateGet(this, _body2) == null ? null : new Uint8Array(__privateGet(this, _body2));
      }
      /**
       *  The response body as a UTF-8 encoded string, or the empty
       *  string (i.e. ``""``) if there was no body.
       *
       *  An error is thrown if the body is invalid UTF-8 data.
       */
      get bodyText() {
        try {
          return __privateGet(this, _body2) == null ? "" : (0, utf8_js_1.toUtf8String)(__privateGet(this, _body2));
        } catch (error) {
          (0, errors_js_1.assert)(false, "response body is not valid UTF-8 data", "UNSUPPORTED_OPERATION", {
            operation: "bodyText",
            info: { response: this }
          });
        }
      }
      /**
       *  The response body, decoded as JSON.
       *
       *  An error is thrown if the body is invalid JSON-encoded data
       *  or if there was no body.
       */
      get bodyJson() {
        try {
          return JSON.parse(this.bodyText);
        } catch (error) {
          (0, errors_js_1.assert)(false, "response body is not valid JSON", "UNSUPPORTED_OPERATION", {
            operation: "bodyJson",
            info: { response: this }
          });
        }
      }
      [Symbol.iterator]() {
        const headers = this.headers;
        const keys = Object.keys(headers);
        let index5 = 0;
        return {
          next: () => {
            if (index5 < keys.length) {
              const key = keys[index5++];
              return {
                value: [key, headers[key]],
                done: false
              };
            }
            return { value: void 0, done: true };
          }
        };
      }
      /**
       *  Return a Response with matching headers and body, but with
       *  an error status code (i.e. 599) and %%message%% with an
       *  optional %%error%%.
       */
      makeServerError(message, error) {
        let statusMessage;
        if (!message) {
          message = `${this.statusCode} ${this.statusMessage}`;
          statusMessage = `CLIENT ESCALATED SERVER ERROR (${message})`;
        } else {
          statusMessage = `CLIENT ESCALATED SERVER ERROR (${this.statusCode} ${this.statusMessage}; ${message})`;
        }
        const response = new _FetchResponse(599, statusMessage, this.headers, this.body, __privateGet(this, _request) || void 0);
        __privateSet(response, _error, { message, error });
        return response;
      }
      /**
       *  If called within a [request.processFunc](FetchRequest-processFunc)
       *  call, causes the request to retry as if throttled for %%stall%%
       *  milliseconds.
       */
      throwThrottleError(message, stall) {
        if (stall == null) {
          stall = -1;
        } else {
          (0, errors_js_1.assertArgument)(Number.isInteger(stall) && stall >= 0, "invalid stall timeout", "stall", stall);
        }
        const error = new Error(message || "throttling requests");
        (0, properties_js_1.defineProperties)(error, { stall, throttle: true });
        throw error;
      }
      /**
       *  Get the header value for %%key%%, ignoring case.
       */
      getHeader(key) {
        return this.headers[key.toLowerCase()];
      }
      /**
       *  Returns true if the response has a body.
       */
      hasBody() {
        return __privateGet(this, _body2) != null;
      }
      /**
       *  The request made for this response.
       */
      get request() {
        return __privateGet(this, _request);
      }
      /**
       *  Returns true if this response was a success statusCode.
       */
      ok() {
        return __privateGet(this, _error).message === "" && this.statusCode >= 200 && this.statusCode < 300;
      }
      /**
       *  Throws a ``SERVER_ERROR`` if this response is not ok.
       */
      assertOk() {
        if (this.ok()) {
          return;
        }
        let { message, error } = __privateGet(this, _error);
        if (message === "") {
          message = `server response ${this.statusCode} ${this.statusMessage}`;
        }
        let requestUrl = null;
        if (this.request) {
          requestUrl = this.request.url;
        }
        let responseBody = null;
        try {
          if (__privateGet(this, _body2)) {
            responseBody = (0, utf8_js_1.toUtf8String)(__privateGet(this, _body2));
          }
        } catch (e2) {
        }
        (0, errors_js_1.assert)(false, message, "SERVER_ERROR", {
          request: this.request || "unknown request",
          response: this,
          error,
          info: {
            requestUrl,
            responseBody,
            responseStatus: `${this.statusCode} ${this.statusMessage}`
          }
        });
      }
    };
    _statusCode = new WeakMap();
    _statusMessage = new WeakMap();
    _headers2 = new WeakMap();
    _body2 = new WeakMap();
    _request = new WeakMap();
    _error = new WeakMap();
    var FetchResponse = _FetchResponse;
    exports.FetchResponse = FetchResponse;
    function getTime() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
    function unpercent(value) {
      return (0, utf8_js_1.toUtf8Bytes)(value.replace(/%([0-9a-f][0-9a-f])/gi, (all3, code) => {
        return String.fromCharCode(parseInt(code, 16));
      }));
    }
    function wait(delay2) {
      return new Promise((resolve) => setTimeout(resolve, delay2));
    }
  }
});

// node_modules/ethers/lib.commonjs/utils/fixednumber.js
var require_fixednumber = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/fixednumber.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FixedNumber = void 0;
    var data_js_1 = require_data();
    var errors_js_1 = require_errors();
    var maths_js_1 = require_maths();
    var properties_js_1 = require_properties();
    var BN_N1 = BigInt(-1);
    var BN_0 = BigInt(0);
    var BN_1 = BigInt(1);
    var BN_5 = BigInt(5);
    var _guard = {};
    var Zeros = "0000";
    while (Zeros.length < 80) {
      Zeros += Zeros;
    }
    function getTens(decimals) {
      let result = Zeros;
      while (result.length < decimals) {
        result += result;
      }
      return BigInt("1" + result.substring(0, decimals));
    }
    function checkValue(val, format6, safeOp) {
      const width = BigInt(format6.width);
      if (format6.signed) {
        const limit = BN_1 << width - BN_1;
        (0, errors_js_1.assert)(safeOp == null || val >= -limit && val < limit, "overflow", "NUMERIC_FAULT", {
          operation: safeOp,
          fault: "overflow",
          value: val
        });
        if (val > BN_0) {
          val = (0, maths_js_1.fromTwos)((0, maths_js_1.mask)(val, width), width);
        } else {
          val = -(0, maths_js_1.fromTwos)((0, maths_js_1.mask)(-val, width), width);
        }
      } else {
        const limit = BN_1 << width;
        (0, errors_js_1.assert)(safeOp == null || val >= 0 && val < limit, "overflow", "NUMERIC_FAULT", {
          operation: safeOp,
          fault: "overflow",
          value: val
        });
        val = (val % limit + limit) % limit & limit - BN_1;
      }
      return val;
    }
    function getFormat(value) {
      if (typeof value === "number") {
        value = `fixed128x${value}`;
      }
      let signed2 = true;
      let width = 128;
      let decimals = 18;
      if (typeof value === "string") {
        if (value === "fixed") {
        } else if (value === "ufixed") {
          signed2 = false;
        } else {
          const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
          (0, errors_js_1.assertArgument)(match, "invalid fixed format", "format", value);
          signed2 = match[1] !== "u";
          width = parseInt(match[2]);
          decimals = parseInt(match[3]);
        }
      } else if (value) {
        const v2 = value;
        const check = (key, type6, defaultValue) => {
          if (v2[key] == null) {
            return defaultValue;
          }
          (0, errors_js_1.assertArgument)(typeof v2[key] === type6, "invalid fixed format (" + key + " not " + type6 + ")", "format." + key, v2[key]);
          return v2[key];
        };
        signed2 = check("signed", "boolean", signed2);
        width = check("width", "number", width);
        decimals = check("decimals", "number", decimals);
      }
      (0, errors_js_1.assertArgument)(width % 8 === 0, "invalid FixedNumber width (not byte aligned)", "format.width", width);
      (0, errors_js_1.assertArgument)(decimals <= 80, "invalid FixedNumber decimals (too large)", "format.decimals", decimals);
      const name = (signed2 ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
      return { signed: signed2, width, decimals, name };
    }
    function toString7(val, decimals) {
      let negative = "";
      if (val < BN_0) {
        negative = "-";
        val *= BN_N1;
      }
      let str = val.toString();
      if (decimals === 0) {
        return negative + str;
      }
      while (str.length <= decimals) {
        str = Zeros + str;
      }
      const index5 = str.length - decimals;
      str = str.substring(0, index5) + "." + str.substring(index5);
      while (str[0] === "0" && str[1] !== ".") {
        str = str.substring(1);
      }
      while (str[str.length - 1] === "0" && str[str.length - 2] !== ".") {
        str = str.substring(0, str.length - 1);
      }
      return negative + str;
    }
    var _format, _val, _tens, _FixedNumber_instances, checkFormat_fn, checkValue_fn, add_fn, sub_fn, mul_fn, div_fn;
    var _FixedNumber = class _FixedNumber {
      // Use this when changing this file to get some typing info,
      // but then switch to any to mask the internal type
      //constructor(guard: any, value: bigint, format: _FixedFormat) {
      /**
       *  @private
       */
      constructor(guard, value, format6) {
        __privateAdd(this, _FixedNumber_instances);
        /**
         *  The specific fixed-point arithmetic field for this value.
         */
        __publicField(this, "format");
        __privateAdd(this, _format);
        // The actual value (accounting for decimals)
        __privateAdd(this, _val);
        // A base-10 value to multiple values by to maintain the magnitude
        __privateAdd(this, _tens);
        /**
         *  This is a property so console.log shows a human-meaningful value.
         *
         *  @private
         */
        __publicField(this, "_value");
        (0, errors_js_1.assertPrivate)(guard, _guard, "FixedNumber");
        __privateSet(this, _val, value);
        __privateSet(this, _format, format6);
        const _value = toString7(value, format6.decimals);
        (0, properties_js_1.defineProperties)(this, { format: format6.name, _value });
        __privateSet(this, _tens, getTens(format6.decimals));
      }
      /**
       *  If true, negative values are permitted, otherwise only
       *  positive values and zero are allowed.
       */
      get signed() {
        return __privateGet(this, _format).signed;
      }
      /**
       *  The number of bits available to store the value.
       */
      get width() {
        return __privateGet(this, _format).width;
      }
      /**
       *  The number of decimal places in the fixed-point arithment field.
       */
      get decimals() {
        return __privateGet(this, _format).decimals;
      }
      /**
       *  The value as an integer, based on the smallest unit the
       *  [[decimals]] allow.
       */
      get value() {
        return __privateGet(this, _val);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% added
       *  to %%other%%, ignoring overflow.
       */
      addUnsafe(other) {
        return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% added
       *  to %%other%%. A [[NumericFaultError]] is thrown if overflow
       *  occurs.
       */
      add(other) {
        return __privateMethod(this, _FixedNumber_instances, add_fn).call(this, other, "add");
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
       *  from %%this%%, ignoring overflow.
       */
      subUnsafe(other) {
        return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%other%% subtracted
       *  from %%this%%. A [[NumericFaultError]] is thrown if overflow
       *  occurs.
       */
      sub(other) {
        return __privateMethod(this, _FixedNumber_instances, sub_fn).call(this, other, "sub");
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
       *  by %%other%%, ignoring overflow and underflow (precision loss).
       */
      mulUnsafe(other) {
        return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
       *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
       *  occurs.
       */
      mul(other) {
        return __privateMethod(this, _FixedNumber_instances, mul_fn).call(this, other, "mul");
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% multiplied
       *  by %%other%%. A [[NumericFaultError]] is thrown if overflow
       *  occurs or if underflow (precision loss) occurs.
       */
      mulSignal(other) {
        __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
        const value = __privateGet(this, _val) * __privateGet(other, _val);
        (0, errors_js_1.assert)(value % __privateGet(this, _tens) === BN_0, "precision lost during signalling mul", "NUMERIC_FAULT", {
          operation: "mulSignal",
          fault: "underflow",
          value: this
        });
        return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(this, _tens), "mulSignal");
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% divided
       *  by %%other%%, ignoring underflow (precision loss). A
       *  [[NumericFaultError]] is thrown if overflow occurs.
       */
      divUnsafe(other) {
        return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other);
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% divided
       *  by %%other%%, ignoring underflow (precision loss). A
       *  [[NumericFaultError]] is thrown if overflow occurs.
       */
      div(other) {
        return __privateMethod(this, _FixedNumber_instances, div_fn).call(this, other, "div");
      }
      /**
       *  Returns a new [[FixedNumber]] with the result of %%this%% divided
       *  by %%other%%. A [[NumericFaultError]] is thrown if underflow
       *  (precision loss) occurs.
       */
      divSignal(other) {
        (0, errors_js_1.assert)(__privateGet(other, _val) !== BN_0, "division by zero", "NUMERIC_FAULT", {
          operation: "div",
          fault: "divide-by-zero",
          value: this
        });
        __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, other);
        const value = __privateGet(this, _val) * __privateGet(this, _tens);
        (0, errors_js_1.assert)(value % __privateGet(other, _val) === BN_0, "precision lost during signalling div", "NUMERIC_FAULT", {
          operation: "divSignal",
          fault: "underflow",
          value: this
        });
        return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, value / __privateGet(other, _val), "divSignal");
      }
      /**
       *  Returns a comparison result between %%this%% and %%other%%.
       *
       *  This is suitable for use in sorting, where ``-1`` implies %%this%%
       *  is smaller, ``1`` implies %%this%% is larger and ``0`` implies
       *  both are equal.
       */
      cmp(other) {
        let a3 = this.value, b4 = other.value;
        const delta = this.decimals - other.decimals;
        if (delta > 0) {
          b4 *= getTens(delta);
        } else if (delta < 0) {
          a3 *= getTens(-delta);
        }
        if (a3 < b4) {
          return -1;
        }
        if (a3 > b4) {
          return 1;
        }
        return 0;
      }
      /**
       *  Returns true if %%other%% is equal to %%this%%.
       */
      eq(other) {
        return this.cmp(other) === 0;
      }
      /**
       *  Returns true if %%other%% is less than to %%this%%.
       */
      lt(other) {
        return this.cmp(other) < 0;
      }
      /**
       *  Returns true if %%other%% is less than or equal to %%this%%.
       */
      lte(other) {
        return this.cmp(other) <= 0;
      }
      /**
       *  Returns true if %%other%% is greater than to %%this%%.
       */
      gt(other) {
        return this.cmp(other) > 0;
      }
      /**
       *  Returns true if %%other%% is greater than or equal to %%this%%.
       */
      gte(other) {
        return this.cmp(other) >= 0;
      }
      /**
       *  Returns a new [[FixedNumber]] which is the largest **integer**
       *  that is less than or equal to %%this%%.
       *
       *  The decimal component of the result will always be ``0``.
       */
      floor() {
        let val = __privateGet(this, _val);
        if (__privateGet(this, _val) < BN_0) {
          val -= __privateGet(this, _tens) - BN_1;
        }
        val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
        return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "floor");
      }
      /**
       *  Returns a new [[FixedNumber]] which is the smallest **integer**
       *  that is greater than or equal to %%this%%.
       *
       *  The decimal component of the result will always be ``0``.
       */
      ceiling() {
        let val = __privateGet(this, _val);
        if (__privateGet(this, _val) > BN_0) {
          val += __privateGet(this, _tens) - BN_1;
        }
        val = __privateGet(this, _val) / __privateGet(this, _tens) * __privateGet(this, _tens);
        return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, val, "ceiling");
      }
      /**
       *  Returns a new [[FixedNumber]] with the decimal component
       *  rounded up on ties at %%decimals%% places.
       */
      round(decimals) {
        if (decimals == null) {
          decimals = 0;
        }
        if (decimals >= this.decimals) {
          return this;
        }
        const delta = this.decimals - decimals;
        const bump = BN_5 * getTens(delta - 1);
        let value = this.value + bump;
        const tens = getTens(delta);
        value = value / tens * tens;
        checkValue(value, __privateGet(this, _format), "round");
        return new _FixedNumber(_guard, value, __privateGet(this, _format));
      }
      /**
       *  Returns true if %%this%% is equal to ``0``.
       */
      isZero() {
        return __privateGet(this, _val) === BN_0;
      }
      /**
       *  Returns true if %%this%% is less than ``0``.
       */
      isNegative() {
        return __privateGet(this, _val) < BN_0;
      }
      /**
       *  Returns the string representation of %%this%%.
       */
      toString() {
        return this._value;
      }
      /**
       *  Returns a float approximation.
       *
       *  Due to IEEE 754 precission (or lack thereof), this function
       *  can only return an approximation and most values will contain
       *  rounding errors.
       */
      toUnsafeFloat() {
        return parseFloat(this.toString());
      }
      /**
       *  Return a new [[FixedNumber]] with the same value but has had
       *  its field set to %%format%%.
       *
       *  This will throw if the value cannot fit into %%format%%.
       */
      toFormat(format6) {
        return _FixedNumber.fromString(this.toString(), format6);
      }
      /**
       *  Creates a new [[FixedNumber]] for %%value%% divided by
       *  %%decimal%% places with %%format%%.
       *
       *  This will throw a [[NumericFaultError]] if %%value%% (once adjusted
       *  for %%decimals%%) cannot fit in %%format%%, either due to overflow
       *  or underflow (precision loss).
       */
      static fromValue(_value, _decimals, _format2) {
        const decimals = _decimals == null ? 0 : (0, maths_js_1.getNumber)(_decimals);
        const format6 = getFormat(_format2);
        let value = (0, maths_js_1.getBigInt)(_value, "value");
        const delta = decimals - format6.decimals;
        if (delta > 0) {
          const tens = getTens(delta);
          (0, errors_js_1.assert)(value % tens === BN_0, "value loses precision for format", "NUMERIC_FAULT", {
            operation: "fromValue",
            fault: "underflow",
            value: _value
          });
          value /= tens;
        } else if (delta < 0) {
          value *= getTens(-delta);
        }
        checkValue(value, format6, "fromValue");
        return new _FixedNumber(_guard, value, format6);
      }
      /**
       *  Creates a new [[FixedNumber]] for %%value%% with %%format%%.
       *
       *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
       *  in %%format%%, either due to overflow or underflow (precision loss).
       */
      static fromString(_value, _format2) {
        const match = _value.match(/^(-?)([0-9]*)\.?([0-9]*)$/);
        (0, errors_js_1.assertArgument)(match && match[2].length + match[3].length > 0, "invalid FixedNumber string value", "value", _value);
        const format6 = getFormat(_format2);
        let whole = match[2] || "0", decimal = match[3] || "";
        while (decimal.length < format6.decimals) {
          decimal += Zeros;
        }
        (0, errors_js_1.assert)(decimal.substring(format6.decimals).match(/^0*$/), "too many decimals for format", "NUMERIC_FAULT", {
          operation: "fromString",
          fault: "underflow",
          value: _value
        });
        decimal = decimal.substring(0, format6.decimals);
        const value = BigInt(match[1] + whole + decimal);
        checkValue(value, format6, "fromString");
        return new _FixedNumber(_guard, value, format6);
      }
      /**
       *  Creates a new [[FixedNumber]] with the big-endian representation
       *  %%value%% with %%format%%.
       *
       *  This will throw a [[NumericFaultError]] if %%value%% cannot fit
       *  in %%format%% due to overflow.
       */
      static fromBytes(_value, _format2) {
        let value = (0, maths_js_1.toBigInt)((0, data_js_1.getBytes)(_value, "value"));
        const format6 = getFormat(_format2);
        if (format6.signed) {
          value = (0, maths_js_1.fromTwos)(value, format6.width);
        }
        checkValue(value, format6, "fromBytes");
        return new _FixedNumber(_guard, value, format6);
      }
    };
    _format = new WeakMap();
    _val = new WeakMap();
    _tens = new WeakMap();
    _FixedNumber_instances = new WeakSet();
    checkFormat_fn = function(other) {
      (0, errors_js_1.assertArgument)(this.format === other.format, "incompatible format; use fixedNumber.toFormat", "other", other);
    };
    checkValue_fn = function(val, safeOp) {
      val = checkValue(val, __privateGet(this, _format), safeOp);
      return new _FixedNumber(_guard, val, __privateGet(this, _format));
    };
    add_fn = function(o2, safeOp) {
      __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
      return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) + __privateGet(o2, _val), safeOp);
    };
    sub_fn = function(o2, safeOp) {
      __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
      return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) - __privateGet(o2, _val), safeOp);
    };
    mul_fn = function(o2, safeOp) {
      __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
      return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(o2, _val) / __privateGet(this, _tens), safeOp);
    };
    div_fn = function(o2, safeOp) {
      (0, errors_js_1.assert)(__privateGet(o2, _val) !== BN_0, "division by zero", "NUMERIC_FAULT", {
        operation: "div",
        fault: "divide-by-zero",
        value: this
      });
      __privateMethod(this, _FixedNumber_instances, checkFormat_fn).call(this, o2);
      return __privateMethod(this, _FixedNumber_instances, checkValue_fn).call(this, __privateGet(this, _val) * __privateGet(this, _tens) / __privateGet(o2, _val), safeOp);
    };
    var FixedNumber = _FixedNumber;
    exports.FixedNumber = FixedNumber;
  }
});

// node_modules/ethers/lib.commonjs/utils/rlp-decode.js
var require_rlp_decode = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/rlp-decode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeRlp = void 0;
    var data_js_1 = require_data();
    var errors_js_1 = require_errors();
    var data_js_2 = require_data();
    function hexlifyByte(value) {
      let result = value.toString(16);
      while (result.length < 2) {
        result = "0" + result;
      }
      return "0x" + result;
    }
    function unarrayifyInteger(data, offset, length2) {
      let result = 0;
      for (let i2 = 0; i2 < length2; i2++) {
        result = result * 256 + data[offset + i2];
      }
      return result;
    }
    function _decodeChildren(data, offset, childOffset, length2) {
      const result = [];
      while (childOffset < offset + 1 + length2) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        (0, errors_js_1.assert)(childOffset <= offset + 1 + length2, "child data too short", "BUFFER_OVERRUN", {
          buffer: data,
          length: length2,
          offset
        });
      }
      return { consumed: 1 + length2, result };
    }
    function _decode(data, offset) {
      (0, errors_js_1.assert)(data.length !== 0, "data too short", "BUFFER_OVERRUN", {
        buffer: data,
        length: 0,
        offset: 1
      });
      const checkOffset = (offset2) => {
        (0, errors_js_1.assert)(offset2 <= data.length, "data short segment too short", "BUFFER_OVERRUN", {
          buffer: data,
          length: data.length,
          offset: offset2
        });
      };
      if (data[offset] >= 248) {
        const lengthLength = data[offset] - 247;
        checkOffset(offset + 1 + lengthLength);
        const length2 = unarrayifyInteger(data, offset + 1, lengthLength);
        checkOffset(offset + 1 + lengthLength + length2);
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length2);
      } else if (data[offset] >= 192) {
        const length2 = data[offset] - 192;
        checkOffset(offset + 1 + length2);
        return _decodeChildren(data, offset, offset + 1, length2);
      } else if (data[offset] >= 184) {
        const lengthLength = data[offset] - 183;
        checkOffset(offset + 1 + lengthLength);
        const length2 = unarrayifyInteger(data, offset + 1, lengthLength);
        checkOffset(offset + 1 + lengthLength + length2);
        const result = (0, data_js_1.hexlify)(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length2));
        return { consumed: 1 + lengthLength + length2, result };
      } else if (data[offset] >= 128) {
        const length2 = data[offset] - 128;
        checkOffset(offset + 1 + length2);
        const result = (0, data_js_1.hexlify)(data.slice(offset + 1, offset + 1 + length2));
        return { consumed: 1 + length2, result };
      }
      return { consumed: 1, result: hexlifyByte(data[offset]) };
    }
    function decodeRlp(_data) {
      const data = (0, data_js_2.getBytes)(_data, "data");
      const decoded = _decode(data, 0);
      (0, errors_js_1.assertArgument)(decoded.consumed === data.length, "unexpected junk after rlp payload", "data", _data);
      return decoded.result;
    }
    exports.decodeRlp = decodeRlp;
  }
});

// node_modules/ethers/lib.commonjs/utils/rlp-encode.js
var require_rlp_encode = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/rlp-encode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeRlp = void 0;
    var data_js_1 = require_data();
    function arrayifyInteger(value) {
      const result = [];
      while (value) {
        result.unshift(value & 255);
        value >>= 8;
      }
      return result;
    }
    function _encode(object) {
      if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function(child) {
          payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
          payload.unshift(192 + payload.length);
          return payload;
        }
        const length3 = arrayifyInteger(payload.length);
        length3.unshift(247 + length3.length);
        return length3.concat(payload);
      }
      const data = Array.prototype.slice.call((0, data_js_1.getBytes)(object, "object"));
      if (data.length === 1 && data[0] <= 127) {
        return data;
      } else if (data.length <= 55) {
        data.unshift(128 + data.length);
        return data;
      }
      const length2 = arrayifyInteger(data.length);
      length2.unshift(183 + length2.length);
      return length2.concat(data);
    }
    var nibbles = "0123456789abcdef";
    function encodeRlp(object) {
      let result = "0x";
      for (const v2 of _encode(object)) {
        result += nibbles[v2 >> 4];
        result += nibbles[v2 & 15];
      }
      return result;
    }
    exports.encodeRlp = encodeRlp;
  }
});

// node_modules/ethers/lib.commonjs/utils/units.js
var require_units = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/units.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.parseEther = exports.formatEther = exports.parseUnits = exports.formatUnits = void 0;
    var errors_js_1 = require_errors();
    var fixednumber_js_1 = require_fixednumber();
    var maths_js_1 = require_maths();
    var names2 = [
      "wei",
      "kwei",
      "mwei",
      "gwei",
      "szabo",
      "finney",
      "ether"
    ];
    function formatUnits2(value, unit) {
      let decimals = 18;
      if (typeof unit === "string") {
        const index5 = names2.indexOf(unit);
        (0, errors_js_1.assertArgument)(index5 >= 0, "invalid unit", "unit", unit);
        decimals = 3 * index5;
      } else if (unit != null) {
        decimals = (0, maths_js_1.getNumber)(unit, "unit");
      }
      return fixednumber_js_1.FixedNumber.fromValue(value, decimals, { decimals, width: 512 }).toString();
    }
    exports.formatUnits = formatUnits2;
    function parseUnits(value, unit) {
      (0, errors_js_1.assertArgument)(typeof value === "string", "value must be a string", "value", value);
      let decimals = 18;
      if (typeof unit === "string") {
        const index5 = names2.indexOf(unit);
        (0, errors_js_1.assertArgument)(index5 >= 0, "invalid unit", "unit", unit);
        decimals = 3 * index5;
      } else if (unit != null) {
        decimals = (0, maths_js_1.getNumber)(unit, "unit");
      }
      return fixednumber_js_1.FixedNumber.fromString(value, { decimals, width: 512 }).value;
    }
    exports.parseUnits = parseUnits;
    function formatEther2(wei) {
      return formatUnits2(wei, 18);
    }
    exports.formatEther = formatEther2;
    function parseEther(ether) {
      return parseUnits(ether, 18);
    }
    exports.parseEther = parseEther;
  }
});

// node_modules/ethers/lib.commonjs/utils/uuid.js
var require_uuid = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/uuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.uuidV4 = void 0;
    var data_js_1 = require_data();
    function uuidV4(randomBytes3) {
      const bytes = (0, data_js_1.getBytes)(randomBytes3, "randomBytes");
      bytes[6] = bytes[6] & 15 | 64;
      bytes[8] = bytes[8] & 63 | 128;
      const value = (0, data_js_1.hexlify)(bytes);
      return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34)
      ].join("-");
    }
    exports.uuidV4 = uuidV4;
  }
});

// node_modules/ethers/lib.commonjs/utils/index.js
var require_utils5 = __commonJS({
  "node_modules/ethers/lib.commonjs/utils/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.encodeRlp = exports.decodeRlp = exports.defineProperties = exports.resolveProperties = exports.toQuantity = exports.toBeArray = exports.toBeHex = exports.toNumber = exports.toBigInt = exports.getUint = exports.getNumber = exports.getBigInt = exports.mask = exports.toTwos = exports.fromTwos = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.makeError = exports.assertNormalize = exports.assertPrivate = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.isError = exports.isCallException = exports.zeroPadBytes = exports.zeroPadValue = exports.stripZerosLeft = exports.dataSlice = exports.dataLength = exports.concat = exports.hexlify = exports.isBytesLike = exports.isHexString = exports.getBytesCopy = exports.getBytes = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = void 0;
    exports.uuidV4 = exports.Utf8ErrorFuncs = void 0;
    var base58_js_1 = require_base58();
    Object.defineProperty(exports, "decodeBase58", { enumerable: true, get: function() {
      return base58_js_1.decodeBase58;
    } });
    Object.defineProperty(exports, "encodeBase58", { enumerable: true, get: function() {
      return base58_js_1.encodeBase58;
    } });
    var base64_js_1 = require_base64_browser();
    Object.defineProperty(exports, "decodeBase64", { enumerable: true, get: function() {
      return base64_js_1.decodeBase64;
    } });
    Object.defineProperty(exports, "encodeBase64", { enumerable: true, get: function() {
      return base64_js_1.encodeBase64;
    } });
    var data_js_1 = require_data();
    Object.defineProperty(exports, "getBytes", { enumerable: true, get: function() {
      return data_js_1.getBytes;
    } });
    Object.defineProperty(exports, "getBytesCopy", { enumerable: true, get: function() {
      return data_js_1.getBytesCopy;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return data_js_1.isHexString;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return data_js_1.isBytesLike;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return data_js_1.hexlify;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return data_js_1.concat;
    } });
    Object.defineProperty(exports, "dataLength", { enumerable: true, get: function() {
      return data_js_1.dataLength;
    } });
    Object.defineProperty(exports, "dataSlice", { enumerable: true, get: function() {
      return data_js_1.dataSlice;
    } });
    Object.defineProperty(exports, "stripZerosLeft", { enumerable: true, get: function() {
      return data_js_1.stripZerosLeft;
    } });
    Object.defineProperty(exports, "zeroPadValue", { enumerable: true, get: function() {
      return data_js_1.zeroPadValue;
    } });
    Object.defineProperty(exports, "zeroPadBytes", { enumerable: true, get: function() {
      return data_js_1.zeroPadBytes;
    } });
    var errors_js_1 = require_errors();
    Object.defineProperty(exports, "isCallException", { enumerable: true, get: function() {
      return errors_js_1.isCallException;
    } });
    Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
      return errors_js_1.isError;
    } });
    Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
      return errors_js_1.assert;
    } });
    Object.defineProperty(exports, "assertArgument", { enumerable: true, get: function() {
      return errors_js_1.assertArgument;
    } });
    Object.defineProperty(exports, "assertArgumentCount", { enumerable: true, get: function() {
      return errors_js_1.assertArgumentCount;
    } });
    Object.defineProperty(exports, "assertPrivate", { enumerable: true, get: function() {
      return errors_js_1.assertPrivate;
    } });
    Object.defineProperty(exports, "assertNormalize", { enumerable: true, get: function() {
      return errors_js_1.assertNormalize;
    } });
    Object.defineProperty(exports, "makeError", { enumerable: true, get: function() {
      return errors_js_1.makeError;
    } });
    var events_js_1 = require_events2();
    Object.defineProperty(exports, "EventPayload", { enumerable: true, get: function() {
      return events_js_1.EventPayload;
    } });
    var fetch_js_1 = require_fetch();
    Object.defineProperty(exports, "FetchRequest", { enumerable: true, get: function() {
      return fetch_js_1.FetchRequest;
    } });
    Object.defineProperty(exports, "FetchResponse", { enumerable: true, get: function() {
      return fetch_js_1.FetchResponse;
    } });
    Object.defineProperty(exports, "FetchCancelSignal", { enumerable: true, get: function() {
      return fetch_js_1.FetchCancelSignal;
    } });
    var fixednumber_js_1 = require_fixednumber();
    Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
      return fixednumber_js_1.FixedNumber;
    } });
    var maths_js_1 = require_maths();
    Object.defineProperty(exports, "fromTwos", { enumerable: true, get: function() {
      return maths_js_1.fromTwos;
    } });
    Object.defineProperty(exports, "toTwos", { enumerable: true, get: function() {
      return maths_js_1.toTwos;
    } });
    Object.defineProperty(exports, "mask", { enumerable: true, get: function() {
      return maths_js_1.mask;
    } });
    Object.defineProperty(exports, "getBigInt", { enumerable: true, get: function() {
      return maths_js_1.getBigInt;
    } });
    Object.defineProperty(exports, "getNumber", { enumerable: true, get: function() {
      return maths_js_1.getNumber;
    } });
    Object.defineProperty(exports, "getUint", { enumerable: true, get: function() {
      return maths_js_1.getUint;
    } });
    Object.defineProperty(exports, "toBigInt", { enumerable: true, get: function() {
      return maths_js_1.toBigInt;
    } });
    Object.defineProperty(exports, "toNumber", { enumerable: true, get: function() {
      return maths_js_1.toNumber;
    } });
    Object.defineProperty(exports, "toBeHex", { enumerable: true, get: function() {
      return maths_js_1.toBeHex;
    } });
    Object.defineProperty(exports, "toBeArray", { enumerable: true, get: function() {
      return maths_js_1.toBeArray;
    } });
    Object.defineProperty(exports, "toQuantity", { enumerable: true, get: function() {
      return maths_js_1.toQuantity;
    } });
    var properties_js_1 = require_properties();
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return properties_js_1.resolveProperties;
    } });
    Object.defineProperty(exports, "defineProperties", { enumerable: true, get: function() {
      return properties_js_1.defineProperties;
    } });
    var rlp_decode_js_1 = require_rlp_decode();
    Object.defineProperty(exports, "decodeRlp", { enumerable: true, get: function() {
      return rlp_decode_js_1.decodeRlp;
    } });
    var rlp_encode_js_1 = require_rlp_encode();
    Object.defineProperty(exports, "encodeRlp", { enumerable: true, get: function() {
      return rlp_encode_js_1.encodeRlp;
    } });
    var units_js_1 = require_units();
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return units_js_1.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return units_js_1.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return units_js_1.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return units_js_1.parseUnits;
    } });
    var utf8_js_1 = require_utf8();
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return utf8_js_1.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return utf8_js_1.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return utf8_js_1.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return utf8_js_1.Utf8ErrorFuncs;
    } });
    var uuid_js_1 = require_uuid();
    Object.defineProperty(exports, "uuidV4", { enumerable: true, get: function() {
      return uuid_js_1.uuidV4;
    } });
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js
var require_abstract_coder = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/abstract-coder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Reader = exports.Writer = exports.Coder = exports.checkResultErrors = exports.Result = exports.WordSize = void 0;
    var index_js_1 = require_utils5();
    exports.WordSize = 32;
    var Padding = new Uint8Array(exports.WordSize);
    var passProperties = ["then"];
    var _guard = {};
    var resultNames = /* @__PURE__ */ new WeakMap();
    function getNames(result) {
      return resultNames.get(result);
    }
    function setNames(result, names2) {
      resultNames.set(result, names2);
    }
    function throwError(name, error) {
      const wrapped = new Error(`deferred error during ABI decoding triggered accessing ${name}`);
      wrapped.error = error;
      throw wrapped;
    }
    function toObject(names2, items, deep) {
      if (names2.indexOf(null) >= 0) {
        return items.map((item, index5) => {
          if (item instanceof Result) {
            return toObject(getNames(item), item, deep);
          }
          return item;
        });
      }
      return names2.reduce((accum, name, index5) => {
        let item = items.getValue(name);
        if (!(name in accum)) {
          if (deep && item instanceof Result) {
            item = toObject(getNames(item), item, deep);
          }
          accum[name] = item;
        }
        return accum;
      }, {});
    }
    var _names;
    var _Result = class _Result extends Array {
      /**
       *  @private
       */
      constructor(...args) {
        const guard = args[0];
        let items = args[1];
        let names2 = (args[2] || []).slice();
        let wrap2 = true;
        if (guard !== _guard) {
          items = args;
          names2 = [];
          wrap2 = false;
        }
        super(items.length);
        // No longer used; but cannot be removed as it will remove the
        // #private field from the .d.ts which may break backwards
        // compatibility
        __privateAdd(this, _names);
        items.forEach((item, index5) => {
          this[index5] = item;
        });
        const nameCounts = names2.reduce((accum, name) => {
          if (typeof name === "string") {
            accum.set(name, (accum.get(name) || 0) + 1);
          }
          return accum;
        }, /* @__PURE__ */ new Map());
        setNames(this, Object.freeze(items.map((item, index5) => {
          const name = names2[index5];
          if (name != null && nameCounts.get(name) === 1) {
            return name;
          }
          return null;
        })));
        __privateSet(this, _names, []);
        if (__privateGet(this, _names) == null) {
          void __privateGet(this, _names);
        }
        if (!wrap2) {
          return;
        }
        Object.freeze(this);
        const proxy2 = new Proxy(this, {
          get: (target, prop, receiver) => {
            if (typeof prop === "string") {
              if (prop.match(/^[0-9]+$/)) {
                const index5 = (0, index_js_1.getNumber)(prop, "%index");
                if (index5 < 0 || index5 >= this.length) {
                  throw new RangeError("out of result range");
                }
                const item = target[index5];
                if (item instanceof Error) {
                  throwError(`index ${index5}`, item);
                }
                return item;
              }
              if (passProperties.indexOf(prop) >= 0) {
                return Reflect.get(target, prop, receiver);
              }
              const value = target[prop];
              if (value instanceof Function) {
                return function(...args2) {
                  return value.apply(this === receiver ? target : this, args2);
                };
              } else if (!(prop in target)) {
                return target.getValue.apply(this === receiver ? target : this, [prop]);
              }
            }
            return Reflect.get(target, prop, receiver);
          }
        });
        setNames(proxy2, getNames(this));
        return proxy2;
      }
      /**
       *  Returns the Result as a normal Array. If %%deep%%, any children
       *  which are Result objects are also converted to a normal Array.
       *
       *  This will throw if there are any outstanding deferred
       *  errors.
       */
      toArray(deep) {
        const result = [];
        this.forEach((item, index5) => {
          if (item instanceof Error) {
            throwError(`index ${index5}`, item);
          }
          if (deep && item instanceof _Result) {
            item = item.toArray(deep);
          }
          result.push(item);
        });
        return result;
      }
      /**
       *  Returns the Result as an Object with each name-value pair. If
       *  %%deep%%, any children which are Result objects are also
       *  converted to an Object.
       *
       *  This will throw if any value is unnamed, or if there are
       *  any outstanding deferred errors.
       */
      toObject(deep) {
        const names2 = getNames(this);
        return names2.reduce((accum, name, index5) => {
          (0, index_js_1.assert)(name != null, `value at index ${index5} unnamed`, "UNSUPPORTED_OPERATION", {
            operation: "toObject()"
          });
          return toObject(names2, this, deep);
        }, {});
      }
      /**
       *  @_ignore
       */
      slice(start, end) {
        if (start == null) {
          start = 0;
        }
        if (start < 0) {
          start += this.length;
          if (start < 0) {
            start = 0;
          }
        }
        if (end == null) {
          end = this.length;
        }
        if (end < 0) {
          end += this.length;
          if (end < 0) {
            end = 0;
          }
        }
        if (end > this.length) {
          end = this.length;
        }
        const _names2 = getNames(this);
        const result = [], names2 = [];
        for (let i2 = start; i2 < end; i2++) {
          result.push(this[i2]);
          names2.push(_names2[i2]);
        }
        return new _Result(_guard, result, names2);
      }
      /**
       *  @_ignore
       */
      filter(callback, thisArg) {
        const _names2 = getNames(this);
        const result = [], names2 = [];
        for (let i2 = 0; i2 < this.length; i2++) {
          const item = this[i2];
          if (item instanceof Error) {
            throwError(`index ${i2}`, item);
          }
          if (callback.call(thisArg, item, i2, this)) {
            result.push(item);
            names2.push(_names2[i2]);
          }
        }
        return new _Result(_guard, result, names2);
      }
      /**
       *  @_ignore
       */
      map(callback, thisArg) {
        const result = [];
        for (let i2 = 0; i2 < this.length; i2++) {
          const item = this[i2];
          if (item instanceof Error) {
            throwError(`index ${i2}`, item);
          }
          result.push(callback.call(thisArg, item, i2, this));
        }
        return result;
      }
      /**
       *  Returns the value for %%name%%.
       *
       *  Since it is possible to have a key whose name conflicts with
       *  a method on a [[Result]] or its superclass Array, or any
       *  JavaScript keyword, this ensures all named values are still
       *  accessible by name.
       */
      getValue(name) {
        const index5 = getNames(this).indexOf(name);
        if (index5 === -1) {
          return void 0;
        }
        const value = this[index5];
        if (value instanceof Error) {
          throwError(`property ${JSON.stringify(name)}`, value.error);
        }
        return value;
      }
      /**
       *  Creates a new [[Result]] for %%items%% with each entry
       *  also accessible by its corresponding name in %%keys%%.
       */
      static fromItems(items, keys) {
        return new _Result(_guard, items, keys);
      }
    };
    _names = new WeakMap();
    var Result = _Result;
    exports.Result = Result;
    function checkResultErrors(result) {
      const errors = [];
      const checkErrors = function(path2, object) {
        if (!Array.isArray(object)) {
          return;
        }
        for (let key in object) {
          const childPath = path2.slice();
          childPath.push(key);
          try {
            checkErrors(childPath, object[key]);
          } catch (error) {
            errors.push({ path: childPath, error });
          }
        }
      };
      checkErrors([], result);
      return errors;
    }
    exports.checkResultErrors = checkResultErrors;
    function getValue2(value) {
      let bytes = (0, index_js_1.toBeArray)(value);
      (0, index_js_1.assert)(bytes.length <= exports.WordSize, "value out-of-bounds", "BUFFER_OVERRUN", { buffer: bytes, length: exports.WordSize, offset: bytes.length });
      if (bytes.length !== exports.WordSize) {
        bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([Padding.slice(bytes.length % exports.WordSize), bytes]));
      }
      return bytes;
    }
    var Coder = class {
      constructor(name, type6, localName, dynamic) {
        // The coder name:
        //   - address, uint256, tuple, array, etc.
        __publicField(this, "name");
        // The fully expanded type, including composite types:
        //   - address, uint256, tuple(address,bytes), uint256[3][4][],  etc.
        __publicField(this, "type");
        // The localName bound in the signature, in this example it is "baz":
        //   - tuple(address foo, uint bar) baz
        __publicField(this, "localName");
        // Whether this type is dynamic:
        //  - Dynamic: bytes, string, address[], tuple(boolean[]), etc.
        //  - Not Dynamic: address, uint256, boolean[3], tuple(address, uint8)
        __publicField(this, "dynamic");
        (0, index_js_1.defineProperties)(this, { name, type: type6, localName, dynamic }, {
          name: "string",
          type: "string",
          localName: "string",
          dynamic: "boolean"
        });
      }
      _throwError(message, value) {
        (0, index_js_1.assertArgument)(false, message, this.localName, value);
      }
    };
    exports.Coder = Coder;
    var _data, _dataLength, _Writer_instances, writeData_fn;
    var Writer = class {
      constructor() {
        __privateAdd(this, _Writer_instances);
        // An array of WordSize lengthed objects to concatenation
        __privateAdd(this, _data);
        __privateAdd(this, _dataLength);
        __privateSet(this, _data, []);
        __privateSet(this, _dataLength, 0);
      }
      get data() {
        return (0, index_js_1.concat)(__privateGet(this, _data));
      }
      get length() {
        return __privateGet(this, _dataLength);
      }
      appendWriter(writer) {
        return __privateMethod(this, _Writer_instances, writeData_fn).call(this, (0, index_js_1.getBytesCopy)(writer.data));
      }
      // Arrayish item; pad on the right to *nearest* WordSize
      writeBytes(value) {
        let bytes = (0, index_js_1.getBytesCopy)(value);
        const paddingOffset = bytes.length % exports.WordSize;
        if (paddingOffset) {
          bytes = (0, index_js_1.getBytesCopy)((0, index_js_1.concat)([bytes, Padding.slice(paddingOffset)]));
        }
        return __privateMethod(this, _Writer_instances, writeData_fn).call(this, bytes);
      }
      // Numeric item; pad on the left *to* WordSize
      writeValue(value) {
        return __privateMethod(this, _Writer_instances, writeData_fn).call(this, getValue2(value));
      }
      // Inserts a numeric place-holder, returning a callback that can
      // be used to asjust the value later
      writeUpdatableValue() {
        const offset = __privateGet(this, _data).length;
        __privateGet(this, _data).push(Padding);
        __privateSet(this, _dataLength, __privateGet(this, _dataLength) + exports.WordSize);
        return (value) => {
          __privateGet(this, _data)[offset] = getValue2(value);
        };
      }
    };
    _data = new WeakMap();
    _dataLength = new WeakMap();
    _Writer_instances = new WeakSet();
    writeData_fn = function(data) {
      __privateGet(this, _data).push(data);
      __privateSet(this, _dataLength, __privateGet(this, _dataLength) + data.length);
      return data.length;
    };
    exports.Writer = Writer;
    var _data2, _offset, _bytesRead, _parent, _maxInflation, _Reader_instances, incrementBytesRead_fn, peekBytes_fn;
    var _Reader = class _Reader {
      constructor(data, allowLoose, maxInflation) {
        __privateAdd(this, _Reader_instances);
        // Allows incomplete unpadded data to be read; otherwise an error
        // is raised if attempting to overrun the buffer. This is required
        // to deal with an old Solidity bug, in which event data for
        // external (not public thoguh) was tightly packed.
        __publicField(this, "allowLoose");
        __privateAdd(this, _data2);
        __privateAdd(this, _offset);
        __privateAdd(this, _bytesRead);
        __privateAdd(this, _parent);
        __privateAdd(this, _maxInflation);
        (0, index_js_1.defineProperties)(this, { allowLoose: !!allowLoose });
        __privateSet(this, _data2, (0, index_js_1.getBytesCopy)(data));
        __privateSet(this, _bytesRead, 0);
        __privateSet(this, _parent, null);
        __privateSet(this, _maxInflation, maxInflation != null ? maxInflation : 1024);
        __privateSet(this, _offset, 0);
      }
      get data() {
        return (0, index_js_1.hexlify)(__privateGet(this, _data2));
      }
      get dataLength() {
        return __privateGet(this, _data2).length;
      }
      get consumed() {
        return __privateGet(this, _offset);
      }
      get bytes() {
        return new Uint8Array(__privateGet(this, _data2));
      }
      // Create a sub-reader with the same underlying data, but offset
      subReader(offset) {
        const reader = new _Reader(__privateGet(this, _data2).slice(__privateGet(this, _offset) + offset), this.allowLoose, __privateGet(this, _maxInflation));
        __privateSet(reader, _parent, this);
        return reader;
      }
      // Read bytes
      readBytes(length2, loose) {
        let bytes = __privateMethod(this, _Reader_instances, peekBytes_fn).call(this, 0, length2, !!loose);
        __privateMethod(this, _Reader_instances, incrementBytesRead_fn).call(this, length2);
        __privateSet(this, _offset, __privateGet(this, _offset) + bytes.length);
        return bytes.slice(0, length2);
      }
      // Read a numeric values
      readValue() {
        return (0, index_js_1.toBigInt)(this.readBytes(exports.WordSize));
      }
      readIndex() {
        return (0, index_js_1.toNumber)(this.readBytes(exports.WordSize));
      }
    };
    _data2 = new WeakMap();
    _offset = new WeakMap();
    _bytesRead = new WeakMap();
    _parent = new WeakMap();
    _maxInflation = new WeakMap();
    _Reader_instances = new WeakSet();
    incrementBytesRead_fn = function(count) {
      var _a2;
      if (__privateGet(this, _parent)) {
        return __privateMethod(_a2 = __privateGet(this, _parent), _Reader_instances, incrementBytesRead_fn).call(_a2, count);
      }
      __privateSet(this, _bytesRead, __privateGet(this, _bytesRead) + count);
      (0, index_js_1.assert)(__privateGet(this, _maxInflation) < 1 || __privateGet(this, _bytesRead) <= __privateGet(this, _maxInflation) * this.dataLength, `compressed ABI data exceeds inflation ratio of ${__privateGet(this, _maxInflation)} ( see: https://github.com/ethers-io/ethers.js/issues/4537 )`, "BUFFER_OVERRUN", {
        buffer: (0, index_js_1.getBytesCopy)(__privateGet(this, _data2)),
        offset: __privateGet(this, _offset),
        length: count,
        info: {
          bytesRead: __privateGet(this, _bytesRead),
          dataLength: this.dataLength
        }
      });
    };
    peekBytes_fn = function(offset, length2, loose) {
      let alignedLength = Math.ceil(length2 / exports.WordSize) * exports.WordSize;
      if (__privateGet(this, _offset) + alignedLength > __privateGet(this, _data2).length) {
        if (this.allowLoose && loose && __privateGet(this, _offset) + length2 <= __privateGet(this, _data2).length) {
          alignedLength = length2;
        } else {
          (0, index_js_1.assert)(false, "data out-of-bounds", "BUFFER_OVERRUN", {
            buffer: (0, index_js_1.getBytesCopy)(__privateGet(this, _data2)),
            length: __privateGet(this, _data2).length,
            offset: __privateGet(this, _offset) + alignedLength
          });
        }
      }
      return __privateGet(this, _data2).slice(__privateGet(this, _offset), __privateGet(this, _offset) + alignedLength);
    };
    var Reader = _Reader;
    exports.Reader = Reader;
  }
});

// node_modules/ethers/node_modules/@noble/hashes/_assert.js
var require_assert = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/_assert.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.output = exports.exists = exports.hash = exports.bytes = exports.bool = exports.number = void 0;
    function number2(n2) {
      if (!Number.isSafeInteger(n2) || n2 < 0)
        throw new Error(`Wrong positive integer: ${n2}`);
    }
    exports.number = number2;
    function bool(b4) {
      if (typeof b4 !== "boolean")
        throw new Error(`Expected boolean, not ${b4}`);
    }
    exports.bool = bool;
    function bytes(b4, ...lengths) {
      if (!(b4 instanceof Uint8Array))
        throw new Error("Expected Uint8Array");
      if (lengths.length > 0 && !lengths.includes(b4.length))
        throw new Error(`Expected Uint8Array of length ${lengths}, not of length=${b4.length}`);
    }
    exports.bytes = bytes;
    function hash8(hash9) {
      if (typeof hash9 !== "function" || typeof hash9.create !== "function")
        throw new Error("Hash should be wrapped by utils.wrapConstructor");
      number2(hash9.outputLen);
      number2(hash9.blockLen);
    }
    exports.hash = hash8;
    function exists(instance, checkFinished = true) {
      if (instance.destroyed)
        throw new Error("Hash instance has been destroyed");
      if (checkFinished && instance.finished)
        throw new Error("Hash#digest() has already been called");
    }
    exports.exists = exists;
    function output(out, instance) {
      bytes(out);
      const min = instance.outputLen;
      if (out.length < min) {
        throw new Error(`digestInto() expects output buffer of length at least ${min}`);
      }
    }
    exports.output = output;
    var assert9 = { number: number2, bool, bytes, hash: hash8, exists, output };
    exports.default = assert9;
  }
});

// node_modules/ethers/node_modules/@noble/hashes/crypto.js
var require_crypto = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/crypto.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.crypto = void 0;
    exports.crypto = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;
  }
});

// node_modules/ethers/node_modules/@noble/hashes/utils.js
var require_utils6 = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.wrapXOFConstructorWithOpts = exports.wrapConstructorWithOpts = exports.wrapConstructor = exports.checkOpts = exports.Hash = exports.concatBytes = exports.toBytes = exports.utf8ToBytes = exports.asyncLoop = exports.nextTick = exports.hexToBytes = exports.bytesToHex = exports.isLE = exports.rotr = exports.createView = exports.u32 = exports.u8 = void 0;
    var crypto_1 = require_crypto();
    var u8a = (a3) => a3 instanceof Uint8Array;
    var u82 = (arr) => new Uint8Array(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.u8 = u82;
    var u322 = (arr) => new Uint32Array(arr.buffer, arr.byteOffset, Math.floor(arr.byteLength / 4));
    exports.u32 = u322;
    var createView3 = (arr) => new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
    exports.createView = createView3;
    var rotr4 = (word, shift) => word << 32 - shift | word >>> shift;
    exports.rotr = rotr4;
    exports.isLE = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
    if (!exports.isLE)
      throw new Error("Non little-endian hardware is not supported");
    var hexes3 = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex3(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex3 = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        hex3 += hexes3[bytes[i2]];
      }
      return hex3;
    }
    exports.bytesToHex = bytesToHex3;
    function hexToBytes3(hex3) {
      if (typeof hex3 !== "string")
        throw new Error("hex string expected, got " + typeof hex3);
      const len = hex3.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j3 = i2 * 2;
        const hexByte = hex3.slice(j3, j3 + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i2] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes3;
    var nextTick = async () => {
    };
    exports.nextTick = nextTick;
    async function asyncLoop2(iters, tick, cb2) {
      let ts2 = Date.now();
      for (let i2 = 0; i2 < iters; i2++) {
        cb2(i2);
        const diff = Date.now() - ts2;
        if (diff >= 0 && diff < tick)
          continue;
        await (0, exports.nextTick)();
        ts2 += diff;
      }
    }
    exports.asyncLoop = asyncLoop2;
    function utf8ToBytes3(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes3;
    function toBytes13(data) {
      if (typeof data === "string")
        data = utf8ToBytes3(data);
      if (!u8a(data))
        throw new Error(`expected Uint8Array, got ${typeof data}`);
      return data;
    }
    exports.toBytes = toBytes13;
    function concatBytes3(...arrays) {
      const r2 = new Uint8Array(arrays.reduce((sum, a3) => sum + a3.length, 0));
      let pad2 = 0;
      arrays.forEach((a3) => {
        if (!u8a(a3))
          throw new Error("Uint8Array expected");
        r2.set(a3, pad2);
        pad2 += a3.length;
      });
      return r2;
    }
    exports.concatBytes = concatBytes3;
    var Hash4 = class {
      // Safe version that clones internal state
      clone() {
        return this._cloneInto();
      }
    };
    exports.Hash = Hash4;
    var toStr = {}.toString;
    function checkOpts2(defaults3, opts) {
      if (opts !== void 0 && toStr.call(opts) !== "[object Object]")
        throw new Error("Options should be object or undefined");
      const merged = Object.assign(defaults3, opts);
      return merged;
    }
    exports.checkOpts = checkOpts2;
    function wrapConstructor3(hashCons) {
      const hashC = (msg) => hashCons().update(toBytes13(msg)).digest();
      const tmp = hashCons();
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = () => hashCons();
      return hashC;
    }
    exports.wrapConstructor = wrapConstructor3;
    function wrapConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes13(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapConstructorWithOpts = wrapConstructorWithOpts;
    function wrapXOFConstructorWithOpts(hashCons) {
      const hashC = (msg, opts) => hashCons(opts).update(toBytes13(msg)).digest();
      const tmp = hashCons({});
      hashC.outputLen = tmp.outputLen;
      hashC.blockLen = tmp.blockLen;
      hashC.create = (opts) => hashCons(opts);
      return hashC;
    }
    exports.wrapXOFConstructorWithOpts = wrapXOFConstructorWithOpts;
    function randomBytes3(bytesLength = 32) {
      if (crypto_1.crypto && typeof crypto_1.crypto.getRandomValues === "function") {
        return crypto_1.crypto.getRandomValues(new Uint8Array(bytesLength));
      }
      throw new Error("crypto.getRandomValues must be defined");
    }
    exports.randomBytes = randomBytes3;
  }
});

// node_modules/ethers/node_modules/@noble/hashes/hmac.js
var require_hmac = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.hmac = exports.HMAC = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils6();
    var HMAC3 = class extends utils_js_1.Hash {
      constructor(hash8, _key) {
        super();
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.hash)(hash8);
        const key = (0, utils_js_1.toBytes)(_key);
        this.iHash = hash8.create();
        if (typeof this.iHash.update !== "function")
          throw new Error("Expected instance of class which extends utils.Hash");
        this.blockLen = this.iHash.blockLen;
        this.outputLen = this.iHash.outputLen;
        const blockLen = this.blockLen;
        const pad2 = new Uint8Array(blockLen);
        pad2.set(key.length > blockLen ? hash8.create().update(key).digest() : key);
        for (let i2 = 0; i2 < pad2.length; i2++)
          pad2[i2] ^= 54;
        this.iHash.update(pad2);
        this.oHash = hash8.create();
        for (let i2 = 0; i2 < pad2.length; i2++)
          pad2[i2] ^= 54 ^ 92;
        this.oHash.update(pad2);
        pad2.fill(0);
      }
      update(buf) {
        (0, _assert_js_1.exists)(this);
        this.iHash.update(buf);
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.bytes)(out, this.outputLen);
        this.finished = true;
        this.iHash.digestInto(out);
        this.oHash.update(out);
        this.oHash.digestInto(out);
        this.destroy();
      }
      digest() {
        const out = new Uint8Array(this.oHash.outputLen);
        this.digestInto(out);
        return out;
      }
      _cloneInto(to4) {
        to4 || (to4 = Object.create(Object.getPrototypeOf(this), {}));
        const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
        to4 = to4;
        to4.finished = finished;
        to4.destroyed = destroyed;
        to4.blockLen = blockLen;
        to4.outputLen = outputLen;
        to4.oHash = oHash._cloneInto(to4.oHash);
        to4.iHash = iHash._cloneInto(to4.iHash);
        return to4;
      }
      destroy() {
        this.destroyed = true;
        this.oHash.destroy();
        this.iHash.destroy();
      }
    };
    exports.HMAC = HMAC3;
    var hmac3 = (hash8, key, message) => new HMAC3(hash8, key).update(message).digest();
    exports.hmac = hmac3;
    exports.hmac.create = (hash8, key) => new HMAC3(hash8, key);
  }
});

// node_modules/ethers/node_modules/@noble/hashes/pbkdf2.js
var require_pbkdf2 = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2Async = exports.pbkdf2 = void 0;
    var _assert_js_1 = require_assert();
    var hmac_js_1 = require_hmac();
    var utils_js_1 = require_utils6();
    function pbkdf2Init2(hash8, _password, _salt, _opts) {
      (0, _assert_js_1.hash)(hash8);
      const opts = (0, utils_js_1.checkOpts)({ dkLen: 32, asyncTick: 10 }, _opts);
      const { c: c3, dkLen, asyncTick } = opts;
      (0, _assert_js_1.number)(c3);
      (0, _assert_js_1.number)(dkLen);
      (0, _assert_js_1.number)(asyncTick);
      if (c3 < 1)
        throw new Error("PBKDF2: iterations (c) should be >= 1");
      const password = (0, utils_js_1.toBytes)(_password);
      const salt = (0, utils_js_1.toBytes)(_salt);
      const DK = new Uint8Array(dkLen);
      const PRF = hmac_js_1.hmac.create(hash8, password);
      const PRFSalt = PRF._cloneInto().update(salt);
      return { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt };
    }
    function pbkdf2Output2(PRF, PRFSalt, DK, prfW, u3) {
      PRF.destroy();
      PRFSalt.destroy();
      if (prfW)
        prfW.destroy();
      u3.fill(0);
      return DK;
    }
    function pbkdf22(hash8, password, salt, opts) {
      const { c: c3, dkLen, DK, PRF, PRFSalt } = pbkdf2Init2(hash8, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u3 = new Uint8Array(PRF.outputLen);
      for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
        const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti2, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u3);
        Ti2.set(u3.subarray(0, Ti2.length));
        for (let ui = 1; ui < c3; ui++) {
          PRF._cloneInto(prfW).update(u3).digestInto(u3);
          for (let i2 = 0; i2 < Ti2.length; i2++)
            Ti2[i2] ^= u3[i2];
        }
      }
      return pbkdf2Output2(PRF, PRFSalt, DK, prfW, u3);
    }
    exports.pbkdf2 = pbkdf22;
    async function pbkdf2Async2(hash8, password, salt, opts) {
      const { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt } = pbkdf2Init2(hash8, password, salt, opts);
      let prfW;
      const arr = new Uint8Array(4);
      const view = (0, utils_js_1.createView)(arr);
      const u3 = new Uint8Array(PRF.outputLen);
      for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
        const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
        view.setInt32(0, ti2, false);
        (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u3);
        Ti2.set(u3.subarray(0, Ti2.length));
        await (0, utils_js_1.asyncLoop)(c3 - 1, asyncTick, () => {
          PRF._cloneInto(prfW).update(u3).digestInto(u3);
          for (let i2 = 0; i2 < Ti2.length; i2++)
            Ti2[i2] ^= u3[i2];
        });
      }
      return pbkdf2Output2(PRF, PRFSalt, DK, prfW, u3);
    }
    exports.pbkdf2Async = pbkdf2Async2;
  }
});

// node_modules/ethers/node_modules/@noble/hashes/_sha2.js
var require_sha2 = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/_sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SHA2 = void 0;
    var _assert_js_1 = require_assert();
    var utils_js_1 = require_utils6();
    function setBigUint643(view, byteOffset, value, isLE3) {
      if (typeof view.setBigUint64 === "function")
        return view.setBigUint64(byteOffset, value, isLE3);
      const _32n3 = BigInt(32);
      const _u32_max = BigInt(4294967295);
      const wh = Number(value >> _32n3 & _u32_max);
      const wl2 = Number(value & _u32_max);
      const h = isLE3 ? 4 : 0;
      const l3 = isLE3 ? 0 : 4;
      view.setUint32(byteOffset + h, wh, isLE3);
      view.setUint32(byteOffset + l3, wl2, isLE3);
    }
    var SHA2 = class extends utils_js_1.Hash {
      constructor(blockLen, outputLen, padOffset, isLE3) {
        super();
        this.blockLen = blockLen;
        this.outputLen = outputLen;
        this.padOffset = padOffset;
        this.isLE = isLE3;
        this.finished = false;
        this.length = 0;
        this.pos = 0;
        this.destroyed = false;
        this.buffer = new Uint8Array(blockLen);
        this.view = (0, utils_js_1.createView)(this.buffer);
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { view, buffer: buffer3, blockLen } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          if (take === blockLen) {
            const dataView = (0, utils_js_1.createView)(data);
            for (; blockLen <= len - pos; pos += blockLen)
              this.process(dataView, pos);
            continue;
          }
          buffer3.set(data.subarray(pos, pos + take), this.pos);
          this.pos += take;
          pos += take;
          if (this.pos === blockLen) {
            this.process(view, 0);
            this.pos = 0;
          }
        }
        this.length += data.length;
        this.roundClean();
        return this;
      }
      digestInto(out) {
        (0, _assert_js_1.exists)(this);
        (0, _assert_js_1.output)(out, this);
        this.finished = true;
        const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
        let { pos } = this;
        buffer3[pos++] = 128;
        this.buffer.subarray(pos).fill(0);
        if (this.padOffset > blockLen - pos) {
          this.process(view, 0);
          pos = 0;
        }
        for (let i2 = pos; i2 < blockLen; i2++)
          buffer3[i2] = 0;
        setBigUint643(view, blockLen - 8, BigInt(this.length * 8), isLE3);
        this.process(view, 0);
        const oview = (0, utils_js_1.createView)(out);
        const len = this.outputLen;
        if (len % 4)
          throw new Error("_sha2: outputLen should be aligned to 32bit");
        const outLen = len / 4;
        const state = this.get();
        if (outLen > state.length)
          throw new Error("_sha2: outputLen bigger than state");
        for (let i2 = 0; i2 < outLen; i2++)
          oview.setUint32(4 * i2, state[i2], isLE3);
      }
      digest() {
        const { buffer: buffer3, outputLen } = this;
        this.digestInto(buffer3);
        const res = buffer3.slice(0, outputLen);
        this.destroy();
        return res;
      }
      _cloneInto(to4) {
        to4 || (to4 = new this.constructor());
        to4.set(...this.get());
        const { blockLen, buffer: buffer3, length: length2, finished, destroyed, pos } = this;
        to4.length = length2;
        to4.pos = pos;
        to4.finished = finished;
        to4.destroyed = destroyed;
        if (length2 % blockLen)
          to4.buffer.set(buffer3);
        return to4;
      }
    };
    exports.SHA2 = SHA2;
  }
});

// node_modules/ethers/node_modules/@noble/hashes/sha256.js
var require_sha256 = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/sha256.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha224 = exports.sha256 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils6();
    var Chi3 = (a3, b4, c3) => a3 & b4 ^ ~a3 & c3;
    var Maj3 = (a3, b4, c3) => a3 & b4 ^ a3 & c3 ^ b4 & c3;
    var SHA256_K3 = new Uint32Array([
      1116352408,
      1899447441,
      3049323471,
      3921009573,
      961987163,
      1508970993,
      2453635748,
      2870763221,
      3624381080,
      310598401,
      607225278,
      1426881987,
      1925078388,
      2162078206,
      2614888103,
      3248222580,
      3835390401,
      4022224774,
      264347078,
      604807628,
      770255983,
      1249150122,
      1555081692,
      1996064986,
      2554220882,
      2821834349,
      2952996808,
      3210313671,
      3336571891,
      3584528711,
      113926993,
      338241895,
      666307205,
      773529912,
      1294757372,
      1396182291,
      1695183700,
      1986661051,
      2177026350,
      2456956037,
      2730485921,
      2820302411,
      3259730800,
      3345764771,
      3516065817,
      3600352804,
      4094571909,
      275423344,
      430227734,
      506948616,
      659060556,
      883997877,
      958139571,
      1322822218,
      1537002063,
      1747873779,
      1955562222,
      2024104815,
      2227730452,
      2361852424,
      2428436474,
      2756734187,
      3204031479,
      3329325298
    ]);
    var IV = new Uint32Array([
      1779033703,
      3144134277,
      1013904242,
      2773480762,
      1359893119,
      2600822924,
      528734635,
      1541459225
    ]);
    var SHA256_W3 = new Uint32Array(64);
    var SHA2563 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 32, 8, false);
        this.A = IV[0] | 0;
        this.B = IV[1] | 0;
        this.C = IV[2] | 0;
        this.D = IV[3] | 0;
        this.E = IV[4] | 0;
        this.F = IV[5] | 0;
        this.G = IV[6] | 0;
        this.H = IV[7] | 0;
      }
      get() {
        const { A, B: B2, C: C2, D: D3, E: E3, F: F2, G: G2, H: H3 } = this;
        return [A, B2, C2, D3, E3, F2, G2, H3];
      }
      // prettier-ignore
      set(A, B2, C2, D3, E3, F2, G2, H3) {
        this.A = A | 0;
        this.B = B2 | 0;
        this.C = C2 | 0;
        this.D = D3 | 0;
        this.E = E3 | 0;
        this.F = F2 | 0;
        this.G = G2 | 0;
        this.H = H3 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          SHA256_W3[i2] = view.getUint32(offset, false);
        for (let i2 = 16; i2 < 64; i2++) {
          const W15 = SHA256_W3[i2 - 15];
          const W22 = SHA256_W3[i2 - 2];
          const s0 = (0, utils_js_1.rotr)(W15, 7) ^ (0, utils_js_1.rotr)(W15, 18) ^ W15 >>> 3;
          const s1 = (0, utils_js_1.rotr)(W22, 17) ^ (0, utils_js_1.rotr)(W22, 19) ^ W22 >>> 10;
          SHA256_W3[i2] = s1 + SHA256_W3[i2 - 7] + s0 + SHA256_W3[i2 - 16] | 0;
        }
        let { A, B: B2, C: C2, D: D3, E: E3, F: F2, G: G2, H: H3 } = this;
        for (let i2 = 0; i2 < 64; i2++) {
          const sigma1 = (0, utils_js_1.rotr)(E3, 6) ^ (0, utils_js_1.rotr)(E3, 11) ^ (0, utils_js_1.rotr)(E3, 25);
          const T12 = H3 + sigma1 + Chi3(E3, F2, G2) + SHA256_K3[i2] + SHA256_W3[i2] | 0;
          const sigma0 = (0, utils_js_1.rotr)(A, 2) ^ (0, utils_js_1.rotr)(A, 13) ^ (0, utils_js_1.rotr)(A, 22);
          const T22 = sigma0 + Maj3(A, B2, C2) | 0;
          H3 = G2;
          G2 = F2;
          F2 = E3;
          E3 = D3 + T12 | 0;
          D3 = C2;
          C2 = B2;
          B2 = A;
          A = T12 + T22 | 0;
        }
        A = A + this.A | 0;
        B2 = B2 + this.B | 0;
        C2 = C2 + this.C | 0;
        D3 = D3 + this.D | 0;
        E3 = E3 + this.E | 0;
        F2 = F2 + this.F | 0;
        G2 = G2 + this.G | 0;
        H3 = H3 + this.H | 0;
        this.set(A, B2, C2, D3, E3, F2, G2, H3);
      }
      roundClean() {
        SHA256_W3.fill(0);
      }
      destroy() {
        this.set(0, 0, 0, 0, 0, 0, 0, 0);
        this.buffer.fill(0);
      }
    };
    var SHA2243 = class extends SHA2563 {
      constructor() {
        super();
        this.A = 3238371032 | 0;
        this.B = 914150663 | 0;
        this.C = 812702999 | 0;
        this.D = 4144912697 | 0;
        this.E = 4290775857 | 0;
        this.F = 1750603025 | 0;
        this.G = 1694076839 | 0;
        this.H = 3204075428 | 0;
        this.outputLen = 28;
      }
    };
    exports.sha256 = (0, utils_js_1.wrapConstructor)(() => new SHA2563());
    exports.sha224 = (0, utils_js_1.wrapConstructor)(() => new SHA2243());
  }
});

// node_modules/ethers/node_modules/@noble/hashes/_u64.js
var require_u64 = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/_u64.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.add5L = exports.add5H = exports.add4H = exports.add4L = exports.add3H = exports.add3L = exports.add = exports.rotlBL = exports.rotlBH = exports.rotlSL = exports.rotlSH = exports.rotr32L = exports.rotr32H = exports.rotrBL = exports.rotrBH = exports.rotrSL = exports.rotrSH = exports.shrSL = exports.shrSH = exports.toBig = exports.split = exports.fromBig = void 0;
    var U32_MASK643 = BigInt(2 ** 32 - 1);
    var _32n3 = BigInt(32);
    function fromBig4(n2, le2 = false) {
      if (le2)
        return { h: Number(n2 & U32_MASK643), l: Number(n2 >> _32n3 & U32_MASK643) };
      return { h: Number(n2 >> _32n3 & U32_MASK643) | 0, l: Number(n2 & U32_MASK643) | 0 };
    }
    exports.fromBig = fromBig4;
    function split4(lst, le2 = false) {
      let Ah = new Uint32Array(lst.length);
      let Al2 = new Uint32Array(lst.length);
      for (let i2 = 0; i2 < lst.length; i2++) {
        const { h, l: l3 } = fromBig4(lst[i2], le2);
        [Ah[i2], Al2[i2]] = [h, l3];
      }
      return [Ah, Al2];
    }
    exports.split = split4;
    var toBig3 = (h, l3) => BigInt(h >>> 0) << _32n3 | BigInt(l3 >>> 0);
    exports.toBig = toBig3;
    var shrSH3 = (h, _l2, s2) => h >>> s2;
    exports.shrSH = shrSH3;
    var shrSL3 = (h, l3, s2) => h << 32 - s2 | l3 >>> s2;
    exports.shrSL = shrSL3;
    var rotrSH4 = (h, l3, s2) => h >>> s2 | l3 << 32 - s2;
    exports.rotrSH = rotrSH4;
    var rotrSL4 = (h, l3, s2) => h << 32 - s2 | l3 >>> s2;
    exports.rotrSL = rotrSL4;
    var rotrBH4 = (h, l3, s2) => h << 64 - s2 | l3 >>> s2 - 32;
    exports.rotrBH = rotrBH4;
    var rotrBL4 = (h, l3, s2) => h >>> s2 - 32 | l3 << 64 - s2;
    exports.rotrBL = rotrBL4;
    var rotr32H4 = (_h, l3) => l3;
    exports.rotr32H = rotr32H4;
    var rotr32L4 = (h, _l2) => h;
    exports.rotr32L = rotr32L4;
    var rotlSH3 = (h, l3, s2) => h << s2 | l3 >>> 32 - s2;
    exports.rotlSH = rotlSH3;
    var rotlSL3 = (h, l3, s2) => l3 << s2 | h >>> 32 - s2;
    exports.rotlSL = rotlSL3;
    var rotlBH3 = (h, l3, s2) => l3 << s2 - 32 | h >>> 64 - s2;
    exports.rotlBH = rotlBH3;
    var rotlBL3 = (h, l3, s2) => h << s2 - 32 | l3 >>> 64 - s2;
    exports.rotlBL = rotlBL3;
    function add4(Ah, Al2, Bh, Bl2) {
      const l3 = (Al2 >>> 0) + (Bl2 >>> 0);
      return { h: Ah + Bh + (l3 / 2 ** 32 | 0) | 0, l: l3 | 0 };
    }
    exports.add = add4;
    var add3L4 = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
    exports.add3L = add3L4;
    var add3H4 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
    exports.add3H = add3H4;
    var add4L3 = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
    exports.add4L = add4L3;
    var add4H3 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
    exports.add4H = add4H3;
    var add5L3 = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
    exports.add5L = add5L3;
    var add5H3 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
    exports.add5H = add5H3;
    var u643 = {
      fromBig: fromBig4,
      split: split4,
      toBig: toBig3,
      shrSH: shrSH3,
      shrSL: shrSL3,
      rotrSH: rotrSH4,
      rotrSL: rotrSL4,
      rotrBH: rotrBH4,
      rotrBL: rotrBL4,
      rotr32H: rotr32H4,
      rotr32L: rotr32L4,
      rotlSH: rotlSH3,
      rotlSL: rotlSL3,
      rotlBH: rotlBH3,
      rotlBL: rotlBL3,
      add: add4,
      add3L: add3L4,
      add3H: add3H4,
      add4L: add4L3,
      add4H: add4H3,
      add5H: add5H3,
      add5L: add5L3
    };
    exports.default = u643;
  }
});

// node_modules/ethers/node_modules/@noble/hashes/sha512.js
var require_sha512 = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/sha512.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha384 = exports.sha512_256 = exports.sha512_224 = exports.sha512 = exports.SHA512 = void 0;
    var _sha2_js_1 = require_sha2();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils6();
    var [SHA512_Kh3, SHA512_Kl3] = (() => _u64_js_1.default.split([
      "0x428a2f98d728ae22",
      "0x7137449123ef65cd",
      "0xb5c0fbcfec4d3b2f",
      "0xe9b5dba58189dbbc",
      "0x3956c25bf348b538",
      "0x59f111f1b605d019",
      "0x923f82a4af194f9b",
      "0xab1c5ed5da6d8118",
      "0xd807aa98a3030242",
      "0x12835b0145706fbe",
      "0x243185be4ee4b28c",
      "0x550c7dc3d5ffb4e2",
      "0x72be5d74f27b896f",
      "0x80deb1fe3b1696b1",
      "0x9bdc06a725c71235",
      "0xc19bf174cf692694",
      "0xe49b69c19ef14ad2",
      "0xefbe4786384f25e3",
      "0x0fc19dc68b8cd5b5",
      "0x240ca1cc77ac9c65",
      "0x2de92c6f592b0275",
      "0x4a7484aa6ea6e483",
      "0x5cb0a9dcbd41fbd4",
      "0x76f988da831153b5",
      "0x983e5152ee66dfab",
      "0xa831c66d2db43210",
      "0xb00327c898fb213f",
      "0xbf597fc7beef0ee4",
      "0xc6e00bf33da88fc2",
      "0xd5a79147930aa725",
      "0x06ca6351e003826f",
      "0x142929670a0e6e70",
      "0x27b70a8546d22ffc",
      "0x2e1b21385c26c926",
      "0x4d2c6dfc5ac42aed",
      "0x53380d139d95b3df",
      "0x650a73548baf63de",
      "0x766a0abb3c77b2a8",
      "0x81c2c92e47edaee6",
      "0x92722c851482353b",
      "0xa2bfe8a14cf10364",
      "0xa81a664bbc423001",
      "0xc24b8b70d0f89791",
      "0xc76c51a30654be30",
      "0xd192e819d6ef5218",
      "0xd69906245565a910",
      "0xf40e35855771202a",
      "0x106aa07032bbd1b8",
      "0x19a4c116b8d2d0c8",
      "0x1e376c085141ab53",
      "0x2748774cdf8eeb99",
      "0x34b0bcb5e19b48a8",
      "0x391c0cb3c5c95a63",
      "0x4ed8aa4ae3418acb",
      "0x5b9cca4f7763e373",
      "0x682e6ff3d6b2b8a3",
      "0x748f82ee5defb2fc",
      "0x78a5636f43172f60",
      "0x84c87814a1f0ab72",
      "0x8cc702081a6439ec",
      "0x90befffa23631e28",
      "0xa4506cebde82bde9",
      "0xbef9a3f7b2c67915",
      "0xc67178f2e372532b",
      "0xca273eceea26619c",
      "0xd186b8c721c0c207",
      "0xeada7dd6cde0eb1e",
      "0xf57d4f7fee6ed178",
      "0x06f067aa72176fba",
      "0x0a637dc5a2c898a6",
      "0x113f9804bef90dae",
      "0x1b710b35131c471b",
      "0x28db77f523047d84",
      "0x32caab7b40c72493",
      "0x3c9ebe0a15c9bebc",
      "0x431d67c49c100d4c",
      "0x4cc5d4becb3e42b6",
      "0x597f299cfc657e2a",
      "0x5fcb6fab3ad6faec",
      "0x6c44198c4a475817"
    ].map((n2) => BigInt(n2))))();
    var SHA512_W_H3 = new Uint32Array(80);
    var SHA512_W_L3 = new Uint32Array(80);
    var SHA5123 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(128, 64, 16, false);
        this.Ah = 1779033703 | 0;
        this.Al = 4089235720 | 0;
        this.Bh = 3144134277 | 0;
        this.Bl = 2227873595 | 0;
        this.Ch = 1013904242 | 0;
        this.Cl = 4271175723 | 0;
        this.Dh = 2773480762 | 0;
        this.Dl = 1595750129 | 0;
        this.Eh = 1359893119 | 0;
        this.El = 2917565137 | 0;
        this.Fh = 2600822924 | 0;
        this.Fl = 725511199 | 0;
        this.Gh = 528734635 | 0;
        this.Gl = 4215389547 | 0;
        this.Hh = 1541459225 | 0;
        this.Hl = 327033209 | 0;
      }
      // prettier-ignore
      get() {
        const { Ah, Al: Al2, Bh, Bl: Bl2, Ch, Cl: Cl2, Dh, Dl: Dl2, Eh, El: El2, Fh, Fl: Fl2, Gh, Gl: Gl2, Hh, Hl: Hl2 } = this;
        return [Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2];
      }
      // prettier-ignore
      set(Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2) {
        this.Ah = Ah | 0;
        this.Al = Al2 | 0;
        this.Bh = Bh | 0;
        this.Bl = Bl2 | 0;
        this.Ch = Ch | 0;
        this.Cl = Cl2 | 0;
        this.Dh = Dh | 0;
        this.Dl = Dl2 | 0;
        this.Eh = Eh | 0;
        this.El = El2 | 0;
        this.Fh = Fh | 0;
        this.Fl = Fl2 | 0;
        this.Gh = Gh | 0;
        this.Gl = Gl2 | 0;
        this.Hh = Hh | 0;
        this.Hl = Hl2 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4) {
          SHA512_W_H3[i2] = view.getUint32(offset);
          SHA512_W_L3[i2] = view.getUint32(offset += 4);
        }
        for (let i2 = 16; i2 < 80; i2++) {
          const W15h = SHA512_W_H3[i2 - 15] | 0;
          const W15l = SHA512_W_L3[i2 - 15] | 0;
          const s0h = _u64_js_1.default.rotrSH(W15h, W15l, 1) ^ _u64_js_1.default.rotrSH(W15h, W15l, 8) ^ _u64_js_1.default.shrSH(W15h, W15l, 7);
          const s0l = _u64_js_1.default.rotrSL(W15h, W15l, 1) ^ _u64_js_1.default.rotrSL(W15h, W15l, 8) ^ _u64_js_1.default.shrSL(W15h, W15l, 7);
          const W2h = SHA512_W_H3[i2 - 2] | 0;
          const W2l = SHA512_W_L3[i2 - 2] | 0;
          const s1h = _u64_js_1.default.rotrSH(W2h, W2l, 19) ^ _u64_js_1.default.rotrBH(W2h, W2l, 61) ^ _u64_js_1.default.shrSH(W2h, W2l, 6);
          const s1l = _u64_js_1.default.rotrSL(W2h, W2l, 19) ^ _u64_js_1.default.rotrBL(W2h, W2l, 61) ^ _u64_js_1.default.shrSL(W2h, W2l, 6);
          const SUMl = _u64_js_1.default.add4L(s0l, s1l, SHA512_W_L3[i2 - 7], SHA512_W_L3[i2 - 16]);
          const SUMh = _u64_js_1.default.add4H(SUMl, s0h, s1h, SHA512_W_H3[i2 - 7], SHA512_W_H3[i2 - 16]);
          SHA512_W_H3[i2] = SUMh | 0;
          SHA512_W_L3[i2] = SUMl | 0;
        }
        let { Ah, Al: Al2, Bh, Bl: Bl2, Ch, Cl: Cl2, Dh, Dl: Dl2, Eh, El: El2, Fh, Fl: Fl2, Gh, Gl: Gl2, Hh, Hl: Hl2 } = this;
        for (let i2 = 0; i2 < 80; i2++) {
          const sigma1h = _u64_js_1.default.rotrSH(Eh, El2, 14) ^ _u64_js_1.default.rotrSH(Eh, El2, 18) ^ _u64_js_1.default.rotrBH(Eh, El2, 41);
          const sigma1l = _u64_js_1.default.rotrSL(Eh, El2, 14) ^ _u64_js_1.default.rotrSL(Eh, El2, 18) ^ _u64_js_1.default.rotrBL(Eh, El2, 41);
          const CHIh = Eh & Fh ^ ~Eh & Gh;
          const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
          const T1ll = _u64_js_1.default.add5L(Hl2, sigma1l, CHIl, SHA512_Kl3[i2], SHA512_W_L3[i2]);
          const T1h = _u64_js_1.default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh3[i2], SHA512_W_H3[i2]);
          const T1l = T1ll | 0;
          const sigma0h = _u64_js_1.default.rotrSH(Ah, Al2, 28) ^ _u64_js_1.default.rotrBH(Ah, Al2, 34) ^ _u64_js_1.default.rotrBH(Ah, Al2, 39);
          const sigma0l = _u64_js_1.default.rotrSL(Ah, Al2, 28) ^ _u64_js_1.default.rotrBL(Ah, Al2, 34) ^ _u64_js_1.default.rotrBL(Ah, Al2, 39);
          const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
          const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
          Hh = Gh | 0;
          Hl2 = Gl2 | 0;
          Gh = Fh | 0;
          Gl2 = Fl2 | 0;
          Fh = Eh | 0;
          Fl2 = El2 | 0;
          ({ h: Eh, l: El2 } = _u64_js_1.default.add(Dh | 0, Dl2 | 0, T1h | 0, T1l | 0));
          Dh = Ch | 0;
          Dl2 = Cl2 | 0;
          Ch = Bh | 0;
          Cl2 = Bl2 | 0;
          Bh = Ah | 0;
          Bl2 = Al2 | 0;
          const All = _u64_js_1.default.add3L(T1l, sigma0l, MAJl);
          Ah = _u64_js_1.default.add3H(All, T1h, sigma0h, MAJh);
          Al2 = All | 0;
        }
        ({ h: Ah, l: Al2 } = _u64_js_1.default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al2 | 0));
        ({ h: Bh, l: Bl2 } = _u64_js_1.default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
        ({ h: Ch, l: Cl2 } = _u64_js_1.default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl2 | 0));
        ({ h: Dh, l: Dl2 } = _u64_js_1.default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl2 | 0));
        ({ h: Eh, l: El2 } = _u64_js_1.default.add(this.Eh | 0, this.El | 0, Eh | 0, El2 | 0));
        ({ h: Fh, l: Fl2 } = _u64_js_1.default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl2 | 0));
        ({ h: Gh, l: Gl2 } = _u64_js_1.default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl2 | 0));
        ({ h: Hh, l: Hl2 } = _u64_js_1.default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl2 | 0));
        this.set(Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2);
      }
      roundClean() {
        SHA512_W_H3.fill(0);
        SHA512_W_L3.fill(0);
      }
      destroy() {
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
      }
    };
    exports.SHA512 = SHA5123;
    var SHA512_2243 = class extends SHA5123 {
      constructor() {
        super();
        this.Ah = 2352822216 | 0;
        this.Al = 424955298 | 0;
        this.Bh = 1944164710 | 0;
        this.Bl = 2312950998 | 0;
        this.Ch = 502970286 | 0;
        this.Cl = 855612546 | 0;
        this.Dh = 1738396948 | 0;
        this.Dl = 1479516111 | 0;
        this.Eh = 258812777 | 0;
        this.El = 2077511080 | 0;
        this.Fh = 2011393907 | 0;
        this.Fl = 79989058 | 0;
        this.Gh = 1067287976 | 0;
        this.Gl = 1780299464 | 0;
        this.Hh = 286451373 | 0;
        this.Hl = 2446758561 | 0;
        this.outputLen = 28;
      }
    };
    var SHA512_2563 = class extends SHA5123 {
      constructor() {
        super();
        this.Ah = 573645204 | 0;
        this.Al = 4230739756 | 0;
        this.Bh = 2673172387 | 0;
        this.Bl = 3360449730 | 0;
        this.Ch = 596883563 | 0;
        this.Cl = 1867755857 | 0;
        this.Dh = 2520282905 | 0;
        this.Dl = 1497426621 | 0;
        this.Eh = 2519219938 | 0;
        this.El = 2827943907 | 0;
        this.Fh = 3193839141 | 0;
        this.Fl = 1401305490 | 0;
        this.Gh = 721525244 | 0;
        this.Gl = 746961066 | 0;
        this.Hh = 246885852 | 0;
        this.Hl = 2177182882 | 0;
        this.outputLen = 32;
      }
    };
    var SHA3843 = class extends SHA5123 {
      constructor() {
        super();
        this.Ah = 3418070365 | 0;
        this.Al = 3238371032 | 0;
        this.Bh = 1654270250 | 0;
        this.Bl = 914150663 | 0;
        this.Ch = 2438529370 | 0;
        this.Cl = 812702999 | 0;
        this.Dh = 355462360 | 0;
        this.Dl = 4144912697 | 0;
        this.Eh = 1731405415 | 0;
        this.El = 4290775857 | 0;
        this.Fh = 2394180231 | 0;
        this.Fl = 1750603025 | 0;
        this.Gh = 3675008525 | 0;
        this.Gl = 1694076839 | 0;
        this.Hh = 1203062813 | 0;
        this.Hl = 3204075428 | 0;
        this.outputLen = 48;
      }
    };
    exports.sha512 = (0, utils_js_1.wrapConstructor)(() => new SHA5123());
    exports.sha512_224 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2243());
    exports.sha512_256 = (0, utils_js_1.wrapConstructor)(() => new SHA512_2563());
    exports.sha384 = (0, utils_js_1.wrapConstructor)(() => new SHA3843());
  }
});

// node_modules/ethers/lib.commonjs/crypto/crypto-browser.js
var require_crypto_browser = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/crypto-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = exports.pbkdf2Sync = exports.createHmac = exports.createHash = void 0;
    var hmac_1 = require_hmac();
    var pbkdf2_1 = require_pbkdf2();
    var sha256_1 = require_sha256();
    var sha512_1 = require_sha512();
    var index_js_1 = require_utils5();
    function getGlobal() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    }
    var anyGlobal = getGlobal();
    var crypto4 = anyGlobal.crypto || anyGlobal.msCrypto;
    function createHash(algo) {
      switch (algo) {
        case "sha256":
          return sha256_1.sha256.create();
        case "sha512":
          return sha512_1.sha512.create();
      }
      (0, index_js_1.assertArgument)(false, "invalid hashing algorithm name", "algorithm", algo);
    }
    exports.createHash = createHash;
    function createHmac(_algo, key) {
      const algo = { sha256: sha256_1.sha256, sha512: sha512_1.sha512 }[_algo];
      (0, index_js_1.assertArgument)(algo != null, "invalid hmac algorithm", "algorithm", _algo);
      return hmac_1.hmac.create(algo, key);
    }
    exports.createHmac = createHmac;
    function pbkdf2Sync(password, salt, iterations, keylen, _algo) {
      const algo = { sha256: sha256_1.sha256, sha512: sha512_1.sha512 }[_algo];
      (0, index_js_1.assertArgument)(algo != null, "invalid pbkdf2 algorithm", "algorithm", _algo);
      return (0, pbkdf2_1.pbkdf2)(algo, password, salt, { c: iterations, dkLen: keylen });
    }
    exports.pbkdf2Sync = pbkdf2Sync;
    function randomBytes3(length2) {
      (0, index_js_1.assert)(crypto4 != null, "platform does not support secure random numbers", "UNSUPPORTED_OPERATION", {
        operation: "randomBytes"
      });
      (0, index_js_1.assertArgument)(Number.isInteger(length2) && length2 > 0 && length2 <= 1024, "invalid length", "length", length2);
      const result = new Uint8Array(length2);
      crypto4.getRandomValues(result);
      return result;
    }
    exports.randomBytes = randomBytes3;
  }
});

// node_modules/ethers/lib.commonjs/crypto/hmac.js
var require_hmac2 = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/hmac.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.computeHmac = void 0;
    var crypto_js_1 = require_crypto_browser();
    var index_js_1 = require_utils5();
    var locked = false;
    var _computeHmac = function(algorithm, key, data) {
      return (0, crypto_js_1.createHmac)(algorithm, key).update(data).digest();
    };
    var __computeHmac = _computeHmac;
    function computeHmac(algorithm, _key, _data) {
      const key = (0, index_js_1.getBytes)(_key, "key");
      const data = (0, index_js_1.getBytes)(_data, "data");
      return (0, index_js_1.hexlify)(__computeHmac(algorithm, key, data));
    }
    exports.computeHmac = computeHmac;
    computeHmac._ = _computeHmac;
    computeHmac.lock = function() {
      locked = true;
    };
    computeHmac.register = function(func) {
      if (locked) {
        throw new Error("computeHmac is locked");
      }
      __computeHmac = func;
    };
    Object.freeze(computeHmac);
  }
});

// node_modules/ethers/node_modules/@noble/hashes/sha3.js
var require_sha32 = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/sha3.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.shake256 = exports.shake128 = exports.keccak_512 = exports.keccak_384 = exports.keccak_256 = exports.keccak_224 = exports.sha3_512 = exports.sha3_384 = exports.sha3_256 = exports.sha3_224 = exports.Keccak = exports.keccakP = void 0;
    var _assert_js_1 = require_assert();
    var _u64_js_1 = require_u64();
    var utils_js_1 = require_utils6();
    var [SHA3_PI, SHA3_ROTL, _SHA3_IOTA] = [[], [], []];
    var _0n4 = BigInt(0);
    var _1n4 = BigInt(1);
    var _2n4 = BigInt(2);
    var _7n = BigInt(7);
    var _256n = BigInt(256);
    var _0x71n = BigInt(113);
    for (let round = 0, R2 = _1n4, x2 = 1, y2 = 0; round < 24; round++) {
      [x2, y2] = [y2, (2 * x2 + 3 * y2) % 5];
      SHA3_PI.push(2 * (5 * y2 + x2));
      SHA3_ROTL.push((round + 1) * (round + 2) / 2 % 64);
      let t2 = _0n4;
      for (let j3 = 0; j3 < 7; j3++) {
        R2 = (R2 << _1n4 ^ (R2 >> _7n) * _0x71n) % _256n;
        if (R2 & _2n4)
          t2 ^= _1n4 << (_1n4 << BigInt(j3)) - _1n4;
      }
      _SHA3_IOTA.push(t2);
    }
    var [SHA3_IOTA_H, SHA3_IOTA_L] = (0, _u64_js_1.split)(_SHA3_IOTA, true);
    var rotlH = (h, l3, s2) => s2 > 32 ? (0, _u64_js_1.rotlBH)(h, l3, s2) : (0, _u64_js_1.rotlSH)(h, l3, s2);
    var rotlL = (h, l3, s2) => s2 > 32 ? (0, _u64_js_1.rotlBL)(h, l3, s2) : (0, _u64_js_1.rotlSL)(h, l3, s2);
    function keccakP(s2, rounds = 24) {
      const B2 = new Uint32Array(5 * 2);
      for (let round = 24 - rounds; round < 24; round++) {
        for (let x2 = 0; x2 < 10; x2++)
          B2[x2] = s2[x2] ^ s2[x2 + 10] ^ s2[x2 + 20] ^ s2[x2 + 30] ^ s2[x2 + 40];
        for (let x2 = 0; x2 < 10; x2 += 2) {
          const idx1 = (x2 + 8) % 10;
          const idx0 = (x2 + 2) % 10;
          const B0 = B2[idx0];
          const B1 = B2[idx0 + 1];
          const Th = rotlH(B0, B1, 1) ^ B2[idx1];
          const Tl2 = rotlL(B0, B1, 1) ^ B2[idx1 + 1];
          for (let y2 = 0; y2 < 50; y2 += 10) {
            s2[x2 + y2] ^= Th;
            s2[x2 + y2 + 1] ^= Tl2;
          }
        }
        let curH = s2[2];
        let curL = s2[3];
        for (let t2 = 0; t2 < 24; t2++) {
          const shift = SHA3_ROTL[t2];
          const Th = rotlH(curH, curL, shift);
          const Tl2 = rotlL(curH, curL, shift);
          const PI = SHA3_PI[t2];
          curH = s2[PI];
          curL = s2[PI + 1];
          s2[PI] = Th;
          s2[PI + 1] = Tl2;
        }
        for (let y2 = 0; y2 < 50; y2 += 10) {
          for (let x2 = 0; x2 < 10; x2++)
            B2[x2] = s2[y2 + x2];
          for (let x2 = 0; x2 < 10; x2++)
            s2[y2 + x2] ^= ~B2[(x2 + 2) % 10] & B2[(x2 + 4) % 10];
        }
        s2[0] ^= SHA3_IOTA_H[round];
        s2[1] ^= SHA3_IOTA_L[round];
      }
      B2.fill(0);
    }
    exports.keccakP = keccakP;
    var Keccak = class _Keccak extends utils_js_1.Hash {
      // NOTE: we accept arguments in bytes instead of bits here.
      constructor(blockLen, suffix, outputLen, enableXOF = false, rounds = 24) {
        super();
        this.blockLen = blockLen;
        this.suffix = suffix;
        this.outputLen = outputLen;
        this.enableXOF = enableXOF;
        this.rounds = rounds;
        this.pos = 0;
        this.posOut = 0;
        this.finished = false;
        this.destroyed = false;
        (0, _assert_js_1.number)(outputLen);
        if (0 >= this.blockLen || this.blockLen >= 200)
          throw new Error("Sha3 supports only keccak-f1600 function");
        this.state = new Uint8Array(200);
        this.state32 = (0, utils_js_1.u32)(this.state);
      }
      keccak() {
        keccakP(this.state32, this.rounds);
        this.posOut = 0;
        this.pos = 0;
      }
      update(data) {
        (0, _assert_js_1.exists)(this);
        const { blockLen, state } = this;
        data = (0, utils_js_1.toBytes)(data);
        const len = data.length;
        for (let pos = 0; pos < len; ) {
          const take = Math.min(blockLen - this.pos, len - pos);
          for (let i2 = 0; i2 < take; i2++)
            state[this.pos++] ^= data[pos++];
          if (this.pos === blockLen)
            this.keccak();
        }
        return this;
      }
      finish() {
        if (this.finished)
          return;
        this.finished = true;
        const { state, suffix, pos, blockLen } = this;
        state[pos] ^= suffix;
        if ((suffix & 128) !== 0 && pos === blockLen - 1)
          this.keccak();
        state[blockLen - 1] ^= 128;
        this.keccak();
      }
      writeInto(out) {
        (0, _assert_js_1.exists)(this, false);
        (0, _assert_js_1.bytes)(out);
        this.finish();
        const bufferOut = this.state;
        const { blockLen } = this;
        for (let pos = 0, len = out.length; pos < len; ) {
          if (this.posOut >= blockLen)
            this.keccak();
          const take = Math.min(blockLen - this.posOut, len - pos);
          out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
          this.posOut += take;
          pos += take;
        }
        return out;
      }
      xofInto(out) {
        if (!this.enableXOF)
          throw new Error("XOF is not possible for this instance");
        return this.writeInto(out);
      }
      xof(bytes) {
        (0, _assert_js_1.number)(bytes);
        return this.xofInto(new Uint8Array(bytes));
      }
      digestInto(out) {
        (0, _assert_js_1.output)(out, this);
        if (this.finished)
          throw new Error("digest() was already called");
        this.writeInto(out);
        this.destroy();
        return out;
      }
      digest() {
        return this.digestInto(new Uint8Array(this.outputLen));
      }
      destroy() {
        this.destroyed = true;
        this.state.fill(0);
      }
      _cloneInto(to4) {
        const { blockLen, suffix, outputLen, rounds, enableXOF } = this;
        to4 || (to4 = new _Keccak(blockLen, suffix, outputLen, enableXOF, rounds));
        to4.state32.set(this.state32);
        to4.pos = this.pos;
        to4.posOut = this.posOut;
        to4.finished = this.finished;
        to4.rounds = rounds;
        to4.suffix = suffix;
        to4.outputLen = outputLen;
        to4.enableXOF = enableXOF;
        to4.destroyed = this.destroyed;
        return to4;
      }
    };
    exports.Keccak = Keccak;
    var gen = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapConstructor)(() => new Keccak(blockLen, suffix, outputLen));
    exports.sha3_224 = gen(6, 144, 224 / 8);
    exports.sha3_256 = gen(6, 136, 256 / 8);
    exports.sha3_384 = gen(6, 104, 384 / 8);
    exports.sha3_512 = gen(6, 72, 512 / 8);
    exports.keccak_224 = gen(1, 144, 224 / 8);
    exports.keccak_256 = gen(1, 136, 256 / 8);
    exports.keccak_384 = gen(1, 104, 384 / 8);
    exports.keccak_512 = gen(1, 72, 512 / 8);
    var genShake = (suffix, blockLen, outputLen) => (0, utils_js_1.wrapXOFConstructorWithOpts)((opts = {}) => new Keccak(blockLen, suffix, opts.dkLen === void 0 ? outputLen : opts.dkLen, true));
    exports.shake128 = genShake(31, 168, 128 / 8);
    exports.shake256 = genShake(31, 136, 256 / 8);
  }
});

// node_modules/ethers/lib.commonjs/crypto/keccak.js
var require_keccak = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/keccak.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.keccak256 = void 0;
    var sha3_1 = require_sha32();
    var index_js_1 = require_utils5();
    var locked = false;
    var _keccak256 = function(data) {
      return (0, sha3_1.keccak_256)(data);
    };
    var __keccak256 = _keccak256;
    function keccak2563(_data) {
      const data = (0, index_js_1.getBytes)(_data, "data");
      return (0, index_js_1.hexlify)(__keccak256(data));
    }
    exports.keccak256 = keccak2563;
    keccak2563._ = _keccak256;
    keccak2563.lock = function() {
      locked = true;
    };
    keccak2563.register = function(func) {
      if (locked) {
        throw new TypeError("keccak256 is locked");
      }
      __keccak256 = func;
    };
    Object.freeze(keccak2563);
  }
});

// node_modules/ethers/node_modules/@noble/hashes/ripemd160.js
var require_ripemd160 = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/ripemd160.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.RIPEMD160 = void 0;
    var _sha2_js_1 = require_sha2();
    var utils_js_1 = require_utils6();
    var Rho2 = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
    var Id3 = Uint8Array.from({ length: 16 }, (_2, i2) => i2);
    var Pi3 = Id3.map((i2) => (9 * i2 + 5) % 16);
    var idxL2 = [Id3];
    var idxR2 = [Pi3];
    for (let i2 = 0; i2 < 4; i2++)
      for (let j3 of [idxL2, idxR2])
        j3.push(j3[i2].map((k4) => Rho2[k4]));
    var shifts2 = [
      [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
      [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
      [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
      [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
      [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
    ].map((i2) => new Uint8Array(i2));
    var shiftsL2 = idxL2.map((idx, i2) => idx.map((j3) => shifts2[i2][j3]));
    var shiftsR2 = idxR2.map((idx, i2) => idx.map((j3) => shifts2[i2][j3]));
    var Kl3 = new Uint32Array([
      0,
      1518500249,
      1859775393,
      2400959708,
      2840853838
    ]);
    var Kr2 = new Uint32Array([
      1352829926,
      1548603684,
      1836072691,
      2053994217,
      0
    ]);
    var rotl2 = (word, shift) => word << shift | word >>> 32 - shift;
    function f3(group, x2, y2, z3) {
      if (group === 0)
        return x2 ^ y2 ^ z3;
      else if (group === 1)
        return x2 & y2 | ~x2 & z3;
      else if (group === 2)
        return (x2 | ~y2) ^ z3;
      else if (group === 3)
        return x2 & z3 | y2 & ~z3;
      else
        return x2 ^ (y2 | ~z3);
    }
    var BUF = new Uint32Array(16);
    var RIPEMD1602 = class extends _sha2_js_1.SHA2 {
      constructor() {
        super(64, 20, 8, true);
        this.h0 = 1732584193 | 0;
        this.h1 = 4023233417 | 0;
        this.h2 = 2562383102 | 0;
        this.h3 = 271733878 | 0;
        this.h4 = 3285377520 | 0;
      }
      get() {
        const { h0, h1, h2, h3, h4 } = this;
        return [h0, h1, h2, h3, h4];
      }
      set(h0, h1, h2, h3, h4) {
        this.h0 = h0 | 0;
        this.h1 = h1 | 0;
        this.h2 = h2 | 0;
        this.h3 = h3 | 0;
        this.h4 = h4 | 0;
      }
      process(view, offset) {
        for (let i2 = 0; i2 < 16; i2++, offset += 4)
          BUF[i2] = view.getUint32(offset, true);
        let al2 = this.h0 | 0, ar2 = al2, bl2 = this.h1 | 0, br2 = bl2, cl2 = this.h2 | 0, cr2 = cl2, dl2 = this.h3 | 0, dr2 = dl2, el2 = this.h4 | 0, er2 = el2;
        for (let group = 0; group < 5; group++) {
          const rGroup = 4 - group;
          const hbl = Kl3[group], hbr = Kr2[group];
          const rl2 = idxL2[group], rr2 = idxR2[group];
          const sl2 = shiftsL2[group], sr2 = shiftsR2[group];
          for (let i2 = 0; i2 < 16; i2++) {
            const tl2 = rotl2(al2 + f3(group, bl2, cl2, dl2) + BUF[rl2[i2]] + hbl, sl2[i2]) + el2 | 0;
            al2 = el2, el2 = dl2, dl2 = rotl2(cl2, 10) | 0, cl2 = bl2, bl2 = tl2;
          }
          for (let i2 = 0; i2 < 16; i2++) {
            const tr2 = rotl2(ar2 + f3(rGroup, br2, cr2, dr2) + BUF[rr2[i2]] + hbr, sr2[i2]) + er2 | 0;
            ar2 = er2, er2 = dr2, dr2 = rotl2(cr2, 10) | 0, cr2 = br2, br2 = tr2;
          }
        }
        this.set(this.h1 + cl2 + dr2 | 0, this.h2 + dl2 + er2 | 0, this.h3 + el2 + ar2 | 0, this.h4 + al2 + br2 | 0, this.h0 + bl2 + cr2 | 0);
      }
      roundClean() {
        BUF.fill(0);
      }
      destroy() {
        this.destroyed = true;
        this.buffer.fill(0);
        this.set(0, 0, 0, 0, 0);
      }
    };
    exports.RIPEMD160 = RIPEMD1602;
    exports.ripemd160 = (0, utils_js_1.wrapConstructor)(() => new RIPEMD1602());
  }
});

// node_modules/ethers/lib.commonjs/crypto/ripemd160.js
var require_ripemd1602 = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/ripemd160.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = void 0;
    var ripemd160_1 = require_ripemd160();
    var index_js_1 = require_utils5();
    var locked = false;
    var _ripemd160 = function(data) {
      return (0, ripemd160_1.ripemd160)(data);
    };
    var __ripemd160 = _ripemd160;
    function ripemd1602(_data) {
      const data = (0, index_js_1.getBytes)(_data, "data");
      return (0, index_js_1.hexlify)(__ripemd160(data));
    }
    exports.ripemd160 = ripemd1602;
    ripemd1602._ = _ripemd160;
    ripemd1602.lock = function() {
      locked = true;
    };
    ripemd1602.register = function(func) {
      if (locked) {
        throw new TypeError("ripemd160 is locked");
      }
      __ripemd160 = func;
    };
    Object.freeze(ripemd1602);
  }
});

// node_modules/ethers/lib.commonjs/crypto/pbkdf2.js
var require_pbkdf22 = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/pbkdf2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pbkdf2 = void 0;
    var crypto_js_1 = require_crypto_browser();
    var index_js_1 = require_utils5();
    var locked = false;
    var _pbkdf2 = function(password, salt, iterations, keylen, algo) {
      return (0, crypto_js_1.pbkdf2Sync)(password, salt, iterations, keylen, algo);
    };
    var __pbkdf2 = _pbkdf2;
    function pbkdf22(_password, _salt, iterations, keylen, algo) {
      const password = (0, index_js_1.getBytes)(_password, "password");
      const salt = (0, index_js_1.getBytes)(_salt, "salt");
      return (0, index_js_1.hexlify)(__pbkdf2(password, salt, iterations, keylen, algo));
    }
    exports.pbkdf2 = pbkdf22;
    pbkdf22._ = _pbkdf2;
    pbkdf22.lock = function() {
      locked = true;
    };
    pbkdf22.register = function(func) {
      if (locked) {
        throw new Error("pbkdf2 is locked");
      }
      __pbkdf2 = func;
    };
    Object.freeze(pbkdf22);
  }
});

// node_modules/ethers/lib.commonjs/crypto/random.js
var require_random = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomBytes = void 0;
    var crypto_js_1 = require_crypto_browser();
    var locked = false;
    var _randomBytes = function(length2) {
      return new Uint8Array((0, crypto_js_1.randomBytes)(length2));
    };
    var __randomBytes = _randomBytes;
    function randomBytes3(length2) {
      return __randomBytes(length2);
    }
    exports.randomBytes = randomBytes3;
    randomBytes3._ = _randomBytes;
    randomBytes3.lock = function() {
      locked = true;
    };
    randomBytes3.register = function(func) {
      if (locked) {
        throw new Error("randomBytes is locked");
      }
      __randomBytes = func;
    };
    Object.freeze(randomBytes3);
  }
});

// node_modules/ethers/node_modules/@noble/hashes/scrypt.js
var require_scrypt = __commonJS({
  "node_modules/ethers/node_modules/@noble/hashes/scrypt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scryptAsync = exports.scrypt = void 0;
    var _assert_js_1 = require_assert();
    var sha256_js_1 = require_sha256();
    var pbkdf2_js_1 = require_pbkdf2();
    var utils_js_1 = require_utils6();
    var rotl2 = (a3, b4) => a3 << b4 | a3 >>> 32 - b4;
    function XorAndSalsa(prev, pi, input, ii, out, oi) {
      let y00 = prev[pi++] ^ input[ii++], y01 = prev[pi++] ^ input[ii++];
      let y02 = prev[pi++] ^ input[ii++], y03 = prev[pi++] ^ input[ii++];
      let y04 = prev[pi++] ^ input[ii++], y05 = prev[pi++] ^ input[ii++];
      let y06 = prev[pi++] ^ input[ii++], y07 = prev[pi++] ^ input[ii++];
      let y08 = prev[pi++] ^ input[ii++], y09 = prev[pi++] ^ input[ii++];
      let y10 = prev[pi++] ^ input[ii++], y11 = prev[pi++] ^ input[ii++];
      let y12 = prev[pi++] ^ input[ii++], y13 = prev[pi++] ^ input[ii++];
      let y14 = prev[pi++] ^ input[ii++], y15 = prev[pi++] ^ input[ii++];
      let x00 = y00, x01 = y01, x02 = y02, x03 = y03, x04 = y04, x05 = y05, x06 = y06, x07 = y07, x08 = y08, x09 = y09, x10 = y10, x11 = y11, x12 = y12, x13 = y13, x14 = y14, x15 = y15;
      for (let i2 = 0; i2 < 8; i2 += 2) {
        x04 ^= rotl2(x00 + x12 | 0, 7);
        x08 ^= rotl2(x04 + x00 | 0, 9);
        x12 ^= rotl2(x08 + x04 | 0, 13);
        x00 ^= rotl2(x12 + x08 | 0, 18);
        x09 ^= rotl2(x05 + x01 | 0, 7);
        x13 ^= rotl2(x09 + x05 | 0, 9);
        x01 ^= rotl2(x13 + x09 | 0, 13);
        x05 ^= rotl2(x01 + x13 | 0, 18);
        x14 ^= rotl2(x10 + x06 | 0, 7);
        x02 ^= rotl2(x14 + x10 | 0, 9);
        x06 ^= rotl2(x02 + x14 | 0, 13);
        x10 ^= rotl2(x06 + x02 | 0, 18);
        x03 ^= rotl2(x15 + x11 | 0, 7);
        x07 ^= rotl2(x03 + x15 | 0, 9);
        x11 ^= rotl2(x07 + x03 | 0, 13);
        x15 ^= rotl2(x11 + x07 | 0, 18);
        x01 ^= rotl2(x00 + x03 | 0, 7);
        x02 ^= rotl2(x01 + x00 | 0, 9);
        x03 ^= rotl2(x02 + x01 | 0, 13);
        x00 ^= rotl2(x03 + x02 | 0, 18);
        x06 ^= rotl2(x05 + x04 | 0, 7);
        x07 ^= rotl2(x06 + x05 | 0, 9);
        x04 ^= rotl2(x07 + x06 | 0, 13);
        x05 ^= rotl2(x04 + x07 | 0, 18);
        x11 ^= rotl2(x10 + x09 | 0, 7);
        x08 ^= rotl2(x11 + x10 | 0, 9);
        x09 ^= rotl2(x08 + x11 | 0, 13);
        x10 ^= rotl2(x09 + x08 | 0, 18);
        x12 ^= rotl2(x15 + x14 | 0, 7);
        x13 ^= rotl2(x12 + x15 | 0, 9);
        x14 ^= rotl2(x13 + x12 | 0, 13);
        x15 ^= rotl2(x14 + x13 | 0, 18);
      }
      out[oi++] = y00 + x00 | 0;
      out[oi++] = y01 + x01 | 0;
      out[oi++] = y02 + x02 | 0;
      out[oi++] = y03 + x03 | 0;
      out[oi++] = y04 + x04 | 0;
      out[oi++] = y05 + x05 | 0;
      out[oi++] = y06 + x06 | 0;
      out[oi++] = y07 + x07 | 0;
      out[oi++] = y08 + x08 | 0;
      out[oi++] = y09 + x09 | 0;
      out[oi++] = y10 + x10 | 0;
      out[oi++] = y11 + x11 | 0;
      out[oi++] = y12 + x12 | 0;
      out[oi++] = y13 + x13 | 0;
      out[oi++] = y14 + x14 | 0;
      out[oi++] = y15 + x15 | 0;
    }
    function BlockMix(input, ii, out, oi, r2) {
      let head = oi + 0;
      let tail = oi + 16 * r2;
      for (let i2 = 0; i2 < 16; i2++)
        out[tail + i2] = input[ii + (2 * r2 - 1) * 16 + i2];
      for (let i2 = 0; i2 < r2; i2++, head += 16, ii += 16) {
        XorAndSalsa(out, tail, input, ii, out, head);
        if (i2 > 0)
          tail += 16;
        XorAndSalsa(out, head, input, ii += 16, out, tail);
      }
    }
    function scryptInit(password, salt, _opts) {
      const opts = (0, utils_js_1.checkOpts)({
        dkLen: 32,
        asyncTick: 10,
        maxmem: 1024 ** 3 + 1024
      }, _opts);
      const { N: N2, r: r2, p: p2, dkLen, asyncTick, maxmem, onProgress } = opts;
      (0, _assert_js_1.number)(N2);
      (0, _assert_js_1.number)(r2);
      (0, _assert_js_1.number)(p2);
      (0, _assert_js_1.number)(dkLen);
      (0, _assert_js_1.number)(asyncTick);
      (0, _assert_js_1.number)(maxmem);
      if (onProgress !== void 0 && typeof onProgress !== "function")
        throw new Error("progressCb should be function");
      const blockSize = 128 * r2;
      const blockSize32 = blockSize / 4;
      if (N2 <= 1 || (N2 & N2 - 1) !== 0 || N2 >= 2 ** (blockSize / 8) || N2 > 2 ** 32) {
        throw new Error("Scrypt: N must be larger than 1, a power of 2, less than 2^(128 * r / 8) and less than 2^32");
      }
      if (p2 < 0 || p2 > (2 ** 32 - 1) * 32 / blockSize) {
        throw new Error("Scrypt: p must be a positive integer less than or equal to ((2^32 - 1) * 32) / (128 * r)");
      }
      if (dkLen < 0 || dkLen > (2 ** 32 - 1) * 32) {
        throw new Error("Scrypt: dkLen should be positive integer less than or equal to (2^32 - 1) * 32");
      }
      const memUsed = blockSize * (N2 + p2);
      if (memUsed > maxmem) {
        throw new Error(`Scrypt: parameters too large, ${memUsed} (128 * r * (N + p)) > ${maxmem} (maxmem)`);
      }
      const B2 = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, salt, { c: 1, dkLen: blockSize * p2 });
      const B32 = (0, utils_js_1.u32)(B2);
      const V2 = (0, utils_js_1.u32)(new Uint8Array(blockSize * N2));
      const tmp = (0, utils_js_1.u32)(new Uint8Array(blockSize));
      let blockMixCb = () => {
      };
      if (onProgress) {
        const totalBlockMix = 2 * N2 * p2;
        const callbackPer = Math.max(Math.floor(totalBlockMix / 1e4), 1);
        let blockMixCnt = 0;
        blockMixCb = () => {
          blockMixCnt++;
          if (onProgress && (!(blockMixCnt % callbackPer) || blockMixCnt === totalBlockMix))
            onProgress(blockMixCnt / totalBlockMix);
        };
      }
      return { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb, asyncTick };
    }
    function scryptOutput(password, dkLen, B2, V2, tmp) {
      const res = (0, pbkdf2_js_1.pbkdf2)(sha256_js_1.sha256, password, B2, { c: 1, dkLen });
      B2.fill(0);
      V2.fill(0);
      tmp.fill(0);
      return res;
    }
    function scrypt(password, salt, opts) {
      const { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb } = scryptInit(password, salt, opts);
      for (let pi = 0; pi < p2; pi++) {
        const Pi3 = blockSize32 * pi;
        for (let i2 = 0; i2 < blockSize32; i2++)
          V2[i2] = B32[Pi3 + i2];
        for (let i2 = 0, pos = 0; i2 < N2 - 1; i2++) {
          BlockMix(V2, pos, V2, pos += blockSize32, r2);
          blockMixCb();
        }
        BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi3, r2);
        blockMixCb();
        for (let i2 = 0; i2 < N2; i2++) {
          const j3 = B32[Pi3 + blockSize32 - 16] % N2;
          for (let k4 = 0; k4 < blockSize32; k4++)
            tmp[k4] = B32[Pi3 + k4] ^ V2[j3 * blockSize32 + k4];
          BlockMix(tmp, 0, B32, Pi3, r2);
          blockMixCb();
        }
      }
      return scryptOutput(password, dkLen, B2, V2, tmp);
    }
    exports.scrypt = scrypt;
    async function scryptAsync(password, salt, opts) {
      const { N: N2, r: r2, p: p2, dkLen, blockSize32, V: V2, B32, B: B2, tmp, blockMixCb, asyncTick } = scryptInit(password, salt, opts);
      for (let pi = 0; pi < p2; pi++) {
        const Pi3 = blockSize32 * pi;
        for (let i2 = 0; i2 < blockSize32; i2++)
          V2[i2] = B32[Pi3 + i2];
        let pos = 0;
        await (0, utils_js_1.asyncLoop)(N2 - 1, asyncTick, () => {
          BlockMix(V2, pos, V2, pos += blockSize32, r2);
          blockMixCb();
        });
        BlockMix(V2, (N2 - 1) * blockSize32, B32, Pi3, r2);
        blockMixCb();
        await (0, utils_js_1.asyncLoop)(N2, asyncTick, () => {
          const j3 = B32[Pi3 + blockSize32 - 16] % N2;
          for (let k4 = 0; k4 < blockSize32; k4++)
            tmp[k4] = B32[Pi3 + k4] ^ V2[j3 * blockSize32 + k4];
          BlockMix(tmp, 0, B32, Pi3, r2);
          blockMixCb();
        });
      }
      return scryptOutput(password, dkLen, B2, V2, tmp);
    }
    exports.scryptAsync = scryptAsync;
  }
});

// node_modules/ethers/lib.commonjs/crypto/scrypt.js
var require_scrypt2 = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/scrypt.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.scryptSync = exports.scrypt = void 0;
    var scrypt_1 = require_scrypt();
    var index_js_1 = require_utils5();
    var lockedSync = false;
    var lockedAsync = false;
    var _scryptAsync = async function(passwd, salt, N2, r2, p2, dkLen, onProgress) {
      return await (0, scrypt_1.scryptAsync)(passwd, salt, { N: N2, r: r2, p: p2, dkLen, onProgress });
    };
    var _scryptSync = function(passwd, salt, N2, r2, p2, dkLen) {
      return (0, scrypt_1.scrypt)(passwd, salt, { N: N2, r: r2, p: p2, dkLen });
    };
    var __scryptAsync = _scryptAsync;
    var __scryptSync = _scryptSync;
    async function scrypt(_passwd, _salt, N2, r2, p2, dkLen, progress3) {
      const passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
      const salt = (0, index_js_1.getBytes)(_salt, "salt");
      return (0, index_js_1.hexlify)(await __scryptAsync(passwd, salt, N2, r2, p2, dkLen, progress3));
    }
    exports.scrypt = scrypt;
    scrypt._ = _scryptAsync;
    scrypt.lock = function() {
      lockedAsync = true;
    };
    scrypt.register = function(func) {
      if (lockedAsync) {
        throw new Error("scrypt is locked");
      }
      __scryptAsync = func;
    };
    Object.freeze(scrypt);
    function scryptSync(_passwd, _salt, N2, r2, p2, dkLen) {
      const passwd = (0, index_js_1.getBytes)(_passwd, "passwd");
      const salt = (0, index_js_1.getBytes)(_salt, "salt");
      return (0, index_js_1.hexlify)(__scryptSync(passwd, salt, N2, r2, p2, dkLen));
    }
    exports.scryptSync = scryptSync;
    scryptSync._ = _scryptSync;
    scryptSync.lock = function() {
      lockedSync = true;
    };
    scryptSync.register = function(func) {
      if (lockedSync) {
        throw new Error("scryptSync is locked");
      }
      __scryptSync = func;
    };
    Object.freeze(scryptSync);
  }
});

// node_modules/ethers/lib.commonjs/crypto/sha2.js
var require_sha22 = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/sha2.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.sha512 = exports.sha256 = void 0;
    var crypto_js_1 = require_crypto_browser();
    var index_js_1 = require_utils5();
    var _sha256 = function(data) {
      return (0, crypto_js_1.createHash)("sha256").update(data).digest();
    };
    var _sha512 = function(data) {
      return (0, crypto_js_1.createHash)("sha512").update(data).digest();
    };
    var __sha256 = _sha256;
    var __sha512 = _sha512;
    var locked256 = false;
    var locked512 = false;
    function sha2566(_data) {
      const data = (0, index_js_1.getBytes)(_data, "data");
      return (0, index_js_1.hexlify)(__sha256(data));
    }
    exports.sha256 = sha2566;
    sha2566._ = _sha256;
    sha2566.lock = function() {
      locked256 = true;
    };
    sha2566.register = function(func) {
      if (locked256) {
        throw new Error("sha256 is locked");
      }
      __sha256 = func;
    };
    Object.freeze(sha2566);
    function sha5123(_data) {
      const data = (0, index_js_1.getBytes)(_data, "data");
      return (0, index_js_1.hexlify)(__sha512(data));
    }
    exports.sha512 = sha5123;
    sha5123._ = _sha512;
    sha5123.lock = function() {
      locked512 = true;
    };
    sha5123.register = function(func) {
      if (locked512) {
        throw new Error("sha512 is locked");
      }
      __sha512 = func;
    };
    Object.freeze(sha2566);
  }
});

// node_modules/ethers/node_modules/@noble/curves/abstract/utils.js
var require_utils7 = __commonJS({
  "node_modules/ethers/node_modules/@noble/curves/abstract/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateObject = exports.createHmacDrbg = exports.bitMask = exports.bitSet = exports.bitGet = exports.bitLen = exports.utf8ToBytes = exports.equalBytes = exports.concatBytes = exports.ensureBytes = exports.numberToVarBytesBE = exports.numberToBytesLE = exports.numberToBytesBE = exports.bytesToNumberLE = exports.bytesToNumberBE = exports.hexToBytes = exports.hexToNumber = exports.numberToHexUnpadded = exports.bytesToHex = void 0;
    var _0n4 = BigInt(0);
    var _1n4 = BigInt(1);
    var _2n4 = BigInt(2);
    var u8a = (a3) => a3 instanceof Uint8Array;
    var hexes3 = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
    function bytesToHex3(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      let hex3 = "";
      for (let i2 = 0; i2 < bytes.length; i2++) {
        hex3 += hexes3[bytes[i2]];
      }
      return hex3;
    }
    exports.bytesToHex = bytesToHex3;
    function numberToHexUnpadded(num) {
      const hex3 = num.toString(16);
      return hex3.length & 1 ? `0${hex3}` : hex3;
    }
    exports.numberToHexUnpadded = numberToHexUnpadded;
    function hexToNumber2(hex3) {
      if (typeof hex3 !== "string")
        throw new Error("hex string expected, got " + typeof hex3);
      return BigInt(hex3 === "" ? "0" : `0x${hex3}`);
    }
    exports.hexToNumber = hexToNumber2;
    function hexToBytes3(hex3) {
      if (typeof hex3 !== "string")
        throw new Error("hex string expected, got " + typeof hex3);
      const len = hex3.length;
      if (len % 2)
        throw new Error("padded hex string expected, got unpadded hex of length " + len);
      const array = new Uint8Array(len / 2);
      for (let i2 = 0; i2 < array.length; i2++) {
        const j3 = i2 * 2;
        const hexByte = hex3.slice(j3, j3 + 2);
        const byte = Number.parseInt(hexByte, 16);
        if (Number.isNaN(byte) || byte < 0)
          throw new Error("Invalid byte sequence");
        array[i2] = byte;
      }
      return array;
    }
    exports.hexToBytes = hexToBytes3;
    function bytesToNumberBE2(bytes) {
      return hexToNumber2(bytesToHex3(bytes));
    }
    exports.bytesToNumberBE = bytesToNumberBE2;
    function bytesToNumberLE(bytes) {
      if (!u8a(bytes))
        throw new Error("Uint8Array expected");
      return hexToNumber2(bytesToHex3(Uint8Array.from(bytes).reverse()));
    }
    exports.bytesToNumberLE = bytesToNumberLE;
    function numberToBytesBE2(n2, len) {
      return hexToBytes3(n2.toString(16).padStart(len * 2, "0"));
    }
    exports.numberToBytesBE = numberToBytesBE2;
    function numberToBytesLE(n2, len) {
      return numberToBytesBE2(n2, len).reverse();
    }
    exports.numberToBytesLE = numberToBytesLE;
    function numberToVarBytesBE(n2) {
      return hexToBytes3(numberToHexUnpadded(n2));
    }
    exports.numberToVarBytesBE = numberToVarBytesBE;
    function ensureBytes2(title, hex3, expectedLength) {
      let res;
      if (typeof hex3 === "string") {
        try {
          res = hexToBytes3(hex3);
        } catch (e2) {
          throw new Error(`${title} must be valid hex string, got "${hex3}". Cause: ${e2}`);
        }
      } else if (u8a(hex3)) {
        res = Uint8Array.from(hex3);
      } else {
        throw new Error(`${title} must be hex string or Uint8Array`);
      }
      const len = res.length;
      if (typeof expectedLength === "number" && len !== expectedLength)
        throw new Error(`${title} expected ${expectedLength} bytes, got ${len}`);
      return res;
    }
    exports.ensureBytes = ensureBytes2;
    function concatBytes3(...arrays) {
      const r2 = new Uint8Array(arrays.reduce((sum, a3) => sum + a3.length, 0));
      let pad2 = 0;
      arrays.forEach((a3) => {
        if (!u8a(a3))
          throw new Error("Uint8Array expected");
        r2.set(a3, pad2);
        pad2 += a3.length;
      });
      return r2;
    }
    exports.concatBytes = concatBytes3;
    function equalBytes(b1, b22) {
      if (b1.length !== b22.length)
        return false;
      for (let i2 = 0; i2 < b1.length; i2++)
        if (b1[i2] !== b22[i2])
          return false;
      return true;
    }
    exports.equalBytes = equalBytes;
    function utf8ToBytes3(str) {
      if (typeof str !== "string")
        throw new Error(`utf8ToBytes expected string, got ${typeof str}`);
      return new Uint8Array(new TextEncoder().encode(str));
    }
    exports.utf8ToBytes = utf8ToBytes3;
    function bitLen2(n2) {
      let len;
      for (len = 0; n2 > _0n4; n2 >>= _1n4, len += 1)
        ;
      return len;
    }
    exports.bitLen = bitLen2;
    function bitGet2(n2, pos) {
      return n2 >> BigInt(pos) & _1n4;
    }
    exports.bitGet = bitGet2;
    var bitSet = (n2, pos, value) => {
      return n2 | (value ? _1n4 : _0n4) << BigInt(pos);
    };
    exports.bitSet = bitSet;
    var bitMask2 = (n2) => (_2n4 << BigInt(n2 - 1)) - _1n4;
    exports.bitMask = bitMask2;
    var u8n = (data) => new Uint8Array(data);
    var u8fr = (arr) => Uint8Array.from(arr);
    function createHmacDrbg(hashLen, qByteLen, hmacFn) {
      if (typeof hashLen !== "number" || hashLen < 2)
        throw new Error("hashLen must be a number");
      if (typeof qByteLen !== "number" || qByteLen < 2)
        throw new Error("qByteLen must be a number");
      if (typeof hmacFn !== "function")
        throw new Error("hmacFn must be a function");
      let v2 = u8n(hashLen);
      let k4 = u8n(hashLen);
      let i2 = 0;
      const reset2 = () => {
        v2.fill(1);
        k4.fill(0);
        i2 = 0;
      };
      const h = (...b4) => hmacFn(k4, v2, ...b4);
      const reseed = (seed = u8n()) => {
        k4 = h(u8fr([0]), seed);
        v2 = h();
        if (seed.length === 0)
          return;
        k4 = h(u8fr([1]), seed);
        v2 = h();
      };
      const gen = () => {
        if (i2++ >= 1e3)
          throw new Error("drbg: tried 1000 values");
        let len = 0;
        const out = [];
        while (len < qByteLen) {
          v2 = h();
          const sl2 = v2.slice();
          out.push(sl2);
          len += v2.length;
        }
        return concatBytes3(...out);
      };
      const genUntil = (seed, pred) => {
        reset2();
        reseed(seed);
        let res = void 0;
        while (!(res = pred(gen())))
          reseed();
        reset2();
        return res;
      };
      return genUntil;
    }
    exports.createHmacDrbg = createHmacDrbg;
    var validatorFns = {
      bigint: (val) => typeof val === "bigint",
      function: (val) => typeof val === "function",
      boolean: (val) => typeof val === "boolean",
      string: (val) => typeof val === "string",
      stringOrUint8Array: (val) => typeof val === "string" || val instanceof Uint8Array,
      isSafeInteger: (val) => Number.isSafeInteger(val),
      array: (val) => Array.isArray(val),
      field: (val, object) => object.Fp.isValid(val),
      hash: (val) => typeof val === "function" && Number.isSafeInteger(val.outputLen)
    };
    function validateObject(object, validators3, optValidators = {}) {
      const checkField = (fieldName, type6, isOptional) => {
        const checkVal = validatorFns[type6];
        if (typeof checkVal !== "function")
          throw new Error(`Invalid validator "${type6}", expected function`);
        const val = object[fieldName];
        if (isOptional && val === void 0)
          return;
        if (!checkVal(val, object)) {
          throw new Error(`Invalid param ${String(fieldName)}=${val} (${typeof val}), expected ${type6}`);
        }
      };
      for (const [fieldName, type6] of Object.entries(validators3))
        checkField(fieldName, type6, false);
      for (const [fieldName, type6] of Object.entries(optValidators))
        checkField(fieldName, type6, true);
      return object;
    }
    exports.validateObject = validateObject;
  }
});

// node_modules/ethers/node_modules/@noble/curves/abstract/modular.js
var require_modular = __commonJS({
  "node_modules/ethers/node_modules/@noble/curves/abstract/modular.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapHashToField = exports.getMinHashLength = exports.getFieldBytesLength = exports.hashToPrivateScalar = exports.FpSqrtEven = exports.FpSqrtOdd = exports.Field = exports.nLength = exports.FpIsSquare = exports.FpDiv = exports.FpInvertBatch = exports.FpPow = exports.validateField = exports.isNegativeLE = exports.FpSqrt = exports.tonelliShanks = exports.invert = exports.pow2 = exports.pow = exports.mod = void 0;
    var utils_js_1 = require_utils7();
    var _0n4 = BigInt(0);
    var _1n4 = BigInt(1);
    var _2n4 = BigInt(2);
    var _3n4 = BigInt(3);
    var _4n2 = BigInt(4);
    var _5n = BigInt(5);
    var _8n = BigInt(8);
    var _9n = BigInt(9);
    var _16n = BigInt(16);
    function mod2(a3, b4) {
      const result = a3 % b4;
      return result >= _0n4 ? result : b4 + result;
    }
    exports.mod = mod2;
    function pow(num, power, modulo) {
      if (modulo <= _0n4 || power < _0n4)
        throw new Error("Expected power/modulo > 0");
      if (modulo === _1n4)
        return _0n4;
      let res = _1n4;
      while (power > _0n4) {
        if (power & _1n4)
          res = res * num % modulo;
        num = num * num % modulo;
        power >>= _1n4;
      }
      return res;
    }
    exports.pow = pow;
    function pow2(x2, power, modulo) {
      let res = x2;
      while (power-- > _0n4) {
        res *= res;
        res %= modulo;
      }
      return res;
    }
    exports.pow2 = pow2;
    function invert(number2, modulo) {
      if (number2 === _0n4 || modulo <= _0n4) {
        throw new Error(`invert: expected positive integers, got n=${number2} mod=${modulo}`);
      }
      let a3 = mod2(number2, modulo);
      let b4 = modulo;
      let x2 = _0n4, y2 = _1n4, u3 = _1n4, v2 = _0n4;
      while (a3 !== _0n4) {
        const q3 = b4 / a3;
        const r2 = b4 % a3;
        const m3 = x2 - u3 * q3;
        const n2 = y2 - v2 * q3;
        b4 = a3, a3 = r2, x2 = u3, y2 = v2, u3 = m3, v2 = n2;
      }
      const gcd2 = b4;
      if (gcd2 !== _1n4)
        throw new Error("invert: does not exist");
      return mod2(x2, modulo);
    }
    exports.invert = invert;
    function tonelliShanks(P) {
      const legendreC = (P - _1n4) / _2n4;
      let Q2, S2, Z2;
      for (Q2 = P - _1n4, S2 = 0; Q2 % _2n4 === _0n4; Q2 /= _2n4, S2++)
        ;
      for (Z2 = _2n4; Z2 < P && pow(Z2, legendreC, P) !== P - _1n4; Z2++)
        ;
      if (S2 === 1) {
        const p1div4 = (P + _1n4) / _4n2;
        return function tonelliFast(Fp3, n2) {
          const root2 = Fp3.pow(n2, p1div4);
          if (!Fp3.eql(Fp3.sqr(root2), n2))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      const Q1div2 = (Q2 + _1n4) / _2n4;
      return function tonelliSlow(Fp3, n2) {
        if (Fp3.pow(n2, legendreC) === Fp3.neg(Fp3.ONE))
          throw new Error("Cannot find square root");
        let r2 = S2;
        let g3 = Fp3.pow(Fp3.mul(Fp3.ONE, Z2), Q2);
        let x2 = Fp3.pow(n2, Q1div2);
        let b4 = Fp3.pow(n2, Q2);
        while (!Fp3.eql(b4, Fp3.ONE)) {
          if (Fp3.eql(b4, Fp3.ZERO))
            return Fp3.ZERO;
          let m3 = 1;
          for (let t2 = Fp3.sqr(b4); m3 < r2; m3++) {
            if (Fp3.eql(t2, Fp3.ONE))
              break;
            t2 = Fp3.sqr(t2);
          }
          const ge3 = Fp3.pow(g3, _1n4 << BigInt(r2 - m3 - 1));
          g3 = Fp3.sqr(ge3);
          x2 = Fp3.mul(x2, ge3);
          b4 = Fp3.mul(b4, g3);
          r2 = m3;
        }
        return x2;
      };
    }
    exports.tonelliShanks = tonelliShanks;
    function FpSqrt(P) {
      if (P % _4n2 === _3n4) {
        const p1div4 = (P + _1n4) / _4n2;
        return function sqrt3mod4(Fp3, n2) {
          const root2 = Fp3.pow(n2, p1div4);
          if (!Fp3.eql(Fp3.sqr(root2), n2))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      if (P % _8n === _5n) {
        const c1 = (P - _5n) / _8n;
        return function sqrt5mod8(Fp3, n2) {
          const n22 = Fp3.mul(n2, _2n4);
          const v2 = Fp3.pow(n22, c1);
          const nv = Fp3.mul(n2, v2);
          const i2 = Fp3.mul(Fp3.mul(nv, _2n4), v2);
          const root2 = Fp3.mul(nv, Fp3.sub(i2, Fp3.ONE));
          if (!Fp3.eql(Fp3.sqr(root2), n2))
            throw new Error("Cannot find square root");
          return root2;
        };
      }
      if (P % _16n === _9n) {
      }
      return tonelliShanks(P);
    }
    exports.FpSqrt = FpSqrt;
    var isNegativeLE = (num, modulo) => (mod2(num, modulo) & _1n4) === _1n4;
    exports.isNegativeLE = isNegativeLE;
    var FIELD_FIELDS = [
      "create",
      "isValid",
      "is0",
      "neg",
      "inv",
      "sqrt",
      "sqr",
      "eql",
      "add",
      "sub",
      "mul",
      "pow",
      "div",
      "addN",
      "subN",
      "mulN",
      "sqrN"
    ];
    function validateField(field) {
      const initial = {
        ORDER: "bigint",
        MASK: "bigint",
        BYTES: "isSafeInteger",
        BITS: "isSafeInteger"
      };
      const opts = FIELD_FIELDS.reduce((map, val) => {
        map[val] = "function";
        return map;
      }, initial);
      return (0, utils_js_1.validateObject)(field, opts);
    }
    exports.validateField = validateField;
    function FpPow2(f3, num, power) {
      if (power < _0n4)
        throw new Error("Expected power > 0");
      if (power === _0n4)
        return f3.ONE;
      if (power === _1n4)
        return num;
      let p2 = f3.ONE;
      let d2 = num;
      while (power > _0n4) {
        if (power & _1n4)
          p2 = f3.mul(p2, d2);
        d2 = f3.sqr(d2);
        power >>= _1n4;
      }
      return p2;
    }
    exports.FpPow = FpPow2;
    function FpInvertBatch2(f3, nums) {
      const tmp = new Array(nums.length);
      const lastMultiplied = nums.reduce((acc, num, i2) => {
        if (f3.is0(num))
          return acc;
        tmp[i2] = acc;
        return f3.mul(acc, num);
      }, f3.ONE);
      const inverted = f3.inv(lastMultiplied);
      nums.reduceRight((acc, num, i2) => {
        if (f3.is0(num))
          return acc;
        tmp[i2] = f3.mul(acc, tmp[i2]);
        return f3.mul(acc, num);
      }, inverted);
      return tmp;
    }
    exports.FpInvertBatch = FpInvertBatch2;
    function FpDiv(f3, lhs, rhs) {
      return f3.mul(lhs, typeof rhs === "bigint" ? invert(rhs, f3.ORDER) : f3.inv(rhs));
    }
    exports.FpDiv = FpDiv;
    function FpIsSquare(f3) {
      const legendreConst = (f3.ORDER - _1n4) / _2n4;
      return (x2) => {
        const p2 = f3.pow(x2, legendreConst);
        return f3.eql(p2, f3.ZERO) || f3.eql(p2, f3.ONE);
      };
    }
    exports.FpIsSquare = FpIsSquare;
    function nLength(n2, nBitLength) {
      const _nBitLength = nBitLength !== void 0 ? nBitLength : n2.toString(2).length;
      const nByteLength = Math.ceil(_nBitLength / 8);
      return { nBitLength: _nBitLength, nByteLength };
    }
    exports.nLength = nLength;
    function Field2(ORDER, bitLen2, isLE3 = false, redef = {}) {
      if (ORDER <= _0n4)
        throw new Error(`Expected Field ORDER > 0, got ${ORDER}`);
      const { nBitLength: BITS, nByteLength: BYTES } = nLength(ORDER, bitLen2);
      if (BYTES > 2048)
        throw new Error("Field lengths over 2048 bytes are not supported");
      const sqrtP = FpSqrt(ORDER);
      const f3 = Object.freeze({
        ORDER,
        BITS,
        BYTES,
        MASK: (0, utils_js_1.bitMask)(BITS),
        ZERO: _0n4,
        ONE: _1n4,
        create: (num) => mod2(num, ORDER),
        isValid: (num) => {
          if (typeof num !== "bigint")
            throw new Error(`Invalid field element: expected bigint, got ${typeof num}`);
          return _0n4 <= num && num < ORDER;
        },
        is0: (num) => num === _0n4,
        isOdd: (num) => (num & _1n4) === _1n4,
        neg: (num) => mod2(-num, ORDER),
        eql: (lhs, rhs) => lhs === rhs,
        sqr: (num) => mod2(num * num, ORDER),
        add: (lhs, rhs) => mod2(lhs + rhs, ORDER),
        sub: (lhs, rhs) => mod2(lhs - rhs, ORDER),
        mul: (lhs, rhs) => mod2(lhs * rhs, ORDER),
        pow: (num, power) => FpPow2(f3, num, power),
        div: (lhs, rhs) => mod2(lhs * invert(rhs, ORDER), ORDER),
        // Same as above, but doesn't normalize
        sqrN: (num) => num * num,
        addN: (lhs, rhs) => lhs + rhs,
        subN: (lhs, rhs) => lhs - rhs,
        mulN: (lhs, rhs) => lhs * rhs,
        inv: (num) => invert(num, ORDER),
        sqrt: redef.sqrt || ((n2) => sqrtP(f3, n2)),
        invertBatch: (lst) => FpInvertBatch2(f3, lst),
        // TODO: do we really need constant cmov?
        // We don't have const-time bigints anyway, so probably will be not very useful
        cmov: (a3, b4, c3) => c3 ? b4 : a3,
        toBytes: (num) => isLE3 ? (0, utils_js_1.numberToBytesLE)(num, BYTES) : (0, utils_js_1.numberToBytesBE)(num, BYTES),
        fromBytes: (bytes) => {
          if (bytes.length !== BYTES)
            throw new Error(`Fp.fromBytes: expected ${BYTES}, got ${bytes.length}`);
          return isLE3 ? (0, utils_js_1.bytesToNumberLE)(bytes) : (0, utils_js_1.bytesToNumberBE)(bytes);
        }
      });
      return Object.freeze(f3);
    }
    exports.Field = Field2;
    function FpSqrtOdd(Fp3, elm) {
      if (!Fp3.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root2 = Fp3.sqrt(elm);
      return Fp3.isOdd(root2) ? root2 : Fp3.neg(root2);
    }
    exports.FpSqrtOdd = FpSqrtOdd;
    function FpSqrtEven(Fp3, elm) {
      if (!Fp3.isOdd)
        throw new Error(`Field doesn't have isOdd`);
      const root2 = Fp3.sqrt(elm);
      return Fp3.isOdd(root2) ? Fp3.neg(root2) : root2;
    }
    exports.FpSqrtEven = FpSqrtEven;
    function hashToPrivateScalar(hash8, groupOrder, isLE3 = false) {
      hash8 = (0, utils_js_1.ensureBytes)("privateHash", hash8);
      const hashLen = hash8.length;
      const minLen = nLength(groupOrder).nByteLength + 8;
      if (minLen < 24 || hashLen < minLen || hashLen > 1024)
        throw new Error(`hashToPrivateScalar: expected ${minLen}-1024 bytes of input, got ${hashLen}`);
      const num = isLE3 ? (0, utils_js_1.bytesToNumberLE)(hash8) : (0, utils_js_1.bytesToNumberBE)(hash8);
      return mod2(num, groupOrder - _1n4) + _1n4;
    }
    exports.hashToPrivateScalar = hashToPrivateScalar;
    function getFieldBytesLength(fieldOrder) {
      if (typeof fieldOrder !== "bigint")
        throw new Error("field order must be bigint");
      const bitLength = fieldOrder.toString(2).length;
      return Math.ceil(bitLength / 8);
    }
    exports.getFieldBytesLength = getFieldBytesLength;
    function getMinHashLength2(fieldOrder) {
      const length2 = getFieldBytesLength(fieldOrder);
      return length2 + Math.ceil(length2 / 2);
    }
    exports.getMinHashLength = getMinHashLength2;
    function mapHashToField2(key, fieldOrder, isLE3 = false) {
      const len = key.length;
      const fieldLen = getFieldBytesLength(fieldOrder);
      const minLen = getMinHashLength2(fieldOrder);
      if (len < 16 || len < minLen || len > 1024)
        throw new Error(`expected ${minLen}-1024 bytes of input, got ${len}`);
      const num = isLE3 ? (0, utils_js_1.bytesToNumberBE)(key) : (0, utils_js_1.bytesToNumberLE)(key);
      const reduced = mod2(num, fieldOrder - _1n4) + _1n4;
      return isLE3 ? (0, utils_js_1.numberToBytesLE)(reduced, fieldLen) : (0, utils_js_1.numberToBytesBE)(reduced, fieldLen);
    }
    exports.mapHashToField = mapHashToField2;
  }
});

// node_modules/ethers/node_modules/@noble/curves/abstract/curve.js
var require_curve = __commonJS({
  "node_modules/ethers/node_modules/@noble/curves/abstract/curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.validateBasic = exports.wNAF = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils7();
    var _0n4 = BigInt(0);
    var _1n4 = BigInt(1);
    function wNAF(c3, bits) {
      const constTimeNegate = (condition, item) => {
        const neg = item.negate();
        return condition ? neg : item;
      };
      const opts = (W3) => {
        const windows = Math.ceil(bits / W3) + 1;
        const windowSize = 2 ** (W3 - 1);
        return { windows, windowSize };
      };
      return {
        constTimeNegate,
        // non-const time multiplication ladder
        unsafeLadder(elm, n2) {
          let p2 = c3.ZERO;
          let d2 = elm;
          while (n2 > _0n4) {
            if (n2 & _1n4)
              p2 = p2.add(d2);
            d2 = d2.double();
            n2 >>= _1n4;
          }
          return p2;
        },
        /**
         * Creates a wNAF precomputation window. Used for caching.
         * Default window size is set by `utils.precompute()` and is equal to 8.
         * Number of precomputed points depends on the curve size:
         * 2^(1) * (Math.ceil( / ) + 1), where:
         * -  is the window size
         * -  is the bitlength of the curve order.
         * For a 256-bit curve and window size 8, the number of precomputed points is 128 * 33 = 4224.
         * @returns precomputed point tables flattened to a single array
         */
        precomputeWindow(elm, W3) {
          const { windows, windowSize } = opts(W3);
          const points = [];
          let p2 = elm;
          let base3 = p2;
          for (let window2 = 0; window2 < windows; window2++) {
            base3 = p2;
            points.push(base3);
            for (let i2 = 1; i2 < windowSize; i2++) {
              base3 = base3.add(p2);
              points.push(base3);
            }
            p2 = base3.double();
          }
          return points;
        },
        /**
         * Implements ec multiplication using precomputed tables and w-ary non-adjacent form.
         * @param W window size
         * @param precomputes precomputed tables
         * @param n scalar (we don't check here, but should be less than curve order)
         * @returns real and fake (for const-time) points
         */
        wNAF(W3, precomputes, n2) {
          const { windows, windowSize } = opts(W3);
          let p2 = c3.ZERO;
          let f3 = c3.BASE;
          const mask = BigInt(2 ** W3 - 1);
          const maxNumber = 2 ** W3;
          const shiftBy = BigInt(W3);
          for (let window2 = 0; window2 < windows; window2++) {
            const offset = window2 * windowSize;
            let wbits = Number(n2 & mask);
            n2 >>= shiftBy;
            if (wbits > windowSize) {
              wbits -= maxNumber;
              n2 += _1n4;
            }
            const offset1 = offset;
            const offset2 = offset + Math.abs(wbits) - 1;
            const cond1 = window2 % 2 !== 0;
            const cond2 = wbits < 0;
            if (wbits === 0) {
              f3 = f3.add(constTimeNegate(cond1, precomputes[offset1]));
            } else {
              p2 = p2.add(constTimeNegate(cond2, precomputes[offset2]));
            }
          }
          return { p: p2, f: f3 };
        },
        wNAFCached(P, precomputesMap, n2, transform2) {
          const W3 = P._WINDOW_SIZE || 1;
          let comp = precomputesMap.get(P);
          if (!comp) {
            comp = this.precomputeWindow(P, W3);
            if (W3 !== 1) {
              precomputesMap.set(P, transform2(comp));
            }
          }
          return this.wNAF(W3, comp, n2);
        }
      };
    }
    exports.wNAF = wNAF;
    function validateBasic(curve) {
      (0, modular_js_1.validateField)(curve.Fp);
      (0, utils_js_1.validateObject)(curve, {
        n: "bigint",
        h: "bigint",
        Gx: "field",
        Gy: "field"
      }, {
        nBitLength: "isSafeInteger",
        nByteLength: "isSafeInteger"
      });
      return Object.freeze({
        ...(0, modular_js_1.nLength)(curve.n, curve.nBitLength),
        ...curve,
        ...{ p: curve.Fp.ORDER }
      });
    }
    exports.validateBasic = validateBasic;
  }
});

// node_modules/ethers/node_modules/@noble/curves/abstract/weierstrass.js
var require_weierstrass = __commonJS({
  "node_modules/ethers/node_modules/@noble/curves/abstract/weierstrass.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.mapToCurveSimpleSWU = exports.SWUFpSqrtRatio = exports.weierstrass = exports.weierstrassPoints = exports.DER = void 0;
    var mod2 = require_modular();
    var ut2 = require_utils7();
    var utils_js_1 = require_utils7();
    var curve_js_1 = require_curve();
    function validatePointOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut2.validateObject(opts, {
        a: "field",
        b: "field"
      }, {
        allowedPrivateKeyLengths: "array",
        wrapPrivateKey: "boolean",
        isTorsionFree: "function",
        clearCofactor: "function",
        allowInfinityPoint: "boolean",
        fromBytes: "function",
        toBytes: "function"
      });
      const { endo, Fp: Fp3, a: a3 } = opts;
      if (endo) {
        if (!Fp3.eql(a3, Fp3.ZERO)) {
          throw new Error("Endomorphism can only be defined for Koblitz curves that have a=0");
        }
        if (typeof endo !== "object" || typeof endo.beta !== "bigint" || typeof endo.splitScalar !== "function") {
          throw new Error("Expected endomorphism with beta: bigint and splitScalar: function");
        }
      }
      return Object.freeze({ ...opts });
    }
    var { bytesToNumberBE: b2n, hexToBytes: h2b } = ut2;
    exports.DER = {
      // asn.1 DER encoding utils
      Err: class DERErr extends Error {
        constructor(m3 = "") {
          super(m3);
        }
      },
      _parseInt(data) {
        const { Err: E3 } = exports.DER;
        if (data.length < 2 || data[0] !== 2)
          throw new E3("Invalid signature integer tag");
        const len = data[1];
        const res = data.subarray(2, len + 2);
        if (!len || res.length !== len)
          throw new E3("Invalid signature integer: wrong length");
        if (res[0] & 128)
          throw new E3("Invalid signature integer: negative");
        if (res[0] === 0 && !(res[1] & 128))
          throw new E3("Invalid signature integer: unnecessary leading zero");
        return { d: b2n(res), l: data.subarray(len + 2) };
      },
      toSig(hex3) {
        const { Err: E3 } = exports.DER;
        const data = typeof hex3 === "string" ? h2b(hex3) : hex3;
        if (!(data instanceof Uint8Array))
          throw new Error("ui8a expected");
        let l3 = data.length;
        if (l3 < 2 || data[0] != 48)
          throw new E3("Invalid signature tag");
        if (data[1] !== l3 - 2)
          throw new E3("Invalid signature: incorrect length");
        const { d: r2, l: sBytes } = exports.DER._parseInt(data.subarray(2));
        const { d: s2, l: rBytesLeft } = exports.DER._parseInt(sBytes);
        if (rBytesLeft.length)
          throw new E3("Invalid signature: left bytes after parsing");
        return { r: r2, s: s2 };
      },
      hexFromSig(sig) {
        const slice3 = (s3) => Number.parseInt(s3[0], 16) & 8 ? "00" + s3 : s3;
        const h = (num) => {
          const hex3 = num.toString(16);
          return hex3.length & 1 ? `0${hex3}` : hex3;
        };
        const s2 = slice3(h(sig.s));
        const r2 = slice3(h(sig.r));
        const shl = s2.length / 2;
        const rhl = r2.length / 2;
        const sl2 = h(shl);
        const rl2 = h(rhl);
        return `30${h(rhl + shl + 4)}02${rl2}${r2}02${sl2}${s2}`;
      }
    };
    var _0n4 = BigInt(0);
    var _1n4 = BigInt(1);
    var _2n4 = BigInt(2);
    var _3n4 = BigInt(3);
    var _4n2 = BigInt(4);
    function weierstrassPoints2(opts) {
      const CURVE = validatePointOpts(opts);
      const { Fp: Fp3 } = CURVE;
      const toBytes13 = CURVE.toBytes || ((_c2, point, _isCompressed) => {
        const a3 = point.toAffine();
        return ut2.concatBytes(Uint8Array.from([4]), Fp3.toBytes(a3.x), Fp3.toBytes(a3.y));
      });
      const fromBytes7 = CURVE.fromBytes || ((bytes) => {
        const tail = bytes.subarray(1);
        const x2 = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
        const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
        return { x: x2, y: y2 };
      });
      function weierstrassEquation(x2) {
        const { a: a3, b: b4 } = CURVE;
        const x22 = Fp3.sqr(x2);
        const x3 = Fp3.mul(x22, x2);
        return Fp3.add(Fp3.add(x3, Fp3.mul(x2, a3)), b4);
      }
      if (!Fp3.eql(Fp3.sqr(CURVE.Gy), weierstrassEquation(CURVE.Gx)))
        throw new Error("bad generator point: equation left != right");
      function isWithinCurveOrder(num) {
        return typeof num === "bigint" && _0n4 < num && num < CURVE.n;
      }
      function assertGE(num) {
        if (!isWithinCurveOrder(num))
          throw new Error("Expected valid bigint: 0 < bigint < curve.n");
      }
      function normPrivateKeyToScalar(key) {
        const { allowedPrivateKeyLengths: lengths, nByteLength, wrapPrivateKey, n: n2 } = CURVE;
        if (lengths && typeof key !== "bigint") {
          if (key instanceof Uint8Array)
            key = ut2.bytesToHex(key);
          if (typeof key !== "string" || !lengths.includes(key.length))
            throw new Error("Invalid key");
          key = key.padStart(nByteLength * 2, "0");
        }
        let num;
        try {
          num = typeof key === "bigint" ? key : ut2.bytesToNumberBE((0, utils_js_1.ensureBytes)("private key", key, nByteLength));
        } catch (error) {
          throw new Error(`private key must be ${nByteLength} bytes, hex or bigint, not ${typeof key}`);
        }
        if (wrapPrivateKey)
          num = mod2.mod(num, n2);
        assertGE(num);
        return num;
      }
      const pointPrecomputes = /* @__PURE__ */ new Map();
      function assertPrjPoint(other) {
        if (!(other instanceof Point2))
          throw new Error("ProjectivePoint expected");
      }
      class Point2 {
        constructor(px2, py, pz) {
          this.px = px2;
          this.py = py;
          this.pz = pz;
          if (px2 == null || !Fp3.isValid(px2))
            throw new Error("x required");
          if (py == null || !Fp3.isValid(py))
            throw new Error("y required");
          if (pz == null || !Fp3.isValid(pz))
            throw new Error("z required");
        }
        // Does not validate if the point is on-curve.
        // Use fromHex instead, or call assertValidity() later.
        static fromAffine(p2) {
          const { x: x2, y: y2 } = p2 || {};
          if (!p2 || !Fp3.isValid(x2) || !Fp3.isValid(y2))
            throw new Error("invalid affine point");
          if (p2 instanceof Point2)
            throw new Error("projective point not allowed");
          const is0 = (i2) => Fp3.eql(i2, Fp3.ZERO);
          if (is0(x2) && is0(y2))
            return Point2.ZERO;
          return new Point2(x2, y2, Fp3.ONE);
        }
        get x() {
          return this.toAffine().x;
        }
        get y() {
          return this.toAffine().y;
        }
        /**
         * Takes a bunch of Projective Points but executes only one
         * inversion on all of them. Inversion is very slow operation,
         * so this improves performance massively.
         * Optimization: converts a list of projective points to a list of identical points with Z=1.
         */
        static normalizeZ(points) {
          const toInv = Fp3.invertBatch(points.map((p2) => p2.pz));
          return points.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
        }
        /**
         * Converts hash string or Uint8Array to Point.
         * @param hex short/long ECDSA hex
         */
        static fromHex(hex3) {
          const P = Point2.fromAffine(fromBytes7((0, utils_js_1.ensureBytes)("pointHex", hex3)));
          P.assertValidity();
          return P;
        }
        // Multiplies generator point by privateKey.
        static fromPrivateKey(privateKey) {
          return Point2.BASE.multiply(normPrivateKeyToScalar(privateKey));
        }
        // "Private method", don't use it directly
        _setWindowSize(windowSize) {
          this._WINDOW_SIZE = windowSize;
          pointPrecomputes.delete(this);
        }
        // A point on curve is valid if it conforms to equation.
        assertValidity() {
          if (this.is0()) {
            if (CURVE.allowInfinityPoint && !Fp3.is0(this.py))
              return;
            throw new Error("bad point: ZERO");
          }
          const { x: x2, y: y2 } = this.toAffine();
          if (!Fp3.isValid(x2) || !Fp3.isValid(y2))
            throw new Error("bad point: x or y not FE");
          const left = Fp3.sqr(y2);
          const right = weierstrassEquation(x2);
          if (!Fp3.eql(left, right))
            throw new Error("bad point: equation left != right");
          if (!this.isTorsionFree())
            throw new Error("bad point: not in prime-order subgroup");
        }
        hasEvenY() {
          const { y: y2 } = this.toAffine();
          if (Fp3.isOdd)
            return !Fp3.isOdd(y2);
          throw new Error("Field doesn't support isOdd");
        }
        /**
         * Compare one point to another.
         */
        equals(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X22, py: Y2, pz: Z2 } = other;
          const U1 = Fp3.eql(Fp3.mul(X1, Z2), Fp3.mul(X22, Z1));
          const U2 = Fp3.eql(Fp3.mul(Y1, Z2), Fp3.mul(Y2, Z1));
          return U1 && U2;
        }
        /**
         * Flips point to one corresponding to (x, -y) in Affine coordinates.
         */
        negate() {
          return new Point2(this.px, Fp3.neg(this.py), this.pz);
        }
        // Renes-Costello-Batina exception-free doubling formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 3
        // Cost: 8M + 3S + 3*a + 2*b3 + 15add.
        double() {
          const { a: a3, b: b4 } = CURVE;
          const b32 = Fp3.mul(b4, _3n4);
          const { px: X1, py: Y1, pz: Z1 } = this;
          let X32 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
          let t0 = Fp3.mul(X1, X1);
          let t1 = Fp3.mul(Y1, Y1);
          let t2 = Fp3.mul(Z1, Z1);
          let t3 = Fp3.mul(X1, Y1);
          t3 = Fp3.add(t3, t3);
          Z3 = Fp3.mul(X1, Z1);
          Z3 = Fp3.add(Z3, Z3);
          X32 = Fp3.mul(a3, Z3);
          Y3 = Fp3.mul(b32, t2);
          Y3 = Fp3.add(X32, Y3);
          X32 = Fp3.sub(t1, Y3);
          Y3 = Fp3.add(t1, Y3);
          Y3 = Fp3.mul(X32, Y3);
          X32 = Fp3.mul(t3, X32);
          Z3 = Fp3.mul(b32, Z3);
          t2 = Fp3.mul(a3, t2);
          t3 = Fp3.sub(t0, t2);
          t3 = Fp3.mul(a3, t3);
          t3 = Fp3.add(t3, Z3);
          Z3 = Fp3.add(t0, t0);
          t0 = Fp3.add(Z3, t0);
          t0 = Fp3.add(t0, t2);
          t0 = Fp3.mul(t0, t3);
          Y3 = Fp3.add(Y3, t0);
          t2 = Fp3.mul(Y1, Z1);
          t2 = Fp3.add(t2, t2);
          t0 = Fp3.mul(t2, t3);
          X32 = Fp3.sub(X32, t0);
          Z3 = Fp3.mul(t2, t1);
          Z3 = Fp3.add(Z3, Z3);
          Z3 = Fp3.add(Z3, Z3);
          return new Point2(X32, Y3, Z3);
        }
        // Renes-Costello-Batina exception-free addition formula.
        // There is 30% faster Jacobian formula, but it is not complete.
        // https://eprint.iacr.org/2015/1060, algorithm 1
        // Cost: 12M + 0S + 3*a + 3*b3 + 23add.
        add(other) {
          assertPrjPoint(other);
          const { px: X1, py: Y1, pz: Z1 } = this;
          const { px: X22, py: Y2, pz: Z2 } = other;
          let X32 = Fp3.ZERO, Y3 = Fp3.ZERO, Z3 = Fp3.ZERO;
          const a3 = CURVE.a;
          const b32 = Fp3.mul(CURVE.b, _3n4);
          let t0 = Fp3.mul(X1, X22);
          let t1 = Fp3.mul(Y1, Y2);
          let t2 = Fp3.mul(Z1, Z2);
          let t3 = Fp3.add(X1, Y1);
          let t4 = Fp3.add(X22, Y2);
          t3 = Fp3.mul(t3, t4);
          t4 = Fp3.add(t0, t1);
          t3 = Fp3.sub(t3, t4);
          t4 = Fp3.add(X1, Z1);
          let t5 = Fp3.add(X22, Z2);
          t4 = Fp3.mul(t4, t5);
          t5 = Fp3.add(t0, t2);
          t4 = Fp3.sub(t4, t5);
          t5 = Fp3.add(Y1, Z1);
          X32 = Fp3.add(Y2, Z2);
          t5 = Fp3.mul(t5, X32);
          X32 = Fp3.add(t1, t2);
          t5 = Fp3.sub(t5, X32);
          Z3 = Fp3.mul(a3, t4);
          X32 = Fp3.mul(b32, t2);
          Z3 = Fp3.add(X32, Z3);
          X32 = Fp3.sub(t1, Z3);
          Z3 = Fp3.add(t1, Z3);
          Y3 = Fp3.mul(X32, Z3);
          t1 = Fp3.add(t0, t0);
          t1 = Fp3.add(t1, t0);
          t2 = Fp3.mul(a3, t2);
          t4 = Fp3.mul(b32, t4);
          t1 = Fp3.add(t1, t2);
          t2 = Fp3.sub(t0, t2);
          t2 = Fp3.mul(a3, t2);
          t4 = Fp3.add(t4, t2);
          t0 = Fp3.mul(t1, t4);
          Y3 = Fp3.add(Y3, t0);
          t0 = Fp3.mul(t5, t4);
          X32 = Fp3.mul(t3, X32);
          X32 = Fp3.sub(X32, t0);
          t0 = Fp3.mul(t3, t1);
          Z3 = Fp3.mul(t5, Z3);
          Z3 = Fp3.add(Z3, t0);
          return new Point2(X32, Y3, Z3);
        }
        subtract(other) {
          return this.add(other.negate());
        }
        is0() {
          return this.equals(Point2.ZERO);
        }
        wNAF(n2) {
          return wnaf.wNAFCached(this, pointPrecomputes, n2, (comp) => {
            const toInv = Fp3.invertBatch(comp.map((p2) => p2.pz));
            return comp.map((p2, i2) => p2.toAffine(toInv[i2])).map(Point2.fromAffine);
          });
        }
        /**
         * Non-constant-time multiplication. Uses double-and-add algorithm.
         * It's faster, but should only be used when you don't care about
         * an exposed private key e.g. sig verification, which works over *public* keys.
         */
        multiplyUnsafe(n2) {
          const I3 = Point2.ZERO;
          if (n2 === _0n4)
            return I3;
          assertGE(n2);
          if (n2 === _1n4)
            return this;
          const { endo } = CURVE;
          if (!endo)
            return wnaf.unsafeLadder(this, n2);
          let { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n2);
          let k1p = I3;
          let k2p = I3;
          let d2 = this;
          while (k1 > _0n4 || k22 > _0n4) {
            if (k1 & _1n4)
              k1p = k1p.add(d2);
            if (k22 & _1n4)
              k2p = k2p.add(d2);
            d2 = d2.double();
            k1 >>= _1n4;
            k22 >>= _1n4;
          }
          if (k1neg)
            k1p = k1p.negate();
          if (k2neg)
            k2p = k2p.negate();
          k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
          return k1p.add(k2p);
        }
        /**
         * Constant time multiplication.
         * Uses wNAF method. Windowed method may be 10% faster,
         * but takes 2x longer to generate and consumes 2x memory.
         * Uses precomputes when available.
         * Uses endomorphism for Koblitz curves.
         * @param scalar by which the point would be multiplied
         * @returns New point
         */
        multiply(scalar) {
          assertGE(scalar);
          let n2 = scalar;
          let point, fake;
          const { endo } = CURVE;
          if (endo) {
            const { k1neg, k1, k2neg, k2: k22 } = endo.splitScalar(n2);
            let { p: k1p, f: f1p } = this.wNAF(k1);
            let { p: k2p, f: f2p } = this.wNAF(k22);
            k1p = wnaf.constTimeNegate(k1neg, k1p);
            k2p = wnaf.constTimeNegate(k2neg, k2p);
            k2p = new Point2(Fp3.mul(k2p.px, endo.beta), k2p.py, k2p.pz);
            point = k1p.add(k2p);
            fake = f1p.add(f2p);
          } else {
            const { p: p2, f: f3 } = this.wNAF(n2);
            point = p2;
            fake = f3;
          }
          return Point2.normalizeZ([point, fake])[0];
        }
        /**
         * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
         * Not using Strauss-Shamir trick: precomputation tables are faster.
         * The trick could be useful if both P and Q are not G (not in our case).
         * @returns non-zero affine point
         */
        multiplyAndAddUnsafe(Q2, a3, b4) {
          const G2 = Point2.BASE;
          const mul = (P, a4) => a4 === _0n4 || a4 === _1n4 || !P.equals(G2) ? P.multiplyUnsafe(a4) : P.multiply(a4);
          const sum = mul(this, a3).add(mul(Q2, b4));
          return sum.is0() ? void 0 : sum;
        }
        // Converts Projective point to affine (x, y) coordinates.
        // Can accept precomputed Z^-1 - for example, from invertBatch.
        // (x, y, z)  (x=x/z, y=y/z)
        toAffine(iz) {
          const { px: x2, py: y2, pz: z3 } = this;
          const is0 = this.is0();
          if (iz == null)
            iz = is0 ? Fp3.ONE : Fp3.inv(z3);
          const ax = Fp3.mul(x2, iz);
          const ay = Fp3.mul(y2, iz);
          const zz = Fp3.mul(z3, iz);
          if (is0)
            return { x: Fp3.ZERO, y: Fp3.ZERO };
          if (!Fp3.eql(zz, Fp3.ONE))
            throw new Error("invZ was invalid");
          return { x: ax, y: ay };
        }
        isTorsionFree() {
          const { h: cofactor, isTorsionFree } = CURVE;
          if (cofactor === _1n4)
            return true;
          if (isTorsionFree)
            return isTorsionFree(Point2, this);
          throw new Error("isTorsionFree() has not been declared for the elliptic curve");
        }
        clearCofactor() {
          const { h: cofactor, clearCofactor } = CURVE;
          if (cofactor === _1n4)
            return this;
          if (clearCofactor)
            return clearCofactor(Point2, this);
          return this.multiplyUnsafe(CURVE.h);
        }
        toRawBytes(isCompressed = true) {
          this.assertValidity();
          return toBytes13(Point2, this, isCompressed);
        }
        toHex(isCompressed = true) {
          return ut2.bytesToHex(this.toRawBytes(isCompressed));
        }
      }
      Point2.BASE = new Point2(CURVE.Gx, CURVE.Gy, Fp3.ONE);
      Point2.ZERO = new Point2(Fp3.ZERO, Fp3.ONE, Fp3.ZERO);
      const _bits = CURVE.nBitLength;
      const wnaf = (0, curve_js_1.wNAF)(Point2, CURVE.endo ? Math.ceil(_bits / 2) : _bits);
      return {
        CURVE,
        ProjectivePoint: Point2,
        normPrivateKeyToScalar,
        weierstrassEquation,
        isWithinCurveOrder
      };
    }
    exports.weierstrassPoints = weierstrassPoints2;
    function validateOpts(curve) {
      const opts = (0, curve_js_1.validateBasic)(curve);
      ut2.validateObject(opts, {
        hash: "hash",
        hmac: "function",
        randomBytes: "function"
      }, {
        bits2int: "function",
        bits2int_modN: "function",
        lowS: "boolean"
      });
      return Object.freeze({ lowS: true, ...opts });
    }
    function weierstrass(curveDef) {
      const CURVE = validateOpts(curveDef);
      const { Fp: Fp3, n: CURVE_ORDER } = CURVE;
      const compressedLen = Fp3.BYTES + 1;
      const uncompressedLen = 2 * Fp3.BYTES + 1;
      function isValidFieldElement(num) {
        return _0n4 < num && num < Fp3.ORDER;
      }
      function modN(a3) {
        return mod2.mod(a3, CURVE_ORDER);
      }
      function invN(a3) {
        return mod2.invert(a3, CURVE_ORDER);
      }
      const { ProjectivePoint: Point2, normPrivateKeyToScalar, weierstrassEquation, isWithinCurveOrder } = weierstrassPoints2({
        ...CURVE,
        toBytes(_c2, point, isCompressed) {
          const a3 = point.toAffine();
          const x2 = Fp3.toBytes(a3.x);
          const cat = ut2.concatBytes;
          if (isCompressed) {
            return cat(Uint8Array.from([point.hasEvenY() ? 2 : 3]), x2);
          } else {
            return cat(Uint8Array.from([4]), x2, Fp3.toBytes(a3.y));
          }
        },
        fromBytes(bytes) {
          const len = bytes.length;
          const head = bytes[0];
          const tail = bytes.subarray(1);
          if (len === compressedLen && (head === 2 || head === 3)) {
            const x2 = ut2.bytesToNumberBE(tail);
            if (!isValidFieldElement(x2))
              throw new Error("Point is not on curve");
            const y2 = weierstrassEquation(x2);
            let y3 = Fp3.sqrt(y2);
            const isYOdd = (y3 & _1n4) === _1n4;
            const isHeadOdd = (head & 1) === 1;
            if (isHeadOdd !== isYOdd)
              y3 = Fp3.neg(y3);
            return { x: x2, y: y3 };
          } else if (len === uncompressedLen && head === 4) {
            const x2 = Fp3.fromBytes(tail.subarray(0, Fp3.BYTES));
            const y2 = Fp3.fromBytes(tail.subarray(Fp3.BYTES, 2 * Fp3.BYTES));
            return { x: x2, y: y2 };
          } else {
            throw new Error(`Point of length ${len} was invalid. Expected ${compressedLen} compressed bytes or ${uncompressedLen} uncompressed bytes`);
          }
        }
      });
      const numToNByteStr = (num) => ut2.bytesToHex(ut2.numberToBytesBE(num, CURVE.nByteLength));
      function isBiggerThanHalfOrder(number2) {
        const HALF = CURVE_ORDER >> _1n4;
        return number2 > HALF;
      }
      function normalizeS(s2) {
        return isBiggerThanHalfOrder(s2) ? modN(-s2) : s2;
      }
      const slcNum = (b4, from26, to4) => ut2.bytesToNumberBE(b4.slice(from26, to4));
      class Signature {
        constructor(r2, s2, recovery) {
          this.r = r2;
          this.s = s2;
          this.recovery = recovery;
          this.assertValidity();
        }
        // pair (bytes of r, bytes of s)
        static fromCompact(hex3) {
          const l3 = CURVE.nByteLength;
          hex3 = (0, utils_js_1.ensureBytes)("compactSignature", hex3, l3 * 2);
          return new Signature(slcNum(hex3, 0, l3), slcNum(hex3, l3, 2 * l3));
        }
        // DER encoded ECDSA signature
        // https://bitcoin.stackexchange.com/questions/57644/what-are-the-parts-of-a-bitcoin-transaction-input-script
        static fromDER(hex3) {
          const { r: r2, s: s2 } = exports.DER.toSig((0, utils_js_1.ensureBytes)("DER", hex3));
          return new Signature(r2, s2);
        }
        assertValidity() {
          if (!isWithinCurveOrder(this.r))
            throw new Error("r must be 0 < r < CURVE.n");
          if (!isWithinCurveOrder(this.s))
            throw new Error("s must be 0 < s < CURVE.n");
        }
        addRecoveryBit(recovery) {
          return new Signature(this.r, this.s, recovery);
        }
        recoverPublicKey(msgHash) {
          const { r: r2, s: s2, recovery: rec } = this;
          const h = bits2int_modN((0, utils_js_1.ensureBytes)("msgHash", msgHash));
          if (rec == null || ![0, 1, 2, 3].includes(rec))
            throw new Error("recovery id invalid");
          const radj = rec === 2 || rec === 3 ? r2 + CURVE.n : r2;
          if (radj >= Fp3.ORDER)
            throw new Error("recovery id 2 or 3 invalid");
          const prefix = (rec & 1) === 0 ? "02" : "03";
          const R2 = Point2.fromHex(prefix + numToNByteStr(radj));
          const ir2 = invN(radj);
          const u1 = modN(-h * ir2);
          const u22 = modN(s2 * ir2);
          const Q2 = Point2.BASE.multiplyAndAddUnsafe(R2, u1, u22);
          if (!Q2)
            throw new Error("point at infinify");
          Q2.assertValidity();
          return Q2;
        }
        // Signatures should be low-s, to prevent malleability.
        hasHighS() {
          return isBiggerThanHalfOrder(this.s);
        }
        normalizeS() {
          return this.hasHighS() ? new Signature(this.r, modN(-this.s), this.recovery) : this;
        }
        // DER-encoded
        toDERRawBytes() {
          return ut2.hexToBytes(this.toDERHex());
        }
        toDERHex() {
          return exports.DER.hexFromSig({ r: this.r, s: this.s });
        }
        // padded bytes of r, then padded bytes of s
        toCompactRawBytes() {
          return ut2.hexToBytes(this.toCompactHex());
        }
        toCompactHex() {
          return numToNByteStr(this.r) + numToNByteStr(this.s);
        }
      }
      const utils2 = {
        isValidPrivateKey(privateKey) {
          try {
            normPrivateKeyToScalar(privateKey);
            return true;
          } catch (error) {
            return false;
          }
        },
        normPrivateKeyToScalar,
        /**
         * Produces cryptographically secure private key from random of size
         * (groupLen + ceil(groupLen / 2)) with modulo bias being negligible.
         */
        randomPrivateKey: () => {
          const length2 = mod2.getMinHashLength(CURVE.n);
          return mod2.mapHashToField(CURVE.randomBytes(length2), CURVE.n);
        },
        /**
         * Creates precompute table for an arbitrary EC point. Makes point "cached".
         * Allows to massively speed-up `point.multiply(scalar)`.
         * @returns cached point
         * @example
         * const fast = utils.precompute(8, ProjectivePoint.fromHex(someonesPubKey));
         * fast.multiply(privKey); // much faster ECDH now
         */
        precompute(windowSize = 8, point = Point2.BASE) {
          point._setWindowSize(windowSize);
          point.multiply(BigInt(3));
          return point;
        }
      };
      function getPublicKey4(privateKey, isCompressed = true) {
        return Point2.fromPrivateKey(privateKey).toRawBytes(isCompressed);
      }
      function isProbPub(item) {
        const arr = item instanceof Uint8Array;
        const str = typeof item === "string";
        const len = (arr || str) && item.length;
        if (arr)
          return len === compressedLen || len === uncompressedLen;
        if (str)
          return len === 2 * compressedLen || len === 2 * uncompressedLen;
        if (item instanceof Point2)
          return true;
        return false;
      }
      function getSharedSecret(privateA, publicB, isCompressed = true) {
        if (isProbPub(privateA))
          throw new Error("first arg must be private key");
        if (!isProbPub(publicB))
          throw new Error("second arg must be public key");
        const b4 = Point2.fromHex(publicB);
        return b4.multiply(normPrivateKeyToScalar(privateA)).toRawBytes(isCompressed);
      }
      const bits2int = CURVE.bits2int || function(bytes) {
        const num = ut2.bytesToNumberBE(bytes);
        const delta = bytes.length * 8 - CURVE.nBitLength;
        return delta > 0 ? num >> BigInt(delta) : num;
      };
      const bits2int_modN = CURVE.bits2int_modN || function(bytes) {
        return modN(bits2int(bytes));
      };
      const ORDER_MASK = ut2.bitMask(CURVE.nBitLength);
      function int2octets(num) {
        if (typeof num !== "bigint")
          throw new Error("bigint expected");
        if (!(_0n4 <= num && num < ORDER_MASK))
          throw new Error(`bigint expected < 2^${CURVE.nBitLength}`);
        return ut2.numberToBytesBE(num, CURVE.nByteLength);
      }
      function prepSig(msgHash, privateKey, opts = defaultSigOpts) {
        if (["recovered", "canonical"].some((k4) => k4 in opts))
          throw new Error("sign() legacy options not supported");
        const { hash: hash8, randomBytes: randomBytes3 } = CURVE;
        let { lowS, prehash, extraEntropy: ent } = opts;
        if (lowS == null)
          lowS = true;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        if (prehash)
          msgHash = (0, utils_js_1.ensureBytes)("prehashed msgHash", hash8(msgHash));
        const h1int = bits2int_modN(msgHash);
        const d2 = normPrivateKeyToScalar(privateKey);
        const seedArgs = [int2octets(d2), int2octets(h1int)];
        if (ent != null) {
          const e2 = ent === true ? randomBytes3(Fp3.BYTES) : ent;
          seedArgs.push((0, utils_js_1.ensureBytes)("extraEntropy", e2));
        }
        const seed = ut2.concatBytes(...seedArgs);
        const m3 = h1int;
        function k2sig(kBytes) {
          const k4 = bits2int(kBytes);
          if (!isWithinCurveOrder(k4))
            return;
          const ik = invN(k4);
          const q3 = Point2.BASE.multiply(k4).toAffine();
          const r2 = modN(q3.x);
          if (r2 === _0n4)
            return;
          const s2 = modN(ik * modN(m3 + r2 * d2));
          if (s2 === _0n4)
            return;
          let recovery = (q3.x === r2 ? 0 : 2) | Number(q3.y & _1n4);
          let normS = s2;
          if (lowS && isBiggerThanHalfOrder(s2)) {
            normS = normalizeS(s2);
            recovery ^= 1;
          }
          return new Signature(r2, normS, recovery);
        }
        return { seed, k2sig };
      }
      const defaultSigOpts = { lowS: CURVE.lowS, prehash: false };
      const defaultVerOpts = { lowS: CURVE.lowS, prehash: false };
      function sign6(msgHash, privKey, opts = defaultSigOpts) {
        const { seed, k2sig } = prepSig(msgHash, privKey, opts);
        const C2 = CURVE;
        const drbg = ut2.createHmacDrbg(C2.hash.outputLen, C2.nByteLength, C2.hmac);
        return drbg(seed, k2sig);
      }
      Point2.BASE._setWindowSize(8);
      function verify6(signature, msgHash, publicKey, opts = defaultVerOpts) {
        var _a2;
        const sg = signature;
        msgHash = (0, utils_js_1.ensureBytes)("msgHash", msgHash);
        publicKey = (0, utils_js_1.ensureBytes)("publicKey", publicKey);
        if ("strict" in opts)
          throw new Error("options.strict was renamed to lowS");
        const { lowS, prehash } = opts;
        let _sig = void 0;
        let P;
        try {
          if (typeof sg === "string" || sg instanceof Uint8Array) {
            try {
              _sig = Signature.fromDER(sg);
            } catch (derError) {
              if (!(derError instanceof exports.DER.Err))
                throw derError;
              _sig = Signature.fromCompact(sg);
            }
          } else if (typeof sg === "object" && typeof sg.r === "bigint" && typeof sg.s === "bigint") {
            const { r: r3, s: s3 } = sg;
            _sig = new Signature(r3, s3);
          } else {
            throw new Error("PARSE");
          }
          P = Point2.fromHex(publicKey);
        } catch (error) {
          if (error.message === "PARSE")
            throw new Error(`signature must be Signature instance, Uint8Array or hex string`);
          return false;
        }
        if (lowS && _sig.hasHighS())
          return false;
        if (prehash)
          msgHash = CURVE.hash(msgHash);
        const { r: r2, s: s2 } = _sig;
        const h = bits2int_modN(msgHash);
        const is2 = invN(s2);
        const u1 = modN(h * is2);
        const u22 = modN(r2 * is2);
        const R2 = (_a2 = Point2.BASE.multiplyAndAddUnsafe(P, u1, u22)) == null ? void 0 : _a2.toAffine();
        if (!R2)
          return false;
        const v2 = modN(R2.x);
        return v2 === r2;
      }
      return {
        CURVE,
        getPublicKey: getPublicKey4,
        getSharedSecret,
        sign: sign6,
        verify: verify6,
        ProjectivePoint: Point2,
        Signature,
        utils: utils2
      };
    }
    exports.weierstrass = weierstrass;
    function SWUFpSqrtRatio(Fp3, Z2) {
      const q3 = Fp3.ORDER;
      let l3 = _0n4;
      for (let o2 = q3 - _1n4; o2 % _2n4 === _0n4; o2 /= _2n4)
        l3 += _1n4;
      const c1 = l3;
      const _2n_pow_c1_1 = _2n4 << c1 - _1n4 - _1n4;
      const _2n_pow_c1 = _2n_pow_c1_1 * _2n4;
      const c22 = (q3 - _1n4) / _2n_pow_c1;
      const c3 = (c22 - _1n4) / _2n4;
      const c4 = _2n_pow_c1 - _1n4;
      const c5 = _2n_pow_c1_1;
      const c6 = Fp3.pow(Z2, c22);
      const c7 = Fp3.pow(Z2, (c22 + _1n4) / _2n4);
      let sqrtRatio = (u3, v2) => {
        let tv1 = c6;
        let tv2 = Fp3.pow(v2, c4);
        let tv3 = Fp3.sqr(tv2);
        tv3 = Fp3.mul(tv3, v2);
        let tv5 = Fp3.mul(u3, tv3);
        tv5 = Fp3.pow(tv5, c3);
        tv5 = Fp3.mul(tv5, tv2);
        tv2 = Fp3.mul(tv5, v2);
        tv3 = Fp3.mul(tv5, u3);
        let tv4 = Fp3.mul(tv3, tv2);
        tv5 = Fp3.pow(tv4, c5);
        let isQR = Fp3.eql(tv5, Fp3.ONE);
        tv2 = Fp3.mul(tv3, c7);
        tv5 = Fp3.mul(tv4, tv1);
        tv3 = Fp3.cmov(tv2, tv3, isQR);
        tv4 = Fp3.cmov(tv5, tv4, isQR);
        for (let i2 = c1; i2 > _1n4; i2--) {
          let tv52 = i2 - _2n4;
          tv52 = _2n4 << tv52 - _1n4;
          let tvv5 = Fp3.pow(tv4, tv52);
          const e1 = Fp3.eql(tvv5, Fp3.ONE);
          tv2 = Fp3.mul(tv3, tv1);
          tv1 = Fp3.mul(tv1, tv1);
          tvv5 = Fp3.mul(tv4, tv1);
          tv3 = Fp3.cmov(tv2, tv3, e1);
          tv4 = Fp3.cmov(tvv5, tv4, e1);
        }
        return { isValid: isQR, value: tv3 };
      };
      if (Fp3.ORDER % _4n2 === _3n4) {
        const c12 = (Fp3.ORDER - _3n4) / _4n2;
        const c23 = Fp3.sqrt(Fp3.neg(Z2));
        sqrtRatio = (u3, v2) => {
          let tv1 = Fp3.sqr(v2);
          const tv2 = Fp3.mul(u3, v2);
          tv1 = Fp3.mul(tv1, tv2);
          let y1 = Fp3.pow(tv1, c12);
          y1 = Fp3.mul(y1, tv2);
          const y2 = Fp3.mul(y1, c23);
          const tv3 = Fp3.mul(Fp3.sqr(y1), v2);
          const isQR = Fp3.eql(tv3, u3);
          let y3 = Fp3.cmov(y2, y1, isQR);
          return { isValid: isQR, value: y3 };
        };
      }
      return sqrtRatio;
    }
    exports.SWUFpSqrtRatio = SWUFpSqrtRatio;
    function mapToCurveSimpleSWU2(Fp3, opts) {
      mod2.validateField(Fp3);
      if (!Fp3.isValid(opts.A) || !Fp3.isValid(opts.B) || !Fp3.isValid(opts.Z))
        throw new Error("mapToCurveSimpleSWU: invalid opts");
      const sqrtRatio = SWUFpSqrtRatio(Fp3, opts.Z);
      if (!Fp3.isOdd)
        throw new Error("Fp.isOdd is not implemented!");
      return (u3) => {
        let tv1, tv2, tv3, tv4, tv5, tv6, x2, y2;
        tv1 = Fp3.sqr(u3);
        tv1 = Fp3.mul(tv1, opts.Z);
        tv2 = Fp3.sqr(tv1);
        tv2 = Fp3.add(tv2, tv1);
        tv3 = Fp3.add(tv2, Fp3.ONE);
        tv3 = Fp3.mul(tv3, opts.B);
        tv4 = Fp3.cmov(opts.Z, Fp3.neg(tv2), !Fp3.eql(tv2, Fp3.ZERO));
        tv4 = Fp3.mul(tv4, opts.A);
        tv2 = Fp3.sqr(tv3);
        tv6 = Fp3.sqr(tv4);
        tv5 = Fp3.mul(tv6, opts.A);
        tv2 = Fp3.add(tv2, tv5);
        tv2 = Fp3.mul(tv2, tv3);
        tv6 = Fp3.mul(tv6, tv4);
        tv5 = Fp3.mul(tv6, opts.B);
        tv2 = Fp3.add(tv2, tv5);
        x2 = Fp3.mul(tv1, tv3);
        const { isValid, value } = sqrtRatio(tv2, tv6);
        y2 = Fp3.mul(tv1, u3);
        y2 = Fp3.mul(y2, value);
        x2 = Fp3.cmov(x2, tv3, isValid);
        y2 = Fp3.cmov(y2, value, isValid);
        const e1 = Fp3.isOdd(u3) === Fp3.isOdd(y2);
        y2 = Fp3.cmov(Fp3.neg(y2), y2, e1);
        x2 = Fp3.div(x2, tv4);
        return { x: x2, y: y2 };
      };
    }
    exports.mapToCurveSimpleSWU = mapToCurveSimpleSWU2;
  }
});

// node_modules/ethers/node_modules/@noble/curves/abstract/hash-to-curve.js
var require_hash_to_curve = __commonJS({
  "node_modules/ethers/node_modules/@noble/curves/abstract/hash-to-curve.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createHasher = exports.isogenyMap = exports.hash_to_field = exports.expand_message_xof = exports.expand_message_xmd = void 0;
    var modular_js_1 = require_modular();
    var utils_js_1 = require_utils7();
    function validateDST(dst) {
      if (dst instanceof Uint8Array)
        return dst;
      if (typeof dst === "string")
        return (0, utils_js_1.utf8ToBytes)(dst);
      throw new Error("DST must be Uint8Array or string");
    }
    var os2ip = utils_js_1.bytesToNumberBE;
    function i2osp(value, length2) {
      if (value < 0 || value >= 1 << 8 * length2) {
        throw new Error(`bad I2OSP call: value=${value} length=${length2}`);
      }
      const res = Array.from({ length: length2 }).fill(0);
      for (let i2 = length2 - 1; i2 >= 0; i2--) {
        res[i2] = value & 255;
        value >>>= 8;
      }
      return new Uint8Array(res);
    }
    function strxor(a3, b4) {
      const arr = new Uint8Array(a3.length);
      for (let i2 = 0; i2 < a3.length; i2++) {
        arr[i2] = a3[i2] ^ b4[i2];
      }
      return arr;
    }
    function isBytes4(item) {
      if (!(item instanceof Uint8Array))
        throw new Error("Uint8Array expected");
    }
    function isNum2(item) {
      if (!Number.isSafeInteger(item))
        throw new Error("number expected");
    }
    function expand_message_xmd(msg, DST, lenInBytes, H3) {
      isBytes4(msg);
      isBytes4(DST);
      isNum2(lenInBytes);
      if (DST.length > 255)
        DST = H3((0, utils_js_1.concatBytes)((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-"), DST));
      const { outputLen: b_in_bytes, blockLen: r_in_bytes } = H3;
      const ell = Math.ceil(lenInBytes / b_in_bytes);
      if (ell > 255)
        throw new Error("Invalid xmd length");
      const DST_prime = (0, utils_js_1.concatBytes)(DST, i2osp(DST.length, 1));
      const Z_pad = i2osp(0, r_in_bytes);
      const l_i_b_str = i2osp(lenInBytes, 2);
      const b4 = new Array(ell);
      const b_0 = H3((0, utils_js_1.concatBytes)(Z_pad, msg, l_i_b_str, i2osp(0, 1), DST_prime));
      b4[0] = H3((0, utils_js_1.concatBytes)(b_0, i2osp(1, 1), DST_prime));
      for (let i2 = 1; i2 <= ell; i2++) {
        const args = [strxor(b_0, b4[i2 - 1]), i2osp(i2 + 1, 1), DST_prime];
        b4[i2] = H3((0, utils_js_1.concatBytes)(...args));
      }
      const pseudo_random_bytes = (0, utils_js_1.concatBytes)(...b4);
      return pseudo_random_bytes.slice(0, lenInBytes);
    }
    exports.expand_message_xmd = expand_message_xmd;
    function expand_message_xof(msg, DST, lenInBytes, k4, H3) {
      isBytes4(msg);
      isBytes4(DST);
      isNum2(lenInBytes);
      if (DST.length > 255) {
        const dkLen = Math.ceil(2 * k4 / 8);
        DST = H3.create({ dkLen }).update((0, utils_js_1.utf8ToBytes)("H2C-OVERSIZE-DST-")).update(DST).digest();
      }
      if (lenInBytes > 65535 || DST.length > 255)
        throw new Error("expand_message_xof: invalid lenInBytes");
      return H3.create({ dkLen: lenInBytes }).update(msg).update(i2osp(lenInBytes, 2)).update(DST).update(i2osp(DST.length, 1)).digest();
    }
    exports.expand_message_xof = expand_message_xof;
    function hash_to_field(msg, count, options) {
      (0, utils_js_1.validateObject)(options, {
        DST: "stringOrUint8Array",
        p: "bigint",
        m: "isSafeInteger",
        k: "isSafeInteger",
        hash: "hash"
      });
      const { p: p2, k: k4, m: m3, hash: hash8, expand, DST: _DST } = options;
      isBytes4(msg);
      isNum2(count);
      const DST = validateDST(_DST);
      const log2p = p2.toString(2).length;
      const L2 = Math.ceil((log2p + k4) / 8);
      const len_in_bytes = count * m3 * L2;
      let prb;
      if (expand === "xmd") {
        prb = expand_message_xmd(msg, DST, len_in_bytes, hash8);
      } else if (expand === "xof") {
        prb = expand_message_xof(msg, DST, len_in_bytes, k4, hash8);
      } else if (expand === "_internal_pass") {
        prb = msg;
      } else {
        throw new Error('expand must be "xmd" or "xof"');
      }
      const u3 = new Array(count);
      for (let i2 = 0; i2 < count; i2++) {
        const e2 = new Array(m3);
        for (let j3 = 0; j3 < m3; j3++) {
          const elm_offset = L2 * (j3 + i2 * m3);
          const tv = prb.subarray(elm_offset, elm_offset + L2);
          e2[j3] = (0, modular_js_1.mod)(os2ip(tv), p2);
        }
        u3[i2] = e2;
      }
      return u3;
    }
    exports.hash_to_field = hash_to_field;
    function isogenyMap2(field, map) {
      const COEFF = map.map((i2) => Array.from(i2).reverse());
      return (x2, y2) => {
        const [xNum, xDen, yNum, yDen] = COEFF.map((val) => val.reduce((acc, i2) => field.add(field.mul(acc, x2), i2)));
        x2 = field.div(xNum, xDen);
        y2 = field.mul(y2, field.div(yNum, yDen));
        return { x: x2, y: y2 };
      };
    }
    exports.isogenyMap = isogenyMap2;
    function createHasher2(Point2, mapToCurve, def) {
      if (typeof mapToCurve !== "function")
        throw new Error("mapToCurve() must be defined");
      return {
        // Encodes byte string to elliptic curve.
        // hash_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        hashToCurve(msg, options) {
          const u3 = hash_to_field(msg, 2, { ...def, DST: def.DST, ...options });
          const u0 = Point2.fromAffine(mapToCurve(u3[0]));
          const u1 = Point2.fromAffine(mapToCurve(u3[1]));
          const P = u0.add(u1).clearCofactor();
          P.assertValidity();
          return P;
        },
        // Encodes byte string to elliptic curve.
        // encode_to_curve from https://www.rfc-editor.org/rfc/rfc9380#section-3
        encodeToCurve(msg, options) {
          const u3 = hash_to_field(msg, 1, { ...def, DST: def.encodeDST, ...options });
          const P = Point2.fromAffine(mapToCurve(u3[0])).clearCofactor();
          P.assertValidity();
          return P;
        }
      };
    }
    exports.createHasher = createHasher2;
  }
});

// node_modules/ethers/node_modules/@noble/curves/_shortw_utils.js
var require_shortw_utils = __commonJS({
  "node_modules/ethers/node_modules/@noble/curves/_shortw_utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.createCurve = exports.getHash = void 0;
    var hmac_1 = require_hmac();
    var utils_1 = require_utils6();
    var weierstrass_js_1 = require_weierstrass();
    function getHash(hash8) {
      return {
        hash: hash8,
        hmac: (key, ...msgs) => (0, hmac_1.hmac)(hash8, key, (0, utils_1.concatBytes)(...msgs)),
        randomBytes: utils_1.randomBytes
      };
    }
    exports.getHash = getHash;
    function createCurve2(curveDef, defHash) {
      const create5 = (hash8) => (0, weierstrass_js_1.weierstrass)({ ...curveDef, ...getHash(hash8) });
      return Object.freeze({ ...create5(defHash), create: create5 });
    }
    exports.createCurve = createCurve2;
  }
});

// node_modules/ethers/node_modules/@noble/curves/secp256k1.js
var require_secp256k1 = __commonJS({
  "node_modules/ethers/node_modules/@noble/curves/secp256k1.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encodeToCurve = exports.hashToCurve = exports.schnorr = exports.secp256k1 = void 0;
    var sha256_1 = require_sha256();
    var utils_1 = require_utils6();
    var modular_js_1 = require_modular();
    var weierstrass_js_1 = require_weierstrass();
    var utils_js_1 = require_utils7();
    var hash_to_curve_js_1 = require_hash_to_curve();
    var _shortw_utils_js_1 = require_shortw_utils();
    var secp256k1P = BigInt("0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f");
    var secp256k1N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var _1n4 = BigInt(1);
    var _2n4 = BigInt(2);
    var divNearest = (a3, b4) => (a3 + b4 / _2n4) / b4;
    function sqrtMod(y2) {
      const P = secp256k1P;
      const _3n4 = BigInt(3), _6n = BigInt(6), _11n = BigInt(11), _22n = BigInt(22);
      const _23n = BigInt(23), _44n = BigInt(44), _88n = BigInt(88);
      const b22 = y2 * y2 * y2 % P;
      const b32 = b22 * b22 * y2 % P;
      const b6 = (0, modular_js_1.pow2)(b32, _3n4, P) * b32 % P;
      const b9 = (0, modular_js_1.pow2)(b6, _3n4, P) * b32 % P;
      const b11 = (0, modular_js_1.pow2)(b9, _2n4, P) * b22 % P;
      const b222 = (0, modular_js_1.pow2)(b11, _11n, P) * b11 % P;
      const b44 = (0, modular_js_1.pow2)(b222, _22n, P) * b222 % P;
      const b88 = (0, modular_js_1.pow2)(b44, _44n, P) * b44 % P;
      const b176 = (0, modular_js_1.pow2)(b88, _88n, P) * b88 % P;
      const b220 = (0, modular_js_1.pow2)(b176, _44n, P) * b44 % P;
      const b223 = (0, modular_js_1.pow2)(b220, _3n4, P) * b32 % P;
      const t1 = (0, modular_js_1.pow2)(b223, _23n, P) * b222 % P;
      const t2 = (0, modular_js_1.pow2)(t1, _6n, P) * b22 % P;
      const root2 = (0, modular_js_1.pow2)(t2, _2n4, P);
      if (!Fp3.eql(Fp3.sqr(root2), y2))
        throw new Error("Cannot find square root");
      return root2;
    }
    var Fp3 = (0, modular_js_1.Field)(secp256k1P, void 0, void 0, { sqrt: sqrtMod });
    exports.secp256k1 = (0, _shortw_utils_js_1.createCurve)({
      a: BigInt(0),
      b: BigInt(7),
      Fp: Fp3,
      n: secp256k1N,
      // Base point (x, y) aka generator point
      Gx: BigInt("55066263022277343669578718895168534326250603453777594175500187360389116729240"),
      Gy: BigInt("32670510020758816978083085130507043184471273380659243275938904335757337482424"),
      h: BigInt(1),
      lowS: true,
      /**
       * secp256k1 belongs to Koblitz curves: it has efficiently computable endomorphism.
       * Endomorphism uses 2x less RAM, speeds up precomputation by 2x and ECDH / key recovery by 20%.
       * For precomputed wNAF it trades off 1/2 init time & 1/3 ram for 20% perf hit.
       * Explanation: https://gist.github.com/paulmillr/eb670806793e84df628a7c434a873066
       */
      endo: {
        beta: BigInt("0x7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee"),
        splitScalar: (k4) => {
          const n2 = secp256k1N;
          const a1 = BigInt("0x3086d221a7d46bcde86c90e49284eb15");
          const b1 = -_1n4 * BigInt("0xe4437ed6010e88286f547fa90abfe4c3");
          const a22 = BigInt("0x114ca50f7a8e2f3f657c1108d9d44cfd8");
          const b22 = a1;
          const POW_2_128 = BigInt("0x100000000000000000000000000000000");
          const c1 = divNearest(b22 * k4, n2);
          const c22 = divNearest(-b1 * k4, n2);
          let k1 = (0, modular_js_1.mod)(k4 - c1 * a1 - c22 * a22, n2);
          let k22 = (0, modular_js_1.mod)(-c1 * b1 - c22 * b22, n2);
          const k1neg = k1 > POW_2_128;
          const k2neg = k22 > POW_2_128;
          if (k1neg)
            k1 = n2 - k1;
          if (k2neg)
            k22 = n2 - k22;
          if (k1 > POW_2_128 || k22 > POW_2_128) {
            throw new Error("splitScalar: Endomorphism failed, k=" + k4);
          }
          return { k1neg, k1, k2neg, k2: k22 };
        }
      }
    }, sha256_1.sha256);
    var _0n4 = BigInt(0);
    var fe3 = (x2) => typeof x2 === "bigint" && _0n4 < x2 && x2 < secp256k1P;
    var ge3 = (x2) => typeof x2 === "bigint" && _0n4 < x2 && x2 < secp256k1N;
    var TAGGED_HASH_PREFIXES = {};
    function taggedHash(tag, ...messages) {
      let tagP = TAGGED_HASH_PREFIXES[tag];
      if (tagP === void 0) {
        const tagH = (0, sha256_1.sha256)(Uint8Array.from(tag, (c3) => c3.charCodeAt(0)));
        tagP = (0, utils_js_1.concatBytes)(tagH, tagH);
        TAGGED_HASH_PREFIXES[tag] = tagP;
      }
      return (0, sha256_1.sha256)((0, utils_js_1.concatBytes)(tagP, ...messages));
    }
    var pointToBytes = (point) => point.toRawBytes(true).slice(1);
    var numTo32b = (n2) => (0, utils_js_1.numberToBytesBE)(n2, 32);
    var modP = (x2) => (0, modular_js_1.mod)(x2, secp256k1P);
    var modN = (x2) => (0, modular_js_1.mod)(x2, secp256k1N);
    var Point2 = exports.secp256k1.ProjectivePoint;
    var GmulAdd = (Q2, a3, b4) => Point2.BASE.multiplyAndAddUnsafe(Q2, a3, b4);
    function schnorrGetExtPubKey(priv) {
      let d_ = exports.secp256k1.utils.normPrivateKeyToScalar(priv);
      let p2 = Point2.fromPrivateKey(d_);
      const scalar = p2.hasEvenY() ? d_ : modN(-d_);
      return { scalar, bytes: pointToBytes(p2) };
    }
    function lift_x(x2) {
      if (!fe3(x2))
        throw new Error("bad x: need 0 < x < p");
      const xx = modP(x2 * x2);
      const c3 = modP(xx * x2 + BigInt(7));
      let y2 = sqrtMod(c3);
      if (y2 % _2n4 !== _0n4)
        y2 = modP(-y2);
      const p2 = new Point2(x2, y2, _1n4);
      p2.assertValidity();
      return p2;
    }
    function challenge(...args) {
      return modN((0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/challenge", ...args)));
    }
    function schnorrGetPublicKey(privateKey) {
      return schnorrGetExtPubKey(privateKey).bytes;
    }
    function schnorrSign(message, privateKey, auxRand = (0, utils_1.randomBytes)(32)) {
      const m3 = (0, utils_js_1.ensureBytes)("message", message);
      const { bytes: px2, scalar: d2 } = schnorrGetExtPubKey(privateKey);
      const a3 = (0, utils_js_1.ensureBytes)("auxRand", auxRand, 32);
      const t2 = numTo32b(d2 ^ (0, utils_js_1.bytesToNumberBE)(taggedHash("BIP0340/aux", a3)));
      const rand = taggedHash("BIP0340/nonce", t2, px2, m3);
      const k_ = modN((0, utils_js_1.bytesToNumberBE)(rand));
      if (k_ === _0n4)
        throw new Error("sign failed: k is zero");
      const { bytes: rx, scalar: k4 } = schnorrGetExtPubKey(k_);
      const e2 = challenge(rx, px2, m3);
      const sig = new Uint8Array(64);
      sig.set(rx, 0);
      sig.set(numTo32b(modN(k4 + e2 * d2)), 32);
      if (!schnorrVerify(sig, m3, px2))
        throw new Error("sign: Invalid signature produced");
      return sig;
    }
    function schnorrVerify(signature, message, publicKey) {
      const sig = (0, utils_js_1.ensureBytes)("signature", signature, 64);
      const m3 = (0, utils_js_1.ensureBytes)("message", message);
      const pub = (0, utils_js_1.ensureBytes)("publicKey", publicKey, 32);
      try {
        const P = lift_x((0, utils_js_1.bytesToNumberBE)(pub));
        const r2 = (0, utils_js_1.bytesToNumberBE)(sig.subarray(0, 32));
        if (!fe3(r2))
          return false;
        const s2 = (0, utils_js_1.bytesToNumberBE)(sig.subarray(32, 64));
        if (!ge3(s2))
          return false;
        const e2 = challenge(numTo32b(r2), pointToBytes(P), m3);
        const R2 = GmulAdd(P, s2, modN(-e2));
        if (!R2 || !R2.hasEvenY() || R2.toAffine().x !== r2)
          return false;
        return true;
      } catch (error) {
        return false;
      }
    }
    exports.schnorr = (() => ({
      getPublicKey: schnorrGetPublicKey,
      sign: schnorrSign,
      verify: schnorrVerify,
      utils: {
        randomPrivateKey: exports.secp256k1.utils.randomPrivateKey,
        lift_x,
        pointToBytes,
        numberToBytesBE: utils_js_1.numberToBytesBE,
        bytesToNumberBE: utils_js_1.bytesToNumberBE,
        taggedHash,
        mod: modular_js_1.mod
      }
    }))();
    var isoMap = (() => (0, hash_to_curve_js_1.isogenyMap)(Fp3, [
      // xNum
      [
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa8c7",
        "0x7d3d4c80bc321d5b9f315cea7fd44c5d595d2fc0bf63b92dfff1044f17c6581",
        "0x534c328d23f234e6e2a413deca25caece4506144037c40314ecbd0b53d9dd262",
        "0x8e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38e38daaaaa88c"
      ],
      // xDen
      [
        "0xd35771193d94918a9ca34ccbb7b640dd86cd409542f8487d9fe6b745781eb49b",
        "0xedadc6f64383dc1df7c4b2d51b54225406d36b641f5e41bbc52a56612a8c6d14",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ],
      // yNum
      [
        "0x4bda12f684bda12f684bda12f684bda12f684bda12f684bda12f684b8e38e23c",
        "0xc75e0c32d5cb7c0fa9d0a54b12a0a6d5647ab046d686da6fdffc90fc201d71a3",
        "0x29a6194691f91a73715209ef6512e576722830a201be2018a765e85a9ecee931",
        "0x2f684bda12f684bda12f684bda12f684bda12f684bda12f684bda12f38e38d84"
      ],
      // yDen
      [
        "0xfffffffffffffffffffffffffffffffffffffffffffffffffffffffefffff93b",
        "0x7a06534bb8bdb49fd5e9e6632722c2989467c1bfc8e8d978dfb425d2685c2573",
        "0x6484aa716545ca2cf3a70c3fa8fe337e0a3d21162f0d6299a7bf8192bfd2a76f",
        "0x0000000000000000000000000000000000000000000000000000000000000001"
        // LAST 1
      ]
    ].map((i2) => i2.map((j3) => BigInt(j3)))))();
    var mapSWU2 = (() => (0, weierstrass_js_1.mapToCurveSimpleSWU)(Fp3, {
      A: BigInt("0x3f8731abdd661adca08a5558f0f5d272e953d363cb6f0e5d405447c01a444533"),
      B: BigInt("1771"),
      Z: Fp3.create(BigInt("-11"))
    }))();
    var htf2 = (() => (0, hash_to_curve_js_1.createHasher)(exports.secp256k1.ProjectivePoint, (scalars) => {
      const { x: x2, y: y2 } = mapSWU2(Fp3.create(scalars[0]));
      return isoMap(x2, y2);
    }, {
      DST: "secp256k1_XMD:SHA-256_SSWU_RO_",
      encodeDST: "secp256k1_XMD:SHA-256_SSWU_NU_",
      p: Fp3.ORDER,
      m: 1,
      k: 128,
      expand: "xmd",
      hash: sha256_1.sha256
    }))();
    exports.hashToCurve = (() => htf2.hashToCurve)();
    exports.encodeToCurve = (() => htf2.encodeToCurve)();
  }
});

// node_modules/ethers/lib.commonjs/constants/addresses.js
var require_addresses = __commonJS({
  "node_modules/ethers/lib.commonjs/constants/addresses.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZeroAddress = void 0;
    exports.ZeroAddress = "0x0000000000000000000000000000000000000000";
  }
});

// node_modules/ethers/lib.commonjs/constants/hashes.js
var require_hashes = __commonJS({
  "node_modules/ethers/lib.commonjs/constants/hashes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ZeroHash = void 0;
    exports.ZeroHash = "0x0000000000000000000000000000000000000000000000000000000000000000";
  }
});

// node_modules/ethers/lib.commonjs/constants/numbers.js
var require_numbers = __commonJS({
  "node_modules/ethers/lib.commonjs/constants/numbers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = void 0;
    exports.N = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    exports.WeiPerEther = BigInt("1000000000000000000");
    exports.MaxUint256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    exports.MinInt256 = BigInt("0x8000000000000000000000000000000000000000000000000000000000000000") * BigInt(-1);
    exports.MaxInt256 = BigInt("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
  }
});

// node_modules/ethers/lib.commonjs/constants/strings.js
var require_strings = __commonJS({
  "node_modules/ethers/lib.commonjs/constants/strings.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessagePrefix = exports.EtherSymbol = void 0;
    exports.EtherSymbol = "";
    exports.MessagePrefix = "Ethereum Signed Message:\n";
  }
});

// node_modules/ethers/lib.commonjs/constants/index.js
var require_constants = __commonJS({
  "node_modules/ethers/lib.commonjs/constants/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MessagePrefix = exports.EtherSymbol = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.N = exports.ZeroHash = exports.ZeroAddress = void 0;
    var addresses_js_1 = require_addresses();
    Object.defineProperty(exports, "ZeroAddress", { enumerable: true, get: function() {
      return addresses_js_1.ZeroAddress;
    } });
    var hashes_js_1 = require_hashes();
    Object.defineProperty(exports, "ZeroHash", { enumerable: true, get: function() {
      return hashes_js_1.ZeroHash;
    } });
    var numbers_js_1 = require_numbers();
    Object.defineProperty(exports, "N", { enumerable: true, get: function() {
      return numbers_js_1.N;
    } });
    Object.defineProperty(exports, "WeiPerEther", { enumerable: true, get: function() {
      return numbers_js_1.WeiPerEther;
    } });
    Object.defineProperty(exports, "MaxUint256", { enumerable: true, get: function() {
      return numbers_js_1.MaxUint256;
    } });
    Object.defineProperty(exports, "MinInt256", { enumerable: true, get: function() {
      return numbers_js_1.MinInt256;
    } });
    Object.defineProperty(exports, "MaxInt256", { enumerable: true, get: function() {
      return numbers_js_1.MaxInt256;
    } });
    var strings_js_1 = require_strings();
    Object.defineProperty(exports, "EtherSymbol", { enumerable: true, get: function() {
      return strings_js_1.EtherSymbol;
    } });
    Object.defineProperty(exports, "MessagePrefix", { enumerable: true, get: function() {
      return strings_js_1.MessagePrefix;
    } });
  }
});

// node_modules/ethers/lib.commonjs/crypto/signature.js
var require_signature = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/signature.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Signature = void 0;
    var index_js_1 = require_constants();
    var index_js_2 = require_utils5();
    var BN_0 = BigInt(0);
    var BN_1 = BigInt(1);
    var BN_2 = BigInt(2);
    var BN_27 = BigInt(27);
    var BN_28 = BigInt(28);
    var BN_35 = BigInt(35);
    var _guard = {};
    function toUint256(value) {
      return (0, index_js_2.zeroPadValue)((0, index_js_2.toBeArray)(value), 32);
    }
    var _r2, _s, _v, _networkV;
    var _Signature = class _Signature {
      /**
       *  @private
       */
      constructor(guard, r2, s2, v2) {
        __privateAdd(this, _r2);
        __privateAdd(this, _s);
        __privateAdd(this, _v);
        __privateAdd(this, _networkV);
        (0, index_js_2.assertPrivate)(guard, _guard, "Signature");
        __privateSet(this, _r2, r2);
        __privateSet(this, _s, s2);
        __privateSet(this, _v, v2);
        __privateSet(this, _networkV, null);
      }
      /**
       *  The ``r`` value for a signature.
       *
       *  This represents the ``x`` coordinate of a "reference" or
       *  challenge point, from which the ``y`` can be computed.
       */
      get r() {
        return __privateGet(this, _r2);
      }
      set r(value) {
        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(value) === 32, "invalid r", "value", value);
        __privateSet(this, _r2, (0, index_js_2.hexlify)(value));
      }
      /**
       *  The ``s`` value for a signature.
       */
      get s() {
        return __privateGet(this, _s);
      }
      set s(_value) {
        (0, index_js_2.assertArgument)((0, index_js_2.dataLength)(_value) === 32, "invalid s", "value", _value);
        const value = (0, index_js_2.hexlify)(_value);
        (0, index_js_2.assertArgument)(parseInt(value.substring(0, 3)) < 8, "non-canonical s", "value", value);
        __privateSet(this, _s, value);
      }
      /**
       *  The ``v`` value for a signature.
       *
       *  Since a given ``x`` value for ``r`` has two possible values for
       *  its correspondin ``y``, the ``v`` indicates which of the two ``y``
       *  values to use.
       *
       *  It is normalized to the values ``27`` or ``28`` for legacy
       *  purposes.
       */
      get v() {
        return __privateGet(this, _v);
      }
      set v(value) {
        const v2 = (0, index_js_2.getNumber)(value, "value");
        (0, index_js_2.assertArgument)(v2 === 27 || v2 === 28, "invalid v", "v", value);
        __privateSet(this, _v, v2);
      }
      /**
       *  The EIP-155 ``v`` for legacy transactions. For non-legacy
       *  transactions, this value is ``null``.
       */
      get networkV() {
        return __privateGet(this, _networkV);
      }
      /**
       *  The chain ID for EIP-155 legacy transactions. For non-legacy
       *  transactions, this value is ``null``.
       */
      get legacyChainId() {
        const v2 = this.networkV;
        if (v2 == null) {
          return null;
        }
        return _Signature.getChainId(v2);
      }
      /**
       *  The ``yParity`` for the signature.
       *
       *  See ``v`` for more details on how this value is used.
       */
      get yParity() {
        return this.v === 27 ? 0 : 1;
      }
      /**
       *  The [[link-eip-2098]] compact representation of the ``yParity``
       *  and ``s`` compacted into a single ``bytes32``.
       */
      get yParityAndS() {
        const yParityAndS = (0, index_js_2.getBytes)(this.s);
        if (this.yParity) {
          yParityAndS[0] |= 128;
        }
        return (0, index_js_2.hexlify)(yParityAndS);
      }
      /**
       *  The [[link-eip-2098]] compact representation.
       */
      get compactSerialized() {
        return (0, index_js_2.concat)([this.r, this.yParityAndS]);
      }
      /**
       *  The serialized representation.
       */
      get serialized() {
        return (0, index_js_2.concat)([this.r, this.s, this.yParity ? "0x1c" : "0x1b"]);
      }
      [Symbol.for("nodejs.util.inspect.custom")]() {
        return `Signature { r: "${this.r}", s: "${this.s}", yParity: ${this.yParity}, networkV: ${this.networkV} }`;
      }
      /**
       *  Returns a new identical [[Signature]].
       */
      clone() {
        const clone = new _Signature(_guard, this.r, this.s, this.v);
        if (this.networkV) {
          __privateSet(clone, _networkV, this.networkV);
        }
        return clone;
      }
      /**
       *  Returns a representation that is compatible with ``JSON.stringify``.
       */
      toJSON() {
        const networkV = this.networkV;
        return {
          _type: "signature",
          networkV: networkV != null ? networkV.toString() : null,
          r: this.r,
          s: this.s,
          v: this.v
        };
      }
      /**
       *  Compute the chain ID from the ``v`` in a legacy EIP-155 transactions.
       *
       *  @example:
       *    Signature.getChainId(45)
       *    //_result:
       *
       *    Signature.getChainId(46)
       *    //_result:
       */
      static getChainId(v2) {
        const bv = (0, index_js_2.getBigInt)(v2, "v");
        if (bv == BN_27 || bv == BN_28) {
          return BN_0;
        }
        (0, index_js_2.assertArgument)(bv >= BN_35, "invalid EIP-155 v", "v", v2);
        return (bv - BN_35) / BN_2;
      }
      /**
       *  Compute the ``v`` for a chain ID for a legacy EIP-155 transactions.
       *
       *  Legacy transactions which use [[link-eip-155]] hijack the ``v``
       *  property to include the chain ID.
       *
       *  @example:
       *    Signature.getChainIdV(5, 27)
       *    //_result:
       *
       *    Signature.getChainIdV(5, 28)
       *    //_result:
       *
       */
      static getChainIdV(chainId, v2) {
        return (0, index_js_2.getBigInt)(chainId) * BN_2 + BigInt(35 + v2 - 27);
      }
      /**
       *  Compute the normalized legacy transaction ``v`` from a ``yParirty``,
       *  a legacy transaction ``v`` or a legacy [[link-eip-155]] transaction.
       *
       *  @example:
       *    // The values 0 and 1 imply v is actually yParity
       *    Signature.getNormalizedV(0)
       *    //_result:
       *
       *    // Legacy non-EIP-1559 transaction (i.e. 27 or 28)
       *    Signature.getNormalizedV(27)
       *    //_result:
       *
       *    // Legacy EIP-155 transaction (i.e. >= 35)
       *    Signature.getNormalizedV(46)
       *    //_result:
       *
       *    // Invalid values throw
       *    Signature.getNormalizedV(5)
       *    //_error:
       */
      static getNormalizedV(v2) {
        const bv = (0, index_js_2.getBigInt)(v2);
        if (bv === BN_0 || bv === BN_27) {
          return 27;
        }
        if (bv === BN_1 || bv === BN_28) {
          return 28;
        }
        (0, index_js_2.assertArgument)(bv >= BN_35, "invalid v", "v", v2);
        return bv & BN_1 ? 27 : 28;
      }
      /**
       *  Creates a new [[Signature]].
       *
       *  If no %%sig%% is provided, a new [[Signature]] is created
       *  with default values.
       *
       *  If %%sig%% is a string, it is parsed.
       */
      static from(sig) {
        function assertError2(check, message) {
          (0, index_js_2.assertArgument)(check, message, "signature", sig);
        }
        ;
        if (sig == null) {
          return new _Signature(_guard, index_js_1.ZeroHash, index_js_1.ZeroHash, 27);
        }
        if (typeof sig === "string") {
          const bytes = (0, index_js_2.getBytes)(sig, "signature");
          if (bytes.length === 64) {
            const r3 = (0, index_js_2.hexlify)(bytes.slice(0, 32));
            const s3 = bytes.slice(32, 64);
            const v3 = s3[0] & 128 ? 28 : 27;
            s3[0] &= 127;
            return new _Signature(_guard, r3, (0, index_js_2.hexlify)(s3), v3);
          }
          if (bytes.length === 65) {
            const r3 = (0, index_js_2.hexlify)(bytes.slice(0, 32));
            const s3 = bytes.slice(32, 64);
            assertError2((s3[0] & 128) === 0, "non-canonical s");
            const v3 = _Signature.getNormalizedV(bytes[64]);
            return new _Signature(_guard, r3, (0, index_js_2.hexlify)(s3), v3);
          }
          assertError2(false, "invalid raw signature length");
        }
        if (sig instanceof _Signature) {
          return sig.clone();
        }
        const _r3 = sig.r;
        assertError2(_r3 != null, "missing r");
        const r2 = toUint256(_r3);
        const s2 = function(s3, yParityAndS) {
          if (s3 != null) {
            return toUint256(s3);
          }
          if (yParityAndS != null) {
            assertError2((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
            const bytes = (0, index_js_2.getBytes)(yParityAndS);
            bytes[0] &= 127;
            return (0, index_js_2.hexlify)(bytes);
          }
          assertError2(false, "missing s");
        }(sig.s, sig.yParityAndS);
        assertError2(((0, index_js_2.getBytes)(s2)[0] & 128) == 0, "non-canonical s");
        const { networkV, v: v2 } = function(_v2, yParityAndS, yParity) {
          if (_v2 != null) {
            const v3 = (0, index_js_2.getBigInt)(_v2);
            return {
              networkV: v3 >= BN_35 ? v3 : void 0,
              v: _Signature.getNormalizedV(v3)
            };
          }
          if (yParityAndS != null) {
            assertError2((0, index_js_2.isHexString)(yParityAndS, 32), "invalid yParityAndS");
            return { v: (0, index_js_2.getBytes)(yParityAndS)[0] & 128 ? 28 : 27 };
          }
          if (yParity != null) {
            switch ((0, index_js_2.getNumber)(yParity, "sig.yParity")) {
              case 0:
                return { v: 27 };
              case 1:
                return { v: 28 };
            }
            assertError2(false, "invalid yParity");
          }
          assertError2(false, "missing v");
        }(sig.v, sig.yParityAndS, sig.yParity);
        const result = new _Signature(_guard, r2, s2, v2);
        if (networkV) {
          __privateSet(result, _networkV, networkV);
        }
        assertError2(sig.yParity == null || (0, index_js_2.getNumber)(sig.yParity, "sig.yParity") === result.yParity, "yParity mismatch");
        assertError2(sig.yParityAndS == null || sig.yParityAndS === result.yParityAndS, "yParityAndS mismatch");
        return result;
      }
    };
    _r2 = new WeakMap();
    _s = new WeakMap();
    _v = new WeakMap();
    _networkV = new WeakMap();
    var Signature = _Signature;
    exports.Signature = Signature;
  }
});

// node_modules/ethers/lib.commonjs/crypto/signing-key.js
var require_signing_key = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/signing-key.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SigningKey = void 0;
    var secp256k1_1 = require_secp256k1();
    var index_js_1 = require_utils5();
    var signature_js_1 = require_signature();
    var _privateKey;
    var _SigningKey = class _SigningKey {
      /**
       *  Creates a new **SigningKey** for %%privateKey%%.
       */
      constructor(privateKey) {
        __privateAdd(this, _privateKey);
        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(privateKey) === 32, "invalid private key", "privateKey", "[REDACTED]");
        __privateSet(this, _privateKey, (0, index_js_1.hexlify)(privateKey));
      }
      /**
       *  The private key.
       */
      get privateKey() {
        return __privateGet(this, _privateKey);
      }
      /**
       *  The uncompressed public key.
       *
       * This will always begin with the prefix ``0x04`` and be 132
       * characters long (the ``0x`` prefix and 130 hexadecimal nibbles).
       */
      get publicKey() {
        return _SigningKey.computePublicKey(__privateGet(this, _privateKey));
      }
      /**
       *  The compressed public key.
       *
       *  This will always begin with either the prefix ``0x02`` or ``0x03``
       *  and be 68 characters long (the ``0x`` prefix and 33 hexadecimal
       *  nibbles)
       */
      get compressedPublicKey() {
        return _SigningKey.computePublicKey(__privateGet(this, _privateKey), true);
      }
      /**
       *  Return the signature of the signed %%digest%%.
       */
      sign(digest) {
        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
        const sig = secp256k1_1.secp256k1.sign((0, index_js_1.getBytesCopy)(digest), (0, index_js_1.getBytesCopy)(__privateGet(this, _privateKey)), {
          lowS: true
        });
        return signature_js_1.Signature.from({
          r: (0, index_js_1.toBeHex)(sig.r, 32),
          s: (0, index_js_1.toBeHex)(sig.s, 32),
          v: sig.recovery ? 28 : 27
        });
      }
      /**
       *  Returns the [[link-wiki-ecdh]] shared secret between this
       *  private key and the %%other%% key.
       *
       *  The %%other%% key may be any type of key, a raw public key,
       *  a compressed/uncompressed pubic key or aprivate key.
       *
       *  Best practice is usually to use a cryptographic hash on the
       *  returned value before using it as a symetric secret.
       *
       *  @example:
       *    sign1 = new SigningKey(id("some-secret-1"))
       *    sign2 = new SigningKey(id("some-secret-2"))
       *
       *    // Notice that privA.computeSharedSecret(pubB)...
       *    sign1.computeSharedSecret(sign2.publicKey)
       *    //_result:
       *
       *    // ...is equal to privB.computeSharedSecret(pubA).
       *    sign2.computeSharedSecret(sign1.publicKey)
       *    //_result:
       */
      computeSharedSecret(other) {
        const pubKey = _SigningKey.computePublicKey(other);
        return (0, index_js_1.hexlify)(secp256k1_1.secp256k1.getSharedSecret((0, index_js_1.getBytesCopy)(__privateGet(this, _privateKey)), (0, index_js_1.getBytes)(pubKey), false));
      }
      /**
       *  Compute the public key for %%key%%, optionally %%compressed%%.
       *
       *  The %%key%% may be any type of key, a raw public key, a
       *  compressed/uncompressed public key or private key.
       *
       *  @example:
       *    sign = new SigningKey(id("some-secret"));
       *
       *    // Compute the uncompressed public key for a private key
       *    SigningKey.computePublicKey(sign.privateKey)
       *    //_result:
       *
       *    // Compute the compressed public key for a private key
       *    SigningKey.computePublicKey(sign.privateKey, true)
       *    //_result:
       *
       *    // Compute the uncompressed public key
       *    SigningKey.computePublicKey(sign.publicKey, false);
       *    //_result:
       *
       *    // Compute the Compressed a public key
       *    SigningKey.computePublicKey(sign.publicKey, true);
       *    //_result:
       */
      static computePublicKey(key, compressed) {
        let bytes = (0, index_js_1.getBytes)(key, "key");
        if (bytes.length === 32) {
          const pubKey = secp256k1_1.secp256k1.getPublicKey(bytes, !!compressed);
          return (0, index_js_1.hexlify)(pubKey);
        }
        if (bytes.length === 64) {
          const pub = new Uint8Array(65);
          pub[0] = 4;
          pub.set(bytes, 1);
          bytes = pub;
        }
        const point = secp256k1_1.secp256k1.ProjectivePoint.fromHex(bytes);
        return (0, index_js_1.hexlify)(point.toRawBytes(compressed));
      }
      /**
       *  Returns the public key for the private key which produced the
       *  %%signature%% for the given %%digest%%.
       *
       *  @example:
       *    key = new SigningKey(id("some-secret"))
       *    digest = id("hello world")
       *    sig = key.sign(digest)
       *
       *    // Notice the signer public key...
       *    key.publicKey
       *    //_result:
       *
       *    // ...is equal to the recovered public key
       *    SigningKey.recoverPublicKey(digest, sig)
       *    //_result:
       *
       */
      static recoverPublicKey(digest, signature) {
        (0, index_js_1.assertArgument)((0, index_js_1.dataLength)(digest) === 32, "invalid digest length", "digest", digest);
        const sig = signature_js_1.Signature.from(signature);
        let secpSig = secp256k1_1.secp256k1.Signature.fromCompact((0, index_js_1.getBytesCopy)((0, index_js_1.concat)([sig.r, sig.s])));
        secpSig = secpSig.addRecoveryBit(sig.yParity);
        const pubKey = secpSig.recoverPublicKey((0, index_js_1.getBytesCopy)(digest));
        (0, index_js_1.assertArgument)(pubKey != null, "invalid signature for digest", "signature", signature);
        return "0x" + pubKey.toHex(false);
      }
      /**
       *  Returns the point resulting from adding the ellipic curve points
       *  %%p0%% and %%p1%%.
       *
       *  This is not a common function most developers should require, but
       *  can be useful for certain privacy-specific techniques.
       *
       *  For example, it is used by [[HDNodeWallet]] to compute child
       *  addresses from parent public keys and chain codes.
       */
      static addPoints(p0, p1, compressed) {
        const pub0 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p0).substring(2));
        const pub1 = secp256k1_1.secp256k1.ProjectivePoint.fromHex(_SigningKey.computePublicKey(p1).substring(2));
        return "0x" + pub0.add(pub1).toHex(!!compressed);
      }
    };
    _privateKey = new WeakMap();
    var SigningKey = _SigningKey;
    exports.SigningKey = SigningKey;
  }
});

// node_modules/ethers/lib.commonjs/crypto/index.js
var require_crypto2 = __commonJS({
  "node_modules/ethers/lib.commonjs/crypto/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.lock = exports.Signature = exports.SigningKey = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = void 0;
    var hmac_js_1 = require_hmac2();
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return hmac_js_1.computeHmac;
    } });
    var keccak_js_1 = require_keccak();
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return keccak_js_1.keccak256;
    } });
    var ripemd160_js_1 = require_ripemd1602();
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return ripemd160_js_1.ripemd160;
    } });
    var pbkdf2_js_1 = require_pbkdf22();
    Object.defineProperty(exports, "pbkdf2", { enumerable: true, get: function() {
      return pbkdf2_js_1.pbkdf2;
    } });
    var random_js_1 = require_random();
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return random_js_1.randomBytes;
    } });
    var scrypt_js_1 = require_scrypt2();
    Object.defineProperty(exports, "scrypt", { enumerable: true, get: function() {
      return scrypt_js_1.scrypt;
    } });
    Object.defineProperty(exports, "scryptSync", { enumerable: true, get: function() {
      return scrypt_js_1.scryptSync;
    } });
    var sha2_js_1 = require_sha22();
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return sha2_js_1.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return sha2_js_1.sha512;
    } });
    var signing_key_js_1 = require_signing_key();
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return signing_key_js_1.SigningKey;
    } });
    var signature_js_1 = require_signature();
    Object.defineProperty(exports, "Signature", { enumerable: true, get: function() {
      return signature_js_1.Signature;
    } });
    function lock() {
      hmac_js_1.computeHmac.lock();
      keccak_js_1.keccak256.lock();
      pbkdf2_js_1.pbkdf2.lock();
      random_js_1.randomBytes.lock();
      ripemd160_js_1.ripemd160.lock();
      scrypt_js_1.scrypt.lock();
      scrypt_js_1.scryptSync.lock();
      sha2_js_1.sha256.lock();
      sha2_js_1.sha512.lock();
      random_js_1.randomBytes.lock();
    }
    exports.lock = lock;
  }
});

// node_modules/ethers/lib.commonjs/address/address.js
var require_address = __commonJS({
  "node_modules/ethers/lib.commonjs/address/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getIcapAddress = exports.getAddress = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_utils5();
    var BN_0 = BigInt(0);
    var BN_36 = BigInt(36);
    function getChecksumAddress(address) {
      address = address.toLowerCase();
      const chars = address.substring(2).split("");
      const expanded = new Uint8Array(40);
      for (let i2 = 0; i2 < 40; i2++) {
        expanded[i2] = chars[i2].charCodeAt(0);
      }
      const hashed = (0, index_js_2.getBytes)((0, index_js_1.keccak256)(expanded));
      for (let i2 = 0; i2 < 40; i2 += 2) {
        if (hashed[i2 >> 1] >> 4 >= 8) {
          chars[i2] = chars[i2].toUpperCase();
        }
        if ((hashed[i2 >> 1] & 15) >= 8) {
          chars[i2 + 1] = chars[i2 + 1].toUpperCase();
        }
      }
      return "0x" + chars.join("");
    }
    var ibanLookup = {};
    for (let i2 = 0; i2 < 10; i2++) {
      ibanLookup[String(i2)] = String(i2);
    }
    for (let i2 = 0; i2 < 26; i2++) {
      ibanLookup[String.fromCharCode(65 + i2)] = String(10 + i2);
    }
    var safeDigits = 15;
    function ibanChecksum(address) {
      address = address.toUpperCase();
      address = address.substring(4) + address.substring(0, 2) + "00";
      let expanded = address.split("").map((c3) => {
        return ibanLookup[c3];
      }).join("");
      while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
      }
      let checksum2 = String(98 - parseInt(expanded, 10) % 97);
      while (checksum2.length < 2) {
        checksum2 = "0" + checksum2;
      }
      return checksum2;
    }
    var Base36 = function() {
      ;
      const result = {};
      for (let i2 = 0; i2 < 36; i2++) {
        const key = "0123456789abcdefghijklmnopqrstuvwxyz"[i2];
        result[key] = BigInt(i2);
      }
      return result;
    }();
    function fromBase36(value) {
      value = value.toLowerCase();
      let result = BN_0;
      for (let i2 = 0; i2 < value.length; i2++) {
        result = result * BN_36 + Base36[value[i2]];
      }
      return result;
    }
    function getAddress2(address) {
      (0, index_js_2.assertArgument)(typeof address === "string", "invalid address", "address", address);
      if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        if (!address.startsWith("0x")) {
          address = "0x" + address;
        }
        const result = getChecksumAddress(address);
        (0, index_js_2.assertArgument)(!address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) || result === address, "bad address checksum", "address", address);
        return result;
      }
      if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        (0, index_js_2.assertArgument)(address.substring(2, 4) === ibanChecksum(address), "bad icap checksum", "address", address);
        let result = fromBase36(address.substring(4)).toString(16);
        while (result.length < 40) {
          result = "0" + result;
        }
        return getChecksumAddress("0x" + result);
      }
      (0, index_js_2.assertArgument)(false, "invalid address", "address", address);
    }
    exports.getAddress = getAddress2;
    function getIcapAddress(address) {
      let base36 = BigInt(getAddress2(address)).toString(36).toUpperCase();
      while (base36.length < 30) {
        base36 = "0" + base36;
      }
      return "XE" + ibanChecksum("XE00" + base36) + base36;
    }
    exports.getIcapAddress = getIcapAddress;
  }
});

// node_modules/ethers/lib.commonjs/address/contract-address.js
var require_contract_address = __commonJS({
  "node_modules/ethers/lib.commonjs/address/contract-address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getCreate2Address = exports.getCreateAddress = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_utils5();
    var address_js_1 = require_address();
    function getCreateAddress(tx) {
      const from26 = (0, address_js_1.getAddress)(tx.from);
      const nonce = (0, index_js_2.getBigInt)(tx.nonce, "tx.nonce");
      let nonceHex = nonce.toString(16);
      if (nonceHex === "0") {
        nonceHex = "0x";
      } else if (nonceHex.length % 2) {
        nonceHex = "0x0" + nonceHex;
      } else {
        nonceHex = "0x" + nonceHex;
      }
      return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.encodeRlp)([from26, nonceHex])), 12));
    }
    exports.getCreateAddress = getCreateAddress;
    function getCreate2Address(_from, _salt, _initCodeHash) {
      const from26 = (0, address_js_1.getAddress)(_from);
      const salt = (0, index_js_2.getBytes)(_salt, "salt");
      const initCodeHash = (0, index_js_2.getBytes)(_initCodeHash, "initCodeHash");
      (0, index_js_2.assertArgument)(salt.length === 32, "salt must be 32 bytes", "salt", _salt);
      (0, index_js_2.assertArgument)(initCodeHash.length === 32, "initCodeHash must be 32 bytes", "initCodeHash", _initCodeHash);
      return (0, address_js_1.getAddress)((0, index_js_2.dataSlice)((0, index_js_1.keccak256)((0, index_js_2.concat)(["0xff", from26, salt, initCodeHash])), 12));
    }
    exports.getCreate2Address = getCreate2Address;
  }
});

// node_modules/ethers/lib.commonjs/address/checks.js
var require_checks = __commonJS({
  "node_modules/ethers/lib.commonjs/address/checks.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveAddress = exports.isAddress = exports.isAddressable = void 0;
    var index_js_1 = require_utils5();
    var address_js_1 = require_address();
    function isAddressable(value) {
      return value && typeof value.getAddress === "function";
    }
    exports.isAddressable = isAddressable;
    function isAddress2(value) {
      try {
        (0, address_js_1.getAddress)(value);
        return true;
      } catch (error) {
      }
      return false;
    }
    exports.isAddress = isAddress2;
    async function checkAddress(target, promise) {
      const result = await promise;
      if (result == null || result === "0x0000000000000000000000000000000000000000") {
        (0, index_js_1.assert)(typeof target !== "string", "unconfigured name", "UNCONFIGURED_NAME", { value: target });
        (0, index_js_1.assertArgument)(false, "invalid AddressLike value; did not resolve to a value address", "target", target);
      }
      return (0, address_js_1.getAddress)(result);
    }
    function resolveAddress(target, resolver) {
      if (typeof target === "string") {
        if (target.match(/^0x[0-9a-f]{40}$/i)) {
          return (0, address_js_1.getAddress)(target);
        }
        (0, index_js_1.assert)(resolver != null, "ENS resolution requires a provider", "UNSUPPORTED_OPERATION", { operation: "resolveName" });
        return checkAddress(target, resolver.resolveName(target));
      } else if (isAddressable(target)) {
        return checkAddress(target, target.getAddress());
      } else if (target && typeof target.then === "function") {
        return checkAddress(target, target);
      }
      (0, index_js_1.assertArgument)(false, "unsupported addressable value", "target", target);
    }
    exports.resolveAddress = resolveAddress;
  }
});

// node_modules/ethers/lib.commonjs/address/index.js
var require_address2 = __commonJS({
  "node_modules/ethers/lib.commonjs/address/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = void 0;
    var address_js_1 = require_address();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return address_js_1.getAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return address_js_1.getIcapAddress;
    } });
    var contract_address_js_1 = require_contract_address();
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return contract_address_js_1.getCreateAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return contract_address_js_1.getCreate2Address;
    } });
    var checks_js_1 = require_checks();
    Object.defineProperty(exports, "isAddressable", { enumerable: true, get: function() {
      return checks_js_1.isAddressable;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return checks_js_1.isAddress;
    } });
    Object.defineProperty(exports, "resolveAddress", { enumerable: true, get: function() {
      return checks_js_1.resolveAddress;
    } });
  }
});

// node_modules/ethers/lib.commonjs/abi/typed.js
var require_typed = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/typed.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Typed = void 0;
    var index_js_1 = require_utils5();
    var _gaurd = {};
    function n2(value, width) {
      let signed2 = false;
      if (width < 0) {
        signed2 = true;
        width *= -1;
      }
      return new Typed(_gaurd, `${signed2 ? "" : "u"}int${width}`, value, { signed: signed2, width });
    }
    function b4(value, size5) {
      return new Typed(_gaurd, `bytes${size5 ? size5 : ""}`, value, { size: size5 });
    }
    var _typedSymbol = Symbol.for("_ethers_typed");
    var _options;
    var _Typed = class _Typed {
      /**
       *  @_ignore:
       */
      constructor(gaurd, type6, value, options) {
        /**
         *  The type, as a Solidity-compatible type.
         */
        __publicField(this, "type");
        /**
         *  The actual value.
         */
        __publicField(this, "value");
        __privateAdd(this, _options);
        /**
         *  @_ignore:
         */
        __publicField(this, "_typedSymbol");
        if (options == null) {
          options = null;
        }
        (0, index_js_1.assertPrivate)(_gaurd, gaurd, "Typed");
        (0, index_js_1.defineProperties)(this, { _typedSymbol, type: type6, value });
        __privateSet(this, _options, options);
        this.format();
      }
      /**
       *  Format the type as a Human-Readable type.
       */
      format() {
        if (this.type === "array") {
          throw new Error("");
        } else if (this.type === "dynamicArray") {
          throw new Error("");
        } else if (this.type === "tuple") {
          return `tuple(${this.value.map((v2) => v2.format()).join(",")})`;
        }
        return this.type;
      }
      /**
       *  The default value returned by this type.
       */
      defaultValue() {
        return 0;
      }
      /**
       *  The minimum value for numeric types.
       */
      minValue() {
        return 0;
      }
      /**
       *  The maximum value for numeric types.
       */
      maxValue() {
        return 0;
      }
      /**
       *  Returns ``true`` and provides a type guard is this is a [[TypedBigInt]].
       */
      isBigInt() {
        return !!this.type.match(/^u?int[0-9]+$/);
      }
      /**
       *  Returns ``true`` and provides a type guard is this is a [[TypedData]].
       */
      isData() {
        return this.type.startsWith("bytes");
      }
      /**
       *  Returns ``true`` and provides a type guard is this is a [[TypedString]].
       */
      isString() {
        return this.type === "string";
      }
      /**
       *  Returns the tuple name, if this is a tuple. Throws otherwise.
       */
      get tupleName() {
        if (this.type !== "tuple") {
          throw TypeError("not a tuple");
        }
        return __privateGet(this, _options);
      }
      // Returns the length of this type as an array
      // - `null` indicates the length is unforced, it could be dynamic
      // - `-1` indicates the length is dynamic
      // - any other value indicates it is a static array and is its length
      /**
       *  Returns the length of the array type or ``-1`` if it is dynamic.
       *
       *  Throws if the type is not an array.
       */
      get arrayLength() {
        if (this.type !== "array") {
          throw TypeError("not an array");
        }
        if (__privateGet(this, _options) === true) {
          return -1;
        }
        if (__privateGet(this, _options) === false) {
          return this.value.length;
        }
        return null;
      }
      /**
       *  Returns a new **Typed** of %%type%% with the %%value%%.
       */
      static from(type6, value) {
        return new _Typed(_gaurd, type6, value);
      }
      /**
       *  Return a new ``uint8`` type for %%v%%.
       */
      static uint8(v2) {
        return n2(v2, 8);
      }
      /**
       *  Return a new ``uint16`` type for %%v%%.
       */
      static uint16(v2) {
        return n2(v2, 16);
      }
      /**
       *  Return a new ``uint24`` type for %%v%%.
       */
      static uint24(v2) {
        return n2(v2, 24);
      }
      /**
       *  Return a new ``uint32`` type for %%v%%.
       */
      static uint32(v2) {
        return n2(v2, 32);
      }
      /**
       *  Return a new ``uint40`` type for %%v%%.
       */
      static uint40(v2) {
        return n2(v2, 40);
      }
      /**
       *  Return a new ``uint48`` type for %%v%%.
       */
      static uint48(v2) {
        return n2(v2, 48);
      }
      /**
       *  Return a new ``uint56`` type for %%v%%.
       */
      static uint56(v2) {
        return n2(v2, 56);
      }
      /**
       *  Return a new ``uint64`` type for %%v%%.
       */
      static uint64(v2) {
        return n2(v2, 64);
      }
      /**
       *  Return a new ``uint72`` type for %%v%%.
       */
      static uint72(v2) {
        return n2(v2, 72);
      }
      /**
       *  Return a new ``uint80`` type for %%v%%.
       */
      static uint80(v2) {
        return n2(v2, 80);
      }
      /**
       *  Return a new ``uint88`` type for %%v%%.
       */
      static uint88(v2) {
        return n2(v2, 88);
      }
      /**
       *  Return a new ``uint96`` type for %%v%%.
       */
      static uint96(v2) {
        return n2(v2, 96);
      }
      /**
       *  Return a new ``uint104`` type for %%v%%.
       */
      static uint104(v2) {
        return n2(v2, 104);
      }
      /**
       *  Return a new ``uint112`` type for %%v%%.
       */
      static uint112(v2) {
        return n2(v2, 112);
      }
      /**
       *  Return a new ``uint120`` type for %%v%%.
       */
      static uint120(v2) {
        return n2(v2, 120);
      }
      /**
       *  Return a new ``uint128`` type for %%v%%.
       */
      static uint128(v2) {
        return n2(v2, 128);
      }
      /**
       *  Return a new ``uint136`` type for %%v%%.
       */
      static uint136(v2) {
        return n2(v2, 136);
      }
      /**
       *  Return a new ``uint144`` type for %%v%%.
       */
      static uint144(v2) {
        return n2(v2, 144);
      }
      /**
       *  Return a new ``uint152`` type for %%v%%.
       */
      static uint152(v2) {
        return n2(v2, 152);
      }
      /**
       *  Return a new ``uint160`` type for %%v%%.
       */
      static uint160(v2) {
        return n2(v2, 160);
      }
      /**
       *  Return a new ``uint168`` type for %%v%%.
       */
      static uint168(v2) {
        return n2(v2, 168);
      }
      /**
       *  Return a new ``uint176`` type for %%v%%.
       */
      static uint176(v2) {
        return n2(v2, 176);
      }
      /**
       *  Return a new ``uint184`` type for %%v%%.
       */
      static uint184(v2) {
        return n2(v2, 184);
      }
      /**
       *  Return a new ``uint192`` type for %%v%%.
       */
      static uint192(v2) {
        return n2(v2, 192);
      }
      /**
       *  Return a new ``uint200`` type for %%v%%.
       */
      static uint200(v2) {
        return n2(v2, 200);
      }
      /**
       *  Return a new ``uint208`` type for %%v%%.
       */
      static uint208(v2) {
        return n2(v2, 208);
      }
      /**
       *  Return a new ``uint216`` type for %%v%%.
       */
      static uint216(v2) {
        return n2(v2, 216);
      }
      /**
       *  Return a new ``uint224`` type for %%v%%.
       */
      static uint224(v2) {
        return n2(v2, 224);
      }
      /**
       *  Return a new ``uint232`` type for %%v%%.
       */
      static uint232(v2) {
        return n2(v2, 232);
      }
      /**
       *  Return a new ``uint240`` type for %%v%%.
       */
      static uint240(v2) {
        return n2(v2, 240);
      }
      /**
       *  Return a new ``uint248`` type for %%v%%.
       */
      static uint248(v2) {
        return n2(v2, 248);
      }
      /**
       *  Return a new ``uint256`` type for %%v%%.
       */
      static uint256(v2) {
        return n2(v2, 256);
      }
      /**
       *  Return a new ``uint256`` type for %%v%%.
       */
      static uint(v2) {
        return n2(v2, 256);
      }
      /**
       *  Return a new ``int8`` type for %%v%%.
       */
      static int8(v2) {
        return n2(v2, -8);
      }
      /**
       *  Return a new ``int16`` type for %%v%%.
       */
      static int16(v2) {
        return n2(v2, -16);
      }
      /**
       *  Return a new ``int24`` type for %%v%%.
       */
      static int24(v2) {
        return n2(v2, -24);
      }
      /**
       *  Return a new ``int32`` type for %%v%%.
       */
      static int32(v2) {
        return n2(v2, -32);
      }
      /**
       *  Return a new ``int40`` type for %%v%%.
       */
      static int40(v2) {
        return n2(v2, -40);
      }
      /**
       *  Return a new ``int48`` type for %%v%%.
       */
      static int48(v2) {
        return n2(v2, -48);
      }
      /**
       *  Return a new ``int56`` type for %%v%%.
       */
      static int56(v2) {
        return n2(v2, -56);
      }
      /**
       *  Return a new ``int64`` type for %%v%%.
       */
      static int64(v2) {
        return n2(v2, -64);
      }
      /**
       *  Return a new ``int72`` type for %%v%%.
       */
      static int72(v2) {
        return n2(v2, -72);
      }
      /**
       *  Return a new ``int80`` type for %%v%%.
       */
      static int80(v2) {
        return n2(v2, -80);
      }
      /**
       *  Return a new ``int88`` type for %%v%%.
       */
      static int88(v2) {
        return n2(v2, -88);
      }
      /**
       *  Return a new ``int96`` type for %%v%%.
       */
      static int96(v2) {
        return n2(v2, -96);
      }
      /**
       *  Return a new ``int104`` type for %%v%%.
       */
      static int104(v2) {
        return n2(v2, -104);
      }
      /**
       *  Return a new ``int112`` type for %%v%%.
       */
      static int112(v2) {
        return n2(v2, -112);
      }
      /**
       *  Return a new ``int120`` type for %%v%%.
       */
      static int120(v2) {
        return n2(v2, -120);
      }
      /**
       *  Return a new ``int128`` type for %%v%%.
       */
      static int128(v2) {
        return n2(v2, -128);
      }
      /**
       *  Return a new ``int136`` type for %%v%%.
       */
      static int136(v2) {
        return n2(v2, -136);
      }
      /**
       *  Return a new ``int144`` type for %%v%%.
       */
      static int144(v2) {
        return n2(v2, -144);
      }
      /**
       *  Return a new ``int52`` type for %%v%%.
       */
      static int152(v2) {
        return n2(v2, -152);
      }
      /**
       *  Return a new ``int160`` type for %%v%%.
       */
      static int160(v2) {
        return n2(v2, -160);
      }
      /**
       *  Return a new ``int168`` type for %%v%%.
       */
      static int168(v2) {
        return n2(v2, -168);
      }
      /**
       *  Return a new ``int176`` type for %%v%%.
       */
      static int176(v2) {
        return n2(v2, -176);
      }
      /**
       *  Return a new ``int184`` type for %%v%%.
       */
      static int184(v2) {
        return n2(v2, -184);
      }
      /**
       *  Return a new ``int92`` type for %%v%%.
       */
      static int192(v2) {
        return n2(v2, -192);
      }
      /**
       *  Return a new ``int200`` type for %%v%%.
       */
      static int200(v2) {
        return n2(v2, -200);
      }
      /**
       *  Return a new ``int208`` type for %%v%%.
       */
      static int208(v2) {
        return n2(v2, -208);
      }
      /**
       *  Return a new ``int216`` type for %%v%%.
       */
      static int216(v2) {
        return n2(v2, -216);
      }
      /**
       *  Return a new ``int224`` type for %%v%%.
       */
      static int224(v2) {
        return n2(v2, -224);
      }
      /**
       *  Return a new ``int232`` type for %%v%%.
       */
      static int232(v2) {
        return n2(v2, -232);
      }
      /**
       *  Return a new ``int240`` type for %%v%%.
       */
      static int240(v2) {
        return n2(v2, -240);
      }
      /**
       *  Return a new ``int248`` type for %%v%%.
       */
      static int248(v2) {
        return n2(v2, -248);
      }
      /**
       *  Return a new ``int256`` type for %%v%%.
       */
      static int256(v2) {
        return n2(v2, -256);
      }
      /**
       *  Return a new ``int256`` type for %%v%%.
       */
      static int(v2) {
        return n2(v2, -256);
      }
      /**
       *  Return a new ``bytes1`` type for %%v%%.
       */
      static bytes1(v2) {
        return b4(v2, 1);
      }
      /**
       *  Return a new ``bytes2`` type for %%v%%.
       */
      static bytes2(v2) {
        return b4(v2, 2);
      }
      /**
       *  Return a new ``bytes3`` type for %%v%%.
       */
      static bytes3(v2) {
        return b4(v2, 3);
      }
      /**
       *  Return a new ``bytes4`` type for %%v%%.
       */
      static bytes4(v2) {
        return b4(v2, 4);
      }
      /**
       *  Return a new ``bytes5`` type for %%v%%.
       */
      static bytes5(v2) {
        return b4(v2, 5);
      }
      /**
       *  Return a new ``bytes6`` type for %%v%%.
       */
      static bytes6(v2) {
        return b4(v2, 6);
      }
      /**
       *  Return a new ``bytes7`` type for %%v%%.
       */
      static bytes7(v2) {
        return b4(v2, 7);
      }
      /**
       *  Return a new ``bytes8`` type for %%v%%.
       */
      static bytes8(v2) {
        return b4(v2, 8);
      }
      /**
       *  Return a new ``bytes9`` type for %%v%%.
       */
      static bytes9(v2) {
        return b4(v2, 9);
      }
      /**
       *  Return a new ``bytes10`` type for %%v%%.
       */
      static bytes10(v2) {
        return b4(v2, 10);
      }
      /**
       *  Return a new ``bytes11`` type for %%v%%.
       */
      static bytes11(v2) {
        return b4(v2, 11);
      }
      /**
       *  Return a new ``bytes12`` type for %%v%%.
       */
      static bytes12(v2) {
        return b4(v2, 12);
      }
      /**
       *  Return a new ``bytes13`` type for %%v%%.
       */
      static bytes13(v2) {
        return b4(v2, 13);
      }
      /**
       *  Return a new ``bytes14`` type for %%v%%.
       */
      static bytes14(v2) {
        return b4(v2, 14);
      }
      /**
       *  Return a new ``bytes15`` type for %%v%%.
       */
      static bytes15(v2) {
        return b4(v2, 15);
      }
      /**
       *  Return a new ``bytes16`` type for %%v%%.
       */
      static bytes16(v2) {
        return b4(v2, 16);
      }
      /**
       *  Return a new ``bytes17`` type for %%v%%.
       */
      static bytes17(v2) {
        return b4(v2, 17);
      }
      /**
       *  Return a new ``bytes18`` type for %%v%%.
       */
      static bytes18(v2) {
        return b4(v2, 18);
      }
      /**
       *  Return a new ``bytes19`` type for %%v%%.
       */
      static bytes19(v2) {
        return b4(v2, 19);
      }
      /**
       *  Return a new ``bytes20`` type for %%v%%.
       */
      static bytes20(v2) {
        return b4(v2, 20);
      }
      /**
       *  Return a new ``bytes21`` type for %%v%%.
       */
      static bytes21(v2) {
        return b4(v2, 21);
      }
      /**
       *  Return a new ``bytes22`` type for %%v%%.
       */
      static bytes22(v2) {
        return b4(v2, 22);
      }
      /**
       *  Return a new ``bytes23`` type for %%v%%.
       */
      static bytes23(v2) {
        return b4(v2, 23);
      }
      /**
       *  Return a new ``bytes24`` type for %%v%%.
       */
      static bytes24(v2) {
        return b4(v2, 24);
      }
      /**
       *  Return a new ``bytes25`` type for %%v%%.
       */
      static bytes25(v2) {
        return b4(v2, 25);
      }
      /**
       *  Return a new ``bytes26`` type for %%v%%.
       */
      static bytes26(v2) {
        return b4(v2, 26);
      }
      /**
       *  Return a new ``bytes27`` type for %%v%%.
       */
      static bytes27(v2) {
        return b4(v2, 27);
      }
      /**
       *  Return a new ``bytes28`` type for %%v%%.
       */
      static bytes28(v2) {
        return b4(v2, 28);
      }
      /**
       *  Return a new ``bytes29`` type for %%v%%.
       */
      static bytes29(v2) {
        return b4(v2, 29);
      }
      /**
       *  Return a new ``bytes30`` type for %%v%%.
       */
      static bytes30(v2) {
        return b4(v2, 30);
      }
      /**
       *  Return a new ``bytes31`` type for %%v%%.
       */
      static bytes31(v2) {
        return b4(v2, 31);
      }
      /**
       *  Return a new ``bytes32`` type for %%v%%.
       */
      static bytes32(v2) {
        return b4(v2, 32);
      }
      /**
       *  Return a new ``address`` type for %%v%%.
       */
      static address(v2) {
        return new _Typed(_gaurd, "address", v2);
      }
      /**
       *  Return a new ``bool`` type for %%v%%.
       */
      static bool(v2) {
        return new _Typed(_gaurd, "bool", !!v2);
      }
      /**
       *  Return a new ``bytes`` type for %%v%%.
       */
      static bytes(v2) {
        return new _Typed(_gaurd, "bytes", v2);
      }
      /**
       *  Return a new ``string`` type for %%v%%.
       */
      static string(v2) {
        return new _Typed(_gaurd, "string", v2);
      }
      /**
       *  Return a new ``array`` type for %%v%%, allowing %%dynamic%% length.
       */
      static array(v2, dynamic) {
        throw new Error("not implemented yet");
        return new _Typed(_gaurd, "array", v2, dynamic);
      }
      /**
       *  Return a new ``tuple`` type for %%v%%, with the optional %%name%%.
       */
      static tuple(v2, name) {
        throw new Error("not implemented yet");
        return new _Typed(_gaurd, "tuple", v2, name);
      }
      /**
       *  Return a new ``uint8`` type for %%v%%.
       */
      static overrides(v2) {
        return new _Typed(_gaurd, "overrides", Object.assign({}, v2));
      }
      /**
       *  Returns true only if %%value%% is a [[Typed]] instance.
       */
      static isTyped(value) {
        return value && typeof value === "object" && "_typedSymbol" in value && value._typedSymbol === _typedSymbol;
      }
      /**
       *  If the value is a [[Typed]] instance, validates the underlying value
       *  and returns it, otherwise returns value directly.
       *
       *  This is useful for functions that with to accept either a [[Typed]]
       *  object or values.
       */
      static dereference(value, type6) {
        if (_Typed.isTyped(value)) {
          if (value.type !== type6) {
            throw new Error(`invalid type: expecetd ${type6}, got ${value.type}`);
          }
          return value.value;
        }
        return value;
      }
    };
    _options = new WeakMap();
    var Typed = _Typed;
    exports.Typed = Typed;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/address.js
var require_address3 = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AddressCoder = void 0;
    var index_js_1 = require_address2();
    var maths_js_1 = require_maths();
    var typed_js_1 = require_typed();
    var abstract_coder_js_1 = require_abstract_coder();
    var AddressCoder = class extends abstract_coder_js_1.Coder {
      constructor(localName) {
        super("address", "address", localName, false);
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000";
      }
      encode(writer, _value) {
        let value = typed_js_1.Typed.dereference(_value, "string");
        try {
          value = (0, index_js_1.getAddress)(value);
        } catch (error) {
          return this._throwError(error.message, _value);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        return (0, index_js_1.getAddress)((0, maths_js_1.toBeHex)(reader.readValue(), 20));
      }
    };
    exports.AddressCoder = AddressCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/anonymous.js
var require_anonymous = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/anonymous.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnonymousCoder = void 0;
    var abstract_coder_js_1 = require_abstract_coder();
    var AnonymousCoder = class extends abstract_coder_js_1.Coder {
      constructor(coder) {
        super(coder.name, coder.type, "_", coder.dynamic);
        __publicField(this, "coder");
        this.coder = coder;
      }
      defaultValue() {
        return this.coder.defaultValue();
      }
      encode(writer, value) {
        return this.coder.encode(writer, value);
      }
      decode(reader) {
        return this.coder.decode(reader);
      }
    };
    exports.AnonymousCoder = AnonymousCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/array.js
var require_array = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/array.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ArrayCoder = exports.unpack = exports.pack = void 0;
    var index_js_1 = require_utils5();
    var typed_js_1 = require_typed();
    var abstract_coder_js_1 = require_abstract_coder();
    var anonymous_js_1 = require_anonymous();
    function pack(writer, coders, values) {
      let arrayValues = [];
      if (Array.isArray(values)) {
        arrayValues = values;
      } else if (values && typeof values === "object") {
        let unique2 = {};
        arrayValues = coders.map((coder) => {
          const name = coder.localName;
          (0, index_js_1.assert)(name, "cannot encode object for signature with missing names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
          (0, index_js_1.assert)(!unique2[name], "cannot encode object for signature with duplicate names", "INVALID_ARGUMENT", { argument: "values", info: { coder }, value: values });
          unique2[name] = true;
          return values[name];
        });
      } else {
        (0, index_js_1.assertArgument)(false, "invalid tuple value", "tuple", values);
      }
      (0, index_js_1.assertArgument)(coders.length === arrayValues.length, "types/value length mismatch", "tuple", values);
      let staticWriter = new abstract_coder_js_1.Writer();
      let dynamicWriter = new abstract_coder_js_1.Writer();
      let updateFuncs = [];
      coders.forEach((coder, index5) => {
        let value = arrayValues[index5];
        if (coder.dynamic) {
          let dynamicOffset = dynamicWriter.length;
          coder.encode(dynamicWriter, value);
          let updateFunc = staticWriter.writeUpdatableValue();
          updateFuncs.push((baseOffset) => {
            updateFunc(baseOffset + dynamicOffset);
          });
        } else {
          coder.encode(staticWriter, value);
        }
      });
      updateFuncs.forEach((func) => {
        func(staticWriter.length);
      });
      let length2 = writer.appendWriter(staticWriter);
      length2 += writer.appendWriter(dynamicWriter);
      return length2;
    }
    exports.pack = pack;
    function unpack(reader, coders) {
      let values = [];
      let keys = [];
      let baseReader = reader.subReader(0);
      coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
          let offset = reader.readIndex();
          let offsetReader = baseReader.subReader(offset);
          try {
            value = coder.decode(offsetReader);
          } catch (error) {
            if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
              throw error;
            }
            value = error;
            value.baseType = coder.name;
            value.name = coder.localName;
            value.type = coder.type;
          }
        } else {
          try {
            value = coder.decode(reader);
          } catch (error) {
            if ((0, index_js_1.isError)(error, "BUFFER_OVERRUN")) {
              throw error;
            }
            value = error;
            value.baseType = coder.name;
            value.name = coder.localName;
            value.type = coder.type;
          }
        }
        if (value == void 0) {
          throw new Error("investigate");
        }
        values.push(value);
        keys.push(coder.localName || null);
      });
      return abstract_coder_js_1.Result.fromItems(values, keys);
    }
    exports.unpack = unpack;
    var ArrayCoder = class extends abstract_coder_js_1.Coder {
      constructor(coder, length2, localName) {
        const type6 = coder.type + "[" + (length2 >= 0 ? length2 : "") + "]";
        const dynamic = length2 === -1 || coder.dynamic;
        super("array", type6, localName, dynamic);
        __publicField(this, "coder");
        __publicField(this, "length");
        (0, index_js_1.defineProperties)(this, { coder, length: length2 });
      }
      defaultValue() {
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i2 = 0; i2 < this.length; i2++) {
          result.push(defaultChild);
        }
        return result;
      }
      encode(writer, _value) {
        const value = typed_js_1.Typed.dereference(_value, "array");
        if (!Array.isArray(value)) {
          this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
          count = value.length;
          writer.writeValue(value.length);
        }
        (0, index_js_1.assertArgumentCount)(value.length, count, "coder array" + (this.localName ? " " + this.localName : ""));
        let coders = [];
        for (let i2 = 0; i2 < value.length; i2++) {
          coders.push(this.coder);
        }
        return pack(writer, coders, value);
      }
      decode(reader) {
        let count = this.length;
        if (count === -1) {
          count = reader.readIndex();
          (0, index_js_1.assert)(count * abstract_coder_js_1.WordSize <= reader.dataLength, "insufficient data length", "BUFFER_OVERRUN", { buffer: reader.bytes, offset: count * abstract_coder_js_1.WordSize, length: reader.dataLength });
        }
        let coders = [];
        for (let i2 = 0; i2 < count; i2++) {
          coders.push(new anonymous_js_1.AnonymousCoder(this.coder));
        }
        return unpack(reader, coders);
      }
    };
    exports.ArrayCoder = ArrayCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/boolean.js
var require_boolean = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/boolean.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BooleanCoder = void 0;
    var typed_js_1 = require_typed();
    var abstract_coder_js_1 = require_abstract_coder();
    var BooleanCoder = class extends abstract_coder_js_1.Coder {
      constructor(localName) {
        super("bool", "bool", localName, false);
      }
      defaultValue() {
        return false;
      }
      encode(writer, _value) {
        const value = typed_js_1.Typed.dereference(_value, "bool");
        return writer.writeValue(value ? 1 : 0);
      }
      decode(reader) {
        return !!reader.readValue();
      }
    };
    exports.BooleanCoder = BooleanCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/bytes.js
var require_bytes = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BytesCoder = exports.DynamicBytesCoder = void 0;
    var index_js_1 = require_utils5();
    var abstract_coder_js_1 = require_abstract_coder();
    var DynamicBytesCoder = class extends abstract_coder_js_1.Coder {
      constructor(type6, localName) {
        super(type6, type6, localName, true);
      }
      defaultValue() {
        return "0x";
      }
      encode(writer, value) {
        value = (0, index_js_1.getBytesCopy)(value);
        let length2 = writer.writeValue(value.length);
        length2 += writer.writeBytes(value);
        return length2;
      }
      decode(reader) {
        return reader.readBytes(reader.readIndex(), true);
      }
    };
    exports.DynamicBytesCoder = DynamicBytesCoder;
    var BytesCoder = class extends DynamicBytesCoder {
      constructor(localName) {
        super("bytes", localName);
      }
      decode(reader) {
        return (0, index_js_1.hexlify)(super.decode(reader));
      }
    };
    exports.BytesCoder = BytesCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js
var require_fixed_bytes = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/fixed-bytes.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FixedBytesCoder = void 0;
    var index_js_1 = require_utils5();
    var typed_js_1 = require_typed();
    var abstract_coder_js_1 = require_abstract_coder();
    var FixedBytesCoder = class extends abstract_coder_js_1.Coder {
      constructor(size5, localName) {
        let name = "bytes" + String(size5);
        super(name, name, localName, false);
        __publicField(this, "size");
        (0, index_js_1.defineProperties)(this, { size: size5 }, { size: "number" });
      }
      defaultValue() {
        return "0x0000000000000000000000000000000000000000000000000000000000000000".substring(0, 2 + this.size * 2);
      }
      encode(writer, _value) {
        let data = (0, index_js_1.getBytesCopy)(typed_js_1.Typed.dereference(_value, this.type));
        if (data.length !== this.size) {
          this._throwError("incorrect data length", _value);
        }
        return writer.writeBytes(data);
      }
      decode(reader) {
        return (0, index_js_1.hexlify)(reader.readBytes(this.size));
      }
    };
    exports.FixedBytesCoder = FixedBytesCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/null.js
var require_null = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/null.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NullCoder = void 0;
    var abstract_coder_js_1 = require_abstract_coder();
    var Empty = new Uint8Array([]);
    var NullCoder = class extends abstract_coder_js_1.Coder {
      constructor(localName) {
        super("null", "", localName, false);
      }
      defaultValue() {
        return null;
      }
      encode(writer, value) {
        if (value != null) {
          this._throwError("not null", value);
        }
        return writer.writeBytes(Empty);
      }
      decode(reader) {
        reader.readBytes(0);
        return null;
      }
    };
    exports.NullCoder = NullCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/number.js
var require_number = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/number.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NumberCoder = void 0;
    var index_js_1 = require_utils5();
    var typed_js_1 = require_typed();
    var abstract_coder_js_1 = require_abstract_coder();
    var BN_0 = BigInt(0);
    var BN_1 = BigInt(1);
    var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    var NumberCoder = class extends abstract_coder_js_1.Coder {
      constructor(size5, signed2, localName) {
        const name = (signed2 ? "int" : "uint") + size5 * 8;
        super(name, name, localName, false);
        __publicField(this, "size");
        __publicField(this, "signed");
        (0, index_js_1.defineProperties)(this, { size: size5, signed: signed2 }, { size: "number", signed: "boolean" });
      }
      defaultValue() {
        return 0;
      }
      encode(writer, _value) {
        let value = (0, index_js_1.getBigInt)(typed_js_1.Typed.dereference(_value, this.type));
        let maxUintValue = (0, index_js_1.mask)(BN_MAX_UINT256, abstract_coder_js_1.WordSize * 8);
        if (this.signed) {
          let bounds = (0, index_js_1.mask)(maxUintValue, this.size * 8 - 1);
          if (value > bounds || value < -(bounds + BN_1)) {
            this._throwError("value out-of-bounds", _value);
          }
          value = (0, index_js_1.toTwos)(value, 8 * abstract_coder_js_1.WordSize);
        } else if (value < BN_0 || value > (0, index_js_1.mask)(maxUintValue, this.size * 8)) {
          this._throwError("value out-of-bounds", _value);
        }
        return writer.writeValue(value);
      }
      decode(reader) {
        let value = (0, index_js_1.mask)(reader.readValue(), this.size * 8);
        if (this.signed) {
          value = (0, index_js_1.fromTwos)(value, this.size * 8);
        }
        return value;
      }
    };
    exports.NumberCoder = NumberCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/string.js
var require_string = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/string.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StringCoder = void 0;
    var utf8_js_1 = require_utf8();
    var typed_js_1 = require_typed();
    var bytes_js_1 = require_bytes();
    var StringCoder = class extends bytes_js_1.DynamicBytesCoder {
      constructor(localName) {
        super("string", localName);
      }
      defaultValue() {
        return "";
      }
      encode(writer, _value) {
        return super.encode(writer, (0, utf8_js_1.toUtf8Bytes)(typed_js_1.Typed.dereference(_value, "string")));
      }
      decode(reader) {
        return (0, utf8_js_1.toUtf8String)(super.decode(reader));
      }
    };
    exports.StringCoder = StringCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/coders/tuple.js
var require_tuple = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/coders/tuple.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TupleCoder = void 0;
    var properties_js_1 = require_properties();
    var typed_js_1 = require_typed();
    var abstract_coder_js_1 = require_abstract_coder();
    var array_js_1 = require_array();
    var TupleCoder = class extends abstract_coder_js_1.Coder {
      constructor(coders, localName) {
        let dynamic = false;
        const types3 = [];
        coders.forEach((coder) => {
          if (coder.dynamic) {
            dynamic = true;
          }
          types3.push(coder.type);
        });
        const type6 = "tuple(" + types3.join(",") + ")";
        super("tuple", type6, localName, dynamic);
        __publicField(this, "coders");
        (0, properties_js_1.defineProperties)(this, { coders: Object.freeze(coders.slice()) });
      }
      defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
          values.push(coder.defaultValue());
        });
        const uniqueNames = this.coders.reduce((accum, coder) => {
          const name = coder.localName;
          if (name) {
            if (!accum[name]) {
              accum[name] = 0;
            }
            accum[name]++;
          }
          return accum;
        }, {});
        this.coders.forEach((coder, index5) => {
          let name = coder.localName;
          if (!name || uniqueNames[name] !== 1) {
            return;
          }
          if (name === "length") {
            name = "_length";
          }
          if (values[name] != null) {
            return;
          }
          values[name] = values[index5];
        });
        return Object.freeze(values);
      }
      encode(writer, _value) {
        const value = typed_js_1.Typed.dereference(_value, "tuple");
        return (0, array_js_1.pack)(writer, this.coders, value);
      }
      decode(reader) {
        return (0, array_js_1.unpack)(reader, this.coders);
      }
    };
    exports.TupleCoder = TupleCoder;
  }
});

// node_modules/ethers/lib.commonjs/hash/id.js
var require_id = __commonJS({
  "node_modules/ethers/lib.commonjs/hash/id.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.id = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_utils5();
    function id3(value) {
      return (0, index_js_1.keccak256)((0, index_js_2.toUtf8Bytes)(value));
    }
    exports.id = id3;
  }
});

// node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs
var require_dist = __commonJS({
  "node_modules/ethers/node_modules/@adraffy/ens-normalize/dist/index.cjs"(exports) {
    "use strict";
    var COMPRESSED$12 = "AEEUdwmgDS8BxQKKAP4BOgDjATAAngDUAIMAoABoAOAAagCOAEQAhABMAHIAOwA9ACsANgAmAGIAHgAuACgAJwAXAC0AGgAjAB8ALwAUACkAEgAeAAkAGwARABkAFgA5ACgALQArADcAFQApABAAHgAiABAAGgAeABMAGAUhBe8BFxREN8sF2wC5AK5HAW8ArQkDzQCuhzc3NzcBP68NEfMABQdHBuw5BV8FYAA9MzkI9r4ZBg7QyQAWA9CeOwLNCjcCjqkChuA/lm+RAsXTAoP6ASfnEQDytQFJAjWVCkeXAOsA6godAB/cwdAUE0WlBCN/AQUCQRjFD/MRBjHxDQSJbw0jBzUAswBxme+tnIcAYwabAysG8QAjAEMMmxcDqgPKQyDXCMMxA7kUQwD3NXOrAKmFIAAfBC0D3x4BJQDBGdUFAhEgVD8JnwmQJiNWYUzrg0oAGwAUAB0AFnNcACkAFgBP9h3gPfsDOWDKneY2ChglX1UDYD30ABsAFAAdABZzIGRAnwDD8wAjAEEMzRbDqgMB2sAFYwXqAtCnAsS4AwpUJKRtFHsadUz9AMMVbwLpABM1NJEX0ZkCgYMBEyMAxRVvAukAEzUBUFAtmUwSAy4DBTER33EftQHfSwB5MxJ/AjkWKQLzL8E/cwBB6QH9LQDPDtO9ASNriQC5DQANAwCK21EFI91zHwCoL9kBqQcHBwcHKzUDowBvAQohPvU3fAQgHwCyAc8CKQMA5zMSezr7ULgFmDp/LzVQBgEGAi8FYQVgt8AFcTtlQhpCWEmfe5tmZ6IAExsDzQ8t+X8rBKtTAltbAn0jsy8Bl6utPWMDTR8Ei2kRANkDBrNHNysDBzECQWUAcwFpJ3kAiyUhAJ0BUb8AL3EfAbfNAz81KUsFWwF3YQZtAm0A+VEfAzEJDQBRSQCzAQBlAHsAM70GD/v3IZWHBwARKQAxALsjTwHZAeMPEzmXgIHwABIAGQA8AEUAQDt3gdvIEGcQZAkGTRFMdEIVEwK0D64L7REdDNkq09PgADSxB/MDWwfzA1sDWwfzB/MDWwfzA1sDWwNbA1scEvAi28gQZw9QBHUFlgWTBN4IiyZREYkHMAjaVBV0JhxPA00BBCMtSSQ7mzMTJUpMFE0LCAQ2SmyvfUADTzGzVP2QqgPTMlc5dAkGHnkSqAAyD3skNb1OhnpPcagKU0+2tYdJak5vAsY6sEAACikJm2/Dd1YGRRAfJ6kQ+ww3AbkBPw3xS9wE9QY/BM0fgRkdD9GVoAipLeEM8SbnLqWAXiP5KocF8Uv4POELUVFsD10LaQnnOmeBUgMlAREijwrhDT0IcRD3Cs1vDekRSQc9A9lJngCpBwULFR05FbkmFGKwCw05ewb/GvoLkyazEy17AAXXGiUGUQEtGwMA0y7rhbRaNVwgT2MGBwspI8sUrFAkDSlAu3hMGh8HGSWtApVDdEqLUToelyH6PEENai4XUYAH+TwJGVMLhTyiRq9FEhHWPpE9TCJNTDAEOYMsMyePCdMPiQy9fHYBXQklCbUMdRM1ERs3yQg9Bx0xlygnGQglRplgngT7owP3E9UDDwVDCUUHFwO5HDETMhUtBRGBKNsC9zbZLrcCk1aEARsFzw8pH+MQVEfkDu0InwJpA4cl7wAxFSUAGyKfCEdnAGOP3FMJLs8Iy2pwI3gDaxTrZRF3B5UOWwerHDcVwxzlcMxeD4YMKKezCV8BeQmdAWME5wgNNV+MpCBFZ1eLXBifIGVBQ14AAjUMaRWjRMGHfAKPD28SHwE5AXcHPQ0FAnsR8RFvEJkI74YINbkz/DopBFMhhyAVCisDU2zSCysm/Qz8bQGnEmYDEDRBd/Jnr2C6KBgBBx0yyUFkIfULlk/RDKAaxRhGVDIZ6AfDA/ca9yfuQVsGAwOnBxc6UTPyBMELbQiPCUMATQ6nGwfbGG4KdYzUATWPAbudA1uVhwJzkwY7Bw8Aaw+LBX3pACECqwinAAkA0wNbAD0CsQehAB0AiUUBQQMrMwEl6QKTA5cINc8BmTMB9y0EH8cMGQD7O25OAsO1AoBuZqYF4VwCkgJNOQFRKQQJUktVA7N15QDfAE8GF+NLARmvTs8e50cB43MvAMsA/wAJOQcJRQHRAfdxALsBYws1Caa3uQFR7S0AhwAZbwHbAo0A4QA5AIP1AVcAUQVd/QXXAlNNARU1HC9bZQG/AyMBNwERAH0Gz5GpzQsjBHEH1wIQHxXlAu8yB7kFAyLjE9FCyQK94lkAMhoKPAqrCqpgX2Q3CjV2PVQAEh+sPss/UgVVO1c7XDtXO1w7VztcO1c7XDtXO1wDm8Pmw+YKcF9JYe8Mqg3YRMw6TRPfYFVgNhPMLbsUxRXSJVoZQRrAJwkl6FUNDwgt12Y0CDA0eRfAAEMpbINFY4oeNApPHOtTlVT8LR8AtUumM7MNsBsZREQFS3XxYi4WEgomAmSFAmJGX1GzAV83JAKh+wJonAJmDQKfiDgfDwJmPwJmKgRyBIMDfxcDfpY5Cjl7GzmGOicnAmwhAjI6OA4CbcsCbbLzjgM3a0kvAWsA4gDlAE4JB5wMkQECD8YAEbkCdzMCdqZDAnlPRwJ4viFg30WyRvcCfEMCeswCfQ0CfPRIBEiBZygALxlJXEpfGRtK0ALRBQLQ0EsrA4hTA4fqRMmRNgLypV0HAwOyS9JMMSkH001QTbMCi0MCitzFHwshR2sJuwKOOwKOYESbhQKO3QKOYHxRuFM5AQ5S2FSJApP/ApMQAO0AIFUiVbNV1AosHymZijLleGpFPz0Cl6MC77ZYJawAXSkClpMCloCgAK1ZsFoNhVEAPwKWuQKWUlxIXNUCmc8CmWhczl0LHQKcnznGOqECnBoCn58CnryOACETNS4TAp31Ap6WALlBYThh8wKe1wKgcgGtAp6jIwKeUqljzGQrKS8CJ7MCJoICoP8CoFDbAqYzAqXSAqgDAIECp/ZogGi1AAdNaiBq1QKs5wKssgKtawKtBgJXIQJV4AKx5dsDH1JsmwKywRECsuwbbORtZ21MYwMl0QK2YD9DbpQDKUkCuGICuUsZArkue3A6cOUCvR0DLbYDMhUCvoxyBgMzdQK+HnMmc1MCw88CwwhzhnRPOUl05AM8qwEDPJ4DPcMCxYACxksCxhSNAshtVQLISALJUwLJMgJkoQLd1nh9ZXiyeSlL1AMYp2cGAmH4GfeVKHsPXpZevxUCz28Cz3AzT1fW9xejAMqxAs93AS3uA04Wfk8JAtwrAtuOAtJTA1JgA1NjAQUDVZCAjUMEzxrxZEl5A4LSg5EC2ssC2eKEFIRNp0ADhqkAMwNkEoZ1Xf0AWQLfaQLevHd7AuIz7RgB8zQrAfSfAfLWiwLr9wLpdH0DAur9AuroAP1LAb0C7o0C66CWrpcHAu5DA4XkmH1w5HGlAvMHAG0DjhqZlwL3FwORcgOSiwL3nAL53QL4apogmq+/O5siA52HAv7+AR8APZ8gAZ+3AwWRA6ZuA6bdANXJAwZuoYyiCQ0DDE0BEwEjB3EGZb1rCQC/BG/DFY8etxEAG3k9ACcDNxJRA42DAWcrJQCM8wAlAOanC6OVCLsGI6fJBgCvBRnDBvElRUYFFoAFcD9GSDNCKUK8X3kZX8QAls0FOgCQVCGbwTsuYDoZutcONxjOGJHJ/gVfBWAFXwVgBWsFYAVfBWAFXwVgBV8FYAVfBWBOHQjfjW8KCgoKbF7xMwTRA7kGN8PDAMMEr8MA70gxFroFTj5xPnhCR0K+X30/X/AAWBkzswCNBsxzzASm70aCRS4rDDMeLz49fnXfcsH5GcoscQFz13Y4HwVnBXLJycnACNdRYwgICAqEXoWTxgA7P4kACxbZBu21Kw0AjMsTAwkVAOVtJUUsJ1JCuULESUArXy9gPi9AKwnJRQYKTD9LPoA+iT54PnkCkULEUUpDX9NWV3JVEjQAc1w3A3IBE3YnX+g7QiMJb6MKaiszRCUuQrNCxDPMCcwEX9EWJzYREBEEBwIHKn6l33JCNVIfybPJtAltydPUCmhBZw/tEKsZAJOVJU1CLRuxbUHOQAo7P0s+eEJHHA8SJVRPdGM0NVrpvBoKhfUlM0JHHGUQUhEWO1xLSj8MO0ucNAqJIzVCRxv9EFsqKyA4OQgNj2nwZgp5ZNFgE2A1K3YHS2AhQQojJmC7DgpzGG1WYFUZCQYHZO9gHWCdYIVgu2BTYJlwFh8GvRbcXbG8YgtDHrMBwzPVyQonHQgkCyYBgQJ0Ajc4nVqIAwGSCsBPIgDsK3SWEtIVBa5N8gGjAo+kVwVIZwD/AEUSCDweX4ITrRQsJ8K3TwBXFDwEAB0TvzVcAtoTS20RIwDgVgZ9BBImYgA5AL4Coi8LFnezOkCnIQFjAY4KBAPh9RcGsgZSBsEAJctdsWIRu2kTkQstRw7DAcMBKgpPBGIGMDAwKCYnKTQaLg4AKRSVAFwCdl+YUZ0JdicFD3lPAdt1F9ZZKCGxuE3yBxkFVGcA/wBFEgiCBwAOLHQSjxOtQDg1z7deFRMAZ8QTAGtKb1ApIiPHADkAvgKiLy1DFtYCmBiDAlDDWNB0eo7fpaMO/aEVRRv0ATEQZBIODyMEAc8JQhCbDRgzFD4TAEMAu9YBCgCsAOkAm5I3ABwAYxvONnR+MhXJAxgKQyxL2+kkJhMbhQKDBMkSsvF0AD9BNQ6uQC7WqSQHwxEAEEIu1hkhAH2z4iQPwyJPHNWpdyYBRSpnJALzoBAEVPPsH20MxA0CCEQKRgAFyAtFAlMNwwjEDUQJRArELtapMg7DDZgJIw+TGukEIwvDFkMAqAtDEMMMBhioe+QAO3MMRAACrgnEBSPY9Q0FDnbSBoMAB8MSYxkSxAEJAPIJAAB8FWMOFtMc/HcXwxhDAC7DAvOowwAewwJdKDKHAAHDAALrFUQVwwAbwyvzpWMWv8wA/ABpAy++bcYDUKPD0KhDCwKmJ1MAAmMA5+UZwxAagwipBRL/eADfw6fDGOMCGsOjk3l6BwOpo4sAEsMOGxMAA5sAbcMOAAvDp0MJGkMDwgipnNIPAwfIqUMGAOGDAAPzABXDAAcDAAnDAGmTABrDAA7DChjDjnEWAwABYwAOcwAuUyYABsMAF8MIKQANUgC6wy4AA8MADqMq8wCyYgAcIwAB8wqpAAXOCx0V4wAHowBCwwEKAGnDAAuDAB3DAAjDCakABdIAbqcZ3QCZCCkABdIAAAFDAAfjAB2jCCkABqIACYMAGzMAbSMA5sOIAAhjAAhDABTDBAkpAAbSAOOTAAlDC6kOzPtnAAdDAG6kQFAATwAKwwwAA0MACbUDPwAHIwAZgwACE6cDAAojAApDAAoDp/MGwwAJIwADEwAQQwgAFEMAEXMAD5MADfMADcMAGRMOFiMAFUMAbqMWuwHDAMIAE0MLAGkzEgDhUwACQwAEWgAXgwUjAAbYABjDBSYBgzBaAEFNALcQBxUMegAwMngBrA0IZgJ0KxQHBREPd1N0ZzKRJwaIHAZqNT4DqQq8BwngAB4DAwt2AX56T1ocKQNXAh1GATQGC3tOxYNagkgAMQA5CQADAQEAWxLjAIOYNAEzAH7tFRk6TglSAF8NAAlYAQ+S1ACAQwQorQBiAN4dAJ1wPyeTANVzuQDX3AIeEMp9eyMgXiUAEdkBkJizKltbVVAaRMqRAAEAhyQ/SDEz6BmfVwB6ATEsOClKIRcDOF0E/832AFNt5AByAnkCRxGCOs94NjXdAwINGBonDBwPALW2AwICAgAAAAAAAAYDBQMDARrUAwAtAAAAAgEGBgYGBgYFBQUFBQUEBQYHCAkEBQUFBQQAAAICAAAAIgCNAJAAlT0A6gC7ANwApEQAwgCyAK0AqADuAKYA2gCjAOcBCAEDAMcAgQBiANIA1AEDAN4A8gCQAKkBMQDqAN8A3AsBCQ8yO9ra2tq8xuLT1tRJOB0BUgFcNU0BWgFpAWgBWwFMUUlLbhMBUxsNEAs6PhMOACcUKy0vMj5AQENDQ0RFFEYGJFdXV1dZWVhZL1pbXVxcI2NnZ2ZoZypsbnZ1eHh4eHh4enp6enp6enp6enp8fH18e2IARPIASQCaAHgAMgBm+ACOAFcAVwA3AnbvAIsABfj4AGQAk/IAnwBPAGIAZP//sACFAIUAaQBWALEAJAC2AIMCQAJDAPwA5wD+AP4A6AD/AOkA6QDoAOYALwJ7AVEBQAE+AVQBPgE+AT4BOQE4ATgBOAEcAVgXADEQCAEAUx8SHgsdHhYAjgCWAKYAUQBqIAIxAHYAbwCXAxUDJzIDIUlGTzEAkQJPAMcCVwKkAMAClgKWApYClgKWApYCiwKWApYClgKWApYClgKVApUCmAKgApcClgKWApQClAKUApQCkgKVAnUB1AKXAp8ClgKWApUeAIETBQD+DQOfAmECOh8BVBg9AuIZEjMbAU4/G1WZAXusRAFpYQEFA0FPAQYAmTEeIJdyADFoAHEANgCRA5zMk/C2jGINwjMWygIZCaXdfDILBCs5dAE7YnQBugDlhoiHhoiGiYqKhouOjIaNkI6Ij4qQipGGkoaThpSSlYaWhpeKmIaZhpqGm4aci52QnoqfhuIC4XTpAt90AIp0LHSoAIsAdHQEQwRABEIERQRDBEkERgRBBEcESQRIBEQERgRJAJ5udACrA490ALxuAQ10ANFZdHQA13QCFHQA/mJ0AP4BIQD+APwA/AD9APwDhGZ03ASMK23HAP4A/AD8AP0A/CR0dACRYnQA/gCRASEA/gCRAvQA/gCRA4RmdNwEjCttxyR0AP9idAEhAP4A/gD8APwA/QD8AP8A/AD8AP0A/AOEZnTcBIwrbcckdHQAkWJ0ASEA/gCRAP4AkQL0AP4AkQOEZnTcBIwrbcckdAJLAT50AlIBQXQCU8l0dAJfdHQDpgL0A6YDpgOnA6cDpwOnA4RmdNwEjCttxyR0dACRYnQBIQOmAJEDpgCRAvQDpgCRA4RmdNwEjCttxyR0BDh0AJEEOQCRDpU5dSgCADR03gV2CwArdAEFAM5iCnR0AF1iAAYcOgp0dACRCnQAXAEIwWZ0CnRmdHQAkWZ0CnRmdEXgAFF03gp0dEY0tlT2u3SOAQTwscwhjZZKrhYcBSfFp9XNbKiVDOD2b+cpe4/Z17mQnbtzzhaeQtE2GGj0IDNTjRUSyTxxw/RPHW/+vS7d1NfRt9z9QPZg4X7QFfhCnkvgNPIItOsC2eV6hPannZNHlZ9xrwZXIMOlu3jSoQSq78WEjwLjw1ELSlF1aBvfzwk5ZX7AUvQzjPQKbDuQ+sm4wNOp4A6AdVuRS0t1y/DZpg4R6m7FNjM9HgvW7Bi88zaMjOo6lM8wtBBdj8LP4ylv3zCXPhebMKJc066o9sF71oFW/8JXu86HJbwDID5lzw5GWLR/LhT0Qqnp2JQxNZNfcbLIzPy+YypqRm/lBmGmex+82+PisxUumSeJkALIT6rJezxMH+CTJmQtt5uwTVbL3ptmjDUQzlSIvWi8Tl7ng1NpuRn1Ng4n14Qc+3Iil7OwkvNWogLSPkn3pihIFytyIGmMhOe3n1tWsuMy9BdKyqF4Z3v2SgggTL9KVvMXPnCbRe+oOuFFP3HejBG/w9gvmfNYvg6JuWia2lcSSN1uIjBktzoIazOHPJZ7kKHPz8mRWVdW3lA8WGF9dQF6Bm673boov3BUWDU2JNcahR23GtfHKLOz/viZ+rYnZFaIznXO67CYEJ1fXuTRpZhYZkKe54xeoagkNGLs+NTZHE0rX45/XvQ2RGADX6vcAvdxIUBV27wxGm2zjZo4X3ILgAlrOFheuZ6wtsvaIj4yLY7qqawlliaIcrz2G+c3vscAnCkCuMzMmZvMfu9lLwTvfX+3cVSyPdN9ZwgDZhfjRgNJcLiJ67b9xx8JHswprbiE3v9UphotAPIgnXVIN5KmMc0piXhc6cChPnN+MRhG9adtdttQTTwSIpl8I4/j//d3sz1326qTBTpPRM/Hgh3kzqEXs8ZAk4ErQhNO8hzrQ0DLkWMA/N+91tn2MdOJnWC2FCZehkQrwzwbKOjhvZsbM95QoeL9skYyMf4srVPVJSgg7pOLUtr/n9eT99oe9nLtFRpjA9okV2Kj8h9k5HaC0oivRD8VyXkJ81tcd4fHNXPCfloIQasxsuO18/46dR2jgul/UIet2G0kRvnyONMKhHs6J26FEoqSqd+rfYjeEGwHWVDpX1fh1jBBcKGMqRepju9Y00mDVHC+Xdij/j44rKfvfjGinNs1jO/0F3jB83XCDINN/HB84axlP+3E/klktRo+vl3U/aiyMJbIodE1XSsDn6UAzIoMtUObY2+k/4gY/l+AkZJ5Sj2vQrkyLm3FoxjhDX+31UXBFf9XrAH31fFqoBmDEZvhvvpnZ87N+oZEu7U9O/nnk+QWj3x8uyoRbEnf+O5UMr9i0nHP38IF5AvzrBW8YWBUR0mIAzIvndQq9N3v/Jto3aPjPXUPl8ASdPPyAp7jENf8bk7VMM9ol9XGmlBmeDMuGqt+WzuL6CXAxXjIhCPM5vACchgMJ/8XBGLO/D1isVvGhwwHHr1DLaI5mn2Jr/b1pUD90uciDaS8cXNDzCWvNmT/PhQe5e8nTnnnkt8Ds/SIjibcum/fqDhKopxAY8AkSrPn+IGDEKOO+U3XOP6djFs2H5N9+orhOahiQk5KnEUWa+CzkVzhp8bMHRbg81qhjjXuIKbHjSLSIBKWqockGtKinY+z4/RdBUF6pcc3JmnlxVcNgrI4SEzKUZSwcD2QCyxzKve+gAmg6ZuSRkpPFa6mfThu7LJNu3H5K42uCpNvPAsoedolKV/LHe/eJ+BbaG5MG0NaSGVPRUmNFMFFSSpXEcXwbVh7UETOZZtoVNRGOIbbkig3McEtR68cG0RZAoJevWYo7Dg/lZ1CQzblWeUvVHmr8fY4Nqd9JJiH/zEX24mJviH60fAyFr0A3c4bC1j3yZU60VgJxXn8JgJXLUIsiBnmKmMYz+7yBQFBvqb2eYnuW59joZBf56/wXvWIR4R8wTmV80i1mZy+S4+BUES+hzjk0uXpC///z/IlqHZ1monzlXp8aCfhGKMti73FI1KbL1q6IKO4fuBuZ59gagjn5xU79muMpHXg6S+e+gDM/U9BKLHbl9l6o8czQKl4RUkJJiqftQG2i3BMg/TQlUYFkJDYBOOvAugYuzYSDnZbDDd/aSd9x0Oe6F+bJcHfl9+gp6L5/TgA+BdFFovbfCrQ40s5vMPw8866pNX8zyFGeFWdxIpPVp9Rg1UPOVFbFZrvaFq/YAzHQgqMWpahMYfqHpmwXfHL1/kpYmGuHFwT55mQu0dylfNuq2Oq0hTMCPwqfxnuBIPLXfci4Y1ANy+1CUipQxld/izVh16WyG2Q0CQQ9NqtAnx1HCHwDj7sYxOSB0wopZSnOzxQOcExmxrVTF2BkOthVpGfuhaGECfCJpJKpjnihY+xOT2QJxN61+9K6QSqtv2Shr82I3jgJrqBg0wELFZPjvHpvzTtaJnLK6Vb97Yn933koO/saN7fsjwNKzp4l2lJVx2orjCGzC/4ZL4zCver6aQYtC5sdoychuFE6ufOiog+VWi5UDkbmvmtah/3aArEBIi39s5ILUnlFLgilcGuz9CQshEY7fw2ouoILAYPVT/gyAIq3TFAIwVsl+ktkRz/qGfnCDGrm5gsl/l9QdvCWGsjPz3dU7XuqKfdUrr/6XIgjp4rey6AJBmCmUJMjITHVdFb5m1p+dLMCL8t55zD42cmftmLEJC0Da04YiRCVUBLLa8D071/N5UBNBXDh0LFsmhV/5B5ExOB4j3WVG/S3lfK5o+V6ELHvy6RR9n4ac+VsK4VE4yphPvV+kG9FegTBH4ZRXL2HytUHCduJazB/KykjfetYxOXTLws267aGOd+I+JhKP//+VnXmS90OD/jvLcVu0asyqcuYN1mSb6XTlCkqv1vigZPIYwNF/zpWcT1GR/6aEIRjkh0yhg4LXJfaGobYJTY4JI58KiAKgmmgAKWdl5nYCeLqavRJGQNuYuZtZFGx+IkI4w4NS2xwbetNMunOjBu/hmKCI/w7tfiiyUd//4rbTeWt4izBY8YvGIN6vyKYmP/8X8wHKCeN+WRcKM70+tXKNGyevU9H2Dg5BsljnTf8YbsJ1TmMs74Ce2XlHisleguhyeg44rQOHZuw/6HTkhnnurK2d62q6yS7210SsAIaR+jXMQA+svkrLpsUY+F30Uw89uOdGAR6vo4FIME0EfVVeHTu6eKicfhSqOeXJhbftcd08sWEnNUL1C9fnprTgd83IMut8onVUF0hvqzZfHduPjbjwEXIcoYmy+P6tcJZHmeOv6VrvEdkHDJecjHuHeWANe79VG662qTjA/HCvumVv3qL+LrOcpqGps2ZGwQdFJ7PU4iuyRlBrwfO+xnPyr47s2cXVbWzAyznDiBGjCM3ksxjjqM62GE9C8f5U38kB3VjtabKp/nRdvMESPGDG90bWRLAt1Qk5DyLuazRR1YzdC1c+hZXvAWV8xA72S4A8B67vjVhbba3MMop293FeEXpe7zItMWrJG/LOH9ByOXmYnNJfjmfuX9KbrpgLOba4nZ+fl8Gbdv/ihv+6wFGKHCYrVwmhFC0J3V2bn2tIB1wCc1CST3d3X2OyxhguXcs4sm679UngzofuSeBewMFJboIQHbUh/m2JhW2hG9DIvG2t7yZIzKBTz9wBtnNC+2pCRYhSIuQ1j8xsz5VvqnyUIthvuoyyu7fNIrg/KQUVmGQaqkqZk/Vx5b33/gsEs8yX7SC1J+NV4icz6bvIE7C5G6McBaI8rVg56q5QBJWxn/87Q1sPK4+sQa8fLU5gXo4paaq4cOcQ4wR0VBHPGjKh+UlPCbA1nLXyEUX45qZ8J7/Ln4FPJE2TdzD0Z8MLSNQiykMMmSyOCiFfy84Rq60emYB2vD09KjYwsoIpeDcBDTElBbXxND72yhd9pC/1CMid/5HUMvAL27OtcIJDzNKpRPNqPOpyt2aPGz9QWIs9hQ9LiX5s8m9hjTUu/f7MyIatjjd+tSfQ3ufZxPpmJhTaBtZtKLUcfOCUqADuO+QoH8B9v6U+P0HV1GLQmtoNFTb3s74ivZgjES0qfK+8RdGgBbcCMSy8eBvh98+et1KIFqSe1KQPyXULBMTsIYnysIwiZBJYdI20vseV+wuJkcqGemehKjaAb9L57xZm3g2zX0bZ2xk/fU+bCo7TlnbW7JuF1YdURo/2Gw7VclDG1W7LOtas2LX4upifZ/23rzpsnY/ALfRgrcWP5hYmV9VxVOQA1fZvp9F2UNU+7d7xRyVm5wiLp3/0dlV7vdw1PMiZrbDAYzIVqEjRY2YU03sJhPnlwIPcZUG5ltL6S8XCxU1eYS5cjr34veBmXAvy7yN4ZjArIG0dfD/5UpBNlX1ZPoxJOwyqRi3wQWtOzd4oNKh0LkoTm8cwqgIfKhqqGOhwo71I+zXnMemTv2B2AUzABWyFztGgGULjDDzWYwJUVBTjKCn5K2QGMK1CQT7SzziOjo+BhAmqBjzuc3xYym2eedGeOIRJVyTwDw37iCMe4g5Vbnsb5ZBdxOAnMT7HU4DHpxWGuQ7GeiY30Cpbvzss55+5Km1YsbD5ea3NI9QNYIXol5apgSu9dZ8f8xS5dtHpido5BclDuLWY4lhik0tbJa07yJhH0BOyEut/GRbYTS6RfiTYWGMCkNpfSHi7HvdiTglEVHKZXaVhezH4kkXiIvKopYAlPusftpE4a5IZwvw1x/eLvoDIh/zpo9FiQInsTb2SAkKHV42XYBjpJDg4374XiVb3ws4qM0s9eSQ5HzsMU4OZJKuopFjBM+dAZEl8RUMx5uU2N486Kr141tVsGQfGjORYMCJAMsxELeNT4RmWjRcpdTGBwcx6XN9drWqPmJzcrGrH4+DRc7+n1w3kPZwu0BkNr6hQrqgo7JTB9A5kdJ/H7P4cWBMwsmuixAzJB3yrQpnGIq90lxAXLzDCdn1LPibsRt7rHNjgQBklRgPZ8vTbjXdgXrTWQsK5MdrXXQVPp0Rinq3frzZKJ0qD6Qhc40VzAraUXlob1gvkhK3vpmHgI6FRlQZNx6eRqkp0zy4AQlX813fAPtL3jMRaitGFFjo0zmErloC+h+YYdVQ6k4F/epxAoF0BmqEoKNTt6j4vQZNQ2BoqF9Vj53TOIoNmDiu9Xp15RkIgQIGcoLpfoIbenzpGUAtqFJp5W+LLnx38jHeECTJ/navKY1NWfN0sY1T8/pB8kIH3DU3DX+u6W3YwpypBMYOhbSxGjq84RZ84fWJow8pyHqn4S/9J15EcCMsXqrfwyd9mhiu3+rEo9pPpoJkdZqHjra4NvzFwuThNKy6hao/SlLw3ZADUcUp3w3SRVfW2rhl80zOgTYnKE0Hs2qp1J6H3xqPqIkvUDRMFDYyRbsFI3M9MEyovPk8rlw7/0a81cDVLmBsR2ze2pBuKb23fbeZC0uXoIvDppfTwIDxk1Oq2dGesGc+oJXWJLGkOha3CX+DUnzgAp9HGH9RsPZN63Hn4RMA5eSVhPHO+9RcRb/IOgtW31V1Q5IPGtoxPjC+MEJbVlIMYADd9aHYWUIQKopuPOHmoqSkubnAKnzgKHqgIOfW5RdAgotN6BN+O2ZYHkuemLnvQ8U9THVrS1RtLmKbcC7PeeDsYznvqzeg6VCNwmr0Yyx1wnLjyT84BZz3EJyCptD3yeueAyDWIs0L2qs/VQ3HUyqfrja0V1LdDzqAikeWuV4sc7RLIB69jEIBjCkyZedoUHqCrOvShVzyd73OdrJW0hPOuQv2qOoHDc9xVb6Yu6uq3Xqp2ZaH46A7lzevbxQEmfrzvAYSJuZ4WDk1Hz3QX1LVdiUK0EvlAGAYlG3Md30r7dcPN63yqBCIj25prpvZP0nI4+EgWoFG95V596CurXpKRBGRjQlHCvy5Ib/iW8nZJWwrET3mgd6mEhfP4KCuaLjopWs7h+MdXFdIv8dHQJgg1xi1eYqB0uDYjxwVmri0Sv5XKut/onqapC+FQiC2C1lvYJ9MVco6yDYsS3AANUfMtvtbYI2hfwZatiSsnoUeMZd34GVjkMMKA+XnjJpXgRW2SHTZplVowPmJsvXy6w3cfO1AK2dvtZEKTkC/TY9LFiKHCG0DnrMQdGm2lzlBHM9iEYynH2UcVMhUEjsc0oDBTgo2ZSQ1gzkAHeWeBXYFjYLuuf8yzTCy7/RFR81WDjXMbq2BOH5dURnxo6oivmxL3cKzKInlZkD31nvpHB9Kk7GfcfE1t+1V64b9LtgeJGlpRFxQCAqWJ5DoY77ski8gsOEOr2uywZaoO/NGa0X0y1pNQHBi3b2SUGNpcZxDT7rLbBf1FSnQ8guxGW3W+36BW0gBje4DOz6Ba6SVk0xiKgt+q2JOFyr4SYfnu+Ic1QZYIuwHBrgzr6UvOcSCzPTOo7D6IC4ISeS7zkl4h+2VoeHpnG/uWR3+ysNgPcOIXQbv0n4mr3BwQcdKJxgPSeyuP/z1Jjg4e9nUvoXegqQVIE30EHx5GHv+FAVUNTowYDJgyFhf5IvlYmEqRif6+WN1MkEJmDcQITx9FX23a4mxy1AQRsOHO/+eImX9l8EMJI3oPWzVXxSOeHU1dUWYr2uAA7AMb+vAEZSbU3qob9ibCyXeypEMpZ6863o6QPqlqGHZkuWABSTVNd4cOh9hv3qEpSx2Zy/DJMP6cItEmiBJ5PFqQnDEIt3NrA3COlOSgz43D7gpNFNJ5MBh4oFzhDPiglC2ypsNU4ISywY2erkyb1NC3Qh/IfWj0eDgZI4/ln8WPfBsT3meTjq1Uqt1E7Zl/qftqkx6aM9KueMCekSnMrcHj1CqTWWzEzPsZGcDe3Ue4Ws+XFYVxNbOFF8ezkvQGR6ZOtOLU2lQEnMBStx47vE6Pb7AYMBRj2OOfZXfisjJnpTfSNjo6sZ6qSvNxZNmDeS7Gk3yYyCk1HtKN2UnhMIjOXUzAqDv90lx9O/q/AT1ZMnit5XQe9wmQxnE/WSH0CqZ9/2Hy+Sfmpeg8RwsHI5Z8kC8H293m/LHVVM/BA7HaTJYg5Enk7M/xWpq0192ACfBai2LA/qrCjCr6Dh1BIMzMXINBmX96MJ5Hn2nxln/RXPFhwHxUmSV0EV2V0jm86/dxxuYSU1W7sVkEbN9EzkG0QFwPhyHKyb3t+Fj5WoUUTErcazE/N6EW6Lvp0d//SDPj7EV9UdJN+Amnf3Wwk3A0SlJ9Z00yvXZ7n3z70G47Hfsow8Wq1JXcfwnA+Yxa5mFsgV464KKP4T31wqIgzFPd3eCe3j5ory5fBF2hgCFyVFrLzI9eetNXvM7oQqyFgDo4CTp/hDV9NMX9JDHQ/nyHTLvZLNLF6ftn2OxjGm8+PqOwhxnPHWipkE/8wbtyri80Sr7pMNkQGMfo4ZYK9OcCC4ESVFFbLMIvlxSoRqWie0wxqnLfcLSXMSpMMQEJYDVObYsXIQNv4TGNwjq1kvT1UOkicTrG3IaBZ3XdScS3u8sgeZPVpOLkbiF940FjbCeNRINNvDbd01EPBrTCPpm12m43ze1bBB59Ia6Ovhnur/Nvx3IxwSWol+3H2qfCJR8df6aQf4v6WiONxkK+IqT4pKQrZK/LplgDI/PJZbOep8dtbV7oCr6CgfpWa8NczOkPx81iSHbsNhVSJBOtrLIMrL31LK9TqHqAbAHe0RLmmV806kRLDLNEhUEJfm9u0sxpkL93Zgd6rw+tqBfTMi59xqXHLXSHwSbSBl0EK0+loECOPtrl+/nsaFe197di4yUgoe4jKoAJDXc6DGDjrQOoFDWZJ9HXwt8xDrQP+7aRwWKWI1GF8s8O4KzxWBBcwnl3vnl1Oez3oh6Ea1vjR7/z7DDTrFtqU2W/KAEzAuXDNZ7MY73MF216dzdSbWmUp4lcm7keJfWaMHgut9x5C9mj66Z0lJ+yhsjVvyiWrfk1lzPOTdhG15Y7gQlXtacvI7qv/XNSscDwqkgwHT/gUsD5yB7LdRRvJxQGYINn9hTpodKFVSTPrtGvyQw+HlRFXIkodErAGu9Iy1YpfSPc3jkFh5CX3lPxv7aqjE/JAfTIpEjGb/H7MO0e2vsViSW1qa/Lmi4/n4DEI3g7lYrcanspDfEpKkdV1OjSLOy0BCUqVoECaB55vs06rXl4jqmLsPsFM/7vYJ0vrBhDCm/00A/H81l1uekJ/6Lml3Hb9+NKiLqATJmDpyzfYZFHumEjC662L0Bwkxi7E9U4cQA0XMVDuMYAIeLMPgQaMVOd8fmt5SflFIfuBoszeAw7ow5gXPE2Y/yBc/7jExARUf/BxIHQBF5Sn3i61w4z5xJdCyO1F1X3+3ax+JSvMeZ7S6QSKp1Fp/sjYz6Z+VgCZzibGeEoujryfMulH7Rai5kAft9ebcW50DyJr2uo2z97mTWIu45YsSnNSMrrNUuG1XsYBtD9TDYzQffKB87vWbkM4EbPAFgoBV4GQS+vtFDUqOFAoi1nTtmIOvg38N4hT2Sn8r8clmBCXspBlMBYTnrqFJGBT3wZOzAyJDre9dHH7+x7qaaKDOB4UQALD5ecS0DE4obubQEiuJZ0EpBVpLuYcce8Aa4PYd/V4DLDAJBYKQPCWTcrEaZ5HYbJi11Gd6hjGom1ii18VHYnG28NKpkz2UKVPxlhYSp8uZr367iOmoy7zsxehW9wzcy2zG0a80PBMCRQMb32hnaHeOR8fnNDzZhaNYhkOdDsBUZ3loDMa1YP0uS0cjUP3b/6DBlqmZOeNABDsLl5BI5QJups8uxAuWJdkUB/pO6Zax6tsg7fN5mjjDgMGngO+DPcKqiHIDbFIGudxtPTIyDi9SFMKBDcfdGQRv41q1AqmxgkVfJMnP8w/Bc7N9/TR6C7mGObFqFkIEom8sKi2xYqJLTCHK7cxzaZvqODo22c3wisBCP4HeAgcRbNPAsBkNRhSmD48dHupdBRw4mIvtS5oeF6zeT1KMCyhMnmhpkFAGWnGscoNkwvQ8ZM5lE/vgTHFYL99OuNxdFBxTEDd5v2qLR8y9WkXsWgG6kZNndFG+pO/UAkOCipqIhL3hq7cRSdrCq7YhUsTocEcnaFa6nVkhnSeRYUA1YO0z5itF9Sly3VlxYDw239TJJH6f3EUfYO5lb7bcFcz8Bp7Oo8QmnsUHOz/fagVUBtKEw1iT88j+aKkv8cscKNkMxjYr8344D1kFoZ7/td1W6LCNYN594301tUGRmFjAzeRg5vyoM1F6+bJZ/Q54jN/k8SFd3DxPTYaAUsivsBfgTn7Mx8H2SpPt4GOdYRnEJOH6jHM2p6SgB0gzIRq6fHxGMmSmqaPCmlfwxiuloaVIitLGN8wie2CDWhkzLoCJcODh7KIOAqbHEvXdUxaS4TTTs07Clzj/6GmVs9kiZDerMxEnhUB6QQPlcfqkG9882RqHoLiHGBoHfQuXIsAG8GTAtao2KVwRnvvam8jo1e312GQAKWEa4sUVEAMG4G6ckcONDwRcg1e2D3+ohXgY4UAWF8wHKQMrSnzCgfFpsxh+aHXMGtPQroQasRY4U6UdG0rz1Vjbka0MekOGRZQEvqQFlxseFor8zWFgHek3v29+WqN6gaK5gZOTOMZzpQIC1201LkMCXild3vWXSc5UX9xcFYfbRPzGFa1FDcPfPB/jUEq/FeGt419CI3YmBlVoHsa4KdcwQP5ZSwHHhFJ7/Ph/Rap/4vmG91eDwPP0lDfCDRCLszTqfzM71xpmiKi2HwS4WlqvGNwtvwF5Dqpn6KTq8ax00UMPkxDcZrEEEsIvHiUXXEphdb4GB4FymlPwBz4Gperqq5pW7TQ6/yNRhW8VT5NhuP0udlxo4gILq5ZxAZk8ZGh3g4CqxJlPKY7AQxupfUcVpWT5VItp1+30UqoyP4wWsRo3olRRgkWZZ2ZN6VC3OZFeXB8NbnUrSdikNptD1QiGuKkr8EmSR/AK9Rw+FF3s5uwuPbvHGiPeFOViltMK7AUaOsq9+x9cndk3iJEE5LKZRlWJbKOZweROzmPNVPkjE3K/TyA57Rs68TkZ3MR8akKpm7cFjnjPd/DdkWjgYoKHSr5Wu5ssoBYU4acRs5g2DHxUmdq8VXOXRbunD8QN0LhgkssgahcdoYsNvuXGUK/KXD/7oFb+VGdhqIn02veuM5bLudJOc2Ky0GMaG4W/xWBxIJcL7yliJOXOpx0AkBqUgzlDczmLT4iILXDxxtRR1oZa2JWFgiAb43obrJnG/TZC2KSK2wqOzRZTXavZZFMb1f3bXvVaNaK828w9TO610gk8JNf3gMfETzXXsbcvRGCG9JWQZ6+cDPqc4466Yo2RcKH+PILeKOqtnlbInR3MmBeGG3FH10yzkybuqEC2HSQwpA0An7d9+73BkDUTm30bZmoP/RGbgFN+GrCOfADgqr0WbI1a1okpFms8iHYw9hm0zUvlEMivBRxModrbJJ+9/p3jUdQQ9BCtQdxnOGrT5dzRUmw0593/mbRSdBg0nRvRZM5/E16m7ZHmDEtWhwvfdZCZ8J8M12W0yRMszXamWfQTwIZ4ayYktrnscQuWr8idp3PjT2eF/jmtdhIfcpMnb+IfZY2FebW6UY/AK3jP4u3Tu4zE4qlnQgLFbM19EBIsNf7KhjdbqQ/D6yiDb+NlEi2SKD+ivXVUK8ib0oBo366gXkR8ZxGjpJIDcEgZPa9TcYe0TIbiPl/rPUQDu3XBJ9X/GNq3FAUsKsll57DzaGMrjcT+gctp+9MLYXCq+sqP81eVQ0r9lt+gcQfZbACRbEjvlMskztZG8gbC8Qn9tt26Q7y7nDrbZq/LEz7kR6Jc6pg3N9rVX8Y5MJrGlML9p9lU4jbTkKqCveeZUJjHB03m2KRKR2TytoFkTXOLg7keU1s1lrPMQJpoOKLuAAC+y1HlJucU6ysB5hsXhvSPPLq5J7JtnqHKZ4vYjC4Vy8153QY+6780xDuGARsGbOs1WqzH0QS765rnSKEbbKlkO8oI/VDwUd0is13tKpqILu1mDJFNy/iJAWcvDgjxvusIT+PGz3ST/J9r9Mtfd0jpaGeiLYIqXc7DiHSS8TcjFVksi66PEkxW1z6ujbLLUGNNYnzOWpH8BZGK4bCK7iR+MbIv8ncDAz1u4StN3vTTzewr9IQjk9wxFxn+6N1ddKs0vffJiS08N3a4G1SVrlZ97Q/M+8G9fe5AP6d9/Qq4WRnORVhofPIKEdCr3llspUfE0oKIIYoByBRPh+bX1HLS3JWGJRhIvE1aW4NTd8ePi4Z+kXb+Z8snYfSNcqijhAgVsx4RCM54cXUiYkjeBmmC4ajOHrChoELscJJC7+9jjMjw5BagZKlgRMiSNYz7h7vvZIoQqbtQmspc0cUk1G/73iXtSpROl5wtLgQi0mW2Ex8i3WULhcggx6E1LMVHUsdc9GHI1PH3U2Ko0PyGdn9KdVOLm7FPBui0i9a0HpA60MsewVE4z8CAt5d401Gv6zXlIT5Ybit1VIA0FCs7wtvYreru1fUyW3oLAZ/+aTnZrOcYRNVA8spoRtlRoWflsRClFcgzkqiHOrf0/SVw+EpVaFlJ0g4Kxq1MMOmiQdpMNpte8lMMQqm6cIFXlnGbfJllysKDi+0JJMotkqgIxOSQgU9dn/lWkeVf8nUm3iwX2Nl3WDw9i6AUK3vBAbZZrcJpDQ/N64AVwjT07Jef30GSSmtNu2WlW7YoyW2FlWfZFQUwk867EdLYKk9VG6JgEnBiBxkY7LMo4YLQJJlAo9l/oTvJkSARDF/XtyAzM8O2t3eT/iXa6wDN3WewNmQHdPfsxChU/KtLG2Mn8i4ZqKdSlIaBZadxJmRzVS/o4yA65RTSViq60oa395Lqw0pzY4SipwE0SXXsKV+GZraGSkr/RW08wPRvqvSUkYBMA9lPx4m24az+IHmCbXA+0faxTRE9wuGeO06DIXa6QlKJ3puIyiuAVfPr736vzo2pBirS+Vxel3TMm3JKhz9o2ZoRvaFVpIkykb0Hcm4oHFBMcNSNj7/4GJt43ogonY2Vg4nsDQIWxAcorpXACzgBqQPjYsE/VUpXpwNManEru4NwMCFPkXvMoqvoeLN3qyu/N1eWEHttMD65v19l/0kH2mR35iv/FI+yjoHJ9gPMz67af3Mq/BoWXqu3rphiWMXVkmnPSEkpGpUI2h1MThideGFEOK6YZHPwYzMBvpNC7+ZHxPb7epfefGyIB4JzO9DTNEYnDLVVHdQyvOEVefrk6Uv5kTQYVYWWdqrdcIl7yljwwIWdfQ/y+2QB3eR/qxYObuYyB4gTbo2in4PzarU1sO9nETkmj9/AoxDA+JM3GMqQtJR4jtduHtnoCLxd1gQUscHRB/MoRYIEsP2pDZ9KvHgtlk1iTbWWbHhohwFEYX7y51fUV2nuUmnoUcqnWIQAAgl9LTVX+Bc0QGNEhChxHR4YjfE51PUdGfsSFE6ck7BL3/hTf9jLq4G1IafINxOLKeAtO7quulYvH5YOBc+zX7CrMgWnW47/jfRsWnJjYYoE7xMfWV2HN2iyIqLI";
    var FENCED2 = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
    var NSM_MAX2 = 4;
    function decode_arithmetic2(bytes) {
      let pos = 0;
      function u16() {
        return bytes[pos++] << 8 | bytes[pos++];
      }
      let symbol_count = u16();
      let total = 1;
      let acc = [0, 1];
      for (let i2 = 1; i2 < symbol_count; i2++) {
        acc.push(total += u16());
      }
      let skip = u16();
      let pos_payload = pos;
      pos += skip;
      let read_width = 0;
      let read_buffer = 0;
      function read_bit() {
        if (read_width == 0) {
          read_buffer = read_buffer << 8 | bytes[pos++];
          read_width = 8;
        }
        return read_buffer >> --read_width & 1;
      }
      const N2 = 31;
      const FULL = 2 ** N2;
      const HALF = FULL >>> 1;
      const QRTR = HALF >> 1;
      const MASK = FULL - 1;
      let register = 0;
      for (let i2 = 0; i2 < N2; i2++) register = register << 1 | read_bit();
      let symbols = [];
      let low = 0;
      let range = FULL;
      while (true) {
        let value = Math.floor(((register - low + 1) * total - 1) / range);
        let start = 0;
        let end = symbol_count;
        while (end - start > 1) {
          let mid = start + end >>> 1;
          if (value < acc[mid]) {
            end = mid;
          } else {
            start = mid;
          }
        }
        if (start == 0) break;
        symbols.push(start);
        let a3 = low + Math.floor(range * acc[start] / total);
        let b4 = low + Math.floor(range * acc[start + 1] / total) - 1;
        while (((a3 ^ b4) & HALF) == 0) {
          register = register << 1 & MASK | read_bit();
          a3 = a3 << 1 & MASK;
          b4 = b4 << 1 & MASK | 1;
        }
        while (a3 & ~b4 & QRTR) {
          register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
          a3 = a3 << 1 ^ HALF;
          b4 = (b4 ^ HALF) << 1 | HALF | 1;
        }
        low = a3;
        range = 1 + b4 - a3;
      }
      let offset = symbol_count - 4;
      return symbols.map((x2) => {
        switch (x2 - offset) {
          case 3:
            return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 2:
            return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
          case 1:
            return offset + bytes[pos_payload++];
          default:
            return x2 - 1;
        }
      });
    }
    function read_payload2(v2) {
      let pos = 0;
      return () => v2[pos++];
    }
    function read_compressed_payload2(s2) {
      return read_payload2(decode_arithmetic2(unsafe_atob2(s2)));
    }
    function unsafe_atob2(s2) {
      let lookup = [];
      [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c3, i2) => lookup[c3.charCodeAt(0)] = i2);
      let n2 = s2.length;
      let ret = new Uint8Array(6 * n2 >> 3);
      for (let i2 = 0, pos = 0, width = 0, carry = 0; i2 < n2; i2++) {
        carry = carry << 6 | lookup[s2.charCodeAt(i2)];
        width += 6;
        if (width >= 8) {
          ret[pos++] = carry >> (width -= 8);
        }
      }
      return ret;
    }
    function signed2(i2) {
      return i2 & 1 ? ~i2 >> 1 : i2 >> 1;
    }
    function read_deltas2(n2, next) {
      let v2 = Array(n2);
      for (let i2 = 0, x2 = 0; i2 < n2; i2++) v2[i2] = x2 += signed2(next());
      return v2;
    }
    function read_sorted2(next, prev = 0) {
      let ret = [];
      while (true) {
        let x2 = next();
        let n2 = next();
        if (!n2) break;
        prev += x2;
        for (let i2 = 0; i2 < n2; i2++) {
          ret.push(prev + i2);
        }
        prev += n2 + 1;
      }
      return ret;
    }
    function read_sorted_arrays2(next) {
      return read_array_while2(() => {
        let v2 = read_sorted2(next);
        if (v2.length) return v2;
      });
    }
    function read_mapped2(next) {
      let ret = [];
      while (true) {
        let w2 = next();
        if (w2 == 0) break;
        ret.push(read_linear_table2(w2, next));
      }
      while (true) {
        let w2 = next() - 1;
        if (w2 < 0) break;
        ret.push(read_replacement_table2(w2, next));
      }
      return ret.flat();
    }
    function read_array_while2(next) {
      let v2 = [];
      while (true) {
        let x2 = next(v2.length);
        if (!x2) break;
        v2.push(x2);
      }
      return v2;
    }
    function read_transposed2(n2, w2, next) {
      let m3 = Array(n2).fill().map(() => []);
      for (let i2 = 0; i2 < w2; i2++) {
        read_deltas2(n2, next).forEach((x2, j3) => m3[j3].push(x2));
      }
      return m3;
    }
    function read_linear_table2(w2, next) {
      let dx = 1 + next();
      let dy = next();
      let vN = read_array_while2(next);
      let m3 = read_transposed2(vN.length, 1 + w2, next);
      return m3.flatMap((v2, i2) => {
        let [x2, ...ys2] = v2;
        return Array(vN[i2]).fill().map((_2, j3) => {
          let j_dy = j3 * dy;
          return [x2 + j3 * dx, ys2.map((y2) => y2 + j_dy)];
        });
      });
    }
    function read_replacement_table2(w2, next) {
      let n2 = 1 + next();
      let m3 = read_transposed2(n2, 1 + w2, next);
      return m3.map((v2) => [v2[0], v2.slice(1)]);
    }
    function read_trie2(next) {
      let ret = [];
      let sorted = read_sorted2(next);
      expand(decode4([]), []);
      return ret;
      function decode4(Q2) {
        let S2 = next();
        let B2 = read_array_while2(() => {
          let cps = read_sorted2(next).map((i2) => sorted[i2]);
          if (cps.length) return decode4(cps);
        });
        return { S: S2, B: B2, Q: Q2 };
      }
      function expand({ S: S2, B: B2 }, cps, saved) {
        if (S2 & 4 && saved === cps[cps.length - 1]) return;
        if (S2 & 2) saved = cps[cps.length - 1];
        if (S2 & 1) ret.push(cps);
        for (let br2 of B2) {
          for (let cp of br2.Q) {
            expand(br2, [...cps, cp], saved);
          }
        }
      }
    }
    function hex_cp2(cp) {
      return cp.toString(16).toUpperCase().padStart(2, "0");
    }
    function quote_cp2(cp) {
      return `{${hex_cp2(cp)}}`;
    }
    function explode_cp2(s2) {
      let cps = [];
      for (let pos = 0, len = s2.length; pos < len; ) {
        let cp = s2.codePointAt(pos);
        pos += cp < 65536 ? 1 : 2;
        cps.push(cp);
      }
      return cps;
    }
    function str_from_cps2(cps) {
      const chunk = 4096;
      let len = cps.length;
      if (len < chunk) return String.fromCodePoint(...cps);
      let buf = [];
      for (let i2 = 0; i2 < len; ) {
        buf.push(String.fromCodePoint(...cps.slice(i2, i2 += chunk)));
      }
      return buf.join("");
    }
    function compare_arrays2(a3, b4) {
      let n2 = a3.length;
      let c3 = n2 - b4.length;
      for (let i2 = 0; c3 == 0 && i2 < n2; i2++) c3 = a3[i2] - b4[i2];
      return c3;
    }
    var COMPRESSED2 = "AEUDTAHBCFQATQDRADAAcgAgADQAFAAsABQAHwAOACQADQARAAoAFwAHABIACAAPAAUACwAFAAwABAAQAAMABwAEAAoABQAIAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACgANAA0AAwAKAAkABAAdAAYAZwDSAdsDJgC0CkMB8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgsj26PTQyy8FfEQ8AY8IPAGcEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiACnwRZEkkVsS7tANAsBG0RuAQLEPABv9HICTUBXigPZwRBApMDOwAamhtaABqEAY8KvKx3LQ4ArAB8UhwEBAVSagD8AEFZADkBIadVj2UMUgx5Il4ANQC9AxIB1BlbEPMAs30CGxlXAhwZKQIECBc6EbsCoxngzv7UzRQA8M0BawL6ZwkN7wABAD33OQRcsgLJCjMCjqUChtw/km+NAsXPAoP2BT84PwURAK0RAvptb6cApQS/OMMey5HJS84UdxpxTPkCogVFITaTOwERAK5pAvkNBOVyA7q3BKlOJSALAgUIBRcEdASpBXqzABXFSWZOawLCOqw//AolCZdvv3dSBkEQGyelEPcMMwG1ATsN7UvYBPEGOwTJH30ZGQ/NlZwIpS3dDO0m4y6hgFoj9SqDBe1L9DzdC01RaA9ZC2UJ4zpjgU4DIQENIosK3Q05CG0Q8wrJaw3lEUUHOQPVSZoApQcBCxEdNRW1JhBirAsJOXcG+xr2C48mrxMpevwF0xohBk0BKRr/AM8u54WwWjFcHE9fBgMLJSPHFKhQIA0lQLd4SBobBxUlqQKRQ3BKh1E2HpMh9jw9DWYuE1F8B/U8BRlPC4E8nkarRQ4R0j6NPUgiSUwsBDV/LC8niwnPD4UMuXxyAVkJIQmxDHETMREXN8UIOQcZLZckJxUIIUaVYJoE958D8xPRAwsFPwlBBxMDtRwtEy4VKQUNgSTXAvM21S6zAo9WgAEXBcsPJR/fEFBH4A7pCJsCZQODJesALRUhABcimwhDYwBfj9hTBS7LCMdqbCN0A2cU52ERcweRDlcHpxwzFb8c4XDIXguGCCijrwlbAXUJmQFfBOMICTVbjKAgQWdTi1gYmyBhQT9d/AIxDGUVn0S9h3gCiw9rEhsBNQFzBzkNAQJ3Ee0RaxCVCOuGBDW1M/g6JQRPIYMgEQonA09szgsnJvkM+GkBoxJiAww0PXfuZ6tgtiQX/QcZMsVBYCHxC5JPzQycGsEYQlQuGeQHvwPzGvMn6kFXBf8DowMTOk0z7gS9C2kIiwk/AEkOoxcH1xhqCnGM0AExiwG3mQNXkYMCb48GNwcLAGcLhwV55QAdAqcIowAFAM8DVwA5Aq0HnQAZAIVBAT0DJy8BIeUCjwOTCDHLAZUvAfMpBBvDDBUA9zduSgLDsQKAamaiBd1YAo4CSTUBTSUEBU5HUQOvceEA2wBLBhPfRwEVq0rLGuNDAd9vKwDHAPsABTUHBUEBzQHzbQC3AV8LMQmis7UBTekpAIMAFWsB1wKJAN0ANQB/8QFTAE0FWfkF0wJPSQERMRgrV2EBuwMfATMBDQB5BsuNpckHHwRtB9MCEBsV4QLvLge1AQMi3xPNQsUCvd5VoWACZIECYkJbTa9bNyACofcCaJgCZgkCn4Q4GwsCZjsCZiYEbgR/A38TA36SOQY5dxc5gjojIwJsHQIyNjgKAm3HAm2u74ozZ0UrAWcA3gDhAEoFB5gMjQD+C8IADbUCdy8CdqI/AnlLQwJ4uh1c20WuRtcCfD8CesgCfQkCfPAFWQUgSABIfWMkAoFtAoAAAoAFAn+uSVhKWxUXSswC0QEC0MxLJwOITwOH5kTFkTIC8qFdAwMDrkvOTC0lA89NTE2vAos/AorYwRsHHUNnBbcCjjcCjlxAl4ECjtkCjlx4UbRTNQpS1FSFApP7ApMMAOkAHFUeVa9V0AYsGymVhjLheGZFOzkCl58C77JYIagAWSUClo8ClnycAKlZrFoJgU0AOwKWtQKWTlxEXNECmcsCmWRcyl0HGQKcmznCOp0CnBYCn5sCnriKAB0PMSoPAp3xAp6SALU9YTRh7wKe0wKgbgGpAp6fHwKeTqVjyGQnJSsCJ68CJn4CoPsCoEwCot0CocQCpi8Cpc4Cp/8AfQKn8mh8aLEAA0lqHGrRAqzjAqyuAq1nAq0CAlcdAlXcArHh1wMfTmyXArK9DQKy6Bds4G1jbUhfAyXNArZcOz9ukAMpRQK4XgK5RxUCuSp3cDZw4QK9GQK72nCWAzIRAr6IcgIDM3ECvhpzInNPAsPLAsMEc4J0SzVFdOADPKcDPJoDPb8CxXwCxkcCxhCJAshpUQLIRALJTwLJLgJknQLd0nh5YXiueSVL0AMYo2cCAmH0GfOVJHsLXpJeuxECz2sCz2wvS1PS8xOfAMatAs9zASnqA04SfksFAtwnAtuKAtJPA1JcA1NfAQEDVYyAiT8AyxbtYEWCHILTgs6DjQLaxwLZ3oQQhEmnPAOGpQAvA2QOhnFZ+QBVAt9lAt64c3cC4i/tFAHzMCcB9JsB8tKHAuvzAulweQLq+QLq5AD5RwG5Au6JAuuclqqXAwLuPwOF4Jh5cOBxoQLzAwBpA44WmZMC9xMDkW4DkocC95gC+dkC+GaaHJqruzebHgOdgwL++gEbADmfHJ+zAwWNA6ZqA6bZANHFAwZqoYiiBQkDDEkCwAA/AwDhQRdTARHzA2sHl2cFAJMtK7evvdsBiZkUfxEEOQH7KQUhDp0JnwCS/SlXxQL3AZ0AtwW5AG8LbUEuFCaNLgFDAYD8AbUmAHUDDgRtACwCFgyhAAAKAj0CagPdA34EkQEgRQUhfAoABQBEABMANhICdwEABdUDa+8KxQIA9wqfJ7+xt+UBkSFBQgHpFH8RNMCJAAQAGwBaAkUChIsABjpTOpSNbQC4Oo860ACNOME63AClAOgAywE6gTo7Ofw5+Tt2iTpbO56JOm85GAFWATMBbAUvNV01njWtNWY1dTW2NcU1gjWRNdI14TWeNa017jX9NbI1wTYCNhE1xjXVNhY2JzXeNe02LjY9Ni41LSE2OjY9Njw2yTcIBJA8VzY4Nt03IDcPNsogN4k3MAoEsDxnNiQ3GTdsOo03IULUQwdC4EMLHA8PCZsobShRVQYA6X8A6bABFCnXAukBowC9BbcAbwNzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgBFLWZAu0BhQCjBcEAbykBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUABavAj626xQAJP0A3etzuf4NNRA7efy2Z9NQrCnC0OSyANz5BBIbJ5IFDR6miIavYS6tprjjmuKebxm5C74Q225X1pkaYYPb6f1DK4k3xMEBb9S2WMjEibTNWhsRJIA+vwNVEiXTE5iXs/wezV66oFLfp9NZGYW+Gk19J2+bCT6Ye2w6LDYdgzKMUabk595eLBCXANz9HUpWbATq9vqXVx9XDg+Pc9Xp4+bsS005SVM/BJBM4687WUuf+Uj9dEi8aDNaPxtpbDxcG1THTImUMZq4UCaaNYpsVqraNyKLJXDYsFZ/5jl7bLRtO88t7P3xZaAxhb5OdPMXqsSkp1WCieG8jXm1U99+blvLlXzPCS+M93VnJCiK+09LfaSaBAVBomyDgJua8dfUzR7ga34IvR2Nvj+A9heJ6lsl1KG4NkI1032Cnff1m1wof2B9oHJK4bi6JkEdSqeNeiuo6QoZZincoc73/TH9SXF8sCE7XyuYyW8WSgbGFCjPV0ihLKhdPs08Tx82fYAkLLc4I2wdl4apY7GU5lHRFzRWJep7Ww3wbeA3qmd59/86P4xuNaqDpygXt6M85glSBHOCGgJDnt+pN9bK7HApMguX6+06RZNjzVmcZJ+wcUrJ9//bpRNxNuKpNl9uFds+S9tdx7LaM5ZkIrPj6nIU9mnbFtVbs9s/uLgl8MVczAwet+iOEzzBlYW7RCMgE6gyNLeq6+1tIx4dpgZnd0DksJS5f+JNDpwwcPNXaaVspq1fbQajOrJgK0ofKtJ1Ne90L6VO4MOl5S886p7u6xo7OLjG8TGL+HU1JXGJgppg4nNbNJ5nlzSpuPYy21JUEcUA94PoFiZfjZue+QnyQ80ekOuZVkxx4g+cvhJfHgNl4hy1/a6+RKcKlar/J29y//EztlbVPHVUeQ1zX86eQVAjR/M3dA9w4W8LfaXp4EgM85wOWasli837PzVMOnsLzR+k3o75/lRPAJSE1xAKQzEi5v10ke+VBvRt1cwQRMd+U5mLCTGVd6XiZtgBG5cDi0w22GKcVNvHiu5LQbZEDVtz0onn7k5+heuKXVsZtSzilkLRAUmjMXEMB3J9YC50XBxPiz53SC+EhnPl9WsKCv92SM/OFFIMJZYfl0WW8tIO3UxYcwdMAj7FSmgrsZ2aAZO03BOhP1bNNZItyXYQFTpC3SG1VuPDqH9GkiCDmE+JwxyIVSO5siDErAOpEXFgjy6PQtOVDj+s6e1r8heWVvmZnTciuf4EiNZzCAd7SOMhXERIOlsHIMG399i9aLTy3m2hRLZjJVDNLS53iGIK11dPqQt0zBDyg6qc7YqkDm2M5Ve6dCWCaCbTXX2rToaIgz6+zh4lYUi/+6nqcFMAkQJKHYLK0wYk5N9szV6xihDbDDFr45lN1K4aCXBq/FitPSud9gLt5ZVn+ZqGX7cwm2z5EGMgfFpIFyhGGuDPmso6TItTMwny+7uPnLCf4W6goFQFV0oQSsc9VfMmVLcLr6ZetDZbaSFTLqnSO/bIPjA3/zAUoqgGFAEQS4IhuMzEp2I3jJzbzkk/IEmyax+rhZTwd6f+CGtwPixu8IvzACquPWPREu9ZvGkUzpRwvRRuaNN6cr0W1wWits9ICdYJ7ltbgMiSL3sTPeufgNcVqMVWFkCPDH4jG2jA0XcVgQj62Cb29v9f/z/+2KbYvIv/zzjpQAPkliaVDzNrW57TZ/ZOyZD0nlfMmAIBIAGAI0D3k/mdN4xr9v85ZbZbbqfH2jGd5hUqNZWwl5SPfoGmfElmazUIeNL1j/mkF7VNAzTq4jNt8JoQ11NQOcmhprXoxSxfRGJ9LDEOAQ+dmxAQH90iti9e2u/MoeuaGcDTHoC+xsmEeWmxEKefQuIzHbpw5Tc5cEocboAD09oipWQhtTO1wivf/O+DRe2rpl/E9wlrzBorjJsOeG1B/XPW4EaJEFdNlECEZga5ZoGRHXgYouGRuVkm8tDESiEyFNo+3s5M5puSdTyUL2llnINVHEt91XUNW4ewdMgJ4boJfEyt/iY5WXqbA+A2Fkt5Z0lutiWhe9nZIyIUjyXDC3UsaG1t+eNx6z4W/OYoTB7A6x+dNSTOi9AInctbESqm5gvOLww7OWXPrmHwVZasrl4eD113pm+JtT7JVOvnCXqdzzdTRHgJ0PiGTFYW5Gvt9R9LD6Lzfs0v/TZZHSmyVNq7viIHE6DBK7Qp07Iz55EM8SYtQvZf/obBniTWi5C2/ovHfw4VndkE5XYdjOhCMRjDeOEfXeN/CwfGduiUIfsoFeUxXeQXba7c7972XNv8w+dTjjUM0QeNAReW+J014dKAD/McQYXT7c0GQPIkn3Ll6R7gGjuiQoZD0TEeEqQpKoZ15g/0OPQI17QiSv9AUROa/V/TQN3dvLArec3RrsYlvBm1b8LWzltdugsC50lNKYLEp2a+ZZYqPejULRlOJh5zj/LVMyTDvwKhMxxwuDkxJ1QpoNI0OTWLom4Z71SNzI9TV1iXJrIu9Wcnd+MCaAw8o1jSXd94YU/1gnkrC9BUEOtQvEIQ7g0i6h+KL2JKk8Ydl7HruvgWMSAmNe+LshGhV4qnWHhO9/RIPQzY1tHRj2VqOyNsDpK0cww+56AdDC4gsWwY0XxoucIWIqs/GcwnWqlaT0KPr8mbK5U94/301i1WLt4YINTVvCFBrFZbIbY8eycOdeJ2teD5IfPLCRg7jjcFTwlMFNl9zdh/o3E/hHPwj7BWg0MU09pPrBLbrCgm54A6H+I6v27+jL5gkjWg/iYdks9jbfVP5y/n0dlgWEMlKasl7JvFZd56LfybW1eeaVO0gxTfXZwD8G4SI116yx7UKVRgui6Ya1YpixqXeNLc8IxtAwCU5IhwQgn+NqHnRaDv61CxKhOq4pOX7M6pkA+Pmpd4j1vn6ACUALoLLc4vpXci8VidLxzm7qFBe7s+quuJs6ETYmnpgS3LwSZxPIltgBDXz8M1k/W2ySNv2f9/NPhxLGK2D21dkHeSGmenRT3Yqcdl0m/h3OYr8V+lXNYGf8aCCpd4bWjE4QIPj7vUKN4Nrfs7ML6Y2OyS830JCnofg/k7lpFpt4SqZc5HGg1HCOrHvOdC8bP6FGDbE/VV0mX4IakzbdS/op+Kt3G24/8QbBV7y86sGSQ/vZzU8FXs7u6jIvwchsEP2BpIhW3G8uWNwa3HmjfH/ZjhhCWvluAcF+nMf14ClKg5hGgtPLJ98ueNAkc5Hs2WZlk2QHvfreCK1CCGO6nMZVSb99VM/ajr8WHTte9JSmkXq/i/U943HEbdzW6Re/S88dKgg8pGOLlAeNiqrcLkUR3/aClFpMXcOUP3rmETcWSfMXZE3TUOi8i+fqRnTYLflVx/Vb/6GJ7eIRZUA6k3RYR3iFSK9c4iDdNwJuZL2FKz/IK5VimcNWEqdXjSoxSgmF0UPlDoUlNrPcM7ftmA8Y9gKiqKEHuWN+AZRIwtVSxye2Kf8rM3lhJ5XcBXU9n4v0Oy1RU2M+4qM8AQPVwse8ErNSob5oFPWxuqZnVzo1qB/IBxkM3EVUKFUUlO3e51259GgNcJbCmlvrdjtoTW7rChm1wyCKzpCTwozUUEOIcWLneRLgMXh+SjGSFkAllzbGS5HK7LlfCMRNRDSvbQPjcXaenNYxCvu2Qyznz6StuxVj66SgI0T8B6/sfHAJYZaZ78thjOSIFumNWLQbeZixDCCC+v0YBtkxiBB3jefHqZ/dFHU+crbj6OvS1x/JDD7vlm7zOVPwpUC01nhxZuY/63E7g";
    var S02 = 44032;
    var L02 = 4352;
    var V02 = 4449;
    var T02 = 4519;
    var L_COUNT2 = 19;
    var V_COUNT2 = 21;
    var T_COUNT2 = 28;
    var N_COUNT2 = V_COUNT2 * T_COUNT2;
    var S_COUNT2 = L_COUNT2 * N_COUNT2;
    var S12 = S02 + S_COUNT2;
    var L12 = L02 + L_COUNT2;
    var V12 = V02 + V_COUNT2;
    var T12 = T02 + T_COUNT2;
    function unpack_cc2(packed) {
      return packed >> 24 & 255;
    }
    function unpack_cp2(packed) {
      return packed & 16777215;
    }
    var SHIFTED_RANK2;
    var EXCLUSIONS2;
    var DECOMP2;
    var RECOMP2;
    function init$12() {
      let r2 = read_compressed_payload2(COMPRESSED2);
      SHIFTED_RANK2 = new Map(read_sorted_arrays2(r2).flatMap((v2, i2) => v2.map((x2) => [x2, i2 + 1 << 24])));
      EXCLUSIONS2 = new Set(read_sorted2(r2));
      DECOMP2 = /* @__PURE__ */ new Map();
      RECOMP2 = /* @__PURE__ */ new Map();
      for (let [cp, cps] of read_mapped2(r2)) {
        if (!EXCLUSIONS2.has(cp) && cps.length == 2) {
          let [a3, b4] = cps;
          let bucket = RECOMP2.get(a3);
          if (!bucket) {
            bucket = /* @__PURE__ */ new Map();
            RECOMP2.set(a3, bucket);
          }
          bucket.set(b4, cp);
        }
        DECOMP2.set(cp, cps.reverse());
      }
    }
    function is_hangul2(cp) {
      return cp >= S02 && cp < S12;
    }
    function compose_pair2(a3, b4) {
      if (a3 >= L02 && a3 < L12 && b4 >= V02 && b4 < V12) {
        return S02 + (a3 - L02) * N_COUNT2 + (b4 - V02) * T_COUNT2;
      } else if (is_hangul2(a3) && b4 > T02 && b4 < T12 && (a3 - S02) % T_COUNT2 == 0) {
        return a3 + (b4 - T02);
      } else {
        let recomp = RECOMP2.get(a3);
        if (recomp) {
          recomp = recomp.get(b4);
          if (recomp) {
            return recomp;
          }
        }
        return -1;
      }
    }
    function decomposed2(cps) {
      if (!SHIFTED_RANK2) init$12();
      let ret = [];
      let buf = [];
      let check_order = false;
      function add4(cp) {
        let cc3 = SHIFTED_RANK2.get(cp);
        if (cc3) {
          check_order = true;
          cp |= cc3;
        }
        ret.push(cp);
      }
      for (let cp of cps) {
        while (true) {
          if (cp < 128) {
            ret.push(cp);
          } else if (is_hangul2(cp)) {
            let s_index = cp - S02;
            let l_index = s_index / N_COUNT2 | 0;
            let v_index = s_index % N_COUNT2 / T_COUNT2 | 0;
            let t_index = s_index % T_COUNT2;
            add4(L02 + l_index);
            add4(V02 + v_index);
            if (t_index > 0) add4(T02 + t_index);
          } else {
            let mapped = DECOMP2.get(cp);
            if (mapped) {
              buf.push(...mapped);
            } else {
              add4(cp);
            }
          }
          if (!buf.length) break;
          cp = buf.pop();
        }
      }
      if (check_order && ret.length > 1) {
        let prev_cc = unpack_cc2(ret[0]);
        for (let i2 = 1; i2 < ret.length; i2++) {
          let cc3 = unpack_cc2(ret[i2]);
          if (cc3 == 0 || prev_cc <= cc3) {
            prev_cc = cc3;
            continue;
          }
          let j3 = i2 - 1;
          while (true) {
            let tmp = ret[j3 + 1];
            ret[j3 + 1] = ret[j3];
            ret[j3] = tmp;
            if (!j3) break;
            prev_cc = unpack_cc2(ret[--j3]);
            if (prev_cc <= cc3) break;
          }
          prev_cc = unpack_cc2(ret[i2]);
        }
      }
      return ret;
    }
    function composed_from_decomposed2(v2) {
      let ret = [];
      let stack = [];
      let prev_cp = -1;
      let prev_cc = 0;
      for (let packed of v2) {
        let cc3 = unpack_cc2(packed);
        let cp = unpack_cp2(packed);
        if (prev_cp == -1) {
          if (cc3 == 0) {
            prev_cp = cp;
          } else {
            ret.push(cp);
          }
        } else if (prev_cc > 0 && prev_cc >= cc3) {
          if (cc3 == 0) {
            ret.push(prev_cp, ...stack);
            stack.length = 0;
            prev_cp = cp;
          } else {
            stack.push(cp);
          }
          prev_cc = cc3;
        } else {
          let composed = compose_pair2(prev_cp, cp);
          if (composed >= 0) {
            prev_cp = composed;
          } else if (prev_cc == 0 && cc3 == 0) {
            ret.push(prev_cp);
            prev_cp = cp;
          } else {
            stack.push(cp);
            prev_cc = cc3;
          }
        }
      }
      if (prev_cp >= 0) {
        ret.push(prev_cp, ...stack);
      }
      return ret;
    }
    function nfd2(cps) {
      return decomposed2(cps).map(unpack_cp2);
    }
    function nfc2(cps) {
      return composed_from_decomposed2(decomposed2(cps));
    }
    var HYPHEN2 = 45;
    var STOP = 46;
    var STOP_CH2 = ".";
    var FE0F2 = 65039;
    var UNIQUE_PH2 = 1;
    var Array_from2 = (x2) => Array.from(x2);
    function group_has_cp2(g3, cp) {
      return g3.P.has(cp) || g3.Q.has(cp);
    }
    var Emoji2 = class extends Array {
      get is_emoji() {
        return true;
      }
      // free tagging system
    };
    var MAPPED2;
    var IGNORED2;
    var CM2;
    var NSM2;
    var ESCAPE2;
    var NFC_CHECK2;
    var GROUPS2;
    var WHOLE_VALID2;
    var WHOLE_MAP2;
    var VALID2;
    var EMOJI_LIST2;
    var EMOJI_ROOT2;
    function init2() {
      if (MAPPED2) return;
      let r2 = read_compressed_payload2(COMPRESSED$12);
      const read_sorted_array = () => read_sorted2(r2);
      const read_sorted_set = () => new Set(read_sorted_array());
      const set_add_many = (set, v2) => v2.forEach((x2) => set.add(x2));
      MAPPED2 = new Map(read_mapped2(r2));
      IGNORED2 = read_sorted_set();
      CM2 = read_sorted_array();
      NSM2 = new Set(read_sorted_array().map((i2) => CM2[i2]));
      CM2 = new Set(CM2);
      ESCAPE2 = read_sorted_set();
      NFC_CHECK2 = read_sorted_set();
      let chunks = read_sorted_arrays2(r2);
      let unrestricted = r2();
      const read_chunked = () => {
        let set = /* @__PURE__ */ new Set();
        read_sorted_array().forEach((i2) => set_add_many(set, chunks[i2]));
        set_add_many(set, read_sorted_array());
        return set;
      };
      GROUPS2 = read_array_while2((i2) => {
        let N2 = read_array_while2(r2).map((x2) => x2 + 96);
        if (N2.length) {
          let R2 = i2 >= unrestricted;
          N2[0] -= 32;
          N2 = str_from_cps2(N2);
          if (R2) N2 = `Restricted[${N2}]`;
          let P = read_chunked();
          let Q2 = read_chunked();
          let M3 = !r2();
          return { N: N2, P, Q: Q2, M: M3, R: R2 };
        }
      });
      WHOLE_VALID2 = read_sorted_set();
      WHOLE_MAP2 = /* @__PURE__ */ new Map();
      let wholes = read_sorted_array().concat(Array_from2(WHOLE_VALID2)).sort((a3, b4) => a3 - b4);
      wholes.forEach((cp, i2) => {
        let d2 = r2();
        let w2 = wholes[i2] = d2 ? wholes[i2 - d2] : { V: [], M: /* @__PURE__ */ new Map() };
        w2.V.push(cp);
        if (!WHOLE_VALID2.has(cp)) {
          WHOLE_MAP2.set(cp, w2);
        }
      });
      for (let { V: V2, M: M3 } of new Set(WHOLE_MAP2.values())) {
        let recs = [];
        for (let cp of V2) {
          let gs2 = GROUPS2.filter((g3) => group_has_cp2(g3, cp));
          let rec = recs.find(({ G: G2 }) => gs2.some((g3) => G2.has(g3)));
          if (!rec) {
            rec = { G: /* @__PURE__ */ new Set(), V: [] };
            recs.push(rec);
          }
          rec.V.push(cp);
          set_add_many(rec.G, gs2);
        }
        let union = recs.flatMap((x2) => Array_from2(x2.G));
        for (let { G: G2, V: V3 } of recs) {
          let complement = new Set(union.filter((g3) => !G2.has(g3)));
          for (let cp of V3) {
            M3.set(cp, complement);
          }
        }
      }
      VALID2 = /* @__PURE__ */ new Set();
      let multi = /* @__PURE__ */ new Set();
      const add_to_union = (cp) => VALID2.has(cp) ? multi.add(cp) : VALID2.add(cp);
      for (let g3 of GROUPS2) {
        for (let cp of g3.P) add_to_union(cp);
        for (let cp of g3.Q) add_to_union(cp);
      }
      for (let cp of VALID2) {
        if (!WHOLE_MAP2.has(cp) && !multi.has(cp)) {
          WHOLE_MAP2.set(cp, UNIQUE_PH2);
        }
      }
      set_add_many(VALID2, nfd2(VALID2));
      EMOJI_LIST2 = read_trie2(r2).map((v2) => Emoji2.from(v2)).sort(compare_arrays2);
      EMOJI_ROOT2 = /* @__PURE__ */ new Map();
      for (let cps of EMOJI_LIST2) {
        let prev = [EMOJI_ROOT2];
        for (let cp of cps) {
          let next = prev.map((node) => {
            let child = node.get(cp);
            if (!child) {
              child = /* @__PURE__ */ new Map();
              node.set(cp, child);
            }
            return child;
          });
          if (cp === FE0F2) {
            prev.push(...next);
          } else {
            prev = next;
          }
        }
        for (let x2 of prev) {
          x2.V = cps;
        }
      }
    }
    function quoted_cp2(cp) {
      return (should_escape2(cp) ? "" : `${bidi_qq2(safe_str_from_cps2([cp]))} `) + quote_cp2(cp);
    }
    function bidi_qq2(s2) {
      return `"${s2}"`;
    }
    function check_label_extension2(cps) {
      if (cps.length >= 4 && cps[2] == HYPHEN2 && cps[3] == HYPHEN2) {
        throw new Error(`invalid label extension: "${str_from_cps2(cps.slice(0, 4))}"`);
      }
    }
    function check_leading_underscore2(cps) {
      const UNDERSCORE = 95;
      for (let i2 = cps.lastIndexOf(UNDERSCORE); i2 > 0; ) {
        if (cps[--i2] !== UNDERSCORE) {
          throw new Error("underscore allowed only at start");
        }
      }
    }
    function check_fenced2(cps) {
      let cp = cps[0];
      let prev = FENCED2.get(cp);
      if (prev) throw error_placement2(`leading ${prev}`);
      let n2 = cps.length;
      let last = -1;
      for (let i2 = 1; i2 < n2; i2++) {
        cp = cps[i2];
        let match = FENCED2.get(cp);
        if (match) {
          if (last == i2) throw error_placement2(`${prev} + ${match}`);
          last = i2 + 1;
          prev = match;
        }
      }
      if (last == n2) throw error_placement2(`trailing ${prev}`);
    }
    function safe_str_from_cps2(cps, max = Infinity, quoter = quote_cp2) {
      let buf = [];
      if (is_combining_mark2(cps[0])) buf.push("");
      if (cps.length > max) {
        max >>= 1;
        cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
      }
      let prev = 0;
      let n2 = cps.length;
      for (let i2 = 0; i2 < n2; i2++) {
        let cp = cps[i2];
        if (should_escape2(cp)) {
          buf.push(str_from_cps2(cps.slice(prev, i2)));
          buf.push(quoter(cp));
          prev = i2 + 1;
        }
      }
      buf.push(str_from_cps2(cps.slice(prev, n2)));
      return buf.join("");
    }
    function is_combining_mark2(cp) {
      init2();
      return CM2.has(cp);
    }
    function should_escape2(cp) {
      init2();
      return ESCAPE2.has(cp);
    }
    function ens_emoji() {
      init2();
      return EMOJI_LIST2.map((x2) => x2.slice());
    }
    function ens_normalize_fragment(frag, decompose) {
      init2();
      let nf = decompose ? nfd2 : nfc2;
      return frag.split(STOP_CH2).map((label) => str_from_cps2(tokens_from_str2(explode_cp2(label), nf, filter_fe0f2).flat())).join(STOP_CH2);
    }
    function ens_normalize2(name) {
      return flatten2(split4(name, nfc2, filter_fe0f2));
    }
    function ens_beautify(name) {
      let labels = split4(name, nfc2, (x2) => x2);
      for (let { type: type6, output, error } of labels) {
        if (error) break;
        if (type6 !== "Greek") array_replace(output, 958, 926);
      }
      return flatten2(labels);
    }
    function array_replace(v2, a3, b4) {
      let prev = 0;
      while (true) {
        let next = v2.indexOf(a3, prev);
        if (next < 0) break;
        v2[next] = b4;
        prev = next + 1;
      }
    }
    function ens_split(name, preserve_emoji) {
      return split4(name, nfc2, preserve_emoji ? (x2) => x2.slice() : filter_fe0f2);
    }
    function split4(name, nf, ef) {
      if (!name) return [];
      init2();
      let offset = 0;
      return name.split(STOP_CH2).map((label) => {
        let input = explode_cp2(label);
        let info = {
          input,
          offset
          // codepoint, not substring!
        };
        offset += input.length + 1;
        try {
          let tokens = info.tokens = tokens_from_str2(input, nf, ef);
          let token_count = tokens.length;
          let type6;
          if (!token_count) {
            throw new Error(`empty label`);
          }
          let norm = info.output = tokens.flat();
          check_leading_underscore2(norm);
          let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
          if (!emoji && norm.every((cp) => cp < 128)) {
            check_label_extension2(norm);
            type6 = "ASCII";
          } else {
            let chars = tokens.flatMap((x2) => x2.is_emoji ? [] : x2);
            if (!chars.length) {
              type6 = "Emoji";
            } else {
              if (CM2.has(norm[0])) throw error_placement2("leading combining mark");
              for (let i2 = 1; i2 < token_count; i2++) {
                let cps = tokens[i2];
                if (!cps.is_emoji && CM2.has(cps[0])) {
                  throw error_placement2(`emoji + combining mark: "${str_from_cps2(tokens[i2 - 1])} + ${safe_str_from_cps2([cps[0]])}"`);
                }
              }
              check_fenced2(norm);
              let unique2 = Array_from2(new Set(chars));
              let [g3] = determine_group2(unique2);
              check_group2(g3, chars);
              check_whole2(g3, unique2);
              type6 = g3.N;
            }
          }
          info.type = type6;
        } catch (err) {
          info.error = err;
        }
        return info;
      });
    }
    function check_whole2(group, unique2) {
      let maker;
      let shared = [];
      for (let cp of unique2) {
        let whole = WHOLE_MAP2.get(cp);
        if (whole === UNIQUE_PH2) return;
        if (whole) {
          let set = whole.M.get(cp);
          maker = maker ? maker.filter((g3) => set.has(g3)) : Array_from2(set);
          if (!maker.length) return;
        } else {
          shared.push(cp);
        }
      }
      if (maker) {
        for (let g3 of maker) {
          if (shared.every((cp) => group_has_cp2(g3, cp))) {
            throw new Error(`whole-script confusable: ${group.N}/${g3.N}`);
          }
        }
      }
    }
    function determine_group2(unique2) {
      let groups = GROUPS2;
      for (let cp of unique2) {
        let gs2 = groups.filter((g3) => group_has_cp2(g3, cp));
        if (!gs2.length) {
          if (!GROUPS2.some((g3) => group_has_cp2(g3, cp))) {
            throw error_disallowed2(cp);
          } else {
            throw error_group_member2(groups[0], cp);
          }
        }
        groups = gs2;
        if (gs2.length == 1) break;
      }
      return groups;
    }
    function flatten2(split5) {
      return split5.map(({ input, error, output }) => {
        if (error) {
          let msg = error.message;
          throw new Error(split5.length == 1 ? msg : `Invalid label ${bidi_qq2(safe_str_from_cps2(input, 63))}: ${msg}`);
        }
        return str_from_cps2(output);
      }).join(STOP_CH2);
    }
    function error_disallowed2(cp) {
      return new Error(`disallowed character: ${quoted_cp2(cp)}`);
    }
    function error_group_member2(g3, cp) {
      let quoted = quoted_cp2(cp);
      let gg = GROUPS2.find((g4) => g4.P.has(cp));
      if (gg) {
        quoted = `${gg.N} ${quoted}`;
      }
      return new Error(`illegal mixture: ${g3.N} + ${quoted}`);
    }
    function error_placement2(where) {
      return new Error(`illegal placement: ${where}`);
    }
    function check_group2(g3, cps) {
      for (let cp of cps) {
        if (!group_has_cp2(g3, cp)) {
          throw error_group_member2(g3, cp);
        }
      }
      if (g3.M) {
        let decomposed3 = nfd2(cps);
        for (let i2 = 1, e2 = decomposed3.length; i2 < e2; i2++) {
          if (NSM2.has(decomposed3[i2])) {
            let j3 = i2 + 1;
            for (let cp; j3 < e2 && NSM2.has(cp = decomposed3[j3]); j3++) {
              for (let k4 = i2; k4 < j3; k4++) {
                if (decomposed3[k4] == cp) {
                  throw new Error(`duplicate non-spacing marks: ${quoted_cp2(cp)}`);
                }
              }
            }
            if (j3 - i2 > NSM_MAX2) {
              throw new Error(`excessive non-spacing marks: ${bidi_qq2(safe_str_from_cps2(decomposed3.slice(i2 - 1, j3)))} (${j3 - i2}/${NSM_MAX2})`);
            }
            i2 = j3;
          }
        }
      }
    }
    function tokens_from_str2(input, nf, ef) {
      let ret = [];
      let chars = [];
      input = input.slice().reverse();
      while (input.length) {
        let emoji = consume_emoji_reversed2(input);
        if (emoji) {
          if (chars.length) {
            ret.push(nf(chars));
            chars = [];
          }
          ret.push(ef(emoji));
        } else {
          let cp = input.pop();
          if (VALID2.has(cp)) {
            chars.push(cp);
          } else {
            let cps = MAPPED2.get(cp);
            if (cps) {
              chars.push(...cps);
            } else if (!IGNORED2.has(cp)) {
              throw error_disallowed2(cp);
            }
          }
        }
      }
      if (chars.length) {
        ret.push(nf(chars));
      }
      return ret;
    }
    function filter_fe0f2(cps) {
      return cps.filter((cp) => cp != FE0F2);
    }
    function consume_emoji_reversed2(cps, eaten) {
      let node = EMOJI_ROOT2;
      let emoji;
      let pos = cps.length;
      while (pos) {
        node = node.get(cps[--pos]);
        if (!node) break;
        let { V: V2 } = node;
        if (V2) {
          emoji = V2;
          if (eaten) eaten.push(...cps.slice(pos).reverse());
          cps.length = pos;
        }
      }
      return emoji;
    }
    var TY_VALID = "valid";
    var TY_MAPPED = "mapped";
    var TY_IGNORED = "ignored";
    var TY_DISALLOWED = "disallowed";
    var TY_EMOJI = "emoji";
    var TY_NFC = "nfc";
    var TY_STOP = "stop";
    function ens_tokenize(name, {
      nf = true
      // collapse unnormalized runs into a single token
    } = {}) {
      init2();
      let input = explode_cp2(name).reverse();
      let eaten = [];
      let tokens = [];
      while (input.length) {
        let emoji = consume_emoji_reversed2(input, eaten);
        if (emoji) {
          tokens.push({
            type: TY_EMOJI,
            emoji: emoji.slice(),
            // copy emoji
            input: eaten,
            cps: filter_fe0f2(emoji)
          });
          eaten = [];
        } else {
          let cp = input.pop();
          if (cp == STOP) {
            tokens.push({ type: TY_STOP, cp });
          } else if (VALID2.has(cp)) {
            tokens.push({ type: TY_VALID, cps: [cp] });
          } else if (IGNORED2.has(cp)) {
            tokens.push({ type: TY_IGNORED, cp });
          } else {
            let cps = MAPPED2.get(cp);
            if (cps) {
              tokens.push({ type: TY_MAPPED, cp, cps: cps.slice() });
            } else {
              tokens.push({ type: TY_DISALLOWED, cp });
            }
          }
        }
      }
      if (nf) {
        for (let i2 = 0, start = -1; i2 < tokens.length; i2++) {
          let token = tokens[i2];
          if (is_valid_or_mapped(token.type)) {
            if (requires_check(token.cps)) {
              let end = i2 + 1;
              for (let pos = end; pos < tokens.length; pos++) {
                let { type: type6, cps: cps2 } = tokens[pos];
                if (is_valid_or_mapped(type6)) {
                  if (!requires_check(cps2)) break;
                  end = pos + 1;
                } else if (type6 !== TY_IGNORED) {
                  break;
                }
              }
              if (start < 0) start = i2;
              let slice3 = tokens.slice(start, end);
              let cps0 = slice3.flatMap((x2) => is_valid_or_mapped(x2.type) ? x2.cps : []);
              let cps = nfc2(cps0);
              if (compare_arrays2(cps, cps0)) {
                tokens.splice(start, end - start, {
                  type: TY_NFC,
                  input: cps0,
                  // there are 3 states: tokens0 ==(process)=> input ==(nfc)=> tokens/cps
                  cps,
                  tokens0: collapse_valid_tokens(slice3),
                  tokens: ens_tokenize(str_from_cps2(cps), { nf: false })
                });
                i2 = start;
              } else {
                i2 = end - 1;
              }
              start = -1;
            } else {
              start = i2;
            }
          } else if (token.type !== TY_IGNORED) {
            start = -1;
          }
        }
      }
      return collapse_valid_tokens(tokens);
    }
    function is_valid_or_mapped(type6) {
      return type6 == TY_VALID || type6 == TY_MAPPED;
    }
    function requires_check(cps) {
      return cps.some((cp) => NFC_CHECK2.has(cp));
    }
    function collapse_valid_tokens(tokens) {
      for (let i2 = 0; i2 < tokens.length; i2++) {
        if (tokens[i2].type == TY_VALID) {
          let j3 = i2 + 1;
          while (j3 < tokens.length && tokens[j3].type == TY_VALID) j3++;
          tokens.splice(i2, j3 - i2, { type: TY_VALID, cps: tokens.slice(i2, j3).flatMap((x2) => x2.cps) });
        }
      }
      return tokens;
    }
    exports.ens_beautify = ens_beautify;
    exports.ens_emoji = ens_emoji;
    exports.ens_normalize = ens_normalize2;
    exports.ens_normalize_fragment = ens_normalize_fragment;
    exports.ens_split = ens_split;
    exports.ens_tokenize = ens_tokenize;
    exports.is_combining_mark = is_combining_mark2;
    exports.nfc = nfc2;
    exports.nfd = nfd2;
    exports.safe_str_from_cps = safe_str_from_cps2;
    exports.should_escape = should_escape2;
  }
});

// node_modules/ethers/lib.commonjs/hash/namehash.js
var require_namehash = __commonJS({
  "node_modules/ethers/lib.commonjs/hash/namehash.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_utils5();
    var ens_normalize_1 = require_dist();
    var Zeros = new Uint8Array(32);
    Zeros.fill(0);
    function checkComponent(comp) {
      (0, index_js_2.assertArgument)(comp.length !== 0, "invalid ENS name; empty component", "comp", comp);
      return comp;
    }
    function ensNameSplit(name) {
      const bytes = (0, index_js_2.toUtf8Bytes)(ensNormalize(name));
      const comps = [];
      if (name.length === 0) {
        return comps;
      }
      let last = 0;
      for (let i2 = 0; i2 < bytes.length; i2++) {
        const d2 = bytes[i2];
        if (d2 === 46) {
          comps.push(checkComponent(bytes.slice(last, i2)));
          last = i2 + 1;
        }
      }
      (0, index_js_2.assertArgument)(last < bytes.length, "invalid ENS name; empty component", "name", name);
      comps.push(checkComponent(bytes.slice(last)));
      return comps;
    }
    function ensNormalize(name) {
      try {
        if (name.length === 0) {
          throw new Error("empty label");
        }
        return (0, ens_normalize_1.ens_normalize)(name);
      } catch (error) {
        (0, index_js_2.assertArgument)(false, `invalid ENS name (${error.message})`, "name", name);
      }
    }
    exports.ensNormalize = ensNormalize;
    function isValidName(name) {
      try {
        return ensNameSplit(name).length !== 0;
      } catch (error) {
      }
      return false;
    }
    exports.isValidName = isValidName;
    function namehash3(name) {
      (0, index_js_2.assertArgument)(typeof name === "string", "invalid ENS name; not a string", "name", name);
      (0, index_js_2.assertArgument)(name.length, `invalid ENS name (empty label)`, "name", name);
      let result = Zeros;
      const comps = ensNameSplit(name);
      while (comps.length) {
        result = (0, index_js_1.keccak256)((0, index_js_2.concat)([result, (0, index_js_1.keccak256)(comps.pop())]));
      }
      return (0, index_js_2.hexlify)(result);
    }
    exports.namehash = namehash3;
    function dnsEncode(name, _maxLength) {
      const length2 = _maxLength != null ? _maxLength : 63;
      (0, index_js_2.assertArgument)(length2 <= 255, "DNS encoded label cannot exceed 255", "length", length2);
      return (0, index_js_2.hexlify)((0, index_js_2.concat)(ensNameSplit(name).map((comp) => {
        (0, index_js_2.assertArgument)(comp.length <= length2, `label ${JSON.stringify(name)} exceeds ${length2} bytes`, "name", name);
        const bytes = new Uint8Array(comp.length + 1);
        bytes.set(comp, 1);
        bytes[0] = bytes.length - 1;
        return bytes;
      }))) + "00";
    }
    exports.dnsEncode = dnsEncode;
  }
});

// node_modules/ethers/lib.commonjs/transaction/accesslist.js
var require_accesslist = __commonJS({
  "node_modules/ethers/lib.commonjs/transaction/accesslist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.accessListify = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_utils5();
    function accessSetify(addr, storageKeys) {
      return {
        address: (0, index_js_1.getAddress)(addr),
        storageKeys: storageKeys.map((storageKey, index5) => {
          (0, index_js_2.assertArgument)((0, index_js_2.isHexString)(storageKey, 32), "invalid slot", `storageKeys[${index5}]`, storageKey);
          return storageKey.toLowerCase();
        })
      };
    }
    function accessListify(value) {
      if (Array.isArray(value)) {
        return value.map((set, index5) => {
          if (Array.isArray(set)) {
            (0, index_js_2.assertArgument)(set.length === 2, "invalid slot set", `value[${index5}]`, set);
            return accessSetify(set[0], set[1]);
          }
          (0, index_js_2.assertArgument)(set != null && typeof set === "object", "invalid address-slot set", "value", value);
          return accessSetify(set.address, set.storageKeys);
        });
      }
      (0, index_js_2.assertArgument)(value != null && typeof value === "object", "invalid access list", "value", value);
      const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
          accum[storageKey] = true;
          return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
      });
      result.sort((a3, b4) => a3.address.localeCompare(b4.address));
      return result;
    }
    exports.accessListify = accessListify;
  }
});

// node_modules/ethers/lib.commonjs/transaction/address.js
var require_address4 = __commonJS({
  "node_modules/ethers/lib.commonjs/transaction/address.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.recoverAddress = exports.computeAddress = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_crypto2();
    function computeAddress(key) {
      let pubkey;
      if (typeof key === "string") {
        pubkey = index_js_2.SigningKey.computePublicKey(key, false);
      } else {
        pubkey = key.publicKey;
      }
      return (0, index_js_1.getAddress)((0, index_js_2.keccak256)("0x" + pubkey.substring(4)).substring(26));
    }
    exports.computeAddress = computeAddress;
    function recoverAddress2(digest, signature) {
      return computeAddress(index_js_2.SigningKey.recoverPublicKey(digest, signature));
    }
    exports.recoverAddress = recoverAddress2;
  }
});

// node_modules/ethers/lib.commonjs/transaction/transaction.js
var require_transaction = __commonJS({
  "node_modules/ethers/lib.commonjs/transaction/transaction.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = void 0;
    var index_js_1 = require_address2();
    var addresses_js_1 = require_addresses();
    var index_js_2 = require_crypto2();
    var index_js_3 = require_utils5();
    var accesslist_js_1 = require_accesslist();
    var address_js_1 = require_address4();
    var BN_0 = BigInt(0);
    var BN_2 = BigInt(2);
    var BN_27 = BigInt(27);
    var BN_28 = BigInt(28);
    var BN_35 = BigInt(35);
    var BN_MAX_UINT = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    var BLOB_SIZE = 4096 * 32;
    function getVersionedHash(version7, hash8) {
      let versioned = version7.toString(16);
      while (versioned.length < 2) {
        versioned = "0" + versioned;
      }
      versioned += (0, index_js_2.sha256)(hash8).substring(4);
      return "0x" + versioned;
    }
    function handleAddress(value) {
      if (value === "0x") {
        return null;
      }
      return (0, index_js_1.getAddress)(value);
    }
    function handleAccessList(value, param) {
      try {
        return (0, accesslist_js_1.accessListify)(value);
      } catch (error) {
        (0, index_js_3.assertArgument)(false, error.message, param, value);
      }
    }
    function handleNumber(_value2, param) {
      if (_value2 === "0x") {
        return 0;
      }
      return (0, index_js_3.getNumber)(_value2, param);
    }
    function handleUint(_value2, param) {
      if (_value2 === "0x") {
        return BN_0;
      }
      const value = (0, index_js_3.getBigInt)(_value2, param);
      (0, index_js_3.assertArgument)(value <= BN_MAX_UINT, "value exceeds uint size", param, value);
      return value;
    }
    function formatNumber(_value2, name) {
      const value = (0, index_js_3.getBigInt)(_value2, "value");
      const result = (0, index_js_3.toBeArray)(value);
      (0, index_js_3.assertArgument)(result.length <= 32, `value too large`, `tx.${name}`, value);
      return result;
    }
    function formatAccessList(value) {
      return (0, accesslist_js_1.accessListify)(value).map((set) => [set.address, set.storageKeys]);
    }
    function formatHashes(value, param) {
      (0, index_js_3.assertArgument)(Array.isArray(value), `invalid ${param}`, "value", value);
      for (let i2 = 0; i2 < value.length; i2++) {
        (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i2], 32), "invalid ${ param } hash", `value[${i2}]`, value[i2]);
      }
      return value;
    }
    function _parseLegacy(data) {
      const fields = (0, index_js_3.decodeRlp)(data);
      (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 6), "invalid field count for legacy transaction", "data", data);
      const tx = {
        type: 0,
        nonce: handleNumber(fields[0], "nonce"),
        gasPrice: handleUint(fields[1], "gasPrice"),
        gasLimit: handleUint(fields[2], "gasLimit"),
        to: handleAddress(fields[3]),
        value: handleUint(fields[4], "value"),
        data: (0, index_js_3.hexlify)(fields[5]),
        chainId: BN_0
      };
      if (fields.length === 6) {
        return tx;
      }
      const v2 = handleUint(fields[6], "v");
      const r2 = handleUint(fields[7], "r");
      const s2 = handleUint(fields[8], "s");
      if (r2 === BN_0 && s2 === BN_0) {
        tx.chainId = v2;
      } else {
        let chainId = (v2 - BN_35) / BN_2;
        if (chainId < BN_0) {
          chainId = BN_0;
        }
        tx.chainId = chainId;
        (0, index_js_3.assertArgument)(chainId !== BN_0 || (v2 === BN_27 || v2 === BN_28), "non-canonical legacy v", "v", fields[6]);
        tx.signature = index_js_2.Signature.from({
          r: (0, index_js_3.zeroPadValue)(fields[7], 32),
          s: (0, index_js_3.zeroPadValue)(fields[8], 32),
          v: v2
        });
      }
      return tx;
    }
    function _serializeLegacy(tx, sig) {
      const fields = [
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.gasPrice || 0, "gasPrice"),
        formatNumber(tx.gasLimit, "gasLimit"),
        tx.to || "0x",
        formatNumber(tx.value, "value"),
        tx.data
      ];
      let chainId = BN_0;
      if (tx.chainId != BN_0) {
        chainId = (0, index_js_3.getBigInt)(tx.chainId, "tx.chainId");
        (0, index_js_3.assertArgument)(!sig || sig.networkV == null || sig.legacyChainId === chainId, "tx.chainId/sig.v mismatch", "sig", sig);
      } else if (tx.signature) {
        const legacy = tx.signature.legacyChainId;
        if (legacy != null) {
          chainId = legacy;
        }
      }
      if (!sig) {
        if (chainId !== BN_0) {
          fields.push((0, index_js_3.toBeArray)(chainId));
          fields.push("0x");
          fields.push("0x");
        }
        return (0, index_js_3.encodeRlp)(fields);
      }
      let v2 = BigInt(27 + sig.yParity);
      if (chainId !== BN_0) {
        v2 = index_js_2.Signature.getChainIdV(chainId, sig.v);
      } else if (BigInt(sig.v) !== v2) {
        (0, index_js_3.assertArgument)(false, "tx.chainId/sig.v mismatch", "sig", sig);
      }
      fields.push((0, index_js_3.toBeArray)(v2));
      fields.push((0, index_js_3.toBeArray)(sig.r));
      fields.push((0, index_js_3.toBeArray)(sig.s));
      return (0, index_js_3.encodeRlp)(fields);
    }
    function _parseEipSignature(tx, fields) {
      let yParity;
      try {
        yParity = handleNumber(fields[0], "yParity");
        if (yParity !== 0 && yParity !== 1) {
          throw new Error("bad yParity");
        }
      } catch (error) {
        (0, index_js_3.assertArgument)(false, "invalid yParity", "yParity", fields[0]);
      }
      const r2 = (0, index_js_3.zeroPadValue)(fields[1], 32);
      const s2 = (0, index_js_3.zeroPadValue)(fields[2], 32);
      const signature = index_js_2.Signature.from({ r: r2, s: s2, yParity });
      tx.signature = signature;
    }
    function _parseEip1559(data) {
      const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
      (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 9 || fields.length === 12), "invalid field count for transaction type: 2", "data", (0, index_js_3.hexlify)(data));
      const tx = {
        type: 2,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
        maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: handleUint(fields[4], "gasLimit"),
        to: handleAddress(fields[5]),
        value: handleUint(fields[6], "value"),
        data: (0, index_js_3.hexlify)(fields[7]),
        accessList: handleAccessList(fields[8], "accessList")
      };
      if (fields.length === 9) {
        return tx;
      }
      _parseEipSignature(tx, fields.slice(9));
      return tx;
    }
    function _serializeEip1559(tx, sig) {
      const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(tx.gasLimit, "gasLimit"),
        tx.to || "0x",
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || [])
      ];
      if (sig) {
        fields.push(formatNumber(sig.yParity, "yParity"));
        fields.push((0, index_js_3.toBeArray)(sig.r));
        fields.push((0, index_js_3.toBeArray)(sig.s));
      }
      return (0, index_js_3.concat)(["0x02", (0, index_js_3.encodeRlp)(fields)]);
    }
    function _parseEip2930(data) {
      const fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
      (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 8 || fields.length === 11), "invalid field count for transaction type: 1", "data", (0, index_js_3.hexlify)(data));
      const tx = {
        type: 1,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        gasPrice: handleUint(fields[2], "gasPrice"),
        gasLimit: handleUint(fields[3], "gasLimit"),
        to: handleAddress(fields[4]),
        value: handleUint(fields[5], "value"),
        data: (0, index_js_3.hexlify)(fields[6]),
        accessList: handleAccessList(fields[7], "accessList")
      };
      if (fields.length === 8) {
        return tx;
      }
      _parseEipSignature(tx, fields.slice(8));
      return tx;
    }
    function _serializeEip2930(tx, sig) {
      const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.gasPrice || 0, "gasPrice"),
        formatNumber(tx.gasLimit, "gasLimit"),
        tx.to || "0x",
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || [])
      ];
      if (sig) {
        fields.push(formatNumber(sig.yParity, "recoveryParam"));
        fields.push((0, index_js_3.toBeArray)(sig.r));
        fields.push((0, index_js_3.toBeArray)(sig.s));
      }
      return (0, index_js_3.concat)(["0x01", (0, index_js_3.encodeRlp)(fields)]);
    }
    function _parseEip4844(data) {
      let fields = (0, index_js_3.decodeRlp)((0, index_js_3.getBytes)(data).slice(1));
      let typeName = "3";
      let blobs = null;
      if (fields.length === 4 && Array.isArray(fields[0])) {
        typeName = "3 (network format)";
        const fBlobs = fields[1], fCommits = fields[2], fProofs = fields[3];
        (0, index_js_3.assertArgument)(Array.isArray(fBlobs), "invalid network format: blobs not an array", "fields[1]", fBlobs);
        (0, index_js_3.assertArgument)(Array.isArray(fCommits), "invalid network format: commitments not an array", "fields[2]", fCommits);
        (0, index_js_3.assertArgument)(Array.isArray(fProofs), "invalid network format: proofs not an array", "fields[3]", fProofs);
        (0, index_js_3.assertArgument)(fBlobs.length === fCommits.length, "invalid network format: blobs/commitments length mismatch", "fields", fields);
        (0, index_js_3.assertArgument)(fBlobs.length === fProofs.length, "invalid network format: blobs/proofs length mismatch", "fields", fields);
        blobs = [];
        for (let i2 = 0; i2 < fields[1].length; i2++) {
          blobs.push({
            data: fBlobs[i2],
            commitment: fCommits[i2],
            proof: fProofs[i2]
          });
        }
        fields = fields[0];
      }
      (0, index_js_3.assertArgument)(Array.isArray(fields) && (fields.length === 11 || fields.length === 14), `invalid field count for transaction type: ${typeName}`, "data", (0, index_js_3.hexlify)(data));
      const tx = {
        type: 3,
        chainId: handleUint(fields[0], "chainId"),
        nonce: handleNumber(fields[1], "nonce"),
        maxPriorityFeePerGas: handleUint(fields[2], "maxPriorityFeePerGas"),
        maxFeePerGas: handleUint(fields[3], "maxFeePerGas"),
        gasPrice: null,
        gasLimit: handleUint(fields[4], "gasLimit"),
        to: handleAddress(fields[5]),
        value: handleUint(fields[6], "value"),
        data: (0, index_js_3.hexlify)(fields[7]),
        accessList: handleAccessList(fields[8], "accessList"),
        maxFeePerBlobGas: handleUint(fields[9], "maxFeePerBlobGas"),
        blobVersionedHashes: fields[10]
      };
      if (blobs) {
        tx.blobs = blobs;
      }
      (0, index_js_3.assertArgument)(tx.to != null, `invalid address for transaction type: ${typeName}`, "data", data);
      (0, index_js_3.assertArgument)(Array.isArray(tx.blobVersionedHashes), "invalid blobVersionedHashes: must be an array", "data", data);
      for (let i2 = 0; i2 < tx.blobVersionedHashes.length; i2++) {
        (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(tx.blobVersionedHashes[i2], 32), `invalid blobVersionedHash at index ${i2}: must be length 32`, "data", data);
      }
      if (fields.length === 11) {
        return tx;
      }
      _parseEipSignature(tx, fields.slice(11));
      return tx;
    }
    function _serializeEip4844(tx, sig, blobs) {
      const fields = [
        formatNumber(tx.chainId, "chainId"),
        formatNumber(tx.nonce, "nonce"),
        formatNumber(tx.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(tx.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(tx.gasLimit, "gasLimit"),
        tx.to || addresses_js_1.ZeroAddress,
        formatNumber(tx.value, "value"),
        tx.data,
        formatAccessList(tx.accessList || []),
        formatNumber(tx.maxFeePerBlobGas || 0, "maxFeePerBlobGas"),
        formatHashes(tx.blobVersionedHashes || [], "blobVersionedHashes")
      ];
      if (sig) {
        fields.push(formatNumber(sig.yParity, "yParity"));
        fields.push((0, index_js_3.toBeArray)(sig.r));
        fields.push((0, index_js_3.toBeArray)(sig.s));
        if (blobs) {
          return (0, index_js_3.concat)([
            "0x03",
            (0, index_js_3.encodeRlp)([
              fields,
              blobs.map((b4) => b4.data),
              blobs.map((b4) => b4.commitment),
              blobs.map((b4) => b4.proof)
            ])
          ]);
        }
      }
      return (0, index_js_3.concat)(["0x03", (0, index_js_3.encodeRlp)(fields)]);
    }
    var _type, _to, _data, _nonce, _gasLimit, _gasPrice, _maxPriorityFeePerGas, _maxFeePerGas, _value, _chainId, _sig, _accessList, _maxFeePerBlobGas, _blobVersionedHashes, _kzg, _blobs, _Transaction_instances, getSerialized_fn;
    var _Transaction = class _Transaction {
      /**
       *  Creates a new Transaction with default values.
       */
      constructor() {
        __privateAdd(this, _Transaction_instances);
        __privateAdd(this, _type);
        __privateAdd(this, _to);
        __privateAdd(this, _data);
        __privateAdd(this, _nonce);
        __privateAdd(this, _gasLimit);
        __privateAdd(this, _gasPrice);
        __privateAdd(this, _maxPriorityFeePerGas);
        __privateAdd(this, _maxFeePerGas);
        __privateAdd(this, _value);
        __privateAdd(this, _chainId);
        __privateAdd(this, _sig);
        __privateAdd(this, _accessList);
        __privateAdd(this, _maxFeePerBlobGas);
        __privateAdd(this, _blobVersionedHashes);
        __privateAdd(this, _kzg);
        __privateAdd(this, _blobs);
        __privateSet(this, _type, null);
        __privateSet(this, _to, null);
        __privateSet(this, _nonce, 0);
        __privateSet(this, _gasLimit, BN_0);
        __privateSet(this, _gasPrice, null);
        __privateSet(this, _maxPriorityFeePerGas, null);
        __privateSet(this, _maxFeePerGas, null);
        __privateSet(this, _data, "0x");
        __privateSet(this, _value, BN_0);
        __privateSet(this, _chainId, BN_0);
        __privateSet(this, _sig, null);
        __privateSet(this, _accessList, null);
        __privateSet(this, _maxFeePerBlobGas, null);
        __privateSet(this, _blobVersionedHashes, null);
        __privateSet(this, _blobs, null);
        __privateSet(this, _kzg, null);
      }
      /**
       *  The transaction type.
       *
       *  If null, the type will be automatically inferred based on
       *  explicit properties.
       */
      get type() {
        return __privateGet(this, _type);
      }
      set type(value) {
        switch (value) {
          case null:
            __privateSet(this, _type, null);
            break;
          case 0:
          case "legacy":
            __privateSet(this, _type, 0);
            break;
          case 1:
          case "berlin":
          case "eip-2930":
            __privateSet(this, _type, 1);
            break;
          case 2:
          case "london":
          case "eip-1559":
            __privateSet(this, _type, 2);
            break;
          case 3:
          case "cancun":
          case "eip-4844":
            __privateSet(this, _type, 3);
            break;
          default:
            (0, index_js_3.assertArgument)(false, "unsupported transaction type", "type", value);
        }
      }
      /**
       *  The name of the transaction type.
       */
      get typeName() {
        switch (this.type) {
          case 0:
            return "legacy";
          case 1:
            return "eip-2930";
          case 2:
            return "eip-1559";
          case 3:
            return "eip-4844";
        }
        return null;
      }
      /**
       *  The ``to`` address for the transaction or ``null`` if the
       *  transaction is an ``init`` transaction.
       */
      get to() {
        const value = __privateGet(this, _to);
        if (value == null && this.type === 3) {
          return addresses_js_1.ZeroAddress;
        }
        return value;
      }
      set to(value) {
        __privateSet(this, _to, value == null ? null : (0, index_js_1.getAddress)(value));
      }
      /**
       *  The transaction nonce.
       */
      get nonce() {
        return __privateGet(this, _nonce);
      }
      set nonce(value) {
        __privateSet(this, _nonce, (0, index_js_3.getNumber)(value, "value"));
      }
      /**
       *  The gas limit.
       */
      get gasLimit() {
        return __privateGet(this, _gasLimit);
      }
      set gasLimit(value) {
        __privateSet(this, _gasLimit, (0, index_js_3.getBigInt)(value));
      }
      /**
       *  The gas price.
       *
       *  On legacy networks this defines the fee that will be paid. On
       *  EIP-1559 networks, this should be ``null``.
       */
      get gasPrice() {
        const value = __privateGet(this, _gasPrice);
        if (value == null && (this.type === 0 || this.type === 1)) {
          return BN_0;
        }
        return value;
      }
      set gasPrice(value) {
        __privateSet(this, _gasPrice, value == null ? null : (0, index_js_3.getBigInt)(value, "gasPrice"));
      }
      /**
       *  The maximum priority fee per unit of gas to pay. On legacy
       *  networks this should be ``null``.
       */
      get maxPriorityFeePerGas() {
        const value = __privateGet(this, _maxPriorityFeePerGas);
        if (value == null) {
          if (this.type === 2 || this.type === 3) {
            return BN_0;
          }
          return null;
        }
        return value;
      }
      set maxPriorityFeePerGas(value) {
        __privateSet(this, _maxPriorityFeePerGas, value == null ? null : (0, index_js_3.getBigInt)(value, "maxPriorityFeePerGas"));
      }
      /**
       *  The maximum total fee per unit of gas to pay. On legacy
       *  networks this should be ``null``.
       */
      get maxFeePerGas() {
        const value = __privateGet(this, _maxFeePerGas);
        if (value == null) {
          if (this.type === 2 || this.type === 3) {
            return BN_0;
          }
          return null;
        }
        return value;
      }
      set maxFeePerGas(value) {
        __privateSet(this, _maxFeePerGas, value == null ? null : (0, index_js_3.getBigInt)(value, "maxFeePerGas"));
      }
      /**
       *  The transaction data. For ``init`` transactions this is the
       *  deployment code.
       */
      get data() {
        return __privateGet(this, _data);
      }
      set data(value) {
        __privateSet(this, _data, (0, index_js_3.hexlify)(value));
      }
      /**
       *  The amount of ether (in wei) to send in this transactions.
       */
      get value() {
        return __privateGet(this, _value);
      }
      set value(value) {
        __privateSet(this, _value, (0, index_js_3.getBigInt)(value, "value"));
      }
      /**
       *  The chain ID this transaction is valid on.
       */
      get chainId() {
        return __privateGet(this, _chainId);
      }
      set chainId(value) {
        __privateSet(this, _chainId, (0, index_js_3.getBigInt)(value));
      }
      /**
       *  If signed, the signature for this transaction.
       */
      get signature() {
        return __privateGet(this, _sig) || null;
      }
      set signature(value) {
        __privateSet(this, _sig, value == null ? null : index_js_2.Signature.from(value));
      }
      /**
       *  The access list.
       *
       *  An access list permits discounted (but pre-paid) access to
       *  bytecode and state variable access within contract execution.
       */
      get accessList() {
        const value = __privateGet(this, _accessList) || null;
        if (value == null) {
          if (this.type === 1 || this.type === 2 || this.type === 3) {
            return [];
          }
          return null;
        }
        return value;
      }
      set accessList(value) {
        __privateSet(this, _accessList, value == null ? null : (0, accesslist_js_1.accessListify)(value));
      }
      /**
       *  The max fee per blob gas for Cancun transactions.
       */
      get maxFeePerBlobGas() {
        const value = __privateGet(this, _maxFeePerBlobGas);
        if (value == null && this.type === 3) {
          return BN_0;
        }
        return value;
      }
      set maxFeePerBlobGas(value) {
        __privateSet(this, _maxFeePerBlobGas, value == null ? null : (0, index_js_3.getBigInt)(value, "maxFeePerBlobGas"));
      }
      /**
       *  The BLOb versioned hashes for Cancun transactions.
       */
      get blobVersionedHashes() {
        let value = __privateGet(this, _blobVersionedHashes);
        if (value == null && this.type === 3) {
          return [];
        }
        return value;
      }
      set blobVersionedHashes(value) {
        if (value != null) {
          (0, index_js_3.assertArgument)(Array.isArray(value), "blobVersionedHashes must be an Array", "value", value);
          value = value.slice();
          for (let i2 = 0; i2 < value.length; i2++) {
            (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(value[i2], 32), "invalid blobVersionedHash", `value[${i2}]`, value[i2]);
          }
        }
        __privateSet(this, _blobVersionedHashes, value);
      }
      /**
       *  The BLObs for the Transaction, if any.
       *
       *  If ``blobs`` is non-``null``, then the [[seriailized]]
       *  will return the network formatted sidecar, otherwise it
       *  will return the standard [[link-eip-2718]] payload. The
       *  [[unsignedSerialized]] is unaffected regardless.
       *
       *  When setting ``blobs``, either fully valid [[Blob]] objects
       *  may be specified (i.e. correctly padded, with correct
       *  committments and proofs) or a raw [[BytesLike]] may
       *  be provided.
       *
       *  If raw [[BytesLike]] are provided, the [[kzg]] property **must**
       *  be already set. The blob will be correctly padded and the
       *  [[KzgLibrary]] will be used to compute the committment and
       *  proof for the blob.
       *
       *  A BLOb is a sequence of field elements, each of which must
       *  be within the BLS field modulo, so some additional processing
       *  may be required to encode arbitrary data to ensure each 32 byte
       *  field is within the valid range.
       *
       *  Setting this automatically populates [[blobVersionedHashes]],
       *  overwriting any existing values. Setting this to ``null``
       *  does **not** remove the [[blobVersionedHashes]], leaving them
       *  present.
       */
      get blobs() {
        if (__privateGet(this, _blobs) == null) {
          return null;
        }
        return __privateGet(this, _blobs).map((b4) => Object.assign({}, b4));
      }
      set blobs(_blobs2) {
        if (_blobs2 == null) {
          __privateSet(this, _blobs, null);
          return;
        }
        const blobs = [];
        const versionedHashes = [];
        for (let i2 = 0; i2 < _blobs2.length; i2++) {
          const blob = _blobs2[i2];
          if ((0, index_js_3.isBytesLike)(blob)) {
            (0, index_js_3.assert)(__privateGet(this, _kzg), "adding a raw blob requires a KZG library", "UNSUPPORTED_OPERATION", {
              operation: "set blobs()"
            });
            let data = (0, index_js_3.getBytes)(blob);
            (0, index_js_3.assertArgument)(data.length <= BLOB_SIZE, "blob is too large", `blobs[${i2}]`, blob);
            if (data.length !== BLOB_SIZE) {
              const padded = new Uint8Array(BLOB_SIZE);
              padded.set(data);
              data = padded;
            }
            const commit = __privateGet(this, _kzg).blobToKzgCommitment(data);
            const proof = (0, index_js_3.hexlify)(__privateGet(this, _kzg).computeBlobKzgProof(data, commit));
            blobs.push({
              data: (0, index_js_3.hexlify)(data),
              commitment: (0, index_js_3.hexlify)(commit),
              proof
            });
            versionedHashes.push(getVersionedHash(1, commit));
          } else {
            const commit = (0, index_js_3.hexlify)(blob.commitment);
            blobs.push({
              data: (0, index_js_3.hexlify)(blob.data),
              commitment: commit,
              proof: (0, index_js_3.hexlify)(blob.proof)
            });
            versionedHashes.push(getVersionedHash(1, commit));
          }
        }
        __privateSet(this, _blobs, blobs);
        __privateSet(this, _blobVersionedHashes, versionedHashes);
      }
      get kzg() {
        return __privateGet(this, _kzg);
      }
      set kzg(kzg) {
        __privateSet(this, _kzg, kzg);
      }
      /**
       *  The transaction hash, if signed. Otherwise, ``null``.
       */
      get hash() {
        if (this.signature == null) {
          return null;
        }
        return (0, index_js_2.keccak256)(__privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, false));
      }
      /**
       *  The pre-image hash of this transaction.
       *
       *  This is the digest that a [[Signer]] must sign to authorize
       *  this transaction.
       */
      get unsignedHash() {
        return (0, index_js_2.keccak256)(this.unsignedSerialized);
      }
      /**
       *  The sending address, if signed. Otherwise, ``null``.
       */
      get from() {
        if (this.signature == null) {
          return null;
        }
        return (0, address_js_1.recoverAddress)(this.unsignedHash, this.signature);
      }
      /**
       *  The public key of the sender, if signed. Otherwise, ``null``.
       */
      get fromPublicKey() {
        if (this.signature == null) {
          return null;
        }
        return index_js_2.SigningKey.recoverPublicKey(this.unsignedHash, this.signature);
      }
      /**
       *  Returns true if signed.
       *
       *  This provides a Type Guard that properties requiring a signed
       *  transaction are non-null.
       */
      isSigned() {
        return this.signature != null;
      }
      /**
       *  The serialized transaction.
       *
       *  This throws if the transaction is unsigned. For the pre-image,
       *  use [[unsignedSerialized]].
       */
      get serialized() {
        return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, true, true);
      }
      /**
       *  The transaction pre-image.
       *
       *  The hash of this is the digest which needs to be signed to
       *  authorize this transaction.
       */
      get unsignedSerialized() {
        return __privateMethod(this, _Transaction_instances, getSerialized_fn).call(this, false, false);
      }
      /**
       *  Return the most "likely" type; currently the highest
       *  supported transaction type.
       */
      inferType() {
        const types3 = this.inferTypes();
        if (types3.indexOf(2) >= 0) {
          return 2;
        }
        return types3.pop();
      }
      /**
       *  Validates the explicit properties and returns a list of compatible
       *  transaction types.
       */
      inferTypes() {
        const hasGasPrice = this.gasPrice != null;
        const hasFee = this.maxFeePerGas != null || this.maxPriorityFeePerGas != null;
        const hasAccessList = this.accessList != null;
        const hasBlob = __privateGet(this, _maxFeePerBlobGas) != null || __privateGet(this, _blobVersionedHashes);
        if (this.maxFeePerGas != null && this.maxPriorityFeePerGas != null) {
          (0, index_js_3.assert)(this.maxFeePerGas >= this.maxPriorityFeePerGas, "priorityFee cannot be more than maxFee", "BAD_DATA", { value: this });
        }
        (0, index_js_3.assert)(!hasFee || this.type !== 0 && this.type !== 1, "transaction type cannot have maxFeePerGas or maxPriorityFeePerGas", "BAD_DATA", { value: this });
        (0, index_js_3.assert)(this.type !== 0 || !hasAccessList, "legacy transaction cannot have accessList", "BAD_DATA", { value: this });
        const types3 = [];
        if (this.type != null) {
          types3.push(this.type);
        } else {
          if (hasFee) {
            types3.push(2);
          } else if (hasGasPrice) {
            types3.push(1);
            if (!hasAccessList) {
              types3.push(0);
            }
          } else if (hasAccessList) {
            types3.push(1);
            types3.push(2);
          } else if (hasBlob && this.to) {
            types3.push(3);
          } else {
            types3.push(0);
            types3.push(1);
            types3.push(2);
            types3.push(3);
          }
        }
        types3.sort();
        return types3;
      }
      /**
       *  Returns true if this transaction is a legacy transaction (i.e.
       *  ``type === 0``).
       *
       *  This provides a Type Guard that the related properties are
       *  non-null.
       */
      isLegacy() {
        return this.type === 0;
      }
      /**
       *  Returns true if this transaction is berlin hardform transaction (i.e.
       *  ``type === 1``).
       *
       *  This provides a Type Guard that the related properties are
       *  non-null.
       */
      isBerlin() {
        return this.type === 1;
      }
      /**
       *  Returns true if this transaction is london hardform transaction (i.e.
       *  ``type === 2``).
       *
       *  This provides a Type Guard that the related properties are
       *  non-null.
       */
      isLondon() {
        return this.type === 2;
      }
      /**
       *  Returns true if this transaction is an [[link-eip-4844]] BLOB
       *  transaction.
       *
       *  This provides a Type Guard that the related properties are
       *  non-null.
       */
      isCancun() {
        return this.type === 3;
      }
      /**
       *  Create a copy of this transaciton.
       */
      clone() {
        return _Transaction.from(this);
      }
      /**
       *  Return a JSON-friendly object.
       */
      toJSON() {
        const s2 = (v2) => {
          if (v2 == null) {
            return null;
          }
          return v2.toString();
        };
        return {
          type: this.type,
          to: this.to,
          //            from: this.from,
          data: this.data,
          nonce: this.nonce,
          gasLimit: s2(this.gasLimit),
          gasPrice: s2(this.gasPrice),
          maxPriorityFeePerGas: s2(this.maxPriorityFeePerGas),
          maxFeePerGas: s2(this.maxFeePerGas),
          value: s2(this.value),
          chainId: s2(this.chainId),
          sig: this.signature ? this.signature.toJSON() : null,
          accessList: this.accessList
        };
      }
      /**
       *  Create a **Transaction** from a serialized transaction or a
       *  Transaction-like object.
       */
      static from(tx) {
        if (tx == null) {
          return new _Transaction();
        }
        if (typeof tx === "string") {
          const payload = (0, index_js_3.getBytes)(tx);
          if (payload[0] >= 127) {
            return _Transaction.from(_parseLegacy(payload));
          }
          switch (payload[0]) {
            case 1:
              return _Transaction.from(_parseEip2930(payload));
            case 2:
              return _Transaction.from(_parseEip1559(payload));
            case 3:
              return _Transaction.from(_parseEip4844(payload));
          }
          (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: "from" });
        }
        const result = new _Transaction();
        if (tx.type != null) {
          result.type = tx.type;
        }
        if (tx.to != null) {
          result.to = tx.to;
        }
        if (tx.nonce != null) {
          result.nonce = tx.nonce;
        }
        if (tx.gasLimit != null) {
          result.gasLimit = tx.gasLimit;
        }
        if (tx.gasPrice != null) {
          result.gasPrice = tx.gasPrice;
        }
        if (tx.maxPriorityFeePerGas != null) {
          result.maxPriorityFeePerGas = tx.maxPriorityFeePerGas;
        }
        if (tx.maxFeePerGas != null) {
          result.maxFeePerGas = tx.maxFeePerGas;
        }
        if (tx.maxFeePerBlobGas != null) {
          result.maxFeePerBlobGas = tx.maxFeePerBlobGas;
        }
        if (tx.data != null) {
          result.data = tx.data;
        }
        if (tx.value != null) {
          result.value = tx.value;
        }
        if (tx.chainId != null) {
          result.chainId = tx.chainId;
        }
        if (tx.signature != null) {
          result.signature = index_js_2.Signature.from(tx.signature);
        }
        if (tx.accessList != null) {
          result.accessList = tx.accessList;
        }
        if (tx.blobVersionedHashes != null) {
          result.blobVersionedHashes = tx.blobVersionedHashes;
        }
        if (tx.kzg != null) {
          result.kzg = tx.kzg;
        }
        if (tx.blobs != null) {
          result.blobs = tx.blobs;
        }
        if (tx.hash != null) {
          (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define '.hash'", "tx", tx);
          (0, index_js_3.assertArgument)(result.hash === tx.hash, "hash mismatch", "tx", tx);
        }
        if (tx.from != null) {
          (0, index_js_3.assertArgument)(result.isSigned(), "unsigned transaction cannot define '.from'", "tx", tx);
          (0, index_js_3.assertArgument)(result.from.toLowerCase() === (tx.from || "").toLowerCase(), "from mismatch", "tx", tx);
        }
        return result;
      }
    };
    _type = new WeakMap();
    _to = new WeakMap();
    _data = new WeakMap();
    _nonce = new WeakMap();
    _gasLimit = new WeakMap();
    _gasPrice = new WeakMap();
    _maxPriorityFeePerGas = new WeakMap();
    _maxFeePerGas = new WeakMap();
    _value = new WeakMap();
    _chainId = new WeakMap();
    _sig = new WeakMap();
    _accessList = new WeakMap();
    _maxFeePerBlobGas = new WeakMap();
    _blobVersionedHashes = new WeakMap();
    _kzg = new WeakMap();
    _blobs = new WeakMap();
    _Transaction_instances = new WeakSet();
    getSerialized_fn = function(signed2, sidecar) {
      (0, index_js_3.assert)(!signed2 || this.signature != null, "cannot serialize unsigned transaction; maybe you meant .unsignedSerialized", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
      const sig = signed2 ? this.signature : null;
      switch (this.inferType()) {
        case 0:
          return _serializeLegacy(this, sig);
        case 1:
          return _serializeEip2930(this, sig);
        case 2:
          return _serializeEip1559(this, sig);
        case 3:
          return _serializeEip4844(this, sig, sidecar ? this.blobs : null);
      }
      (0, index_js_3.assert)(false, "unsupported transaction type", "UNSUPPORTED_OPERATION", { operation: ".serialized" });
    };
    var Transaction = _Transaction;
    exports.Transaction = Transaction;
  }
});

// node_modules/ethers/lib.commonjs/transaction/index.js
var require_transaction2 = __commonJS({
  "node_modules/ethers/lib.commonjs/transaction/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = void 0;
    var accesslist_js_1 = require_accesslist();
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return accesslist_js_1.accessListify;
    } });
    var address_js_1 = require_address4();
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return address_js_1.computeAddress;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return address_js_1.recoverAddress;
    } });
    var transaction_js_1 = require_transaction();
    Object.defineProperty(exports, "Transaction", { enumerable: true, get: function() {
      return transaction_js_1.Transaction;
    } });
  }
});

// node_modules/ethers/lib.commonjs/hash/message.js
var require_message = __commonJS({
  "node_modules/ethers/lib.commonjs/hash/message.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyMessage = exports.hashMessage = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_constants();
    var index_js_3 = require_transaction2();
    var index_js_4 = require_utils5();
    function hashMessage(message) {
      if (typeof message === "string") {
        message = (0, index_js_4.toUtf8Bytes)(message);
      }
      return (0, index_js_1.keccak256)((0, index_js_4.concat)([
        (0, index_js_4.toUtf8Bytes)(index_js_2.MessagePrefix),
        (0, index_js_4.toUtf8Bytes)(String(message.length)),
        message
      ]));
    }
    exports.hashMessage = hashMessage;
    function verifyMessage3(message, sig) {
      const digest = hashMessage(message);
      return (0, index_js_3.recoverAddress)(digest, sig);
    }
    exports.verifyMessage = verifyMessage3;
  }
});

// node_modules/ethers/lib.commonjs/hash/solidity.js
var require_solidity = __commonJS({
  "node_modules/ethers/lib.commonjs/hash/solidity.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_crypto2();
    var index_js_3 = require_utils5();
    var regexBytes = new RegExp("^bytes([0-9]+)$");
    var regexNumber = new RegExp("^(u?int)([0-9]*)$");
    var regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
    function _pack(type6, value, isArray2) {
      switch (type6) {
        case "address":
          if (isArray2) {
            return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
          }
          return (0, index_js_3.getBytes)((0, index_js_1.getAddress)(value));
        case "string":
          return (0, index_js_3.toUtf8Bytes)(value);
        case "bytes":
          return (0, index_js_3.getBytes)(value);
        case "bool":
          value = !!value ? "0x01" : "0x00";
          if (isArray2) {
            return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)(value, 32));
          }
          return (0, index_js_3.getBytes)(value);
      }
      let match = type6.match(regexNumber);
      if (match) {
        let signed2 = match[1] === "int";
        let size5 = parseInt(match[2] || "256");
        (0, index_js_3.assertArgument)((!match[2] || match[2] === String(size5)) && size5 % 8 === 0 && size5 !== 0 && size5 <= 256, "invalid number type", "type", type6);
        if (isArray2) {
          size5 = 256;
        }
        if (signed2) {
          value = (0, index_js_3.toTwos)(value, size5);
        }
        return (0, index_js_3.getBytes)((0, index_js_3.zeroPadValue)((0, index_js_3.toBeArray)(value), size5 / 8));
      }
      match = type6.match(regexBytes);
      if (match) {
        const size5 = parseInt(match[1]);
        (0, index_js_3.assertArgument)(String(size5) === match[1] && size5 !== 0 && size5 <= 32, "invalid bytes type", "type", type6);
        (0, index_js_3.assertArgument)((0, index_js_3.dataLength)(value) === size5, `invalid value for ${type6}`, "value", value);
        if (isArray2) {
          return (0, index_js_3.getBytes)((0, index_js_3.zeroPadBytes)(value, 32));
        }
        return value;
      }
      match = type6.match(regexArray);
      if (match && Array.isArray(value)) {
        const baseType = match[1];
        const count = parseInt(match[2] || String(value.length));
        (0, index_js_3.assertArgument)(count === value.length, `invalid array length for ${type6}`, "value", value);
        const result = [];
        value.forEach(function(value2) {
          result.push(_pack(baseType, value2, true));
        });
        return (0, index_js_3.getBytes)((0, index_js_3.concat)(result));
      }
      (0, index_js_3.assertArgument)(false, "invalid type", "type", type6);
    }
    function solidityPacked(types3, values) {
      (0, index_js_3.assertArgument)(types3.length === values.length, "wrong number of values; expected ${ types.length }", "values", values);
      const tight = [];
      types3.forEach(function(type6, index5) {
        tight.push(_pack(type6, values[index5]));
      });
      return (0, index_js_3.hexlify)((0, index_js_3.concat)(tight));
    }
    exports.solidityPacked = solidityPacked;
    function solidityPackedKeccak256(types3, values) {
      return (0, index_js_2.keccak256)(solidityPacked(types3, values));
    }
    exports.solidityPackedKeccak256 = solidityPackedKeccak256;
    function solidityPackedSha256(types3, values) {
      return (0, index_js_2.sha256)(solidityPacked(types3, values));
    }
    exports.solidityPackedSha256 = solidityPackedSha256;
  }
});

// node_modules/ethers/lib.commonjs/hash/typed-data.js
var require_typed_data = __commonJS({
  "node_modules/ethers/lib.commonjs/hash/typed-data.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = exports.TypedDataEncoder = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_crypto2();
    var index_js_3 = require_transaction2();
    var index_js_4 = require_utils5();
    var id_js_1 = require_id();
    var padding2 = new Uint8Array(32);
    padding2.fill(0);
    var BN__1 = BigInt(-1);
    var BN_0 = BigInt(0);
    var BN_1 = BigInt(1);
    var BN_MAX_UINT256 = BigInt("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
    function hexPadRight(value) {
      const bytes = (0, index_js_4.getBytes)(value);
      const padOffset = bytes.length % 32;
      if (padOffset) {
        return (0, index_js_4.concat)([bytes, padding2.slice(padOffset)]);
      }
      return (0, index_js_4.hexlify)(bytes);
    }
    var hexTrue = (0, index_js_4.toBeHex)(BN_1, 32);
    var hexFalse = (0, index_js_4.toBeHex)(BN_0, 32);
    var domainFieldTypes = {
      name: "string",
      version: "string",
      chainId: "uint256",
      verifyingContract: "address",
      salt: "bytes32"
    };
    var domainFieldNames = [
      "name",
      "version",
      "chainId",
      "verifyingContract",
      "salt"
    ];
    function checkString(key) {
      return function(value) {
        (0, index_js_4.assertArgument)(typeof value === "string", `invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        return value;
      };
    }
    var domainChecks = {
      name: checkString("name"),
      version: checkString("version"),
      chainId: function(_value) {
        const value = (0, index_js_4.getBigInt)(_value, "domain.chainId");
        (0, index_js_4.assertArgument)(value >= 0, "invalid chain ID", "domain.chainId", _value);
        if (Number.isSafeInteger(value)) {
          return Number(value);
        }
        return (0, index_js_4.toQuantity)(value);
      },
      verifyingContract: function(value) {
        try {
          return (0, index_js_1.getAddress)(value).toLowerCase();
        } catch (error) {
        }
        (0, index_js_4.assertArgument)(false, `invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
      },
      salt: function(value) {
        const bytes = (0, index_js_4.getBytes)(value, "domain.salt");
        (0, index_js_4.assertArgument)(bytes.length === 32, `invalid domain value "salt"`, "domain.salt", value);
        return (0, index_js_4.hexlify)(bytes);
      }
    };
    function getBaseEncoder(type6) {
      {
        const match = type6.match(/^(u?)int(\d+)$/);
        if (match) {
          const signed2 = match[1] === "";
          const width = parseInt(match[2]);
          (0, index_js_4.assertArgument)(width % 8 === 0 && width !== 0 && width <= 256 && match[2] === String(width), "invalid numeric width", "type", type6);
          const boundsUpper = (0, index_js_4.mask)(BN_MAX_UINT256, signed2 ? width - 1 : width);
          const boundsLower = signed2 ? (boundsUpper + BN_1) * BN__1 : BN_0;
          return function(_value) {
            const value = (0, index_js_4.getBigInt)(_value, "value");
            (0, index_js_4.assertArgument)(value >= boundsLower && value <= boundsUpper, `value out-of-bounds for ${type6}`, "value", value);
            return (0, index_js_4.toBeHex)(signed2 ? (0, index_js_4.toTwos)(value, 256) : value, 32);
          };
        }
      }
      {
        const match = type6.match(/^bytes(\d+)$/);
        if (match) {
          const width = parseInt(match[1]);
          (0, index_js_4.assertArgument)(width !== 0 && width <= 32 && match[1] === String(width), "invalid bytes width", "type", type6);
          return function(value) {
            const bytes = (0, index_js_4.getBytes)(value);
            (0, index_js_4.assertArgument)(bytes.length === width, `invalid length for ${type6}`, "value", value);
            return hexPadRight(value);
          };
        }
      }
      switch (type6) {
        case "address":
          return function(value) {
            return (0, index_js_4.zeroPadValue)((0, index_js_1.getAddress)(value), 32);
          };
        case "bool":
          return function(value) {
            return !value ? hexFalse : hexTrue;
          };
        case "bytes":
          return function(value) {
            return (0, index_js_2.keccak256)(value);
          };
        case "string":
          return function(value) {
            return (0, id_js_1.id)(value);
          };
      }
      return null;
    }
    function encodeType2(name, fields) {
      return `${name}(${fields.map(({ name: name2, type: type6 }) => type6 + " " + name2).join(",")})`;
    }
    function splitArray(type6) {
      const match = type6.match(/^([^\x5b]*)((\x5b\d*\x5d)*)(\x5b(\d*)\x5d)$/);
      if (match) {
        return {
          base: match[1],
          index: match[2] + match[4],
          array: {
            base: match[1],
            prefix: match[1] + match[2],
            count: match[5] ? parseInt(match[5]) : -1
          }
        };
      }
      return { base: type6 };
    }
    var _types, _fullTypes, _encoderCache, _TypedDataEncoder_instances, getEncoder_fn;
    var _TypedDataEncoder = class _TypedDataEncoder {
      /**
       *  Create a new **TypedDataEncoder** for %%types%%.
       *
       *  This performs all necessary checking that types are valid and
       *  do not violate the [[link-eip-712]] structural constraints as
       *  well as computes the [[primaryType]].
       */
      constructor(_types2) {
        __privateAdd(this, _TypedDataEncoder_instances);
        /**
         *  The primary type for the structured [[types]].
         *
         *  This is derived automatically from the [[types]], since no
         *  recursion is possible, once the DAG for the types is consturcted
         *  internally, the primary type must be the only remaining type with
         *  no parent nodes.
         */
        __publicField(this, "primaryType");
        __privateAdd(this, _types);
        __privateAdd(this, _fullTypes);
        __privateAdd(this, _encoderCache);
        __privateSet(this, _fullTypes, /* @__PURE__ */ new Map());
        __privateSet(this, _encoderCache, /* @__PURE__ */ new Map());
        const links = /* @__PURE__ */ new Map();
        const parents = /* @__PURE__ */ new Map();
        const subtypes = /* @__PURE__ */ new Map();
        const types3 = {};
        Object.keys(_types2).forEach((type6) => {
          types3[type6] = _types2[type6].map(({ name, type: type7 }) => {
            let { base: base3, index: index5 } = splitArray(type7);
            if (base3 === "int" && !_types2["int"]) {
              base3 = "int256";
            }
            if (base3 === "uint" && !_types2["uint"]) {
              base3 = "uint256";
            }
            return { name, type: base3 + (index5 || "") };
          });
          links.set(type6, /* @__PURE__ */ new Set());
          parents.set(type6, []);
          subtypes.set(type6, /* @__PURE__ */ new Set());
        });
        __privateSet(this, _types, JSON.stringify(types3));
        for (const name in types3) {
          const uniqueNames = /* @__PURE__ */ new Set();
          for (const field of types3[name]) {
            (0, index_js_4.assertArgument)(!uniqueNames.has(field.name), `duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", _types2);
            uniqueNames.add(field.name);
            const baseType = splitArray(field.type).base;
            (0, index_js_4.assertArgument)(baseType !== name, `circular type reference to ${JSON.stringify(baseType)}`, "types", _types2);
            const encoder2 = getBaseEncoder(baseType);
            if (encoder2) {
              continue;
            }
            (0, index_js_4.assertArgument)(parents.has(baseType), `unknown type ${JSON.stringify(baseType)}`, "types", _types2);
            parents.get(baseType).push(name);
            links.get(name).add(baseType);
          }
        }
        const primaryTypes = Array.from(parents.keys()).filter((n2) => parents.get(n2).length === 0);
        (0, index_js_4.assertArgument)(primaryTypes.length !== 0, "missing primary type", "types", _types2);
        (0, index_js_4.assertArgument)(primaryTypes.length === 1, `ambiguous primary types or unused types: ${primaryTypes.map((t2) => JSON.stringify(t2)).join(", ")}`, "types", _types2);
        (0, index_js_4.defineProperties)(this, { primaryType: primaryTypes[0] });
        function checkCircular(type6, found) {
          (0, index_js_4.assertArgument)(!found.has(type6), `circular type reference to ${JSON.stringify(type6)}`, "types", _types2);
          found.add(type6);
          for (const child of links.get(type6)) {
            if (!parents.has(child)) {
              continue;
            }
            checkCircular(child, found);
            for (const subtype of found) {
              subtypes.get(subtype).add(child);
            }
          }
          found.delete(type6);
        }
        checkCircular(this.primaryType, /* @__PURE__ */ new Set());
        for (const [name, set] of subtypes) {
          const st2 = Array.from(set);
          st2.sort();
          __privateGet(this, _fullTypes).set(name, encodeType2(name, types3[name]) + st2.map((t2) => encodeType2(t2, types3[t2])).join(""));
        }
      }
      /**
       *  The types.
       */
      get types() {
        return JSON.parse(__privateGet(this, _types));
      }
      /**
       *  Returnthe encoder for the specific %%type%%.
       */
      getEncoder(type6) {
        let encoder2 = __privateGet(this, _encoderCache).get(type6);
        if (!encoder2) {
          encoder2 = __privateMethod(this, _TypedDataEncoder_instances, getEncoder_fn).call(this, type6);
          __privateGet(this, _encoderCache).set(type6, encoder2);
        }
        return encoder2;
      }
      /**
       *  Return the full type for %%name%%.
       */
      encodeType(name) {
        const result = __privateGet(this, _fullTypes).get(name);
        (0, index_js_4.assertArgument)(result, `unknown type: ${JSON.stringify(name)}`, "name", name);
        return result;
      }
      /**
       *  Return the encoded %%value%% for the %%type%%.
       */
      encodeData(type6, value) {
        return this.getEncoder(type6)(value);
      }
      /**
       *  Returns the hash of %%value%% for the type of %%name%%.
       */
      hashStruct(name, value) {
        return (0, index_js_2.keccak256)(this.encodeData(name, value));
      }
      /**
       *  Return the fulled encoded %%value%% for the [[types]].
       */
      encode(value) {
        return this.encodeData(this.primaryType, value);
      }
      /**
       *  Return the hash of the fully encoded %%value%% for the [[types]].
       */
      hash(value) {
        return this.hashStruct(this.primaryType, value);
      }
      /**
       *  @_ignore:
       */
      _visit(type6, value, callback) {
        {
          const encoder2 = getBaseEncoder(type6);
          if (encoder2) {
            return callback(type6, value);
          }
        }
        const array = splitArray(type6).array;
        if (array) {
          (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
          return value.map((v2) => this._visit(array.prefix, v2, callback));
        }
        const fields = this.types[type6];
        if (fields) {
          return fields.reduce((accum, { name, type: type7 }) => {
            accum[name] = this._visit(type7, value[name], callback);
            return accum;
          }, {});
        }
        (0, index_js_4.assertArgument)(false, `unknown type: ${type6}`, "type", type6);
      }
      /**
       *  Call %%calback%% for each value in %%value%%, passing the type and
       *  component within %%value%%.
       *
       *  This is useful for replacing addresses or other transformation that
       *  may be desired on each component, based on its type.
       */
      visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
      }
      /**
       *  Create a new **TypedDataEncoder** for %%types%%.
       */
      static from(types3) {
        return new _TypedDataEncoder(types3);
      }
      /**
       *  Return the primary type for %%types%%.
       */
      static getPrimaryType(types3) {
        return _TypedDataEncoder.from(types3).primaryType;
      }
      /**
       *  Return the hashed struct for %%value%% using %%types%% and %%name%%.
       */
      static hashStruct(name, types3, value) {
        return _TypedDataEncoder.from(types3).hashStruct(name, value);
      }
      /**
       *  Return the domain hash for %%domain%%.
       */
      static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
          if (domain[name] == null) {
            continue;
          }
          const type6 = domainFieldTypes[name];
          (0, index_js_4.assertArgument)(type6, `invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
          domainFields.push({ name, type: type6 });
        }
        domainFields.sort((a3, b4) => {
          return domainFieldNames.indexOf(a3.name) - domainFieldNames.indexOf(b4.name);
        });
        return _TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
      }
      /**
       *  Return the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
       */
      static encode(domain, types3, value) {
        return (0, index_js_4.concat)([
          "0x1901",
          _TypedDataEncoder.hashDomain(domain),
          _TypedDataEncoder.from(types3).hash(value)
        ]);
      }
      /**
       *  Return the hash of the fully encoded [[link-eip-712]] %%value%% for %%types%% with %%domain%%.
       */
      static hash(domain, types3, value) {
        return (0, index_js_2.keccak256)(_TypedDataEncoder.encode(domain, types3, value));
      }
      // Replaces all address types with ENS names with their looked up address
      /**
       * Resolves to the value from resolving all addresses in %%value%% for
       * %%types%% and the %%domain%%.
       */
      static async resolveNames(domain, types3, value, resolveName) {
        domain = Object.assign({}, domain);
        for (const key in domain) {
          if (domain[key] == null) {
            delete domain[key];
          }
        }
        const ensCache = {};
        if (domain.verifyingContract && !(0, index_js_4.isHexString)(domain.verifyingContract, 20)) {
          ensCache[domain.verifyingContract] = "0x";
        }
        const encoder2 = _TypedDataEncoder.from(types3);
        encoder2.visit(value, (type6, value2) => {
          if (type6 === "address" && !(0, index_js_4.isHexString)(value2, 20)) {
            ensCache[value2] = "0x";
          }
          return value2;
        });
        for (const name in ensCache) {
          ensCache[name] = await resolveName(name);
        }
        if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
          domain.verifyingContract = ensCache[domain.verifyingContract];
        }
        value = encoder2.visit(value, (type6, value2) => {
          if (type6 === "address" && ensCache[value2]) {
            return ensCache[value2];
          }
          return value2;
        });
        return { domain, value };
      }
      /**
       *  Returns the JSON-encoded payload expected by nodes which implement
       *  the JSON-RPC [[link-eip-712]] method.
       */
      static getPayload(domain, types3, value) {
        _TypedDataEncoder.hashDomain(domain);
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
          const value2 = domain[name];
          if (value2 == null) {
            return;
          }
          domainValues[name] = domainChecks[name](value2);
          domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder2 = _TypedDataEncoder.from(types3);
        types3 = encoder2.types;
        const typesWithDomain = Object.assign({}, types3);
        (0, index_js_4.assertArgument)(typesWithDomain.EIP712Domain == null, "types must not contain EIP712Domain type", "types.EIP712Domain", types3);
        typesWithDomain.EIP712Domain = domainTypes;
        encoder2.encode(value);
        return {
          types: typesWithDomain,
          domain: domainValues,
          primaryType: encoder2.primaryType,
          message: encoder2.visit(value, (type6, value2) => {
            if (type6.match(/^bytes(\d*)/)) {
              return (0, index_js_4.hexlify)((0, index_js_4.getBytes)(value2));
            }
            if (type6.match(/^u?int/)) {
              return (0, index_js_4.getBigInt)(value2).toString();
            }
            switch (type6) {
              case "address":
                return value2.toLowerCase();
              case "bool":
                return !!value2;
              case "string":
                (0, index_js_4.assertArgument)(typeof value2 === "string", "invalid string", "value", value2);
                return value2;
            }
            (0, index_js_4.assertArgument)(false, "unsupported type", "type", type6);
          })
        };
      }
    };
    _types = new WeakMap();
    _fullTypes = new WeakMap();
    _encoderCache = new WeakMap();
    _TypedDataEncoder_instances = new WeakSet();
    getEncoder_fn = function(type6) {
      {
        const encoder2 = getBaseEncoder(type6);
        if (encoder2) {
          return encoder2;
        }
      }
      const array = splitArray(type6).array;
      if (array) {
        const subtype = array.prefix;
        const subEncoder = this.getEncoder(subtype);
        return (value) => {
          (0, index_js_4.assertArgument)(array.count === -1 || array.count === value.length, `array length mismatch; expected length ${array.count}`, "value", value);
          let result = value.map(subEncoder);
          if (__privateGet(this, _fullTypes).has(subtype)) {
            result = result.map(index_js_2.keccak256);
          }
          return (0, index_js_2.keccak256)((0, index_js_4.concat)(result));
        };
      }
      const fields = this.types[type6];
      if (fields) {
        const encodedType = (0, id_js_1.id)(__privateGet(this, _fullTypes).get(type6));
        return (value) => {
          const values = fields.map(({ name, type: type7 }) => {
            const result = this.getEncoder(type7)(value[name]);
            if (__privateGet(this, _fullTypes).has(type7)) {
              return (0, index_js_2.keccak256)(result);
            }
            return result;
          });
          values.unshift(encodedType);
          return (0, index_js_4.concat)(values);
        };
      }
      (0, index_js_4.assertArgument)(false, `unknown type: ${type6}`, "type", type6);
    };
    var TypedDataEncoder = _TypedDataEncoder;
    exports.TypedDataEncoder = TypedDataEncoder;
    function verifyTypedData3(domain, types3, value, signature) {
      return (0, index_js_3.recoverAddress)(TypedDataEncoder.hash(domain, types3, value), signature);
    }
    exports.verifyTypedData = verifyTypedData3;
  }
});

// node_modules/ethers/lib.commonjs/hash/index.js
var require_hash = __commonJS({
  "node_modules/ethers/lib.commonjs/hash/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = void 0;
    var id_js_1 = require_id();
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return id_js_1.id;
    } });
    var namehash_js_1 = require_namehash();
    Object.defineProperty(exports, "ensNormalize", { enumerable: true, get: function() {
      return namehash_js_1.ensNormalize;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return namehash_js_1.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return namehash_js_1.namehash;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return namehash_js_1.dnsEncode;
    } });
    var message_js_1 = require_message();
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return message_js_1.hashMessage;
    } });
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return message_js_1.verifyMessage;
    } });
    var solidity_js_1 = require_solidity();
    Object.defineProperty(exports, "solidityPacked", { enumerable: true, get: function() {
      return solidity_js_1.solidityPacked;
    } });
    Object.defineProperty(exports, "solidityPackedKeccak256", { enumerable: true, get: function() {
      return solidity_js_1.solidityPackedKeccak256;
    } });
    Object.defineProperty(exports, "solidityPackedSha256", { enumerable: true, get: function() {
      return solidity_js_1.solidityPackedSha256;
    } });
    var typed_data_js_1 = require_typed_data();
    Object.defineProperty(exports, "TypedDataEncoder", { enumerable: true, get: function() {
      return typed_data_js_1.TypedDataEncoder;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return typed_data_js_1.verifyTypedData;
    } });
  }
});

// node_modules/ethers/lib.commonjs/abi/fragments.js
var require_fragments = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/fragments.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.StructFragment = exports.FunctionFragment = exports.FallbackFragment = exports.ConstructorFragment = exports.EventFragment = exports.ErrorFragment = exports.NamedFragment = exports.Fragment = exports.ParamType = void 0;
    var index_js_1 = require_utils5();
    var index_js_2 = require_hash();
    function setify(items) {
      const result = /* @__PURE__ */ new Set();
      items.forEach((k4) => result.add(k4));
      return Object.freeze(result);
    }
    var _kwVisibDeploy = "external public payable override";
    var KwVisibDeploy = setify(_kwVisibDeploy.split(" "));
    var _kwVisib = "constant external internal payable private public pure view override";
    var KwVisib = setify(_kwVisib.split(" "));
    var _kwTypes = "constructor error event fallback function receive struct";
    var KwTypes = setify(_kwTypes.split(" "));
    var _kwModifiers = "calldata memory storage payable indexed";
    var KwModifiers = setify(_kwModifiers.split(" "));
    var _kwOther = "tuple returns";
    var _keywords = [_kwTypes, _kwModifiers, _kwOther, _kwVisib].join(" ");
    var Keywords = setify(_keywords.split(" "));
    var SimpleTokens = {
      "(": "OPEN_PAREN",
      ")": "CLOSE_PAREN",
      "[": "OPEN_BRACKET",
      "]": "CLOSE_BRACKET",
      ",": "COMMA",
      "@": "AT"
    };
    var regexWhitespacePrefix = new RegExp("^(\\s*)");
    var regexNumberPrefix = new RegExp("^([0-9]+)");
    var regexIdPrefix = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)");
    var regexId = new RegExp("^([a-zA-Z$_][a-zA-Z0-9$_]*)$");
    var regexType = new RegExp("^(address|bool|bytes([0-9]*)|string|u?int([0-9]*))$");
    var _offset, _tokens, _TokenString_instances, subTokenString_fn;
    var _TokenString = class _TokenString {
      constructor(tokens) {
        __privateAdd(this, _TokenString_instances);
        __privateAdd(this, _offset);
        __privateAdd(this, _tokens);
        __privateSet(this, _offset, 0);
        __privateSet(this, _tokens, tokens.slice());
      }
      get offset() {
        return __privateGet(this, _offset);
      }
      get length() {
        return __privateGet(this, _tokens).length - __privateGet(this, _offset);
      }
      clone() {
        return new _TokenString(__privateGet(this, _tokens));
      }
      reset() {
        __privateSet(this, _offset, 0);
      }
      // Pops and returns the value of the next token, if it is a keyword in allowed; throws if out of tokens
      popKeyword(allowed) {
        const top = this.peek();
        if (top.type !== "KEYWORD" || !allowed.has(top.text)) {
          throw new Error(`expected keyword ${top.text}`);
        }
        return this.pop().text;
      }
      // Pops and returns the value of the next token if it is `type`; throws if out of tokens
      popType(type6) {
        if (this.peek().type !== type6) {
          const top = this.peek();
          throw new Error(`expected ${type6}; got ${top.type} ${JSON.stringify(top.text)}`);
        }
        return this.pop().text;
      }
      // Pops and returns a "(" TOKENS ")"
      popParen() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
          throw new Error("bad start");
        }
        const result = __privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset) + 1, top.match + 1);
        __privateSet(this, _offset, top.match + 1);
        return result;
      }
      // Pops and returns the items within "(" ITEM1 "," ITEM2 "," ... ")"
      popParams() {
        const top = this.peek();
        if (top.type !== "OPEN_PAREN") {
          throw new Error("bad start");
        }
        const result = [];
        while (__privateGet(this, _offset) < top.match - 1) {
          const link = this.peek().linkNext;
          result.push(__privateMethod(this, _TokenString_instances, subTokenString_fn).call(this, __privateGet(this, _offset) + 1, link));
          __privateSet(this, _offset, link);
        }
        __privateSet(this, _offset, top.match + 1);
        return result;
      }
      // Returns the top Token, throwing if out of tokens
      peek() {
        if (__privateGet(this, _offset) >= __privateGet(this, _tokens).length) {
          throw new Error("out-of-bounds");
        }
        return __privateGet(this, _tokens)[__privateGet(this, _offset)];
      }
      // Returns the next value, if it is a keyword in `allowed`
      peekKeyword(allowed) {
        const top = this.peekType("KEYWORD");
        return top != null && allowed.has(top) ? top : null;
      }
      // Returns the value of the next token if it is `type`
      peekType(type6) {
        if (this.length === 0) {
          return null;
        }
        const top = this.peek();
        return top.type === type6 ? top.text : null;
      }
      // Returns the next token; throws if out of tokens
      pop() {
        const result = this.peek();
        __privateWrapper(this, _offset)._++;
        return result;
      }
      toString() {
        const tokens = [];
        for (let i2 = __privateGet(this, _offset); i2 < __privateGet(this, _tokens).length; i2++) {
          const token = __privateGet(this, _tokens)[i2];
          tokens.push(`${token.type}:${token.text}`);
        }
        return `<TokenString ${tokens.join(" ")}>`;
      }
    };
    _offset = new WeakMap();
    _tokens = new WeakMap();
    _TokenString_instances = new WeakSet();
    subTokenString_fn = function(from26 = 0, to4 = 0) {
      return new _TokenString(__privateGet(this, _tokens).slice(from26, to4).map((t2) => {
        return Object.freeze(Object.assign({}, t2, {
          match: t2.match - from26,
          linkBack: t2.linkBack - from26,
          linkNext: t2.linkNext - from26
        }));
      }));
    };
    var TokenString = _TokenString;
    function lex(text) {
      const tokens = [];
      const throwError = (message) => {
        const token = offset < text.length ? JSON.stringify(text[offset]) : "$EOI";
        throw new Error(`invalid token ${token} at ${offset}: ${message}`);
      };
      let brackets = [];
      let commas = [];
      let offset = 0;
      while (offset < text.length) {
        let cur = text.substring(offset);
        let match = cur.match(regexWhitespacePrefix);
        if (match) {
          offset += match[1].length;
          cur = text.substring(offset);
        }
        const token = { depth: brackets.length, linkBack: -1, linkNext: -1, match: -1, type: "", text: "", offset, value: -1 };
        tokens.push(token);
        let type6 = SimpleTokens[cur[0]] || "";
        if (type6) {
          token.type = type6;
          token.text = cur[0];
          offset++;
          if (type6 === "OPEN_PAREN") {
            brackets.push(tokens.length - 1);
            commas.push(tokens.length - 1);
          } else if (type6 == "CLOSE_PAREN") {
            if (brackets.length === 0) {
              throwError("no matching open bracket");
            }
            token.match = brackets.pop();
            tokens[token.match].match = tokens.length - 1;
            token.depth--;
            token.linkBack = commas.pop();
            tokens[token.linkBack].linkNext = tokens.length - 1;
          } else if (type6 === "COMMA") {
            token.linkBack = commas.pop();
            tokens[token.linkBack].linkNext = tokens.length - 1;
            commas.push(tokens.length - 1);
          } else if (type6 === "OPEN_BRACKET") {
            token.type = "BRACKET";
          } else if (type6 === "CLOSE_BRACKET") {
            let suffix = tokens.pop().text;
            if (tokens.length > 0 && tokens[tokens.length - 1].type === "NUMBER") {
              const value = tokens.pop().text;
              suffix = value + suffix;
              tokens[tokens.length - 1].value = (0, index_js_1.getNumber)(value);
            }
            if (tokens.length === 0 || tokens[tokens.length - 1].type !== "BRACKET") {
              throw new Error("missing opening bracket");
            }
            tokens[tokens.length - 1].text += suffix;
          }
          continue;
        }
        match = cur.match(regexIdPrefix);
        if (match) {
          token.text = match[1];
          offset += token.text.length;
          if (Keywords.has(token.text)) {
            token.type = "KEYWORD";
            continue;
          }
          if (token.text.match(regexType)) {
            token.type = "TYPE";
            continue;
          }
          token.type = "ID";
          continue;
        }
        match = cur.match(regexNumberPrefix);
        if (match) {
          token.text = match[1];
          token.type = "NUMBER";
          offset += token.text.length;
          continue;
        }
        throw new Error(`unexpected token ${JSON.stringify(cur[0])} at position ${offset}`);
      }
      return new TokenString(tokens.map((t2) => Object.freeze(t2)));
    }
    function allowSingle(set, allowed) {
      let included = [];
      for (const key in allowed.keys()) {
        if (set.has(key)) {
          included.push(key);
        }
      }
      if (included.length > 1) {
        throw new Error(`conflicting types: ${included.join(", ")}`);
      }
    }
    function consumeName(type6, tokens) {
      if (tokens.peekKeyword(KwTypes)) {
        const keyword = tokens.pop().text;
        if (keyword !== type6) {
          throw new Error(`expected ${type6}, got ${keyword}`);
        }
      }
      return tokens.popType("ID");
    }
    function consumeKeywords(tokens, allowed) {
      const keywords = /* @__PURE__ */ new Set();
      while (true) {
        const keyword = tokens.peekType("KEYWORD");
        if (keyword == null || allowed && !allowed.has(keyword)) {
          break;
        }
        tokens.pop();
        if (keywords.has(keyword)) {
          throw new Error(`duplicate keywords: ${JSON.stringify(keyword)}`);
        }
        keywords.add(keyword);
      }
      return Object.freeze(keywords);
    }
    function consumeMutability(tokens) {
      let modifiers = consumeKeywords(tokens, KwVisib);
      allowSingle(modifiers, setify("constant payable nonpayable".split(" ")));
      allowSingle(modifiers, setify("pure view payable nonpayable".split(" ")));
      if (modifiers.has("view")) {
        return "view";
      }
      if (modifiers.has("pure")) {
        return "pure";
      }
      if (modifiers.has("payable")) {
        return "payable";
      }
      if (modifiers.has("nonpayable")) {
        return "nonpayable";
      }
      if (modifiers.has("constant")) {
        return "view";
      }
      return "nonpayable";
    }
    function consumeParams(tokens, allowIndexed) {
      return tokens.popParams().map((t2) => ParamType.from(t2, allowIndexed));
    }
    function consumeGas(tokens) {
      if (tokens.peekType("AT")) {
        tokens.pop();
        if (tokens.peekType("NUMBER")) {
          return (0, index_js_1.getBigInt)(tokens.pop().text);
        }
        throw new Error("invalid gas");
      }
      return null;
    }
    function consumeEoi(tokens) {
      if (tokens.length) {
        throw new Error(`unexpected tokens at offset ${tokens.offset}: ${tokens.toString()}`);
      }
    }
    var regexArrayType = new RegExp(/^(.*)\[([0-9]*)\]$/);
    function verifyBasicType(type6) {
      const match = type6.match(regexType);
      (0, index_js_1.assertArgument)(match, "invalid type", "type", type6);
      if (type6 === "uint") {
        return "uint256";
      }
      if (type6 === "int") {
        return "int256";
      }
      if (match[2]) {
        const length2 = parseInt(match[2]);
        (0, index_js_1.assertArgument)(length2 !== 0 && length2 <= 32, "invalid bytes length", "type", type6);
      } else if (match[3]) {
        const size5 = parseInt(match[3]);
        (0, index_js_1.assertArgument)(size5 !== 0 && size5 <= 256 && size5 % 8 === 0, "invalid numeric width", "type", type6);
      }
      return type6;
    }
    var _guard = {};
    var internal = Symbol.for("_ethers_internal");
    var ParamTypeInternal = "_ParamTypeInternal";
    var ErrorFragmentInternal = "_ErrorInternal";
    var EventFragmentInternal = "_EventInternal";
    var ConstructorFragmentInternal = "_ConstructorInternal";
    var FallbackFragmentInternal = "_FallbackInternal";
    var FunctionFragmentInternal = "_FunctionInternal";
    var StructFragmentInternal = "_StructInternal";
    var _ParamType_instances, walkAsync_fn;
    var _ParamType = class _ParamType {
      /**
       *  @private
       */
      constructor(guard, name, type6, baseType, indexed, components, arrayLength, arrayChildren) {
        __privateAdd(this, _ParamType_instances);
        /**
         *  The local name of the parameter (or ``""`` if unbound)
         */
        __publicField(this, "name");
        /**
         *  The fully qualified type (e.g. ``"address"``, ``"tuple(address)"``,
         *  ``"uint256[3][]"``)
         */
        __publicField(this, "type");
        /**
         *  The base type (e.g. ``"address"``, ``"tuple"``, ``"array"``)
         */
        __publicField(this, "baseType");
        /**
         *  True if the parameters is indexed.
         *
         *  For non-indexable types this is ``null``.
         */
        __publicField(this, "indexed");
        /**
         *  The components for the tuple.
         *
         *  For non-tuple types this is ``null``.
         */
        __publicField(this, "components");
        /**
         *  The array length, or ``-1`` for dynamic-lengthed arrays.
         *
         *  For non-array types this is ``null``.
         */
        __publicField(this, "arrayLength");
        /**
         *  The type of each child in the array.
         *
         *  For non-array types this is ``null``.
         */
        __publicField(this, "arrayChildren");
        (0, index_js_1.assertPrivate)(guard, _guard, "ParamType");
        Object.defineProperty(this, internal, { value: ParamTypeInternal });
        if (components) {
          components = Object.freeze(components.slice());
        }
        if (baseType === "array") {
          if (arrayLength == null || arrayChildren == null) {
            throw new Error("");
          }
        } else if (arrayLength != null || arrayChildren != null) {
          throw new Error("");
        }
        if (baseType === "tuple") {
          if (components == null) {
            throw new Error("");
          }
        } else if (components != null) {
          throw new Error("");
        }
        (0, index_js_1.defineProperties)(this, {
          name,
          type: type6,
          baseType,
          indexed,
          components,
          arrayLength,
          arrayChildren
        });
      }
      /**
       *  Return a string representation of this type.
       *
       *  For example,
       *
       *  ``sighash" => "(uint256,address)"``
       *
       *  ``"minimal" => "tuple(uint256,address) indexed"``
       *
       *  ``"full" => "tuple(uint256 foo, address bar) indexed baz"``
       */
      format(format6) {
        if (format6 == null) {
          format6 = "sighash";
        }
        if (format6 === "json") {
          const name = this.name || "";
          if (this.isArray()) {
            const result3 = JSON.parse(this.arrayChildren.format("json"));
            result3.name = name;
            result3.type += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
            return JSON.stringify(result3);
          }
          const result2 = {
            type: this.baseType === "tuple" ? "tuple" : this.type,
            name
          };
          if (typeof this.indexed === "boolean") {
            result2.indexed = this.indexed;
          }
          if (this.isTuple()) {
            result2.components = this.components.map((c3) => JSON.parse(c3.format(format6)));
          }
          return JSON.stringify(result2);
        }
        let result = "";
        if (this.isArray()) {
          result += this.arrayChildren.format(format6);
          result += `[${this.arrayLength < 0 ? "" : String(this.arrayLength)}]`;
        } else {
          if (this.isTuple()) {
            result += "(" + this.components.map((comp) => comp.format(format6)).join(format6 === "full" ? ", " : ",") + ")";
          } else {
            result += this.type;
          }
        }
        if (format6 !== "sighash") {
          if (this.indexed === true) {
            result += " indexed";
          }
          if (format6 === "full" && this.name) {
            result += " " + this.name;
          }
        }
        return result;
      }
      /**
       *  Returns true if %%this%% is an Array type.
       *
       *  This provides a type gaurd ensuring that [[arrayChildren]]
       *  and [[arrayLength]] are non-null.
       */
      isArray() {
        return this.baseType === "array";
      }
      /**
       *  Returns true if %%this%% is a Tuple type.
       *
       *  This provides a type gaurd ensuring that [[components]]
       *  is non-null.
       */
      isTuple() {
        return this.baseType === "tuple";
      }
      /**
       *  Returns true if %%this%% is an Indexable type.
       *
       *  This provides a type gaurd ensuring that [[indexed]]
       *  is non-null.
       */
      isIndexable() {
        return this.indexed != null;
      }
      /**
       *  Walks the **ParamType** with %%value%%, calling %%process%%
       *  on each type, destructing the %%value%% recursively.
       */
      walk(value, process2) {
        if (this.isArray()) {
          if (!Array.isArray(value)) {
            throw new Error("invalid array value");
          }
          if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
            throw new Error("array is wrong length");
          }
          const _this = this;
          return value.map((v2) => _this.arrayChildren.walk(v2, process2));
        }
        if (this.isTuple()) {
          if (!Array.isArray(value)) {
            throw new Error("invalid tuple value");
          }
          if (value.length !== this.components.length) {
            throw new Error("array is wrong length");
          }
          const _this = this;
          return value.map((v2, i2) => _this.components[i2].walk(v2, process2));
        }
        return process2(this.type, value);
      }
      /**
       *  Walks the **ParamType** with %%value%%, asynchronously calling
       *  %%process%% on each type, destructing the %%value%% recursively.
       *
       *  This can be used to resolve ENS names by walking and resolving each
       *  ``"address"`` type.
       */
      async walkAsync(value, process2) {
        const promises = [];
        const result = [value];
        __privateMethod(this, _ParamType_instances, walkAsync_fn).call(this, promises, value, process2, (value2) => {
          result[0] = value2;
        });
        if (promises.length) {
          await Promise.all(promises);
        }
        return result[0];
      }
      /**
       *  Creates a new **ParamType** for %%obj%%.
       *
       *  If %%allowIndexed%% then the ``indexed`` keyword is permitted,
       *  otherwise the ``indexed`` keyword will throw an error.
       */
      static from(obj, allowIndexed) {
        if (_ParamType.isParamType(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return _ParamType.from(lex(obj), allowIndexed);
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid param type", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          let type7 = "", baseType = "";
          let comps = null;
          if (consumeKeywords(obj, setify(["tuple"])).has("tuple") || obj.peekType("OPEN_PAREN")) {
            baseType = "tuple";
            comps = obj.popParams().map((t2) => _ParamType.from(t2));
            type7 = `tuple(${comps.map((c3) => c3.format()).join(",")})`;
          } else {
            type7 = verifyBasicType(obj.popType("TYPE"));
            baseType = type7;
          }
          let arrayChildren = null;
          let arrayLength = null;
          while (obj.length && obj.peekType("BRACKET")) {
            const bracket = obj.pop();
            arrayChildren = new _ParamType(_guard, "", type7, baseType, null, comps, arrayLength, arrayChildren);
            arrayLength = bracket.value;
            type7 += bracket.text;
            baseType = "array";
            comps = null;
          }
          let indexed2 = null;
          const keywords = consumeKeywords(obj, KwModifiers);
          if (keywords.has("indexed")) {
            if (!allowIndexed) {
              throw new Error("");
            }
            indexed2 = true;
          }
          const name2 = obj.peekType("ID") ? obj.pop().text : "";
          if (obj.length) {
            throw new Error("leftover tokens");
          }
          return new _ParamType(_guard, name2, type7, baseType, indexed2, comps, arrayLength, arrayChildren);
        }
        const name = obj.name;
        (0, index_js_1.assertArgument)(!name || typeof name === "string" && name.match(regexId), "invalid name", "obj.name", name);
        let indexed = obj.indexed;
        if (indexed != null) {
          (0, index_js_1.assertArgument)(allowIndexed, "parameter cannot be indexed", "obj.indexed", obj.indexed);
          indexed = !!indexed;
        }
        let type6 = obj.type;
        let arrayMatch = type6.match(regexArrayType);
        if (arrayMatch) {
          const arrayLength = parseInt(arrayMatch[2] || "-1");
          const arrayChildren = _ParamType.from({
            type: arrayMatch[1],
            components: obj.components
          });
          return new _ParamType(_guard, name || "", type6, "array", indexed, null, arrayLength, arrayChildren);
        }
        if (type6 === "tuple" || type6.startsWith(
          "tuple("
          /* fix: ) */
        ) || type6.startsWith(
          "("
          /* fix: ) */
        )) {
          const comps = obj.components != null ? obj.components.map((c3) => _ParamType.from(c3)) : null;
          const tuple = new _ParamType(_guard, name || "", type6, "tuple", indexed, comps, null, null);
          return tuple;
        }
        type6 = verifyBasicType(obj.type);
        return new _ParamType(_guard, name || "", type6, type6, indexed, null, null, null);
      }
      /**
       *  Returns true if %%value%% is a **ParamType**.
       */
      static isParamType(value) {
        return value && value[internal] === ParamTypeInternal;
      }
    };
    _ParamType_instances = new WeakSet();
    walkAsync_fn = function(promises, value, process2, setValue) {
      if (this.isArray()) {
        if (!Array.isArray(value)) {
          throw new Error("invalid array value");
        }
        if (this.arrayLength !== -1 && value.length !== this.arrayLength) {
          throw new Error("array is wrong length");
        }
        const childType = this.arrayChildren;
        const result2 = value.slice();
        result2.forEach((value2, index5) => {
          var _a2;
          __privateMethod(_a2 = childType, _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
            result2[index5] = value3;
          });
        });
        setValue(result2);
        return;
      }
      if (this.isTuple()) {
        const components = this.components;
        let result2;
        if (Array.isArray(value)) {
          result2 = value.slice();
        } else {
          if (value == null || typeof value !== "object") {
            throw new Error("invalid tuple value");
          }
          result2 = components.map((param) => {
            if (!param.name) {
              throw new Error("cannot use object value with unnamed components");
            }
            if (!(param.name in value)) {
              throw new Error(`missing value for component ${param.name}`);
            }
            return value[param.name];
          });
        }
        if (result2.length !== this.components.length) {
          throw new Error("array is wrong length");
        }
        result2.forEach((value2, index5) => {
          var _a2;
          __privateMethod(_a2 = components[index5], _ParamType_instances, walkAsync_fn).call(_a2, promises, value2, process2, (value3) => {
            result2[index5] = value3;
          });
        });
        setValue(result2);
        return;
      }
      const result = process2(this.type, value);
      if (result.then) {
        promises.push(async function() {
          setValue(await result);
        }());
      } else {
        setValue(result);
      }
    };
    var ParamType = _ParamType;
    exports.ParamType = ParamType;
    var Fragment4 = class _Fragment {
      /**
       *  @private
       */
      constructor(guard, type6, inputs) {
        /**
         *  The type of the fragment.
         */
        __publicField(this, "type");
        /**
         *  The inputs for the fragment.
         */
        __publicField(this, "inputs");
        (0, index_js_1.assertPrivate)(guard, _guard, "Fragment");
        inputs = Object.freeze(inputs.slice());
        (0, index_js_1.defineProperties)(this, { type: type6, inputs });
      }
      /**
       *  Creates a new **Fragment** for %%obj%%, wich can be any supported
       *  ABI frgament type.
       */
      static from(obj) {
        if (typeof obj === "string") {
          try {
            _Fragment.from(JSON.parse(obj));
          } catch (e2) {
          }
          return _Fragment.from(lex(obj));
        }
        if (obj instanceof TokenString) {
          const type6 = obj.peekKeyword(KwTypes);
          switch (type6) {
            case "constructor":
              return ConstructorFragment.from(obj);
            case "error":
              return ErrorFragment.from(obj);
            case "event":
              return EventFragment.from(obj);
            case "fallback":
            case "receive":
              return FallbackFragment.from(obj);
            case "function":
              return FunctionFragment.from(obj);
            case "struct":
              return StructFragment.from(obj);
          }
        } else if (typeof obj === "object") {
          switch (obj.type) {
            case "constructor":
              return ConstructorFragment.from(obj);
            case "error":
              return ErrorFragment.from(obj);
            case "event":
              return EventFragment.from(obj);
            case "fallback":
            case "receive":
              return FallbackFragment.from(obj);
            case "function":
              return FunctionFragment.from(obj);
            case "struct":
              return StructFragment.from(obj);
          }
          (0, index_js_1.assert)(false, `unsupported type: ${obj.type}`, "UNSUPPORTED_OPERATION", {
            operation: "Fragment.from"
          });
        }
        (0, index_js_1.assertArgument)(false, "unsupported frgament object", "obj", obj);
      }
      /**
       *  Returns true if %%value%% is a [[ConstructorFragment]].
       */
      static isConstructor(value) {
        return ConstructorFragment.isFragment(value);
      }
      /**
       *  Returns true if %%value%% is an [[ErrorFragment]].
       */
      static isError(value) {
        return ErrorFragment.isFragment(value);
      }
      /**
       *  Returns true if %%value%% is an [[EventFragment]].
       */
      static isEvent(value) {
        return EventFragment.isFragment(value);
      }
      /**
       *  Returns true if %%value%% is a [[FunctionFragment]].
       */
      static isFunction(value) {
        return FunctionFragment.isFragment(value);
      }
      /**
       *  Returns true if %%value%% is a [[StructFragment]].
       */
      static isStruct(value) {
        return StructFragment.isFragment(value);
      }
    };
    exports.Fragment = Fragment4;
    var NamedFragment = class extends Fragment4 {
      /**
       *  @private
       */
      constructor(guard, type6, name, inputs) {
        super(guard, type6, inputs);
        /**
         *  The name of the fragment.
         */
        __publicField(this, "name");
        (0, index_js_1.assertArgument)(typeof name === "string" && name.match(regexId), "invalid identifier", "name", name);
        inputs = Object.freeze(inputs.slice());
        (0, index_js_1.defineProperties)(this, { name });
      }
    };
    exports.NamedFragment = NamedFragment;
    function joinParams(format6, params) {
      return "(" + params.map((p2) => p2.format(format6)).join(format6 === "full" ? ", " : ",") + ")";
    }
    var ErrorFragment = class _ErrorFragment extends NamedFragment {
      /**
       *  @private
       */
      constructor(guard, name, inputs) {
        super(guard, "error", name, inputs);
        Object.defineProperty(this, internal, { value: ErrorFragmentInternal });
      }
      /**
       *  The Custom Error selector.
       */
      get selector() {
        return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
      }
      /**
       *  Returns a string representation of this fragment as %%format%%.
       */
      format(format6) {
        if (format6 == null) {
          format6 = "sighash";
        }
        if (format6 === "json") {
          return JSON.stringify({
            type: "error",
            name: this.name,
            inputs: this.inputs.map((input) => JSON.parse(input.format(format6)))
          });
        }
        const result = [];
        if (format6 !== "sighash") {
          result.push("error");
        }
        result.push(this.name + joinParams(format6, this.inputs));
        return result.join(" ");
      }
      /**
       *  Returns a new **ErrorFragment** for %%obj%%.
       */
      static from(obj) {
        if (_ErrorFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          return _ErrorFragment.from(lex(obj));
        } else if (obj instanceof TokenString) {
          const name = consumeName("error", obj);
          const inputs = consumeParams(obj);
          consumeEoi(obj);
          return new _ErrorFragment(_guard, name, inputs);
        }
        return new _ErrorFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is an
       *  **ErrorFragment**.
       */
      static isFragment(value) {
        return value && value[internal] === ErrorFragmentInternal;
      }
    };
    exports.ErrorFragment = ErrorFragment;
    var EventFragment = class _EventFragment extends NamedFragment {
      /**
       *  @private
       */
      constructor(guard, name, inputs, anonymous) {
        super(guard, "event", name, inputs);
        /**
         *  Whether this event is anonymous.
         */
        __publicField(this, "anonymous");
        Object.defineProperty(this, internal, { value: EventFragmentInternal });
        (0, index_js_1.defineProperties)(this, { anonymous });
      }
      /**
       *  The Event topic hash.
       */
      get topicHash() {
        return (0, index_js_2.id)(this.format("sighash"));
      }
      /**
       *  Returns a string representation of this event as %%format%%.
       */
      format(format6) {
        if (format6 == null) {
          format6 = "sighash";
        }
        if (format6 === "json") {
          return JSON.stringify({
            type: "event",
            anonymous: this.anonymous,
            name: this.name,
            inputs: this.inputs.map((i2) => JSON.parse(i2.format(format6)))
          });
        }
        const result = [];
        if (format6 !== "sighash") {
          result.push("event");
        }
        result.push(this.name + joinParams(format6, this.inputs));
        if (format6 !== "sighash" && this.anonymous) {
          result.push("anonymous");
        }
        return result.join(" ");
      }
      /**
       *  Return the topic hash for an event with %%name%% and %%params%%.
       */
      static getTopicHash(name, params) {
        params = (params || []).map((p2) => ParamType.from(p2));
        const fragment = new _EventFragment(_guard, name, params, false);
        return fragment.topicHash;
      }
      /**
       *  Returns a new **EventFragment** for %%obj%%.
       */
      static from(obj) {
        if (_EventFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return _EventFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid event fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          const name = consumeName("event", obj);
          const inputs = consumeParams(obj, true);
          const anonymous = !!consumeKeywords(obj, setify(["anonymous"])).has("anonymous");
          consumeEoi(obj);
          return new _EventFragment(_guard, name, inputs, anonymous);
        }
        return new _EventFragment(_guard, obj.name, obj.inputs ? obj.inputs.map((p2) => ParamType.from(p2, true)) : [], !!obj.anonymous);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is an
       *  **EventFragment**.
       */
      static isFragment(value) {
        return value && value[internal] === EventFragmentInternal;
      }
    };
    exports.EventFragment = EventFragment;
    var ConstructorFragment = class _ConstructorFragment extends Fragment4 {
      /**
       *  @private
       */
      constructor(guard, type6, inputs, payable, gas) {
        super(guard, type6, inputs);
        /**
         *  Whether the constructor can receive an endowment.
         */
        __publicField(this, "payable");
        /**
         *  The recommended gas limit for deployment or ``null``.
         */
        __publicField(this, "gas");
        Object.defineProperty(this, internal, { value: ConstructorFragmentInternal });
        (0, index_js_1.defineProperties)(this, { payable, gas });
      }
      /**
       *  Returns a string representation of this constructor as %%format%%.
       */
      format(format6) {
        (0, index_js_1.assert)(format6 != null && format6 !== "sighash", "cannot format a constructor for sighash", "UNSUPPORTED_OPERATION", { operation: "format(sighash)" });
        if (format6 === "json") {
          return JSON.stringify({
            type: "constructor",
            stateMutability: this.payable ? "payable" : "undefined",
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map((i2) => JSON.parse(i2.format(format6)))
          });
        }
        const result = [`constructor${joinParams(format6, this.inputs)}`];
        if (this.payable) {
          result.push("payable");
        }
        if (this.gas != null) {
          result.push(`@${this.gas.toString()}`);
        }
        return result.join(" ");
      }
      /**
       *  Returns a new **ConstructorFragment** for %%obj%%.
       */
      static from(obj) {
        if (_ConstructorFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return _ConstructorFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid constuctor fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          consumeKeywords(obj, setify(["constructor"]));
          const inputs = consumeParams(obj);
          const payable = !!consumeKeywords(obj, KwVisibDeploy).has("payable");
          const gas = consumeGas(obj);
          consumeEoi(obj);
          return new _ConstructorFragment(_guard, "constructor", inputs, payable, gas);
        }
        return new _ConstructorFragment(_guard, "constructor", obj.inputs ? obj.inputs.map(ParamType.from) : [], !!obj.payable, obj.gas != null ? obj.gas : null);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is a
       *  **ConstructorFragment**.
       */
      static isFragment(value) {
        return value && value[internal] === ConstructorFragmentInternal;
      }
    };
    exports.ConstructorFragment = ConstructorFragment;
    var FallbackFragment = class _FallbackFragment extends Fragment4 {
      constructor(guard, inputs, payable) {
        super(guard, "fallback", inputs);
        /**
         *  If the function can be sent value during invocation.
         */
        __publicField(this, "payable");
        Object.defineProperty(this, internal, { value: FallbackFragmentInternal });
        (0, index_js_1.defineProperties)(this, { payable });
      }
      /**
       *  Returns a string representation of this fallback as %%format%%.
       */
      format(format6) {
        const type6 = this.inputs.length === 0 ? "receive" : "fallback";
        if (format6 === "json") {
          const stateMutability = this.payable ? "payable" : "nonpayable";
          return JSON.stringify({ type: type6, stateMutability });
        }
        return `${type6}()${this.payable ? " payable" : ""}`;
      }
      /**
       *  Returns a new **FallbackFragment** for %%obj%%.
       */
      static from(obj) {
        if (_FallbackFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return _FallbackFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid fallback fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          const errorObj = obj.toString();
          const topIsValid = obj.peekKeyword(setify(["fallback", "receive"]));
          (0, index_js_1.assertArgument)(topIsValid, "type must be fallback or receive", "obj", errorObj);
          const type6 = obj.popKeyword(setify(["fallback", "receive"]));
          if (type6 === "receive") {
            const inputs2 = consumeParams(obj);
            (0, index_js_1.assertArgument)(inputs2.length === 0, `receive cannot have arguments`, "obj.inputs", inputs2);
            consumeKeywords(obj, setify(["payable"]));
            consumeEoi(obj);
            return new _FallbackFragment(_guard, [], true);
          }
          let inputs = consumeParams(obj);
          if (inputs.length) {
            (0, index_js_1.assertArgument)(inputs.length === 1 && inputs[0].type === "bytes", "invalid fallback inputs", "obj.inputs", inputs.map((i2) => i2.format("minimal")).join(", "));
          } else {
            inputs = [ParamType.from("bytes")];
          }
          const mutability = consumeMutability(obj);
          (0, index_js_1.assertArgument)(mutability === "nonpayable" || mutability === "payable", "fallback cannot be constants", "obj.stateMutability", mutability);
          if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
            const outputs = consumeParams(obj);
            (0, index_js_1.assertArgument)(outputs.length === 1 && outputs[0].type === "bytes", "invalid fallback outputs", "obj.outputs", outputs.map((i2) => i2.format("minimal")).join(", "));
          }
          consumeEoi(obj);
          return new _FallbackFragment(_guard, inputs, mutability === "payable");
        }
        if (obj.type === "receive") {
          return new _FallbackFragment(_guard, [], true);
        }
        if (obj.type === "fallback") {
          const inputs = [ParamType.from("bytes")];
          const payable = obj.stateMutability === "payable";
          return new _FallbackFragment(_guard, inputs, payable);
        }
        (0, index_js_1.assertArgument)(false, "invalid fallback description", "obj", obj);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is a
       *  **FallbackFragment**.
       */
      static isFragment(value) {
        return value && value[internal] === FallbackFragmentInternal;
      }
    };
    exports.FallbackFragment = FallbackFragment;
    var FunctionFragment = class _FunctionFragment extends NamedFragment {
      /**
       *  @private
       */
      constructor(guard, name, stateMutability, inputs, outputs, gas) {
        super(guard, "function", name, inputs);
        /**
         *  If the function is constant (e.g. ``pure`` or ``view`` functions).
         */
        __publicField(this, "constant");
        /**
         *  The returned types for the result of calling this function.
         */
        __publicField(this, "outputs");
        /**
         *  The state mutability (e.g. ``payable``, ``nonpayable``, ``view``
         *  or ``pure``)
         */
        __publicField(this, "stateMutability");
        /**
         *  If the function can be sent value during invocation.
         */
        __publicField(this, "payable");
        /**
         *  The recommended gas limit to send when calling this function.
         */
        __publicField(this, "gas");
        Object.defineProperty(this, internal, { value: FunctionFragmentInternal });
        outputs = Object.freeze(outputs.slice());
        const constant = stateMutability === "view" || stateMutability === "pure";
        const payable = stateMutability === "payable";
        (0, index_js_1.defineProperties)(this, { constant, gas, outputs, payable, stateMutability });
      }
      /**
       *  The Function selector.
       */
      get selector() {
        return (0, index_js_2.id)(this.format("sighash")).substring(0, 10);
      }
      /**
       *  Returns a string representation of this function as %%format%%.
       */
      format(format6) {
        if (format6 == null) {
          format6 = "sighash";
        }
        if (format6 === "json") {
          return JSON.stringify({
            type: "function",
            name: this.name,
            constant: this.constant,
            stateMutability: this.stateMutability !== "nonpayable" ? this.stateMutability : void 0,
            payable: this.payable,
            gas: this.gas != null ? this.gas : void 0,
            inputs: this.inputs.map((i2) => JSON.parse(i2.format(format6))),
            outputs: this.outputs.map((o2) => JSON.parse(o2.format(format6)))
          });
        }
        const result = [];
        if (format6 !== "sighash") {
          result.push("function");
        }
        result.push(this.name + joinParams(format6, this.inputs));
        if (format6 !== "sighash") {
          if (this.stateMutability !== "nonpayable") {
            result.push(this.stateMutability);
          }
          if (this.outputs && this.outputs.length) {
            result.push("returns");
            result.push(joinParams(format6, this.outputs));
          }
          if (this.gas != null) {
            result.push(`@${this.gas.toString()}`);
          }
        }
        return result.join(" ");
      }
      /**
       *  Return the selector for a function with %%name%% and %%params%%.
       */
      static getSelector(name, params) {
        params = (params || []).map((p2) => ParamType.from(p2));
        const fragment = new _FunctionFragment(_guard, name, "view", params, [], null);
        return fragment.selector;
      }
      /**
       *  Returns a new **FunctionFragment** for %%obj%%.
       */
      static from(obj) {
        if (_FunctionFragment.isFragment(obj)) {
          return obj;
        }
        if (typeof obj === "string") {
          try {
            return _FunctionFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid function fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          const name = consumeName("function", obj);
          const inputs = consumeParams(obj);
          const mutability = consumeMutability(obj);
          let outputs = [];
          if (consumeKeywords(obj, setify(["returns"])).has("returns")) {
            outputs = consumeParams(obj);
          }
          const gas = consumeGas(obj);
          consumeEoi(obj);
          return new _FunctionFragment(_guard, name, mutability, inputs, outputs, gas);
        }
        let stateMutability = obj.stateMutability;
        if (stateMutability == null) {
          stateMutability = "payable";
          if (typeof obj.constant === "boolean") {
            stateMutability = "view";
            if (!obj.constant) {
              stateMutability = "payable";
              if (typeof obj.payable === "boolean" && !obj.payable) {
                stateMutability = "nonpayable";
              }
            }
          } else if (typeof obj.payable === "boolean" && !obj.payable) {
            stateMutability = "nonpayable";
          }
        }
        return new _FunctionFragment(_guard, obj.name, stateMutability, obj.inputs ? obj.inputs.map(ParamType.from) : [], obj.outputs ? obj.outputs.map(ParamType.from) : [], obj.gas != null ? obj.gas : null);
      }
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is a
       *  **FunctionFragment**.
       */
      static isFragment(value) {
        return value && value[internal] === FunctionFragmentInternal;
      }
    };
    exports.FunctionFragment = FunctionFragment;
    var StructFragment = class _StructFragment extends NamedFragment {
      /**
       *  @private
       */
      constructor(guard, name, inputs) {
        super(guard, "struct", name, inputs);
        Object.defineProperty(this, internal, { value: StructFragmentInternal });
      }
      /**
       *  Returns a string representation of this struct as %%format%%.
       */
      format() {
        throw new Error("@TODO");
      }
      /**
       *  Returns a new **StructFragment** for %%obj%%.
       */
      static from(obj) {
        if (typeof obj === "string") {
          try {
            return _StructFragment.from(lex(obj));
          } catch (error) {
            (0, index_js_1.assertArgument)(false, "invalid struct fragment", "obj", obj);
          }
        } else if (obj instanceof TokenString) {
          const name = consumeName("struct", obj);
          const inputs = consumeParams(obj);
          consumeEoi(obj);
          return new _StructFragment(_guard, name, inputs);
        }
        return new _StructFragment(_guard, obj.name, obj.inputs ? obj.inputs.map(ParamType.from) : []);
      }
      // @TODO: fix this return type
      /**
       *  Returns ``true`` and provides a type guard if %%value%% is a
       *  **StructFragment**.
       */
      static isFragment(value) {
        return value && value[internal] === StructFragmentInternal;
      }
    };
    exports.StructFragment = StructFragment;
  }
});

// node_modules/ethers/lib.commonjs/abi/abi-coder.js
var require_abi_coder = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/abi-coder.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbiCoder = void 0;
    var index_js_1 = require_utils5();
    var abstract_coder_js_1 = require_abstract_coder();
    var address_js_1 = require_address3();
    var array_js_1 = require_array();
    var boolean_js_1 = require_boolean();
    var bytes_js_1 = require_bytes();
    var fixed_bytes_js_1 = require_fixed_bytes();
    var null_js_1 = require_null();
    var number_js_1 = require_number();
    var string_js_1 = require_string();
    var tuple_js_1 = require_tuple();
    var fragments_js_1 = require_fragments();
    var index_js_2 = require_address2();
    var index_js_3 = require_utils5();
    var PanicReasons = /* @__PURE__ */ new Map();
    PanicReasons.set(0, "GENERIC_PANIC");
    PanicReasons.set(1, "ASSERT_FALSE");
    PanicReasons.set(17, "OVERFLOW");
    PanicReasons.set(18, "DIVIDE_BY_ZERO");
    PanicReasons.set(33, "ENUM_RANGE_ERROR");
    PanicReasons.set(34, "BAD_STORAGE_DATA");
    PanicReasons.set(49, "STACK_UNDERFLOW");
    PanicReasons.set(50, "ARRAY_RANGE_ERROR");
    PanicReasons.set(65, "OUT_OF_MEMORY");
    PanicReasons.set(81, "UNINITIALIZED_FUNCTION_CALL");
    var paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
    var paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
    var defaultCoder = null;
    var defaultMaxInflation = 1024;
    function getBuiltinCallException(action, tx, data, abiCoder) {
      let message = "missing revert data";
      let reason = null;
      const invocation = null;
      let revert2 = null;
      if (data) {
        message = "execution reverted";
        const bytes = (0, index_js_3.getBytes)(data);
        data = (0, index_js_3.hexlify)(data);
        if (bytes.length === 0) {
          message += " (no data present; likely require(false) occurred";
          reason = "require(false)";
        } else if (bytes.length % 32 !== 4) {
          message += " (could not decode reason; invalid data length)";
        } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x08c379a0") {
          try {
            reason = abiCoder.decode(["string"], bytes.slice(4))[0];
            revert2 = {
              signature: "Error(string)",
              name: "Error",
              args: [reason]
            };
            message += `: ${JSON.stringify(reason)}`;
          } catch (error) {
            message += " (could not decode reason; invalid string data)";
          }
        } else if ((0, index_js_3.hexlify)(bytes.slice(0, 4)) === "0x4e487b71") {
          try {
            const code = Number(abiCoder.decode(["uint256"], bytes.slice(4))[0]);
            revert2 = {
              signature: "Panic(uint256)",
              name: "Panic",
              args: [code]
            };
            reason = `Panic due to ${PanicReasons.get(code) || "UNKNOWN"}(${code})`;
            message += `: ${reason}`;
          } catch (error) {
            message += " (could not decode panic code)";
          }
        } else {
          message += " (unknown custom error)";
        }
      }
      const transaction = {
        to: tx.to ? (0, index_js_2.getAddress)(tx.to) : null,
        data: tx.data || "0x"
      };
      if (tx.from) {
        transaction.from = (0, index_js_2.getAddress)(tx.from);
      }
      return (0, index_js_3.makeError)(message, "CALL_EXCEPTION", {
        action,
        data,
        reason,
        transaction,
        invocation,
        revert: revert2
      });
    }
    var _AbiCoder_instances, getCoder_fn;
    var _AbiCoder = class _AbiCoder {
      constructor() {
        __privateAdd(this, _AbiCoder_instances);
      }
      /**
       *  Get the default values for the given %%types%%.
       *
       *  For example, a ``uint`` is by default ``0`` and ``bool``
       *  is by default ``false``.
       */
      getDefaultValue(types3) {
        const coders = types3.map((type6) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, fragments_js_1.ParamType.from(type6)));
        const coder = new tuple_js_1.TupleCoder(coders, "_");
        return coder.defaultValue();
      }
      /**
       *  Encode the %%values%% as the %%types%% into ABI data.
       *
       *  @returns DataHexstring
       */
      encode(types3, values) {
        (0, index_js_1.assertArgumentCount)(values.length, types3.length, "types/values length mismatch");
        const coders = types3.map((type6) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, fragments_js_1.ParamType.from(type6)));
        const coder = new tuple_js_1.TupleCoder(coders, "_");
        const writer = new abstract_coder_js_1.Writer();
        coder.encode(writer, values);
        return writer.data;
      }
      /**
       *  Decode the ABI %%data%% as the %%types%% into values.
       *
       *  If %%loose%% decoding is enabled, then strict padding is
       *  not enforced. Some older versions of Solidity incorrectly
       *  padded event data emitted from ``external`` functions.
       */
      decode(types3, data, loose) {
        const coders = types3.map((type6) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, fragments_js_1.ParamType.from(type6)));
        const coder = new tuple_js_1.TupleCoder(coders, "_");
        return coder.decode(new abstract_coder_js_1.Reader(data, loose, defaultMaxInflation));
      }
      static _setDefaultMaxInflation(value) {
        (0, index_js_1.assertArgument)(typeof value === "number" && Number.isInteger(value), "invalid defaultMaxInflation factor", "value", value);
        defaultMaxInflation = value;
      }
      /**
       *  Returns the shared singleton instance of a default [[AbiCoder]].
       *
       *  On the first call, the instance is created internally.
       */
      static defaultAbiCoder() {
        if (defaultCoder == null) {
          defaultCoder = new _AbiCoder();
        }
        return defaultCoder;
      }
      /**
       *  Returns an ethers-compatible [[CallExceptionError]] Error for the given
       *  result %%data%% for the [[CallExceptionAction]] %%action%% against
       *  the Transaction %%tx%%.
       */
      static getBuiltinCallException(action, tx, data) {
        return getBuiltinCallException(action, tx, data, _AbiCoder.defaultAbiCoder());
      }
    };
    _AbiCoder_instances = new WeakSet();
    getCoder_fn = function(param) {
      if (param.isArray()) {
        return new array_js_1.ArrayCoder(__privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, param.arrayChildren), param.arrayLength, param.name);
      }
      if (param.isTuple()) {
        return new tuple_js_1.TupleCoder(param.components.map((c3) => __privateMethod(this, _AbiCoder_instances, getCoder_fn).call(this, c3)), param.name);
      }
      switch (param.baseType) {
        case "address":
          return new address_js_1.AddressCoder(param.name);
        case "bool":
          return new boolean_js_1.BooleanCoder(param.name);
        case "string":
          return new string_js_1.StringCoder(param.name);
        case "bytes":
          return new bytes_js_1.BytesCoder(param.name);
        case "":
          return new null_js_1.NullCoder(param.name);
      }
      let match = param.type.match(paramTypeNumber);
      if (match) {
        let size5 = parseInt(match[2] || "256");
        (0, index_js_1.assertArgument)(size5 !== 0 && size5 <= 256 && size5 % 8 === 0, "invalid " + match[1] + " bit length", "param", param);
        return new number_js_1.NumberCoder(size5 / 8, match[1] === "int", param.name);
      }
      match = param.type.match(paramTypeBytes);
      if (match) {
        let size5 = parseInt(match[1]);
        (0, index_js_1.assertArgument)(size5 !== 0 && size5 <= 32, "invalid bytes length", "param", param);
        return new fixed_bytes_js_1.FixedBytesCoder(size5, param.name);
      }
      (0, index_js_1.assertArgument)(false, "invalid type", "type", param.type);
    };
    var AbiCoder = _AbiCoder;
    exports.AbiCoder = AbiCoder;
  }
});

// node_modules/ethers/lib.commonjs/abi/bytes32.js
var require_bytes32 = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/bytes32.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeBytes32String = exports.encodeBytes32String = void 0;
    var index_js_1 = require_utils5();
    function encodeBytes32String(text) {
      const bytes = (0, index_js_1.toUtf8Bytes)(text);
      if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
      }
      return (0, index_js_1.zeroPadBytes)(bytes, 32);
    }
    exports.encodeBytes32String = encodeBytes32String;
    function decodeBytes32String(_bytes) {
      const data = (0, index_js_1.getBytes)(_bytes, "bytes");
      if (data.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
      }
      if (data[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
      }
      let length2 = 31;
      while (data[length2 - 1] === 0) {
        length2--;
      }
      return (0, index_js_1.toUtf8String)(data.slice(0, length2));
    }
    exports.decodeBytes32String = decodeBytes32String;
  }
});

// node_modules/ethers/lib.commonjs/abi/interface.js
var require_interface = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/interface.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Interface = exports.Indexed = exports.ErrorDescription = exports.TransactionDescription = exports.LogDescription = exports.Result = exports.checkResultErrors = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_hash();
    var index_js_3 = require_utils5();
    var abi_coder_js_1 = require_abi_coder();
    var abstract_coder_js_1 = require_abstract_coder();
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return abstract_coder_js_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "Result", { enumerable: true, get: function() {
      return abstract_coder_js_1.Result;
    } });
    var fragments_js_1 = require_fragments();
    var typed_js_1 = require_typed();
    var LogDescription = class {
      /**
       *  @_ignore:
       */
      constructor(fragment, topic, args) {
        /**
         *  The matching fragment for the ``topic0``.
         */
        __publicField(this, "fragment");
        /**
         *  The name of the Event.
         */
        __publicField(this, "name");
        /**
         *  The full Event signature.
         */
        __publicField(this, "signature");
        /**
         *  The topic hash for the Event.
         */
        __publicField(this, "topic");
        /**
         *  The arguments passed into the Event with ``emit``.
         */
        __publicField(this, "args");
        const name = fragment.name, signature = fragment.format();
        (0, index_js_3.defineProperties)(this, {
          fragment,
          name,
          signature,
          topic,
          args
        });
      }
    };
    exports.LogDescription = LogDescription;
    var TransactionDescription = class {
      /**
       *  @_ignore:
       */
      constructor(fragment, selector, args, value) {
        /**
         *  The matching fragment from the transaction ``data``.
         */
        __publicField(this, "fragment");
        /**
         *  The name of the Function from the transaction ``data``.
         */
        __publicField(this, "name");
        /**
         *  The arguments passed to the Function from the transaction ``data``.
         */
        __publicField(this, "args");
        /**
         *  The full Function signature from the transaction ``data``.
         */
        __publicField(this, "signature");
        /**
         *  The selector for the Function from the transaction ``data``.
         */
        __publicField(this, "selector");
        /**
         *  The ``value`` (in wei) from the transaction.
         */
        __publicField(this, "value");
        const name = fragment.name, signature = fragment.format();
        (0, index_js_3.defineProperties)(this, {
          fragment,
          name,
          args,
          signature,
          selector,
          value
        });
      }
    };
    exports.TransactionDescription = TransactionDescription;
    var ErrorDescription = class {
      /**
       *  @_ignore:
       */
      constructor(fragment, selector, args) {
        /**
         *  The matching fragment.
         */
        __publicField(this, "fragment");
        /**
         *  The name of the Error.
         */
        __publicField(this, "name");
        /**
         *  The arguments passed to the Error with ``revert``.
         */
        __publicField(this, "args");
        /**
         *  The full Error signature.
         */
        __publicField(this, "signature");
        /**
         *  The selector for the Error.
         */
        __publicField(this, "selector");
        const name = fragment.name, signature = fragment.format();
        (0, index_js_3.defineProperties)(this, {
          fragment,
          name,
          args,
          signature,
          selector
        });
      }
    };
    exports.ErrorDescription = ErrorDescription;
    var Indexed = class {
      /**
       *  @_ignore:
       */
      constructor(hash8) {
        /**
         *  The ``keccak256`` of the value logged.
         */
        __publicField(this, "hash");
        /**
         *  @_ignore:
         */
        __publicField(this, "_isIndexed");
        (0, index_js_3.defineProperties)(this, { hash: hash8, _isIndexed: true });
      }
      /**
       *  Returns ``true`` if %%value%% is an **Indexed**.
       *
       *  This provides a Type Guard for property access.
       */
      static isIndexed(value) {
        return !!(value && value._isIndexed);
      }
    };
    exports.Indexed = Indexed;
    var PanicReasons = {
      "0": "generic panic",
      "1": "assert(false)",
      "17": "arithmetic overflow",
      "18": "division or modulo by zero",
      "33": "enum overflow",
      "34": "invalid encoded storage byte array accessed",
      "49": "out-of-bounds array access; popping on an empty array",
      "50": "out-of-bounds access of an array or bytesN",
      "65": "out of memory",
      "81": "uninitialized function"
    };
    var BuiltinErrors = {
      "0x08c379a0": {
        signature: "Error(string)",
        name: "Error",
        inputs: ["string"],
        reason: (message) => {
          return `reverted with reason string ${JSON.stringify(message)}`;
        }
      },
      "0x4e487b71": {
        signature: "Panic(uint256)",
        name: "Panic",
        inputs: ["uint256"],
        reason: (code) => {
          let reason = "unknown panic code";
          if (code >= 0 && code <= 255 && PanicReasons[code.toString()]) {
            reason = PanicReasons[code.toString()];
          }
          return `reverted with panic code 0x${code.toString(16)} (${reason})`;
        }
      }
    };
    var _errors, _events, _functions, _abiCoder, _Interface_instances, getFunction_fn, getEvent_fn;
    var _Interface = class _Interface {
      /**
       *  Create a new Interface for the %%fragments%%.
       */
      constructor(fragments) {
        __privateAdd(this, _Interface_instances);
        /**
         *  All the Contract ABI members (i.e. methods, events, errors, etc).
         */
        __publicField(this, "fragments");
        /**
         *  The Contract constructor.
         */
        __publicField(this, "deploy");
        /**
         *  The Fallback method, if any.
         */
        __publicField(this, "fallback");
        /**
         *  If receiving ether is supported.
         */
        __publicField(this, "receive");
        __privateAdd(this, _errors);
        __privateAdd(this, _events);
        __privateAdd(this, _functions);
        //    #structs: Map<string, StructFragment>;
        __privateAdd(this, _abiCoder);
        let abi = [];
        if (typeof fragments === "string") {
          abi = JSON.parse(fragments);
        } else {
          abi = fragments;
        }
        __privateSet(this, _functions, /* @__PURE__ */ new Map());
        __privateSet(this, _errors, /* @__PURE__ */ new Map());
        __privateSet(this, _events, /* @__PURE__ */ new Map());
        const frags = [];
        for (const a3 of abi) {
          try {
            frags.push(fragments_js_1.Fragment.from(a3));
          } catch (error) {
            console.log(`[Warning] Invalid Fragment ${JSON.stringify(a3)}:`, error.message);
          }
        }
        (0, index_js_3.defineProperties)(this, {
          fragments: Object.freeze(frags)
        });
        let fallback3 = null;
        let receive = false;
        __privateSet(this, _abiCoder, this.getAbiCoder());
        this.fragments.forEach((fragment, index5) => {
          let bucket;
          switch (fragment.type) {
            case "constructor":
              if (this.deploy) {
                console.log("duplicate definition - constructor");
                return;
              }
              (0, index_js_3.defineProperties)(this, { deploy: fragment });
              return;
            case "fallback":
              if (fragment.inputs.length === 0) {
                receive = true;
              } else {
                (0, index_js_3.assertArgument)(!fallback3 || fragment.payable !== fallback3.payable, "conflicting fallback fragments", `fragments[${index5}]`, fragment);
                fallback3 = fragment;
                receive = fallback3.payable;
              }
              return;
            case "function":
              bucket = __privateGet(this, _functions);
              break;
            case "event":
              bucket = __privateGet(this, _events);
              break;
            case "error":
              bucket = __privateGet(this, _errors);
              break;
            default:
              return;
          }
          const signature = fragment.format();
          if (bucket.has(signature)) {
            return;
          }
          bucket.set(signature, fragment);
        });
        if (!this.deploy) {
          (0, index_js_3.defineProperties)(this, {
            deploy: fragments_js_1.ConstructorFragment.from("constructor()")
          });
        }
        (0, index_js_3.defineProperties)(this, { fallback: fallback3, receive });
      }
      /**
       *  Returns the entire Human-Readable ABI, as an array of
       *  signatures, optionally as %%minimal%% strings, which
       *  removes parameter names and unneceesary spaces.
       */
      format(minimal2) {
        const format6 = minimal2 ? "minimal" : "full";
        const abi = this.fragments.map((f3) => f3.format(format6));
        return abi;
      }
      /**
       *  Return the JSON-encoded ABI. This is the format Solidiy
       *  returns.
       */
      formatJson() {
        const abi = this.fragments.map((f3) => f3.format("json"));
        return JSON.stringify(abi.map((j3) => JSON.parse(j3)));
      }
      /**
       *  The ABI coder that will be used to encode and decode binary
       *  data.
       */
      getAbiCoder() {
        return abi_coder_js_1.AbiCoder.defaultAbiCoder();
      }
      /**
       *  Get the function name for %%key%%, which may be a function selector,
       *  function name or function signature that belongs to the ABI.
       */
      getFunctionName(key) {
        const fragment = __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
        (0, index_js_3.assertArgument)(fragment, "no matching function", "key", key);
        return fragment.name;
      }
      /**
       *  Returns true if %%key%% (a function selector, function name or
       *  function signature) is present in the ABI.
       *
       *  In the case of a function name, the name may be ambiguous, so
       *  accessing the [[FunctionFragment]] may require refinement.
       */
      hasFunction(key) {
        return !!__privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, null, false);
      }
      /**
       *  Get the [[FunctionFragment]] for %%key%%, which may be a function
       *  selector, function name or function signature that belongs to the ABI.
       *
       *  If %%values%% is provided, it will use the Typed API to handle
       *  ambiguous cases where multiple functions match by name.
       *
       *  If the %%key%% and %%values%% do not refine to a single function in
       *  the ABI, this will throw.
       */
      getFunction(key, values) {
        return __privateMethod(this, _Interface_instances, getFunction_fn).call(this, key, values || null, true);
      }
      /**
       *  Iterate over all functions, calling %%callback%%, sorted by their name.
       */
      forEachFunction(callback) {
        const names2 = Array.from(__privateGet(this, _functions).keys());
        names2.sort((a3, b4) => a3.localeCompare(b4));
        for (let i2 = 0; i2 < names2.length; i2++) {
          const name = names2[i2];
          callback(__privateGet(this, _functions).get(name), i2);
        }
      }
      /**
       *  Get the event name for %%key%%, which may be a topic hash,
       *  event name or event signature that belongs to the ABI.
       */
      getEventName(key) {
        const fragment = __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
        (0, index_js_3.assertArgument)(fragment, "no matching event", "key", key);
        return fragment.name;
      }
      /**
       *  Returns true if %%key%% (an event topic hash, event name or
       *  event signature) is present in the ABI.
       *
       *  In the case of an event name, the name may be ambiguous, so
       *  accessing the [[EventFragment]] may require refinement.
       */
      hasEvent(key) {
        return !!__privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, null, false);
      }
      /**
       *  Get the [[EventFragment]] for %%key%%, which may be a topic hash,
       *  event name or event signature that belongs to the ABI.
       *
       *  If %%values%% is provided, it will use the Typed API to handle
       *  ambiguous cases where multiple events match by name.
       *
       *  If the %%key%% and %%values%% do not refine to a single event in
       *  the ABI, this will throw.
       */
      getEvent(key, values) {
        return __privateMethod(this, _Interface_instances, getEvent_fn).call(this, key, values || null, true);
      }
      /**
       *  Iterate over all events, calling %%callback%%, sorted by their name.
       */
      forEachEvent(callback) {
        const names2 = Array.from(__privateGet(this, _events).keys());
        names2.sort((a3, b4) => a3.localeCompare(b4));
        for (let i2 = 0; i2 < names2.length; i2++) {
          const name = names2[i2];
          callback(__privateGet(this, _events).get(name), i2);
        }
      }
      /**
       *  Get the [[ErrorFragment]] for %%key%%, which may be an error
       *  selector, error name or error signature that belongs to the ABI.
       *
       *  If %%values%% is provided, it will use the Typed API to handle
       *  ambiguous cases where multiple errors match by name.
       *
       *  If the %%key%% and %%values%% do not refine to a single error in
       *  the ABI, this will throw.
       */
      getError(key, values) {
        if ((0, index_js_3.isHexString)(key)) {
          const selector = key.toLowerCase();
          if (BuiltinErrors[selector]) {
            return fragments_js_1.ErrorFragment.from(BuiltinErrors[selector].signature);
          }
          for (const fragment of __privateGet(this, _errors).values()) {
            if (selector === fragment.selector) {
              return fragment;
            }
          }
          return null;
        }
        if (key.indexOf("(") === -1) {
          const matching = [];
          for (const [name, fragment] of __privateGet(this, _errors)) {
            if (name.split(
              "("
              /* fix:) */
            )[0] === key) {
              matching.push(fragment);
            }
          }
          if (matching.length === 0) {
            if (key === "Error") {
              return fragments_js_1.ErrorFragment.from("error Error(string)");
            }
            if (key === "Panic") {
              return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
            }
            return null;
          } else if (matching.length > 1) {
            const matchStr = matching.map((m3) => JSON.stringify(m3.format())).join(", ");
            (0, index_js_3.assertArgument)(false, `ambiguous error description (i.e. ${matchStr})`, "name", key);
          }
          return matching[0];
        }
        key = fragments_js_1.ErrorFragment.from(key).format();
        if (key === "Error(string)") {
          return fragments_js_1.ErrorFragment.from("error Error(string)");
        }
        if (key === "Panic(uint256)") {
          return fragments_js_1.ErrorFragment.from("error Panic(uint256)");
        }
        const result = __privateGet(this, _errors).get(key);
        if (result) {
          return result;
        }
        return null;
      }
      /**
       *  Iterate over all errors, calling %%callback%%, sorted by their name.
       */
      forEachError(callback) {
        const names2 = Array.from(__privateGet(this, _errors).keys());
        names2.sort((a3, b4) => a3.localeCompare(b4));
        for (let i2 = 0; i2 < names2.length; i2++) {
          const name = names2[i2];
          callback(__privateGet(this, _errors).get(name), i2);
        }
      }
      // Get the 4-byte selector used by Solidity to identify a function
      /*
      getSelector(fragment: ErrorFragment | FunctionFragment): string {
          if (typeof(fragment) === "string") {
              const matches: Array<Fragment> = [ ];
      
              try { matches.push(this.getFunction(fragment)); } catch (error) { }
              try { matches.push(this.getError(<string>fragment)); } catch (_) { }
      
              if (matches.length === 0) {
                  logger.throwArgumentError("unknown fragment", "key", fragment);
              } else if (matches.length > 1) {
                  logger.throwArgumentError("ambiguous fragment matches function and error", "key", fragment);
              }
      
              fragment = matches[0];
          }
      
          return dataSlice(id(fragment.format()), 0, 4);
      }
          */
      // Get the 32-byte topic hash used by Solidity to identify an event
      /*
      getEventTopic(fragment: EventFragment): string {
          //if (typeof(fragment) === "string") { fragment = this.getEvent(eventFragment); }
          return id(fragment.format());
      }
      */
      _decodeParams(params, data) {
        return __privateGet(this, _abiCoder).decode(params, data);
      }
      _encodeParams(params, values) {
        return __privateGet(this, _abiCoder).encode(params, values);
      }
      /**
       *  Encodes a ``tx.data`` object for deploying the Contract with
       *  the %%values%% as the constructor arguments.
       */
      encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
      }
      /**
       *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
       *  specified error (see [[getError]] for valid values for
       *  %%key%%).
       *
       *  Most developers should prefer the [[parseCallResult]] method instead,
       *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
       *  corresponding error.
       */
      decodeErrorResult(fragment, data) {
        if (typeof fragment === "string") {
          const f3 = this.getError(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown error", "fragment", fragment);
          fragment = f3;
        }
        (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match error ${fragment.name}.`, "data", data);
        return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
      }
      /**
       *  Encodes the transaction revert data for a call result that
       *  reverted from the the Contract with the sepcified %%error%%
       *  (see [[getError]] for valid values for %%fragment%%) with the %%values%%.
       *
       *  This is generally not used by most developers, unless trying to mock
       *  a result from a Contract.
       */
      encodeErrorResult(fragment, values) {
        if (typeof fragment === "string") {
          const f3 = this.getError(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown error", "fragment", fragment);
          fragment = f3;
        }
        return (0, index_js_3.concat)([
          fragment.selector,
          this._encodeParams(fragment.inputs, values || [])
        ]);
      }
      /**
       *  Decodes the %%data%% from a transaction ``tx.data`` for
       *  the function specified (see [[getFunction]] for valid values
       *  for %%fragment%%).
       *
       *  Most developers should prefer the [[parseTransaction]] method
       *  instead, which will automatically detect the fragment.
       */
      decodeFunctionData(fragment, data) {
        if (typeof fragment === "string") {
          const f3 = this.getFunction(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown function", "fragment", fragment);
          fragment = f3;
        }
        (0, index_js_3.assertArgument)((0, index_js_3.dataSlice)(data, 0, 4) === fragment.selector, `data signature does not match function ${fragment.name}.`, "data", data);
        return this._decodeParams(fragment.inputs, (0, index_js_3.dataSlice)(data, 4));
      }
      /**
       *  Encodes the ``tx.data`` for a transaction that calls the function
       *  specified (see [[getFunction]] for valid values for %%fragment%%) with
       *  the %%values%%.
       */
      encodeFunctionData(fragment, values) {
        if (typeof fragment === "string") {
          const f3 = this.getFunction(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown function", "fragment", fragment);
          fragment = f3;
        }
        return (0, index_js_3.concat)([
          fragment.selector,
          this._encodeParams(fragment.inputs, values || [])
        ]);
      }
      /**
       *  Decodes the result %%data%% (e.g. from an ``eth_call``) for the
       *  specified function (see [[getFunction]] for valid values for
       *  %%key%%).
       *
       *  Most developers should prefer the [[parseCallResult]] method instead,
       *  which will automatically detect a ``CALL_EXCEPTION`` and throw the
       *  corresponding error.
       */
      decodeFunctionResult(fragment, data) {
        if (typeof fragment === "string") {
          const f3 = this.getFunction(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown function", "fragment", fragment);
          fragment = f3;
        }
        let message = "invalid length for result data";
        const bytes = (0, index_js_3.getBytesCopy)(data);
        if (bytes.length % 32 === 0) {
          try {
            return __privateGet(this, _abiCoder).decode(fragment.outputs, bytes);
          } catch (error) {
            message = "could not decode result data";
          }
        }
        (0, index_js_3.assert)(false, message, "BAD_DATA", {
          value: (0, index_js_3.hexlify)(bytes),
          info: { method: fragment.name, signature: fragment.format() }
        });
      }
      makeError(_data, tx) {
        const data = (0, index_js_3.getBytes)(_data, "data");
        const error = abi_coder_js_1.AbiCoder.getBuiltinCallException("call", tx, data);
        const customPrefix = "execution reverted (unknown custom error)";
        if (error.message.startsWith(customPrefix)) {
          const selector = (0, index_js_3.hexlify)(data.slice(0, 4));
          const ef = this.getError(selector);
          if (ef) {
            try {
              const args = __privateGet(this, _abiCoder).decode(ef.inputs, data.slice(4));
              error.revert = {
                name: ef.name,
                signature: ef.format(),
                args
              };
              error.reason = error.revert.signature;
              error.message = `execution reverted: ${error.reason}`;
            } catch (e2) {
              error.message = `execution reverted (coult not decode custom error)`;
            }
          }
        }
        const parsed = this.parseTransaction(tx);
        if (parsed) {
          error.invocation = {
            method: parsed.name,
            signature: parsed.signature,
            args: parsed.args
          };
        }
        return error;
      }
      /**
       *  Encodes the result data (e.g. from an ``eth_call``) for the
       *  specified function (see [[getFunction]] for valid values
       *  for %%fragment%%) with %%values%%.
       *
       *  This is generally not used by most developers, unless trying to mock
       *  a result from a Contract.
       */
      encodeFunctionResult(fragment, values) {
        if (typeof fragment === "string") {
          const f3 = this.getFunction(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown function", "fragment", fragment);
          fragment = f3;
        }
        return (0, index_js_3.hexlify)(__privateGet(this, _abiCoder).encode(fragment.outputs, values || []));
      }
      /*
          spelunk(inputs: Array<ParamType>, values: ReadonlyArray<any>, processfunc: (type: string, value: any) => Promise<any>): Promise<Array<any>> {
              const promises: Array<Promise<>> = [ ];
              const process = function(type: ParamType, value: any): any {
                  if (type.baseType === "array") {
                      return descend(type.child
                  }
                  if (type. === "address") {
                  }
              };
      
              const descend = function (inputs: Array<ParamType>, values: ReadonlyArray<any>) {
                  if (inputs.length !== values.length) { throw new Error("length mismatch"); }
                  
              };
      
              const result: Array<any> = [ ];
              values.forEach((value, index) => {
                  if (value == null) {
                      topics.push(null);
                  } else if (param.baseType === "array" || param.baseType === "tuple") {
                      logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
                  } else if (Array.isArray(value)) {
                      topics.push(value.map((value) => encodeTopic(param, value)));
                  } else {
                      topics.push(encodeTopic(param, value));
                  }
              });
          }
      */
      // Create the filter for the event with search criteria (e.g. for eth_filterLog)
      encodeFilterTopics(fragment, values) {
        if (typeof fragment === "string") {
          const f3 = this.getEvent(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown event", "eventFragment", fragment);
          fragment = f3;
        }
        (0, index_js_3.assert)(values.length <= fragment.inputs.length, `too many arguments for ${fragment.format()}`, "UNEXPECTED_ARGUMENT", { count: values.length, expectedCount: fragment.inputs.length });
        const topics = [];
        if (!fragment.anonymous) {
          topics.push(fragment.topicHash);
        }
        const encodeTopic = (param, value) => {
          if (param.type === "string") {
            return (0, index_js_2.id)(value);
          } else if (param.type === "bytes") {
            return (0, index_js_1.keccak256)((0, index_js_3.hexlify)(value));
          }
          if (param.type === "bool" && typeof value === "boolean") {
            value = value ? "0x01" : "0x00";
          } else if (param.type.match(/^u?int/)) {
            value = (0, index_js_3.toBeHex)(value);
          } else if (param.type.match(/^bytes/)) {
            value = (0, index_js_3.zeroPadBytes)(value, 32);
          } else if (param.type === "address") {
            __privateGet(this, _abiCoder).encode(["address"], [value]);
          }
          return (0, index_js_3.zeroPadValue)((0, index_js_3.hexlify)(value), 32);
        };
        values.forEach((value, index5) => {
          const param = fragment.inputs[index5];
          if (!param.indexed) {
            (0, index_js_3.assertArgument)(value == null, "cannot filter non-indexed parameters; must be null", "contract." + param.name, value);
            return;
          }
          if (value == null) {
            topics.push(null);
          } else if (param.baseType === "array" || param.baseType === "tuple") {
            (0, index_js_3.assertArgument)(false, "filtering with tuples or arrays not supported", "contract." + param.name, value);
          } else if (Array.isArray(value)) {
            topics.push(value.map((value2) => encodeTopic(param, value2)));
          } else {
            topics.push(encodeTopic(param, value));
          }
        });
        while (topics.length && topics[topics.length - 1] === null) {
          topics.pop();
        }
        return topics;
      }
      encodeEventLog(fragment, values) {
        if (typeof fragment === "string") {
          const f3 = this.getEvent(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown event", "eventFragment", fragment);
          fragment = f3;
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!fragment.anonymous) {
          topics.push(fragment.topicHash);
        }
        (0, index_js_3.assertArgument)(values.length === fragment.inputs.length, "event arguments/values mismatch", "values", values);
        fragment.inputs.forEach((param, index5) => {
          const value = values[index5];
          if (param.indexed) {
            if (param.type === "string") {
              topics.push((0, index_js_2.id)(value));
            } else if (param.type === "bytes") {
              topics.push((0, index_js_1.keccak256)(value));
            } else if (param.baseType === "tuple" || param.baseType === "array") {
              throw new Error("not implemented");
            } else {
              topics.push(__privateGet(this, _abiCoder).encode([param.type], [value]));
            }
          } else {
            dataTypes.push(param);
            dataValues.push(value);
          }
        });
        return {
          data: __privateGet(this, _abiCoder).encode(dataTypes, dataValues),
          topics
        };
      }
      // Decode a filter for the event and the search criteria
      decodeEventLog(fragment, data, topics) {
        if (typeof fragment === "string") {
          const f3 = this.getEvent(fragment);
          (0, index_js_3.assertArgument)(f3, "unknown event", "eventFragment", fragment);
          fragment = f3;
        }
        if (topics != null && !fragment.anonymous) {
          const eventTopic = fragment.topicHash;
          (0, index_js_3.assertArgument)((0, index_js_3.isHexString)(topics[0], 32) && topics[0].toLowerCase() === eventTopic, "fragment/topic mismatch", "topics[0]", topics[0]);
          topics = topics.slice(1);
        }
        const indexed = [];
        const nonIndexed = [];
        const dynamic = [];
        fragment.inputs.forEach((param, index5) => {
          if (param.indexed) {
            if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
              indexed.push(fragments_js_1.ParamType.from({ type: "bytes32", name: param.name }));
              dynamic.push(true);
            } else {
              indexed.push(param);
              dynamic.push(false);
            }
          } else {
            nonIndexed.push(param);
            dynamic.push(false);
          }
        });
        const resultIndexed = topics != null ? __privateGet(this, _abiCoder).decode(indexed, (0, index_js_3.concat)(topics)) : null;
        const resultNonIndexed = __privateGet(this, _abiCoder).decode(nonIndexed, data, true);
        const values = [];
        const keys = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        fragment.inputs.forEach((param, index5) => {
          let value = null;
          if (param.indexed) {
            if (resultIndexed == null) {
              value = new Indexed(null);
            } else if (dynamic[index5]) {
              value = new Indexed(resultIndexed[indexedIndex++]);
            } else {
              try {
                value = resultIndexed[indexedIndex++];
              } catch (error) {
                value = error;
              }
            }
          } else {
            try {
              value = resultNonIndexed[nonIndexedIndex++];
            } catch (error) {
              value = error;
            }
          }
          values.push(value);
          keys.push(param.name || null);
        });
        return abstract_coder_js_1.Result.fromItems(values, keys);
      }
      /**
       *  Parses a transaction, finding the matching function and extracts
       *  the parameter values along with other useful function details.
       *
       *  If the matching function cannot be found, return null.
       */
      parseTransaction(tx) {
        const data = (0, index_js_3.getBytes)(tx.data, "tx.data");
        const value = (0, index_js_3.getBigInt)(tx.value != null ? tx.value : 0, "tx.value");
        const fragment = this.getFunction((0, index_js_3.hexlify)(data.slice(0, 4)));
        if (!fragment) {
          return null;
        }
        const args = __privateGet(this, _abiCoder).decode(fragment.inputs, data.slice(4));
        return new TransactionDescription(fragment, fragment.selector, args, value);
      }
      parseCallResult(data) {
        throw new Error("@TODO");
      }
      /**
       *  Parses a receipt log, finding the matching event and extracts
       *  the parameter values along with other useful event details.
       *
       *  If the matching event cannot be found, returns null.
       */
      parseLog(log) {
        const fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
          return null;
        }
        return new LogDescription(fragment, fragment.topicHash, this.decodeEventLog(fragment, log.data, log.topics));
      }
      /**
       *  Parses a revert data, finding the matching error and extracts
       *  the parameter values along with other useful error details.
       *
       *  If the matching error cannot be found, returns null.
       */
      parseError(data) {
        const hexData = (0, index_js_3.hexlify)(data);
        const fragment = this.getError((0, index_js_3.dataSlice)(hexData, 0, 4));
        if (!fragment) {
          return null;
        }
        const args = __privateGet(this, _abiCoder).decode(fragment.inputs, (0, index_js_3.dataSlice)(hexData, 4));
        return new ErrorDescription(fragment, fragment.selector, args);
      }
      /**
       *  Creates a new [[Interface]] from the ABI %%value%%.
       *
       *  The %%value%% may be provided as an existing [[Interface]] object,
       *  a JSON-encoded ABI or any Human-Readable ABI format.
       */
      static from(value) {
        if (value instanceof _Interface) {
          return value;
        }
        if (typeof value === "string") {
          return new _Interface(JSON.parse(value));
        }
        if (typeof value.formatJson === "function") {
          return new _Interface(value.formatJson());
        }
        if (typeof value.format === "function") {
          return new _Interface(value.format("json"));
        }
        return new _Interface(value);
      }
    };
    _errors = new WeakMap();
    _events = new WeakMap();
    _functions = new WeakMap();
    _abiCoder = new WeakMap();
    _Interface_instances = new WeakSet();
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction_fn = function(key, values, forceUnique) {
      if ((0, index_js_3.isHexString)(key)) {
        const selector = key.toLowerCase();
        for (const fragment of __privateGet(this, _functions).values()) {
          if (selector === fragment.selector) {
            return fragment;
          }
        }
        return null;
      }
      if (key.indexOf("(") === -1) {
        const matching = [];
        for (const [name, fragment] of __privateGet(this, _functions)) {
          if (name.split(
            "("
            /* fix:) */
          )[0] === key) {
            matching.push(fragment);
          }
        }
        if (values) {
          const lastValue = values.length > 0 ? values[values.length - 1] : null;
          let valueLength = values.length;
          let allowOptions = true;
          if (typed_js_1.Typed.isTyped(lastValue) && lastValue.type === "overrides") {
            allowOptions = false;
            valueLength--;
          }
          for (let i2 = matching.length - 1; i2 >= 0; i2--) {
            const inputs = matching[i2].inputs.length;
            if (inputs !== valueLength && (!allowOptions || inputs !== valueLength - 1)) {
              matching.splice(i2, 1);
            }
          }
          for (let i2 = matching.length - 1; i2 >= 0; i2--) {
            const inputs = matching[i2].inputs;
            for (let j3 = 0; j3 < values.length; j3++) {
              if (!typed_js_1.Typed.isTyped(values[j3])) {
                continue;
              }
              if (j3 >= inputs.length) {
                if (values[j3].type === "overrides") {
                  continue;
                }
                matching.splice(i2, 1);
                break;
              }
              if (values[j3].type !== inputs[j3].baseType) {
                matching.splice(i2, 1);
                break;
              }
            }
          }
        }
        if (matching.length === 1 && values && values.length !== matching[0].inputs.length) {
          const lastArg = values[values.length - 1];
          if (lastArg == null || Array.isArray(lastArg) || typeof lastArg !== "object") {
            matching.splice(0, 1);
          }
        }
        if (matching.length === 0) {
          return null;
        }
        if (matching.length > 1 && forceUnique) {
          const matchStr = matching.map((m3) => JSON.stringify(m3.format())).join(", ");
          (0, index_js_3.assertArgument)(false, `ambiguous function description (i.e. matches ${matchStr})`, "key", key);
        }
        return matching[0];
      }
      const result = __privateGet(this, _functions).get(fragments_js_1.FunctionFragment.from(key).format());
      if (result) {
        return result;
      }
      return null;
    };
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent_fn = function(key, values, forceUnique) {
      if ((0, index_js_3.isHexString)(key)) {
        const eventTopic = key.toLowerCase();
        for (const fragment of __privateGet(this, _events).values()) {
          if (eventTopic === fragment.topicHash) {
            return fragment;
          }
        }
        return null;
      }
      if (key.indexOf("(") === -1) {
        const matching = [];
        for (const [name, fragment] of __privateGet(this, _events)) {
          if (name.split(
            "("
            /* fix:) */
          )[0] === key) {
            matching.push(fragment);
          }
        }
        if (values) {
          for (let i2 = matching.length - 1; i2 >= 0; i2--) {
            if (matching[i2].inputs.length < values.length) {
              matching.splice(i2, 1);
            }
          }
          for (let i2 = matching.length - 1; i2 >= 0; i2--) {
            const inputs = matching[i2].inputs;
            for (let j3 = 0; j3 < values.length; j3++) {
              if (!typed_js_1.Typed.isTyped(values[j3])) {
                continue;
              }
              if (values[j3].type !== inputs[j3].baseType) {
                matching.splice(i2, 1);
                break;
              }
            }
          }
        }
        if (matching.length === 0) {
          return null;
        }
        if (matching.length > 1 && forceUnique) {
          const matchStr = matching.map((m3) => JSON.stringify(m3.format())).join(", ");
          (0, index_js_3.assertArgument)(false, `ambiguous event description (i.e. matches ${matchStr})`, "key", key);
        }
        return matching[0];
      }
      const result = __privateGet(this, _events).get(fragments_js_1.EventFragment.from(key).format());
      if (result) {
        return result;
      }
      return null;
    };
    var Interface = _Interface;
    exports.Interface = Interface;
  }
});

// node_modules/ethers/lib.commonjs/abi/index.js
var require_abi = __commonJS({
  "node_modules/ethers/lib.commonjs/abi/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Typed = exports.Result = exports.TransactionDescription = exports.LogDescription = exports.ErrorDescription = exports.Interface = exports.Indexed = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.Fragment = exports.FallbackFragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.encodeBytes32String = exports.decodeBytes32String = exports.AbiCoder = void 0;
    var abi_coder_js_1 = require_abi_coder();
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return abi_coder_js_1.AbiCoder;
    } });
    var bytes32_js_1 = require_bytes32();
    Object.defineProperty(exports, "decodeBytes32String", { enumerable: true, get: function() {
      return bytes32_js_1.decodeBytes32String;
    } });
    Object.defineProperty(exports, "encodeBytes32String", { enumerable: true, get: function() {
      return bytes32_js_1.encodeBytes32String;
    } });
    var fragments_js_1 = require_fragments();
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return fragments_js_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return fragments_js_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return fragments_js_1.EventFragment;
    } });
    Object.defineProperty(exports, "FallbackFragment", { enumerable: true, get: function() {
      return fragments_js_1.FallbackFragment;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return fragments_js_1.Fragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return fragments_js_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "NamedFragment", { enumerable: true, get: function() {
      return fragments_js_1.NamedFragment;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return fragments_js_1.ParamType;
    } });
    Object.defineProperty(exports, "StructFragment", { enumerable: true, get: function() {
      return fragments_js_1.StructFragment;
    } });
    var interface_js_1 = require_interface();
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return interface_js_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return interface_js_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return interface_js_1.Interface;
    } });
    Object.defineProperty(exports, "ErrorDescription", { enumerable: true, get: function() {
      return interface_js_1.ErrorDescription;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return interface_js_1.LogDescription;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return interface_js_1.TransactionDescription;
    } });
    Object.defineProperty(exports, "Result", { enumerable: true, get: function() {
      return interface_js_1.Result;
    } });
    var typed_js_1 = require_typed();
    Object.defineProperty(exports, "Typed", { enumerable: true, get: function() {
      return typed_js_1.Typed;
    } });
  }
});

// node_modules/ethers/lib.commonjs/providers/provider.js
var require_provider = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.Block = exports.copyRequest = exports.FeeData = void 0;
    var index_js_1 = require_utils5();
    var index_js_2 = require_transaction2();
    var BN_0 = BigInt(0);
    function getValue2(value) {
      if (value == null) {
        return null;
      }
      return value;
    }
    function toJson(value) {
      if (value == null) {
        return null;
      }
      return value.toString();
    }
    var FeeData = class {
      /**
       *  Creates a new FeeData for %%gasPrice%%, %%maxFeePerGas%% and
       *  %%maxPriorityFeePerGas%%.
       */
      constructor(gasPrice, maxFeePerGas, maxPriorityFeePerGas) {
        /**
         *  The gas price for legacy networks.
         */
        __publicField(this, "gasPrice");
        /**
         *  The maximum fee to pay per gas.
         *
         *  The base fee per gas is defined by the network and based on
         *  congestion, increasing the cost during times of heavy load
         *  and lowering when less busy.
         *
         *  The actual fee per gas will be the base fee for the block
         *  and the priority fee, up to the max fee per gas.
         *
         *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
         */
        __publicField(this, "maxFeePerGas");
        /**
         *  The additional amout to pay per gas to encourage a validator
         *  to include the transaction.
         *
         *  The purpose of this is to compensate the validator for the
         *  adjusted risk for including a given transaction.
         *
         *  This will be ``null`` on legacy networks (i.e. [pre-EIP-1559](link-eip-1559))
         */
        __publicField(this, "maxPriorityFeePerGas");
        (0, index_js_1.defineProperties)(this, {
          gasPrice: getValue2(gasPrice),
          maxFeePerGas: getValue2(maxFeePerGas),
          maxPriorityFeePerGas: getValue2(maxPriorityFeePerGas)
        });
      }
      /**
       *  Returns a JSON-friendly value.
       */
      toJSON() {
        const { gasPrice, maxFeePerGas, maxPriorityFeePerGas } = this;
        return {
          _type: "FeeData",
          gasPrice: toJson(gasPrice),
          maxFeePerGas: toJson(maxFeePerGas),
          maxPriorityFeePerGas: toJson(maxPriorityFeePerGas)
        };
      }
    };
    exports.FeeData = FeeData;
    function copyRequest(req) {
      const result = {};
      if (req.to) {
        result.to = req.to;
      }
      if (req.from) {
        result.from = req.from;
      }
      if (req.data) {
        result.data = (0, index_js_1.hexlify)(req.data);
      }
      const bigIntKeys = "chainId,gasLimit,gasPrice,maxFeePerBlobGas,maxFeePerGas,maxPriorityFeePerGas,value".split(/,/);
      for (const key of bigIntKeys) {
        if (!(key in req) || req[key] == null) {
          continue;
        }
        result[key] = (0, index_js_1.getBigInt)(req[key], `request.${key}`);
      }
      const numberKeys = "type,nonce".split(/,/);
      for (const key of numberKeys) {
        if (!(key in req) || req[key] == null) {
          continue;
        }
        result[key] = (0, index_js_1.getNumber)(req[key], `request.${key}`);
      }
      if (req.accessList) {
        result.accessList = (0, index_js_2.accessListify)(req.accessList);
      }
      if ("blockTag" in req) {
        result.blockTag = req.blockTag;
      }
      if ("enableCcipRead" in req) {
        result.enableCcipRead = !!req.enableCcipRead;
      }
      if ("customData" in req) {
        result.customData = req.customData;
      }
      if ("blobVersionedHashes" in req && req.blobVersionedHashes) {
        result.blobVersionedHashes = req.blobVersionedHashes.slice();
      }
      if ("kzg" in req) {
        result.kzg = req.kzg;
      }
      if ("blobs" in req && req.blobs) {
        result.blobs = req.blobs.map((b4) => {
          if ((0, index_js_1.isBytesLike)(b4)) {
            return (0, index_js_1.hexlify)(b4);
          }
          return Object.assign({}, b4);
        });
      }
      return result;
    }
    exports.copyRequest = copyRequest;
    var _transactions;
    var Block = class {
      /**
       *  Create a new **Block** object.
       *
       *  This should generally not be necessary as the unless implementing a
       *  low-level library.
       */
      constructor(block, provider) {
        /**
         *  The provider connected to the block used to fetch additional details
         *  if necessary.
         */
        __publicField(this, "provider");
        /**
         *  The block number, sometimes called the block height. This is a
         *  sequential number that is one higher than the parent block.
         */
        __publicField(this, "number");
        /**
         *  The block hash.
         *
         *  This hash includes all properties, so can be safely used to identify
         *  an exact set of block properties.
         */
        __publicField(this, "hash");
        /**
         *  The timestamp for this block, which is the number of seconds since
         *  epoch that this block was included.
         */
        __publicField(this, "timestamp");
        /**
         *  The block hash of the parent block.
         */
        __publicField(this, "parentHash");
        /**
         *  The hash tree root of the parent beacon block for the given
         *  execution block. See [[link-eip-4788]].
         */
        __publicField(this, "parentBeaconBlockRoot");
        /**
         *  The nonce.
         *
         *  On legacy networks, this is the random number inserted which
         *  permitted the difficulty target to be reached.
         */
        __publicField(this, "nonce");
        /**
         *  The difficulty target.
         *
         *  On legacy networks, this is the proof-of-work target required
         *  for a block to meet the protocol rules to be included.
         *
         *  On modern networks, this is a random number arrived at using
         *  randao.  @TODO: Find links?
         */
        __publicField(this, "difficulty");
        /**
         *  The total gas limit for this block.
         */
        __publicField(this, "gasLimit");
        /**
         *  The total gas used in this block.
         */
        __publicField(this, "gasUsed");
        /**
         *  The root hash for the global state after applying changes
         *  in this block.
         */
        __publicField(this, "stateRoot");
        /**
         *  The hash of the transaction receipts trie.
         */
        __publicField(this, "receiptsRoot");
        /**
         *  The total amount of blob gas consumed by the transactions
         *  within the block. See [[link-eip-4844]].
         */
        __publicField(this, "blobGasUsed");
        /**
         *  The running total of blob gas consumed in excess of the
         *  target, prior to the block. See [[link-eip-4844]].
         */
        __publicField(this, "excessBlobGas");
        /**
         *  The miner coinbase address, wihch receives any subsidies for
         *  including this block.
         */
        __publicField(this, "miner");
        /**
         *  The latest RANDAO mix of the post beacon state of
         *  the previous block.
         */
        __publicField(this, "prevRandao");
        /**
         *  Any extra data the validator wished to include.
         */
        __publicField(this, "extraData");
        /**
         *  The base fee per gas that all transactions in this block were
         *  charged.
         *
         *  This adjusts after each block, depending on how congested the network
         *  is.
         */
        __publicField(this, "baseFeePerGas");
        __privateAdd(this, _transactions);
        __privateSet(this, _transactions, block.transactions.map((tx) => {
          if (typeof tx !== "string") {
            return new TransactionResponse(tx, provider);
          }
          return tx;
        }));
        (0, index_js_1.defineProperties)(this, {
          provider,
          hash: getValue2(block.hash),
          number: block.number,
          timestamp: block.timestamp,
          parentHash: block.parentHash,
          parentBeaconBlockRoot: block.parentBeaconBlockRoot,
          nonce: block.nonce,
          difficulty: block.difficulty,
          gasLimit: block.gasLimit,
          gasUsed: block.gasUsed,
          blobGasUsed: block.blobGasUsed,
          excessBlobGas: block.excessBlobGas,
          miner: block.miner,
          prevRandao: getValue2(block.prevRandao),
          extraData: block.extraData,
          baseFeePerGas: getValue2(block.baseFeePerGas),
          stateRoot: block.stateRoot,
          receiptsRoot: block.receiptsRoot
        });
      }
      /**
       *  Returns the list of transaction hashes, in the order
       *  they were executed within the block.
       */
      get transactions() {
        return __privateGet(this, _transactions).map((tx) => {
          if (typeof tx === "string") {
            return tx;
          }
          return tx.hash;
        });
      }
      /**
       *  Returns the complete transactions, in the order they
       *  were executed within the block.
       *
       *  This is only available for blocks which prefetched
       *  transactions, by passing ``true`` to %%prefetchTxs%%
       *  into [[Provider-getBlock]].
       */
      get prefetchedTransactions() {
        const txs = __privateGet(this, _transactions).slice();
        if (txs.length === 0) {
          return [];
        }
        (0, index_js_1.assert)(typeof txs[0] === "object", "transactions were not prefetched with block request", "UNSUPPORTED_OPERATION", {
          operation: "transactionResponses()"
        });
        return txs;
      }
      /**
       *  Returns a JSON-friendly value.
       */
      toJSON() {
        const { baseFeePerGas, difficulty, extraData, gasLimit, gasUsed, hash: hash8, miner, prevRandao, nonce, number: number2, parentHash, parentBeaconBlockRoot, stateRoot, receiptsRoot, timestamp, transactions } = this;
        return {
          _type: "Block",
          baseFeePerGas: toJson(baseFeePerGas),
          difficulty: toJson(difficulty),
          extraData,
          gasLimit: toJson(gasLimit),
          gasUsed: toJson(gasUsed),
          blobGasUsed: toJson(this.blobGasUsed),
          excessBlobGas: toJson(this.excessBlobGas),
          hash: hash8,
          miner,
          prevRandao,
          nonce,
          number: number2,
          parentHash,
          timestamp,
          parentBeaconBlockRoot,
          stateRoot,
          receiptsRoot,
          transactions
        };
      }
      [Symbol.iterator]() {
        let index5 = 0;
        const txs = this.transactions;
        return {
          next: () => {
            if (index5 < this.length) {
              return {
                value: txs[index5++],
                done: false
              };
            }
            return { value: void 0, done: true };
          }
        };
      }
      /**
       *  The number of transactions in this block.
       */
      get length() {
        return __privateGet(this, _transactions).length;
      }
      /**
       *  The [[link-js-date]] this block was included at.
       */
      get date() {
        if (this.timestamp == null) {
          return null;
        }
        return new Date(this.timestamp * 1e3);
      }
      /**
       *  Get the transaction at %%indexe%% within this block.
       */
      async getTransaction(indexOrHash) {
        let tx = void 0;
        if (typeof indexOrHash === "number") {
          tx = __privateGet(this, _transactions)[indexOrHash];
        } else {
          const hash8 = indexOrHash.toLowerCase();
          for (const v2 of __privateGet(this, _transactions)) {
            if (typeof v2 === "string") {
              if (v2 !== hash8) {
                continue;
              }
              tx = v2;
              break;
            } else {
              if (v2.hash !== hash8) {
                continue;
              }
              tx = v2;
              break;
            }
          }
        }
        if (tx == null) {
          throw new Error("no such tx");
        }
        if (typeof tx === "string") {
          return await this.provider.getTransaction(tx);
        } else {
          return tx;
        }
      }
      /**
       *  If a **Block** was fetched with a request to include the transactions
       *  this will allow synchronous access to those transactions.
       *
       *  If the transactions were not prefetched, this will throw.
       */
      getPrefetchedTransaction(indexOrHash) {
        const txs = this.prefetchedTransactions;
        if (typeof indexOrHash === "number") {
          return txs[indexOrHash];
        }
        indexOrHash = indexOrHash.toLowerCase();
        for (const tx of txs) {
          if (tx.hash === indexOrHash) {
            return tx;
          }
        }
        (0, index_js_1.assertArgument)(false, "no matching transaction", "indexOrHash", indexOrHash);
      }
      /**
       *  Returns true if this block been mined. This provides a type guard
       *  for all properties on a [[MinedBlock]].
       */
      isMined() {
        return !!this.hash;
      }
      /**
       *  Returns true if this block is an [[link-eip-2930]] block.
       */
      isLondon() {
        return !!this.baseFeePerGas;
      }
      /**
       *  @_ignore:
       */
      orphanedEvent() {
        if (!this.isMined()) {
          throw new Error("");
        }
        return createOrphanedBlockFilter(this);
      }
    };
    _transactions = new WeakMap();
    exports.Block = Block;
    var Log = class {
      /**
       *  @_ignore:
       */
      constructor(log, provider) {
        /**
         *  The provider connected to the log used to fetch additional details
         *  if necessary.
         */
        __publicField(this, "provider");
        /**
         *  The transaction hash of the transaction this log occurred in. Use the
         *  [[Log-getTransaction]] to get the [[TransactionResponse]].
         */
        __publicField(this, "transactionHash");
        /**
         *  The block hash of the block this log occurred in. Use the
         *  [[Log-getBlock]] to get the [[Block]].
         */
        __publicField(this, "blockHash");
        /**
         *  The block number of the block this log occurred in. It is preferred
         *  to use the [[Block-hash]] when fetching the related [[Block]],
         *  since in the case of an orphaned block, the block at that height may
         *  have changed.
         */
        __publicField(this, "blockNumber");
        /**
         *  If the **Log** represents a block that was removed due to an orphaned
         *  block, this will be true.
         *
         *  This can only happen within an orphan event listener.
         */
        __publicField(this, "removed");
        /**
         *  The address of the contract that emitted this log.
         */
        __publicField(this, "address");
        /**
         *  The data included in this log when it was emitted.
         */
        __publicField(this, "data");
        /**
         *  The indexed topics included in this log when it was emitted.
         *
         *  All topics are included in the bloom filters, so they can be
         *  efficiently filtered using the [[Provider-getLogs]] method.
         */
        __publicField(this, "topics");
        /**
         *  The index within the block this log occurred at. This is generally
         *  not useful to developers, but can be used with the various roots
         *  to proof inclusion within a block.
         */
        __publicField(this, "index");
        /**
         *  The index within the transaction of this log.
         */
        __publicField(this, "transactionIndex");
        this.provider = provider;
        const topics = Object.freeze(log.topics.slice());
        (0, index_js_1.defineProperties)(this, {
          transactionHash: log.transactionHash,
          blockHash: log.blockHash,
          blockNumber: log.blockNumber,
          removed: log.removed,
          address: log.address,
          data: log.data,
          topics,
          index: log.index,
          transactionIndex: log.transactionIndex
        });
      }
      /**
       *  Returns a JSON-compatible object.
       */
      toJSON() {
        const { address, blockHash, blockNumber, data, index: index5, removed, topics, transactionHash, transactionIndex } = this;
        return {
          _type: "log",
          address,
          blockHash,
          blockNumber,
          data,
          index: index5,
          removed,
          topics,
          transactionHash,
          transactionIndex
        };
      }
      /**
       *  Returns the block that this log occurred in.
       */
      async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        (0, index_js_1.assert)(!!block, "failed to find transaction", "UNKNOWN_ERROR", {});
        return block;
      }
      /**
       *  Returns the transaction that this log occurred in.
       */
      async getTransaction() {
        const tx = await this.provider.getTransaction(this.transactionHash);
        (0, index_js_1.assert)(!!tx, "failed to find transaction", "UNKNOWN_ERROR", {});
        return tx;
      }
      /**
       *  Returns the transaction receipt fot the transaction that this
       *  log occurred in.
       */
      async getTransactionReceipt() {
        const receipt = await this.provider.getTransactionReceipt(this.transactionHash);
        (0, index_js_1.assert)(!!receipt, "failed to find transaction receipt", "UNKNOWN_ERROR", {});
        return receipt;
      }
      /**
       *  @_ignore:
       */
      removedEvent() {
        return createRemovedLogFilter(this);
      }
    };
    exports.Log = Log;
    var _logs;
    var TransactionReceipt = class {
      /**
       *  @_ignore:
       */
      constructor(tx, provider) {
        /**
         *  The provider connected to the log used to fetch additional details
         *  if necessary.
         */
        __publicField(this, "provider");
        /**
         *  The address the transaction was sent to.
         */
        __publicField(this, "to");
        /**
         *  The sender of the transaction.
         */
        __publicField(this, "from");
        /**
         *  The address of the contract if the transaction was directly
         *  responsible for deploying one.
         *
         *  This is non-null **only** if the ``to`` is empty and the ``data``
         *  was successfully executed as initcode.
         */
        __publicField(this, "contractAddress");
        /**
         *  The transaction hash.
         */
        __publicField(this, "hash");
        /**
         *  The index of this transaction within the block transactions.
         */
        __publicField(this, "index");
        /**
         *  The block hash of the [[Block]] this transaction was included in.
         */
        __publicField(this, "blockHash");
        /**
         *  The block number of the [[Block]] this transaction was included in.
         */
        __publicField(this, "blockNumber");
        /**
         *  The bloom filter bytes that represent all logs that occurred within
         *  this transaction. This is generally not useful for most developers,
         *  but can be used to validate the included logs.
         */
        __publicField(this, "logsBloom");
        /**
         *  The actual amount of gas used by this transaction.
         *
         *  When creating a transaction, the amount of gas that will be used can
         *  only be approximated, but the sender must pay the gas fee for the
         *  entire gas limit. After the transaction, the difference is refunded.
         */
        __publicField(this, "gasUsed");
        /**
         *  The gas used for BLObs. See [[link-eip-4844]].
         */
        __publicField(this, "blobGasUsed");
        /**
         *  The amount of gas used by all transactions within the block for this
         *  and all transactions with a lower ``index``.
         *
         *  This is generally not useful for developers but can be used to
         *  validate certain aspects of execution.
         */
        __publicField(this, "cumulativeGasUsed");
        /**
         *  The actual gas price used during execution.
         *
         *  Due to the complexity of [[link-eip-1559]] this value can only
         *  be caluclated after the transaction has been mined, snce the base
         *  fee is protocol-enforced.
         */
        __publicField(this, "gasPrice");
        /**
         *  The price paid per BLOB in gas. See [[link-eip-4844]].
         */
        __publicField(this, "blobGasPrice");
        /**
         *  The [[link-eip-2718]] transaction type.
         */
        __publicField(this, "type");
        //readonly byzantium!: boolean;
        /**
         *  The status of this transaction, indicating success (i.e. ``1``) or
         *  a revert (i.e. ``0``).
         *
         *  This is available in post-byzantium blocks, but some backends may
         *  backfill this value.
         */
        __publicField(this, "status");
        /**
         *  The root hash of this transaction.
         *
         *  This is no present and was only included in pre-byzantium blocks, but
         *  could be used to validate certain parts of the receipt.
         */
        __publicField(this, "root");
        __privateAdd(this, _logs);
        __privateSet(this, _logs, Object.freeze(tx.logs.map((log) => {
          return new Log(log, provider);
        })));
        let gasPrice = BN_0;
        if (tx.effectiveGasPrice != null) {
          gasPrice = tx.effectiveGasPrice;
        } else if (tx.gasPrice != null) {
          gasPrice = tx.gasPrice;
        }
        (0, index_js_1.defineProperties)(this, {
          provider,
          to: tx.to,
          from: tx.from,
          contractAddress: tx.contractAddress,
          hash: tx.hash,
          index: tx.index,
          blockHash: tx.blockHash,
          blockNumber: tx.blockNumber,
          logsBloom: tx.logsBloom,
          gasUsed: tx.gasUsed,
          cumulativeGasUsed: tx.cumulativeGasUsed,
          blobGasUsed: tx.blobGasUsed,
          gasPrice,
          blobGasPrice: tx.blobGasPrice,
          type: tx.type,
          //byzantium: tx.byzantium,
          status: tx.status,
          root: tx.root
        });
      }
      /**
       *  The logs for this transaction.
       */
      get logs() {
        return __privateGet(this, _logs);
      }
      /**
       *  Returns a JSON-compatible representation.
       */
      toJSON() {
        const {
          to: to4,
          from: from26,
          contractAddress,
          hash: hash8,
          index: index5,
          blockHash,
          blockNumber,
          logsBloom,
          logs,
          //byzantium, 
          status,
          root: root2
        } = this;
        return {
          _type: "TransactionReceipt",
          blockHash,
          blockNumber,
          //byzantium, 
          contractAddress,
          cumulativeGasUsed: toJson(this.cumulativeGasUsed),
          from: from26,
          gasPrice: toJson(this.gasPrice),
          blobGasUsed: toJson(this.blobGasUsed),
          blobGasPrice: toJson(this.blobGasPrice),
          gasUsed: toJson(this.gasUsed),
          hash: hash8,
          index: index5,
          logs,
          logsBloom,
          root: root2,
          status,
          to: to4
        };
      }
      /**
       *  @_ignore:
       */
      get length() {
        return this.logs.length;
      }
      [Symbol.iterator]() {
        let index5 = 0;
        return {
          next: () => {
            if (index5 < this.length) {
              return { value: this.logs[index5++], done: false };
            }
            return { value: void 0, done: true };
          }
        };
      }
      /**
       *  The total fee for this transaction, in wei.
       */
      get fee() {
        return this.gasUsed * this.gasPrice;
      }
      /**
       *  Resolves to the block this transaction occurred in.
       */
      async getBlock() {
        const block = await this.provider.getBlock(this.blockHash);
        if (block == null) {
          throw new Error("TODO");
        }
        return block;
      }
      /**
       *  Resolves to the transaction this transaction occurred in.
       */
      async getTransaction() {
        const tx = await this.provider.getTransaction(this.hash);
        if (tx == null) {
          throw new Error("TODO");
        }
        return tx;
      }
      /**
       *  Resolves to the return value of the execution of this transaction.
       *
       *  Support for this feature is limited, as it requires an archive node
       *  with the ``debug_`` or ``trace_`` API enabled.
       */
      async getResult() {
        return await this.provider.getTransactionResult(this.hash);
      }
      /**
       *  Resolves to the number of confirmations this transaction has.
       */
      async confirmations() {
        return await this.provider.getBlockNumber() - this.blockNumber + 1;
      }
      /**
       *  @_ignore:
       */
      removedEvent() {
        return createRemovedTransactionFilter(this);
      }
      /**
       *  @_ignore:
       */
      reorderedEvent(other) {
        (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transction cannot be orphaned", "UNSUPPORTED_OPERATION", { operation: "reorderedEvent(other)" });
        return createReorderedTransactionFilter(this, other);
      }
    };
    _logs = new WeakMap();
    exports.TransactionReceipt = TransactionReceipt;
    var _startBlock;
    var _TransactionResponse = class _TransactionResponse {
      /**
       *  @_ignore:
       */
      constructor(tx, provider) {
        /**
         *  The provider this is connected to, which will influence how its
         *  methods will resolve its async inspection methods.
         */
        __publicField(this, "provider");
        /**
         *  The block number of the block that this transaction was included in.
         *
         *  This is ``null`` for pending transactions.
         */
        __publicField(this, "blockNumber");
        /**
         *  The blockHash of the block that this transaction was included in.
         *
         *  This is ``null`` for pending transactions.
         */
        __publicField(this, "blockHash");
        /**
         *  The index within the block that this transaction resides at.
         */
        __publicField(this, "index");
        /**
         *  The transaction hash.
         */
        __publicField(this, "hash");
        /**
         *  The [[link-eip-2718]] transaction envelope type. This is
         *  ``0`` for legacy transactions types.
         */
        __publicField(this, "type");
        /**
         *  The receiver of this transaction.
         *
         *  If ``null``, then the transaction is an initcode transaction.
         *  This means the result of executing the [[data]] will be deployed
         *  as a new contract on chain (assuming it does not revert) and the
         *  address may be computed using [[getCreateAddress]].
         */
        __publicField(this, "to");
        /**
         *  The sender of this transaction. It is implicitly computed
         *  from the transaction pre-image hash (as the digest) and the
         *  [[signature]] using ecrecover.
         */
        __publicField(this, "from");
        /**
         *  The nonce, which is used to prevent replay attacks and offer
         *  a method to ensure transactions from a given sender are explicitly
         *  ordered.
         *
         *  When sending a transaction, this must be equal to the number of
         *  transactions ever sent by [[from]].
         */
        __publicField(this, "nonce");
        /**
         *  The maximum units of gas this transaction can consume. If execution
         *  exceeds this, the entries transaction is reverted and the sender
         *  is charged for the full amount, despite not state changes being made.
         */
        __publicField(this, "gasLimit");
        /**
         *  The gas price can have various values, depending on the network.
         *
         *  In modern networks, for transactions that are included this is
         *  the //effective gas price// (the fee per gas that was actually
         *  charged), while for transactions that have not been included yet
         *  is the [[maxFeePerGas]].
         *
         *  For legacy transactions, or transactions on legacy networks, this
         *  is the fee that will be charged per unit of gas the transaction
         *  consumes.
         */
        __publicField(this, "gasPrice");
        /**
         *  The maximum priority fee (per unit of gas) to allow a
         *  validator to charge the sender. This is inclusive of the
         *  [[maxFeeFeePerGas]].
         */
        __publicField(this, "maxPriorityFeePerGas");
        /**
         *  The maximum fee (per unit of gas) to allow this transaction
         *  to charge the sender.
         */
        __publicField(this, "maxFeePerGas");
        /**
         *  The [[link-eip-4844]] max fee per BLOb gas.
         */
        __publicField(this, "maxFeePerBlobGas");
        /**
         *  The data.
         */
        __publicField(this, "data");
        /**
         *  The value, in wei. Use [[formatEther]] to format this value
         *  as ether.
         */
        __publicField(this, "value");
        /**
         *  The chain ID.
         */
        __publicField(this, "chainId");
        /**
         *  The signature.
         */
        __publicField(this, "signature");
        /**
         *  The [[link-eip-2930]] access list for transaction types that
         *  support it, otherwise ``null``.
         */
        __publicField(this, "accessList");
        /**
         *  The [[link-eip-4844]] BLOb versioned hashes.
         */
        __publicField(this, "blobVersionedHashes");
        __privateAdd(this, _startBlock);
        this.provider = provider;
        this.blockNumber = tx.blockNumber != null ? tx.blockNumber : null;
        this.blockHash = tx.blockHash != null ? tx.blockHash : null;
        this.hash = tx.hash;
        this.index = tx.index;
        this.type = tx.type;
        this.from = tx.from;
        this.to = tx.to || null;
        this.gasLimit = tx.gasLimit;
        this.nonce = tx.nonce;
        this.data = tx.data;
        this.value = tx.value;
        this.gasPrice = tx.gasPrice;
        this.maxPriorityFeePerGas = tx.maxPriorityFeePerGas != null ? tx.maxPriorityFeePerGas : null;
        this.maxFeePerGas = tx.maxFeePerGas != null ? tx.maxFeePerGas : null;
        this.maxFeePerBlobGas = tx.maxFeePerBlobGas != null ? tx.maxFeePerBlobGas : null;
        this.chainId = tx.chainId;
        this.signature = tx.signature;
        this.accessList = tx.accessList != null ? tx.accessList : null;
        this.blobVersionedHashes = tx.blobVersionedHashes != null ? tx.blobVersionedHashes : null;
        __privateSet(this, _startBlock, -1);
      }
      /**
       *  Returns a JSON-compatible representation of this transaction.
       */
      toJSON() {
        const { blockNumber, blockHash, index: index5, hash: hash8, type: type6, to: to4, from: from26, nonce, data, signature, accessList, blobVersionedHashes } = this;
        return {
          _type: "TransactionResponse",
          accessList,
          blockNumber,
          blockHash,
          blobVersionedHashes,
          chainId: toJson(this.chainId),
          data,
          from: from26,
          gasLimit: toJson(this.gasLimit),
          gasPrice: toJson(this.gasPrice),
          hash: hash8,
          maxFeePerGas: toJson(this.maxFeePerGas),
          maxPriorityFeePerGas: toJson(this.maxPriorityFeePerGas),
          maxFeePerBlobGas: toJson(this.maxFeePerBlobGas),
          nonce,
          signature,
          to: to4,
          index: index5,
          type: type6,
          value: toJson(this.value)
        };
      }
      /**
       *  Resolves to the Block that this transaction was included in.
       *
       *  This will return null if the transaction has not been included yet.
       */
      async getBlock() {
        let blockNumber = this.blockNumber;
        if (blockNumber == null) {
          const tx = await this.getTransaction();
          if (tx) {
            blockNumber = tx.blockNumber;
          }
        }
        if (blockNumber == null) {
          return null;
        }
        const block = this.provider.getBlock(blockNumber);
        if (block == null) {
          throw new Error("TODO");
        }
        return block;
      }
      /**
       *  Resolves to this transaction being re-requested from the
       *  provider. This can be used if you have an unmined transaction
       *  and wish to get an up-to-date populated instance.
       */
      async getTransaction() {
        return this.provider.getTransaction(this.hash);
      }
      /**
       *  Resolve to the number of confirmations this transaction has.
       */
      async confirmations() {
        if (this.blockNumber == null) {
          const { tx, blockNumber: blockNumber2 } = await (0, index_js_1.resolveProperties)({
            tx: this.getTransaction(),
            blockNumber: this.provider.getBlockNumber()
          });
          if (tx == null || tx.blockNumber == null) {
            return 0;
          }
          return blockNumber2 - tx.blockNumber + 1;
        }
        const blockNumber = await this.provider.getBlockNumber();
        return blockNumber - this.blockNumber + 1;
      }
      /**
       *  Resolves once this transaction has been mined and has
       *  %%confirms%% blocks including it (default: ``1``) with an
       *  optional %%timeout%%.
       *
       *  This can resolve to ``null`` only if %%confirms%% is ``0``
       *  and the transaction has not been mined, otherwise this will
       *  wait until enough confirmations have completed.
       */
      async wait(_confirms, _timeout) {
        const confirms = _confirms == null ? 1 : _confirms;
        const timeout = _timeout == null ? 0 : _timeout;
        let startBlock = __privateGet(this, _startBlock);
        let nextScan = -1;
        let stopScanning = startBlock === -1 ? true : false;
        const checkReplacement = async () => {
          if (stopScanning) {
            return null;
          }
          const { blockNumber, nonce } = await (0, index_js_1.resolveProperties)({
            blockNumber: this.provider.getBlockNumber(),
            nonce: this.provider.getTransactionCount(this.from)
          });
          if (nonce < this.nonce) {
            startBlock = blockNumber;
            return;
          }
          if (stopScanning) {
            return null;
          }
          const mined = await this.getTransaction();
          if (mined && mined.blockNumber != null) {
            return;
          }
          if (nextScan === -1) {
            nextScan = startBlock - 3;
            if (nextScan < __privateGet(this, _startBlock)) {
              nextScan = __privateGet(this, _startBlock);
            }
          }
          while (nextScan <= blockNumber) {
            if (stopScanning) {
              return null;
            }
            const block = await this.provider.getBlock(nextScan, true);
            if (block == null) {
              return;
            }
            for (const hash8 of block) {
              if (hash8 === this.hash) {
                return;
              }
            }
            for (let i2 = 0; i2 < block.length; i2++) {
              const tx = await block.getTransaction(i2);
              if (tx.from === this.from && tx.nonce === this.nonce) {
                if (stopScanning) {
                  return null;
                }
                const receipt2 = await this.provider.getTransactionReceipt(tx.hash);
                if (receipt2 == null) {
                  return;
                }
                if (blockNumber - receipt2.blockNumber + 1 < confirms) {
                  return;
                }
                let reason = "replaced";
                if (tx.data === this.data && tx.to === this.to && tx.value === this.value) {
                  reason = "repriced";
                } else if (tx.data === "0x" && tx.from === tx.to && tx.value === BN_0) {
                  reason = "cancelled";
                }
                (0, index_js_1.assert)(false, "transaction was replaced", "TRANSACTION_REPLACED", {
                  cancelled: reason === "replaced" || reason === "cancelled",
                  reason,
                  replacement: tx.replaceableTransaction(startBlock),
                  hash: tx.hash,
                  receipt: receipt2
                });
              }
            }
            nextScan++;
          }
          return;
        };
        const checkReceipt = (receipt2) => {
          if (receipt2 == null || receipt2.status !== 0) {
            return receipt2;
          }
          (0, index_js_1.assert)(false, "transaction execution reverted", "CALL_EXCEPTION", {
            action: "sendTransaction",
            data: null,
            reason: null,
            invocation: null,
            revert: null,
            transaction: {
              to: receipt2.to,
              from: receipt2.from,
              data: ""
              // @TODO: in v7, split out sendTransaction properties
            },
            receipt: receipt2
          });
        };
        const receipt = await this.provider.getTransactionReceipt(this.hash);
        if (confirms === 0) {
          return checkReceipt(receipt);
        }
        if (receipt) {
          if (await receipt.confirmations() >= confirms) {
            return checkReceipt(receipt);
          }
        } else {
          await checkReplacement();
          if (confirms === 0) {
            return null;
          }
        }
        const waiter = new Promise((resolve, reject) => {
          const cancellers = [];
          const cancel = () => {
            cancellers.forEach((c3) => c3());
          };
          cancellers.push(() => {
            stopScanning = true;
          });
          if (timeout > 0) {
            const timer = setTimeout(() => {
              cancel();
              reject((0, index_js_1.makeError)("wait for transaction timeout", "TIMEOUT"));
            }, timeout);
            cancellers.push(() => {
              clearTimeout(timer);
            });
          }
          const txListener = async (receipt2) => {
            if (await receipt2.confirmations() >= confirms) {
              cancel();
              try {
                resolve(checkReceipt(receipt2));
              } catch (error) {
                reject(error);
              }
            }
          };
          cancellers.push(() => {
            this.provider.off(this.hash, txListener);
          });
          this.provider.on(this.hash, txListener);
          if (startBlock >= 0) {
            const replaceListener = async () => {
              try {
                await checkReplacement();
              } catch (error) {
                if ((0, index_js_1.isError)(error, "TRANSACTION_REPLACED")) {
                  cancel();
                  reject(error);
                  return;
                }
              }
              if (!stopScanning) {
                this.provider.once("block", replaceListener);
              }
            };
            cancellers.push(() => {
              this.provider.off("block", replaceListener);
            });
            this.provider.once("block", replaceListener);
          }
        });
        return await waiter;
      }
      /**
       *  Returns ``true`` if this transaction has been included.
       *
       *  This is effective only as of the time the TransactionResponse
       *  was instantiated. To get up-to-date information, use
       *  [[getTransaction]].
       *
       *  This provides a Type Guard that this transaction will have
       *  non-null property values for properties that are null for
       *  unmined transactions.
       */
      isMined() {
        return this.blockHash != null;
      }
      /**
       *  Returns true if the transaction is a legacy (i.e. ``type == 0``)
       *  transaction.
       *
       *  This provides a Type Guard that this transaction will have
       *  the ``null``-ness for hardfork-specific properties set correctly.
       */
      isLegacy() {
        return this.type === 0;
      }
      /**
       *  Returns true if the transaction is a Berlin (i.e. ``type == 1``)
       *  transaction. See [[link-eip-2070]].
       *
       *  This provides a Type Guard that this transaction will have
       *  the ``null``-ness for hardfork-specific properties set correctly.
       */
      isBerlin() {
        return this.type === 1;
      }
      /**
       *  Returns true if the transaction is a London (i.e. ``type == 2``)
       *  transaction. See [[link-eip-1559]].
       *
       *  This provides a Type Guard that this transaction will have
       *  the ``null``-ness for hardfork-specific properties set correctly.
       */
      isLondon() {
        return this.type === 2;
      }
      /**
       *  Returns true if hte transaction is a Cancun (i.e. ``type == 3``)
       *  transaction. See [[link-eip-4844]].
       */
      isCancun() {
        return this.type === 3;
      }
      /**
       *  Returns a filter which can be used to listen for orphan events
       *  that evict this transaction.
       */
      removedEvent() {
        (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createRemovedTransactionFilter(this);
      }
      /**
       *  Returns a filter which can be used to listen for orphan events
       *  that re-order this event against %%other%%.
       */
      reorderedEvent(other) {
        (0, index_js_1.assert)(this.isMined(), "unmined transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        (0, index_js_1.assert)(!other || other.isMined(), "unmined 'other' transaction canot be orphaned", "UNSUPPORTED_OPERATION", { operation: "removeEvent()" });
        return createReorderedTransactionFilter(this, other);
      }
      /**
       *  Returns a new TransactionResponse instance which has the ability to
       *  detect (and throw an error) if the transaction is replaced, which
       *  will begin scanning at %%startBlock%%.
       *
       *  This should generally not be used by developers and is intended
       *  primarily for internal use. Setting an incorrect %%startBlock%% can
       *  have devastating performance consequences if used incorrectly.
       */
      replaceableTransaction(startBlock) {
        (0, index_js_1.assertArgument)(Number.isInteger(startBlock) && startBlock >= 0, "invalid startBlock", "startBlock", startBlock);
        const tx = new _TransactionResponse(this, this.provider);
        __privateSet(tx, _startBlock, startBlock);
        return tx;
      }
    };
    _startBlock = new WeakMap();
    var TransactionResponse = _TransactionResponse;
    exports.TransactionResponse = TransactionResponse;
    function createOrphanedBlockFilter(block) {
      return { orphan: "drop-block", hash: block.hash, number: block.number };
    }
    function createReorderedTransactionFilter(tx, other) {
      return { orphan: "reorder-transaction", tx, other };
    }
    function createRemovedTransactionFilter(tx) {
      return { orphan: "drop-transaction", tx };
    }
    function createRemovedLogFilter(log) {
      return { orphan: "drop-log", log: {
        transactionHash: log.transactionHash,
        blockHash: log.blockHash,
        blockNumber: log.blockNumber,
        address: log.address,
        data: log.data,
        topics: Object.freeze(log.topics.slice()),
        index: log.index
      } };
    }
  }
});

// node_modules/ethers/lib.commonjs/contract/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/ethers/lib.commonjs/contract/wrappers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContractEventPayload = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.UndecodedEventLog = exports.EventLog = void 0;
    var provider_js_1 = require_provider();
    var index_js_1 = require_utils5();
    var EventLog = class extends provider_js_1.Log {
      /**
       * @_ignore:
       */
      constructor(log, iface, fragment) {
        super(log, log.provider);
        /**
         *  The Contract Interface.
         */
        __publicField(this, "interface");
        /**
         *  The matching event.
         */
        __publicField(this, "fragment");
        /**
         *  The parsed arguments passed to the event by ``emit``.
         */
        __publicField(this, "args");
        const args = iface.decodeEventLog(fragment, log.data, log.topics);
        (0, index_js_1.defineProperties)(this, { args, fragment, interface: iface });
      }
      /**
       *  The name of the event.
       */
      get eventName() {
        return this.fragment.name;
      }
      /**
       *  The signature of the event.
       */
      get eventSignature() {
        return this.fragment.format();
      }
    };
    exports.EventLog = EventLog;
    var UndecodedEventLog = class extends provider_js_1.Log {
      /**
       * @_ignore:
       */
      constructor(log, error) {
        super(log, log.provider);
        /**
         *  The error encounted when trying to decode the log.
         */
        __publicField(this, "error");
        (0, index_js_1.defineProperties)(this, { error });
      }
    };
    exports.UndecodedEventLog = UndecodedEventLog;
    var _iface;
    var ContractTransactionReceipt = class extends provider_js_1.TransactionReceipt {
      /**
       *  @_ignore:
       */
      constructor(iface, provider, tx) {
        super(tx, provider);
        __privateAdd(this, _iface);
        __privateSet(this, _iface, iface);
      }
      /**
       *  The parsed logs for any [[Log]] which has a matching event in the
       *  Contract ABI.
       */
      get logs() {
        return super.logs.map((log) => {
          const fragment = log.topics.length ? __privateGet(this, _iface).getEvent(log.topics[0]) : null;
          if (fragment) {
            try {
              return new EventLog(log, __privateGet(this, _iface), fragment);
            } catch (error) {
              return new UndecodedEventLog(log, error);
            }
          }
          return log;
        });
      }
    };
    _iface = new WeakMap();
    exports.ContractTransactionReceipt = ContractTransactionReceipt;
    var _iface2;
    var ContractTransactionResponse = class extends provider_js_1.TransactionResponse {
      /**
       *  @_ignore:
       */
      constructor(iface, provider, tx) {
        super(tx, provider);
        __privateAdd(this, _iface2);
        __privateSet(this, _iface2, iface);
      }
      /**
       *  Resolves once this transaction has been mined and has
       *  %%confirms%% blocks including it (default: ``1``) with an
       *  optional %%timeout%%.
       *
       *  This can resolve to ``null`` only if %%confirms%% is ``0``
       *  and the transaction has not been mined, otherwise this will
       *  wait until enough confirmations have completed.
       */
      async wait(confirms, timeout) {
        const receipt = await super.wait(confirms, timeout);
        if (receipt == null) {
          return null;
        }
        return new ContractTransactionReceipt(__privateGet(this, _iface2), this.provider, receipt);
      }
    };
    _iface2 = new WeakMap();
    exports.ContractTransactionResponse = ContractTransactionResponse;
    var ContractUnknownEventPayload = class extends index_js_1.EventPayload {
      /**
       *  @_event:
       */
      constructor(contract, listener, filter3, log) {
        super(contract, listener, filter3);
        /**
         *  The log with no matching events.
         */
        __publicField(this, "log");
        (0, index_js_1.defineProperties)(this, { log });
      }
      /**
       *  Resolves to the block the event occured in.
       */
      async getBlock() {
        return await this.log.getBlock();
      }
      /**
       *  Resolves to the transaction the event occured in.
       */
      async getTransaction() {
        return await this.log.getTransaction();
      }
      /**
       *  Resolves to the transaction receipt the event occured in.
       */
      async getTransactionReceipt() {
        return await this.log.getTransactionReceipt();
      }
    };
    exports.ContractUnknownEventPayload = ContractUnknownEventPayload;
    var ContractEventPayload = class extends ContractUnknownEventPayload {
      /**
       *  @_ignore:
       */
      constructor(contract, listener, filter3, fragment, _log) {
        super(contract, listener, filter3, new EventLog(_log, contract.interface, fragment));
        const args = contract.interface.decodeEventLog(fragment, this.log.data, this.log.topics);
        (0, index_js_1.defineProperties)(this, { args, fragment });
      }
      /**
       *  The event name.
       */
      get eventName() {
        return this.fragment.name;
      }
      /**
       *  The event signature.
       */
      get eventSignature() {
        return this.fragment.format();
      }
    };
    exports.ContractEventPayload = ContractEventPayload;
  }
});

// node_modules/ethers/lib.commonjs/contract/contract.js
var require_contract = __commonJS({
  "node_modules/ethers/lib.commonjs/contract/contract.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Contract = exports.BaseContract = exports.resolveArgs = exports.copyOverrides = void 0;
    var index_js_1 = require_abi();
    var index_js_2 = require_address2();
    var provider_js_1 = require_provider();
    var index_js_3 = require_utils5();
    var wrappers_js_1 = require_wrappers();
    var BN_0 = BigInt(0);
    function canCall(value) {
      return value && typeof value.call === "function";
    }
    function canEstimate(value) {
      return value && typeof value.estimateGas === "function";
    }
    function canResolve(value) {
      return value && typeof value.resolveName === "function";
    }
    function canSend(value) {
      return value && typeof value.sendTransaction === "function";
    }
    function getResolver(value) {
      if (value != null) {
        if (canResolve(value)) {
          return value;
        }
        if (value.provider) {
          return value.provider;
        }
      }
      return void 0;
    }
    var _filter;
    var PreparedTopicFilter = class {
      constructor(contract, fragment, args) {
        __privateAdd(this, _filter);
        __publicField(this, "fragment");
        (0, index_js_3.defineProperties)(this, { fragment });
        if (fragment.inputs.length < args.length) {
          throw new Error("too many arguments");
        }
        const runner = getRunner(contract.runner, "resolveName");
        const resolver = canResolve(runner) ? runner : null;
        __privateSet(this, _filter, async function() {
          const resolvedArgs = await Promise.all(fragment.inputs.map((param, index5) => {
            const arg = args[index5];
            if (arg == null) {
              return null;
            }
            return param.walkAsync(args[index5], (type6, value) => {
              if (type6 === "address") {
                if (Array.isArray(value)) {
                  return Promise.all(value.map((v2) => (0, index_js_2.resolveAddress)(v2, resolver)));
                }
                return (0, index_js_2.resolveAddress)(value, resolver);
              }
              return value;
            });
          }));
          return contract.interface.encodeFilterTopics(fragment, resolvedArgs);
        }());
      }
      getTopicFilter() {
        return __privateGet(this, _filter);
      }
    };
    _filter = new WeakMap();
    function getRunner(value, feature) {
      if (value == null) {
        return null;
      }
      if (typeof value[feature] === "function") {
        return value;
      }
      if (value.provider && typeof value.provider[feature] === "function") {
        return value.provider;
      }
      return null;
    }
    function getProvider(value) {
      if (value == null) {
        return null;
      }
      return value.provider || null;
    }
    async function copyOverrides(arg, allowed) {
      const _overrides = index_js_1.Typed.dereference(arg, "overrides");
      (0, index_js_3.assertArgument)(typeof _overrides === "object", "invalid overrides parameter", "overrides", arg);
      const overrides = (0, provider_js_1.copyRequest)(_overrides);
      (0, index_js_3.assertArgument)(overrides.to == null || (allowed || []).indexOf("to") >= 0, "cannot override to", "overrides.to", overrides.to);
      (0, index_js_3.assertArgument)(overrides.data == null || (allowed || []).indexOf("data") >= 0, "cannot override data", "overrides.data", overrides.data);
      if (overrides.from) {
        overrides.from = overrides.from;
      }
      return overrides;
    }
    exports.copyOverrides = copyOverrides;
    async function resolveArgs(_runner, inputs, args) {
      const runner = getRunner(_runner, "resolveName");
      const resolver = canResolve(runner) ? runner : null;
      return await Promise.all(inputs.map((param, index5) => {
        return param.walkAsync(args[index5], (type6, value) => {
          value = index_js_1.Typed.dereference(value, type6);
          if (type6 === "address") {
            return (0, index_js_2.resolveAddress)(value, resolver);
          }
          return value;
        });
      }));
    }
    exports.resolveArgs = resolveArgs;
    function buildWrappedFallback(contract) {
      const populateTransaction = async function(overrides) {
        const tx = await copyOverrides(overrides, ["data"]);
        tx.to = await contract.getAddress();
        if (tx.from) {
          tx.from = await (0, index_js_2.resolveAddress)(tx.from, getResolver(contract.runner));
        }
        const iface = contract.interface;
        const noValue = (0, index_js_3.getBigInt)(tx.value || BN_0, "overrides.value") === BN_0;
        const noData = (tx.data || "0x") === "0x";
        if (iface.fallback && !iface.fallback.payable && iface.receive && !noData && !noValue) {
          (0, index_js_3.assertArgument)(false, "cannot send data to receive or send value to non-payable fallback", "overrides", overrides);
        }
        (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
        const payable = iface.receive || iface.fallback && iface.fallback.payable;
        (0, index_js_3.assertArgument)(payable || noValue, "cannot send value to non-payable fallback", "overrides.value", tx.value);
        (0, index_js_3.assertArgument)(iface.fallback || noData, "cannot send data to receive-only contract", "overrides.data", tx.data);
        return tx;
      };
      const staticCall = async function(overrides) {
        const runner = getRunner(contract.runner, "call");
        (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
        const tx = await populateTransaction(overrides);
        try {
          return await runner.call(tx);
        } catch (error) {
          if ((0, index_js_3.isCallException)(error) && error.data) {
            throw contract.interface.makeError(error.data, tx);
          }
          throw error;
        }
      };
      const send = async function(overrides) {
        const runner = contract.runner;
        (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
        const tx = await runner.sendTransaction(await populateTransaction(overrides));
        const provider = getProvider(contract.runner);
        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);
      };
      const estimateGas4 = async function(overrides) {
        const runner = getRunner(contract.runner, "estimateGas");
        (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
        return await runner.estimateGas(await populateTransaction(overrides));
      };
      const method = async (overrides) => {
        return await send(overrides);
      };
      (0, index_js_3.defineProperties)(method, {
        _contract: contract,
        estimateGas: estimateGas4,
        populateTransaction,
        send,
        staticCall
      });
      return method;
    }
    function buildWrappedMethod(contract, key) {
      const getFragment = function(...args) {
        const fragment = contract.interface.getFunction(key, args);
        (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key, args }
        });
        return fragment;
      };
      const populateTransaction = async function(...args) {
        const fragment = getFragment(...args);
        let overrides = {};
        if (fragment.inputs.length + 1 === args.length) {
          overrides = await copyOverrides(args.pop());
          if (overrides.from) {
            overrides.from = await (0, index_js_2.resolveAddress)(overrides.from, getResolver(contract.runner));
          }
        }
        if (fragment.inputs.length !== args.length) {
          throw new Error("internal error: fragment inputs doesn't match arguments; should not happen");
        }
        const resolvedArgs = await resolveArgs(contract.runner, fragment.inputs, args);
        return Object.assign({}, overrides, await (0, index_js_3.resolveProperties)({
          to: contract.getAddress(),
          data: contract.interface.encodeFunctionData(fragment, resolvedArgs)
        }));
      };
      const staticCall = async function(...args) {
        const result = await staticCallResult(...args);
        if (result.length === 1) {
          return result[0];
        }
        return result;
      };
      const send = async function(...args) {
        const runner = contract.runner;
        (0, index_js_3.assert)(canSend(runner), "contract runner does not support sending transactions", "UNSUPPORTED_OPERATION", { operation: "sendTransaction" });
        const tx = await runner.sendTransaction(await populateTransaction(...args));
        const provider = getProvider(contract.runner);
        return new wrappers_js_1.ContractTransactionResponse(contract.interface, provider, tx);
      };
      const estimateGas4 = async function(...args) {
        const runner = getRunner(contract.runner, "estimateGas");
        (0, index_js_3.assert)(canEstimate(runner), "contract runner does not support gas estimation", "UNSUPPORTED_OPERATION", { operation: "estimateGas" });
        return await runner.estimateGas(await populateTransaction(...args));
      };
      const staticCallResult = async function(...args) {
        const runner = getRunner(contract.runner, "call");
        (0, index_js_3.assert)(canCall(runner), "contract runner does not support calling", "UNSUPPORTED_OPERATION", { operation: "call" });
        const tx = await populateTransaction(...args);
        let result = "0x";
        try {
          result = await runner.call(tx);
        } catch (error) {
          if ((0, index_js_3.isCallException)(error) && error.data) {
            throw contract.interface.makeError(error.data, tx);
          }
          throw error;
        }
        const fragment = getFragment(...args);
        return contract.interface.decodeFunctionResult(fragment, result);
      };
      const method = async (...args) => {
        const fragment = getFragment(...args);
        if (fragment.constant) {
          return await staticCall(...args);
        }
        return await send(...args);
      };
      (0, index_js_3.defineProperties)(method, {
        name: contract.interface.getFunctionName(key),
        _contract: contract,
        _key: key,
        getFragment,
        estimateGas: estimateGas4,
        populateTransaction,
        send,
        staticCall,
        staticCallResult
      });
      Object.defineProperty(method, "fragment", {
        configurable: false,
        enumerable: true,
        get: () => {
          const fragment = contract.interface.getFunction(key);
          (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key }
          });
          return fragment;
        }
      });
      return method;
    }
    function buildWrappedEvent(contract, key) {
      const getFragment = function(...args) {
        const fragment = contract.interface.getEvent(key, args);
        (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
          operation: "fragment",
          info: { key, args }
        });
        return fragment;
      };
      const method = function(...args) {
        return new PreparedTopicFilter(contract, getFragment(...args), args);
      };
      (0, index_js_3.defineProperties)(method, {
        name: contract.interface.getEventName(key),
        _contract: contract,
        _key: key,
        getFragment
      });
      Object.defineProperty(method, "fragment", {
        configurable: false,
        enumerable: true,
        get: () => {
          const fragment = contract.interface.getEvent(key);
          (0, index_js_3.assert)(fragment, "no matching fragment", "UNSUPPORTED_OPERATION", {
            operation: "fragment",
            info: { key }
          });
          return fragment;
        }
      });
      return method;
    }
    var internal = Symbol.for("_ethersInternal_contract");
    var internalValues = /* @__PURE__ */ new WeakMap();
    function setInternal(contract, values) {
      internalValues.set(contract[internal], values);
    }
    function getInternal(contract) {
      return internalValues.get(contract[internal]);
    }
    function isDeferred(value) {
      return value && typeof value === "object" && "getTopicFilter" in value && typeof value.getTopicFilter === "function" && value.fragment;
    }
    async function getSubInfo(contract, event) {
      let topics;
      let fragment = null;
      if (Array.isArray(event)) {
        const topicHashify = function(name) {
          if ((0, index_js_3.isHexString)(name, 32)) {
            return name;
          }
          const fragment2 = contract.interface.getEvent(name);
          (0, index_js_3.assertArgument)(fragment2, "unknown fragment", "name", name);
          return fragment2.topicHash;
        };
        topics = event.map((e2) => {
          if (e2 == null) {
            return null;
          }
          if (Array.isArray(e2)) {
            return e2.map(topicHashify);
          }
          return topicHashify(e2);
        });
      } else if (event === "*") {
        topics = [null];
      } else if (typeof event === "string") {
        if ((0, index_js_3.isHexString)(event, 32)) {
          topics = [event];
        } else {
          fragment = contract.interface.getEvent(event);
          (0, index_js_3.assertArgument)(fragment, "unknown fragment", "event", event);
          topics = [fragment.topicHash];
        }
      } else if (isDeferred(event)) {
        topics = await event.getTopicFilter();
      } else if ("fragment" in event) {
        fragment = event.fragment;
        topics = [fragment.topicHash];
      } else {
        (0, index_js_3.assertArgument)(false, "unknown event name", "event", event);
      }
      topics = topics.map((t2) => {
        if (t2 == null) {
          return null;
        }
        if (Array.isArray(t2)) {
          const items = Array.from(new Set(t2.map((t3) => t3.toLowerCase())).values());
          if (items.length === 1) {
            return items[0];
          }
          items.sort();
          return items;
        }
        return t2.toLowerCase();
      });
      const tag = topics.map((t2) => {
        if (t2 == null) {
          return "null";
        }
        if (Array.isArray(t2)) {
          return t2.join("|");
        }
        return t2;
      }).join("&");
      return { fragment, tag, topics };
    }
    async function hasSub(contract, event) {
      const { subs } = getInternal(contract);
      return subs.get((await getSubInfo(contract, event)).tag) || null;
    }
    async function getSub(contract, operation, event) {
      const provider = getProvider(contract.runner);
      (0, index_js_3.assert)(provider, "contract runner does not support subscribing", "UNSUPPORTED_OPERATION", { operation });
      const { fragment, tag, topics } = await getSubInfo(contract, event);
      const { addr, subs } = getInternal(contract);
      let sub = subs.get(tag);
      if (!sub) {
        const address = addr ? addr : contract;
        const filter3 = { address, topics };
        const listener = (log) => {
          let foundFragment = fragment;
          if (foundFragment == null) {
            try {
              foundFragment = contract.interface.getEvent(log.topics[0]);
            } catch (error) {
            }
          }
          if (foundFragment) {
            const _foundFragment = foundFragment;
            const args = fragment ? contract.interface.decodeEventLog(fragment, log.data, log.topics) : [];
            emit(contract, event, args, (listener2) => {
              return new wrappers_js_1.ContractEventPayload(contract, listener2, event, _foundFragment, log);
            });
          } else {
            emit(contract, event, [], (listener2) => {
              return new wrappers_js_1.ContractUnknownEventPayload(contract, listener2, event, log);
            });
          }
        };
        let starting = [];
        const start = () => {
          if (starting.length) {
            return;
          }
          starting.push(provider.on(filter3, listener));
        };
        const stop = async () => {
          if (starting.length == 0) {
            return;
          }
          let started = starting;
          starting = [];
          await Promise.all(started);
          provider.off(filter3, listener);
        };
        sub = { tag, listeners: [], start, stop };
        subs.set(tag, sub);
      }
      return sub;
    }
    var lastEmit = Promise.resolve();
    async function _emit(contract, event, args, payloadFunc) {
      await lastEmit;
      const sub = await hasSub(contract, event);
      if (!sub) {
        return false;
      }
      const count = sub.listeners.length;
      sub.listeners = sub.listeners.filter(({ listener, once }) => {
        const passArgs = Array.from(args);
        if (payloadFunc) {
          passArgs.push(payloadFunc(once ? null : listener));
        }
        try {
          listener.call(contract, ...passArgs);
        } catch (error) {
        }
        return !once;
      });
      if (sub.listeners.length === 0) {
        sub.stop();
        getInternal(contract).subs.delete(sub.tag);
      }
      return count > 0;
    }
    async function emit(contract, event, args, payloadFunc) {
      try {
        await lastEmit;
      } catch (error) {
      }
      const resultPromise = _emit(contract, event, args, payloadFunc);
      lastEmit = resultPromise;
      return await resultPromise;
    }
    var passProperties = ["then"];
    var _a2;
    _a2 = internal;
    var _BaseContract = class _BaseContract {
      /**
       *  Creates a new contract connected to %%target%% with the %%abi%% and
       *  optionally connected to a %%runner%% to perform operations on behalf
       *  of.
       */
      constructor(target, abi, runner, _deployTx) {
        /**
         *  The target to connect to.
         *
         *  This can be an address, ENS name or any [[Addressable]], such as
         *  another contract. To get the resovled address, use the ``getAddress``
         *  method.
         */
        __publicField(this, "target");
        /**
         *  The contract Interface.
         */
        __publicField(this, "interface");
        /**
         *  The connected runner. This is generally a [[Provider]] or a
         *  [[Signer]], which dictates what operations are supported.
         *
         *  For example, a **Contract** connected to a [[Provider]] may
         *  only execute read-only operations.
         */
        __publicField(this, "runner");
        /**
         *  All the Events available on this contract.
         */
        __publicField(this, "filters");
        /**
         *  @_ignore:
         */
        __publicField(this, _a2);
        /**
         *  The fallback or receive function if any.
         */
        __publicField(this, "fallback");
        (0, index_js_3.assertArgument)(typeof target === "string" || (0, index_js_2.isAddressable)(target), "invalid value for Contract target", "target", target);
        if (runner == null) {
          runner = null;
        }
        const iface = index_js_1.Interface.from(abi);
        (0, index_js_3.defineProperties)(this, { target, runner, interface: iface });
        Object.defineProperty(this, internal, { value: {} });
        let addrPromise;
        let addr = null;
        let deployTx = null;
        if (_deployTx) {
          const provider = getProvider(runner);
          deployTx = new wrappers_js_1.ContractTransactionResponse(this.interface, provider, _deployTx);
        }
        let subs = /* @__PURE__ */ new Map();
        if (typeof target === "string") {
          if ((0, index_js_3.isHexString)(target)) {
            addr = target;
            addrPromise = Promise.resolve(target);
          } else {
            const resolver = getRunner(runner, "resolveName");
            if (!canResolve(resolver)) {
              throw (0, index_js_3.makeError)("contract runner does not support name resolution", "UNSUPPORTED_OPERATION", {
                operation: "resolveName"
              });
            }
            addrPromise = resolver.resolveName(target).then((addr2) => {
              if (addr2 == null) {
                throw (0, index_js_3.makeError)("an ENS name used for a contract target must be correctly configured", "UNCONFIGURED_NAME", {
                  value: target
                });
              }
              getInternal(this).addr = addr2;
              return addr2;
            });
          }
        } else {
          addrPromise = target.getAddress().then((addr2) => {
            if (addr2 == null) {
              throw new Error("TODO");
            }
            getInternal(this).addr = addr2;
            return addr2;
          });
        }
        setInternal(this, { addrPromise, addr, deployTx, subs });
        const filters = new Proxy({}, {
          get: (target2, prop, receiver) => {
            if (typeof prop === "symbol" || passProperties.indexOf(prop) >= 0) {
              return Reflect.get(target2, prop, receiver);
            }
            try {
              return this.getEvent(prop);
            } catch (error) {
              if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                throw error;
              }
            }
            return void 0;
          },
          has: (target2, prop) => {
            if (passProperties.indexOf(prop) >= 0) {
              return Reflect.has(target2, prop);
            }
            return Reflect.has(target2, prop) || this.interface.hasEvent(String(prop));
          }
        });
        (0, index_js_3.defineProperties)(this, { filters });
        (0, index_js_3.defineProperties)(this, {
          fallback: iface.receive || iface.fallback ? buildWrappedFallback(this) : null
        });
        return new Proxy(this, {
          get: (target2, prop, receiver) => {
            if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
              return Reflect.get(target2, prop, receiver);
            }
            try {
              return target2.getFunction(prop);
            } catch (error) {
              if (!(0, index_js_3.isError)(error, "INVALID_ARGUMENT") || error.argument !== "key") {
                throw error;
              }
            }
            return void 0;
          },
          has: (target2, prop) => {
            if (typeof prop === "symbol" || prop in target2 || passProperties.indexOf(prop) >= 0) {
              return Reflect.has(target2, prop);
            }
            return target2.interface.hasFunction(prop);
          }
        });
      }
      /**
       *  Return a new Contract instance with the same target and ABI, but
       *  a different %%runner%%.
       */
      connect(runner) {
        return new _BaseContract(this.target, this.interface, runner);
      }
      /**
       *  Return a new Contract instance with the same ABI and runner, but
       *  a different %%target%%.
       */
      attach(target) {
        return new _BaseContract(target, this.interface, this.runner);
      }
      /**
       *  Return the resolved address of this Contract.
       */
      async getAddress() {
        return await getInternal(this).addrPromise;
      }
      /**
       *  Return the deployed bytecode or null if no bytecode is found.
       */
      async getDeployedCode() {
        const provider = getProvider(this.runner);
        (0, index_js_3.assert)(provider, "runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "getDeployedCode" });
        const code = await provider.getCode(await this.getAddress());
        if (code === "0x") {
          return null;
        }
        return code;
      }
      /**
       *  Resolve to this Contract once the bytecode has been deployed, or
       *  resolve immediately if already deployed.
       */
      async waitForDeployment() {
        const deployTx = this.deploymentTransaction();
        if (deployTx) {
          await deployTx.wait();
          return this;
        }
        const code = await this.getDeployedCode();
        if (code != null) {
          return this;
        }
        const provider = getProvider(this.runner);
        (0, index_js_3.assert)(provider != null, "contract runner does not support .provider", "UNSUPPORTED_OPERATION", { operation: "waitForDeployment" });
        return new Promise((resolve, reject) => {
          const checkCode = async () => {
            try {
              const code2 = await this.getDeployedCode();
              if (code2 != null) {
                return resolve(this);
              }
              provider.once("block", checkCode);
            } catch (error) {
              reject(error);
            }
          };
          checkCode();
        });
      }
      /**
       *  Return the transaction used to deploy this contract.
       *
       *  This is only available if this instance was returned from a
       *  [[ContractFactory]].
       */
      deploymentTransaction() {
        return getInternal(this).deployTx;
      }
      /**
       *  Return the function for a given name. This is useful when a contract
       *  method name conflicts with a JavaScript name such as ``prototype`` or
       *  when using a Contract programatically.
       */
      getFunction(key) {
        if (typeof key !== "string") {
          key = key.format();
        }
        const func = buildWrappedMethod(this, key);
        return func;
      }
      /**
       *  Return the event for a given name. This is useful when a contract
       *  event name conflicts with a JavaScript name such as ``prototype`` or
       *  when using a Contract programatically.
       */
      getEvent(key) {
        if (typeof key !== "string") {
          key = key.format();
        }
        return buildWrappedEvent(this, key);
      }
      /**
       *  @_ignore:
       */
      async queryTransaction(hash8) {
        throw new Error("@TODO");
      }
      /*
          // @TODO: this is a non-backwards compatible change, but will be added
          //        in v7 and in a potential SmartContract class in an upcoming
          //        v6 release
          async getTransactionReceipt(hash: string): Promise<null | ContractTransactionReceipt> {
              const provider = getProvider(this.runner);
              assert(provider, "contract runner does not have a provider",
                  "UNSUPPORTED_OPERATION", { operation: "queryTransaction" });
      
              const receipt = await provider.getTransactionReceipt(hash);
              if (receipt == null) { return null; }
      
              return new ContractTransactionReceipt(this.interface, provider, receipt);
          }
          */
      /**
       *  Provide historic access to event data for %%event%% in the range
       *  %%fromBlock%% (default: ``0``) to %%toBlock%% (default: ``"latest"``)
       *  inclusive.
       */
      async queryFilter(event, fromBlock, toBlock) {
        if (fromBlock == null) {
          fromBlock = 0;
        }
        if (toBlock == null) {
          toBlock = "latest";
        }
        const { addr, addrPromise } = getInternal(this);
        const address = addr ? addr : await addrPromise;
        const { fragment, topics } = await getSubInfo(this, event);
        const filter3 = { address, topics, fromBlock, toBlock };
        const provider = getProvider(this.runner);
        (0, index_js_3.assert)(provider, "contract runner does not have a provider", "UNSUPPORTED_OPERATION", { operation: "queryFilter" });
        return (await provider.getLogs(filter3)).map((log) => {
          let foundFragment = fragment;
          if (foundFragment == null) {
            try {
              foundFragment = this.interface.getEvent(log.topics[0]);
            } catch (error) {
            }
          }
          if (foundFragment) {
            try {
              return new wrappers_js_1.EventLog(log, this.interface, foundFragment);
            } catch (error) {
              return new wrappers_js_1.UndecodedEventLog(log, error);
            }
          }
          return new provider_js_1.Log(log, provider);
        });
      }
      /**
       *  Add an event %%listener%% for the %%event%%.
       */
      async on(event, listener) {
        const sub = await getSub(this, "on", event);
        sub.listeners.push({ listener, once: false });
        sub.start();
        return this;
      }
      /**
       *  Add an event %%listener%% for the %%event%%, but remove the listener
       *  after it is fired once.
       */
      async once(event, listener) {
        const sub = await getSub(this, "once", event);
        sub.listeners.push({ listener, once: true });
        sub.start();
        return this;
      }
      /**
       *  Emit an %%event%% calling all listeners with %%args%%.
       *
       *  Resolves to ``true`` if any listeners were called.
       */
      async emit(event, ...args) {
        return await emit(this, event, args, null);
      }
      /**
       *  Resolves to the number of listeners of %%event%% or the total number
       *  of listeners if unspecified.
       */
      async listenerCount(event) {
        if (event) {
          const sub = await hasSub(this, event);
          if (!sub) {
            return 0;
          }
          return sub.listeners.length;
        }
        const { subs } = getInternal(this);
        let total = 0;
        for (const { listeners: listeners2 } of subs.values()) {
          total += listeners2.length;
        }
        return total;
      }
      /**
       *  Resolves to the listeners subscribed to %%event%% or all listeners
       *  if unspecified.
       */
      async listeners(event) {
        if (event) {
          const sub = await hasSub(this, event);
          if (!sub) {
            return [];
          }
          return sub.listeners.map(({ listener }) => listener);
        }
        const { subs } = getInternal(this);
        let result = [];
        for (const { listeners: listeners2 } of subs.values()) {
          result = result.concat(listeners2.map(({ listener }) => listener));
        }
        return result;
      }
      /**
       *  Remove the %%listener%% from the listeners for %%event%% or remove
       *  all listeners if unspecified.
       */
      async off(event, listener) {
        const sub = await hasSub(this, event);
        if (!sub) {
          return this;
        }
        if (listener) {
          const index5 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
          if (index5 >= 0) {
            sub.listeners.splice(index5, 1);
          }
        }
        if (listener == null || sub.listeners.length === 0) {
          sub.stop();
          getInternal(this).subs.delete(sub.tag);
        }
        return this;
      }
      /**
       *  Remove all the listeners for %%event%% or remove all listeners if
       *  unspecified.
       */
      async removeAllListeners(event) {
        if (event) {
          const sub = await hasSub(this, event);
          if (!sub) {
            return this;
          }
          sub.stop();
          getInternal(this).subs.delete(sub.tag);
        } else {
          const { subs } = getInternal(this);
          for (const { tag, stop } of subs.values()) {
            stop();
            subs.delete(tag);
          }
        }
        return this;
      }
      /**
       *  Alias for [on].
       */
      async addListener(event, listener) {
        return await this.on(event, listener);
      }
      /**
       *  Alias for [off].
       */
      async removeListener(event, listener) {
        return await this.off(event, listener);
      }
      /**
       *  Create a new Class for the %%abi%%.
       */
      static buildClass(abi) {
        class CustomContract extends _BaseContract {
          constructor(address, runner = null) {
            super(address, abi, runner);
          }
        }
        return CustomContract;
      }
      /**
       *  Create a new BaseContract with a specified Interface.
       */
      static from(target, abi, runner) {
        if (runner == null) {
          runner = null;
        }
        const contract = new this(target, abi, runner);
        return contract;
      }
    };
    var BaseContract = _BaseContract;
    exports.BaseContract = BaseContract;
    function _ContractBase() {
      return BaseContract;
    }
    var Contract = class extends _ContractBase() {
    };
    exports.Contract = Contract;
  }
});

// node_modules/ethers/lib.commonjs/contract/factory.js
var require_factory = __commonJS({
  "node_modules/ethers/lib.commonjs/contract/factory.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ContractFactory = void 0;
    var index_js_1 = require_abi();
    var index_js_2 = require_address2();
    var index_js_3 = require_utils5();
    var contract_js_1 = require_contract();
    var ContractFactory = class _ContractFactory {
      /**
       *  Create a new **ContractFactory** with %%abi%% and %%bytecode%%,
       *  optionally connected to %%runner%%.
       *
       *  The %%bytecode%% may be the ``bytecode`` property within the
       *  standard Solidity JSON output.
       */
      constructor(abi, bytecode, runner) {
        /**
         *  The Contract Interface.
         */
        __publicField(this, "interface");
        /**
         *  The Contract deployment bytecode. Often called the initcode.
         */
        __publicField(this, "bytecode");
        /**
         *  The ContractRunner to deploy the Contract as.
         */
        __publicField(this, "runner");
        const iface = index_js_1.Interface.from(abi);
        if (bytecode instanceof Uint8Array) {
          bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
        } else {
          if (typeof bytecode === "object") {
            bytecode = bytecode.object;
          }
          if (!bytecode.startsWith("0x")) {
            bytecode = "0x" + bytecode;
          }
          bytecode = (0, index_js_3.hexlify)((0, index_js_3.getBytes)(bytecode));
        }
        (0, index_js_3.defineProperties)(this, {
          bytecode,
          interface: iface,
          runner: runner || null
        });
      }
      attach(target) {
        return new contract_js_1.BaseContract(target, this.interface, this.runner);
      }
      /**
       *  Resolves to the transaction to deploy the contract, passing %%args%%
       *  into the constructor.
       */
      async getDeployTransaction(...args) {
        let overrides = {};
        const fragment = this.interface.deploy;
        if (fragment.inputs.length + 1 === args.length) {
          overrides = await (0, contract_js_1.copyOverrides)(args.pop());
        }
        if (fragment.inputs.length !== args.length) {
          throw new Error("incorrect number of arguments to constructor");
        }
        const resolvedArgs = await (0, contract_js_1.resolveArgs)(this.runner, fragment.inputs, args);
        const data = (0, index_js_3.concat)([this.bytecode, this.interface.encodeDeploy(resolvedArgs)]);
        return Object.assign({}, overrides, { data });
      }
      /**
       *  Resolves to the Contract deployed by passing %%args%% into the
       *  constructor.
       *
       *  This will resolve to the Contract before it has been deployed to the
       *  network, so the [[BaseContract-waitForDeployment]] should be used before
       *  sending any transactions to it.
       */
      async deploy(...args) {
        const tx = await this.getDeployTransaction(...args);
        (0, index_js_3.assert)(this.runner && typeof this.runner.sendTransaction === "function", "factory runner does not support sending transactions", "UNSUPPORTED_OPERATION", {
          operation: "sendTransaction"
        });
        const sentTx = await this.runner.sendTransaction(tx);
        const address = (0, index_js_2.getCreateAddress)(sentTx);
        return new contract_js_1.BaseContract(address, this.interface, this.runner, sentTx);
      }
      /**
       *  Return a new **ContractFactory** with the same ABI and bytecode,
       *  but connected to %%runner%%.
       */
      connect(runner) {
        return new _ContractFactory(this.interface, this.bytecode, runner);
      }
      /**
       *  Create a new **ContractFactory** from the standard Solidity JSON output.
       */
      static fromSolidity(output, runner) {
        (0, index_js_3.assertArgument)(output != null, "bad compiler output", "output", output);
        if (typeof output === "string") {
          output = JSON.parse(output);
        }
        const abi = output.abi;
        let bytecode = "";
        if (output.bytecode) {
          bytecode = output.bytecode;
        } else if (output.evm && output.evm.bytecode) {
          bytecode = output.evm.bytecode;
        }
        return new this(abi, bytecode, runner);
      }
    };
    exports.ContractFactory = ContractFactory;
  }
});

// node_modules/ethers/lib.commonjs/contract/index.js
var require_contract2 = __commonJS({
  "node_modules/ethers/lib.commonjs/contract/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.UndecodedEventLog = exports.EventLog = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractUnknownEventPayload = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = void 0;
    var contract_js_1 = require_contract();
    Object.defineProperty(exports, "BaseContract", { enumerable: true, get: function() {
      return contract_js_1.BaseContract;
    } });
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return contract_js_1.Contract;
    } });
    var factory_js_1 = require_factory();
    Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function() {
      return factory_js_1.ContractFactory;
    } });
    var wrappers_js_1 = require_wrappers();
    Object.defineProperty(exports, "ContractEventPayload", { enumerable: true, get: function() {
      return wrappers_js_1.ContractEventPayload;
    } });
    Object.defineProperty(exports, "ContractUnknownEventPayload", { enumerable: true, get: function() {
      return wrappers_js_1.ContractUnknownEventPayload;
    } });
    Object.defineProperty(exports, "ContractTransactionReceipt", { enumerable: true, get: function() {
      return wrappers_js_1.ContractTransactionReceipt;
    } });
    Object.defineProperty(exports, "ContractTransactionResponse", { enumerable: true, get: function() {
      return wrappers_js_1.ContractTransactionResponse;
    } });
    Object.defineProperty(exports, "EventLog", { enumerable: true, get: function() {
      return wrappers_js_1.EventLog;
    } });
    Object.defineProperty(exports, "UndecodedEventLog", { enumerable: true, get: function() {
      return wrappers_js_1.UndecodedEventLog;
    } });
  }
});

// node_modules/ethers/lib.commonjs/providers/ens-resolver.js
var require_ens_resolver = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/ens-resolver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EnsResolver = exports.BasicMulticoinProviderPlugin = exports.MulticoinProviderPlugin = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_constants();
    var index_js_3 = require_contract2();
    var index_js_4 = require_hash();
    var index_js_5 = require_utils5();
    function getIpfsLink(link) {
      if (link.match(/^ipfs:\/\/ipfs\//i)) {
        link = link.substring(12);
      } else if (link.match(/^ipfs:\/\//i)) {
        link = link.substring(7);
      } else {
        (0, index_js_5.assertArgument)(false, "unsupported IPFS format", "link", link);
      }
      return `https://gateway.ipfs.io/ipfs/${link}`;
    }
    var MulticoinProviderPlugin = class {
      /**
       *  Creates a new **MulticoinProviderPluing** for %%name%%.
       */
      constructor(name) {
        /**
         *  The name.
         */
        __publicField(this, "name");
        (0, index_js_5.defineProperties)(this, { name });
      }
      connect(proivder) {
        return this;
      }
      /**
       *  Returns ``true`` if %%coinType%% is supported by this plugin.
       */
      supportsCoinType(coinType) {
        return false;
      }
      /**
       *  Resolves to the encoded %%address%% for %%coinType%%.
       */
      async encodeAddress(coinType, address) {
        throw new Error("unsupported coin");
      }
      /**
       *  Resolves to the decoded %%data%% for %%coinType%%.
       */
      async decodeAddress(coinType, data) {
        throw new Error("unsupported coin");
      }
    };
    exports.MulticoinProviderPlugin = MulticoinProviderPlugin;
    var BasicMulticoinPluginId = "org.ethers.plugins.provider.BasicMulticoin";
    var BasicMulticoinProviderPlugin = class extends MulticoinProviderPlugin {
      /**
       *  Creates a new **BasicMulticoinProviderPlugin**.
       */
      constructor() {
        super(BasicMulticoinPluginId);
      }
    };
    exports.BasicMulticoinProviderPlugin = BasicMulticoinProviderPlugin;
    var matcherIpfs = new RegExp("^(ipfs)://(.*)$", "i");
    var matchers = [
      new RegExp("^(https)://(.*)$", "i"),
      new RegExp("^(data):(.*)$", "i"),
      matcherIpfs,
      new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i")
    ];
    var _supports2544, _resolver, _EnsResolver_instances, fetch_fn, _EnsResolver_static, getResolver_fn;
    var _EnsResolver = class _EnsResolver {
      constructor(provider, address, name) {
        __privateAdd(this, _EnsResolver_instances);
        /**
         *  The connected provider.
         */
        __publicField(this, "provider");
        /**
         *  The address of the resolver.
         */
        __publicField(this, "address");
        /**
         *  The name this resolver was resolved against.
         */
        __publicField(this, "name");
        // For EIP-2544 names, the ancestor that provided the resolver
        __privateAdd(this, _supports2544);
        __privateAdd(this, _resolver);
        (0, index_js_5.defineProperties)(this, { provider, address, name });
        __privateSet(this, _supports2544, null);
        __privateSet(this, _resolver, new index_js_3.Contract(address, [
          "function supportsInterface(bytes4) view returns (bool)",
          "function resolve(bytes, bytes) view returns (bytes)",
          "function addr(bytes32) view returns (address)",
          "function addr(bytes32, uint) view returns (bytes)",
          "function text(bytes32, string) view returns (string)",
          "function contenthash(bytes32) view returns (bytes)"
        ], provider));
      }
      /**
       *  Resolves to true if the resolver supports wildcard resolution.
       */
      async supportsWildcard() {
        if (__privateGet(this, _supports2544) == null) {
          __privateSet(this, _supports2544, (async () => {
            try {
              return await __privateGet(this, _resolver).supportsInterface("0x9061b923");
            } catch (error) {
              if ((0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
                return false;
              }
              __privateSet(this, _supports2544, null);
              throw error;
            }
          })());
        }
        return await __privateGet(this, _supports2544);
      }
      /**
       *  Resolves to the address for %%coinType%% or null if the
       *  provided %%coinType%% has not been configured.
       */
      async getAddress(coinType) {
        if (coinType == null) {
          coinType = 60;
        }
        if (coinType === 60) {
          try {
            const result = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32)");
            if (result == null || result === index_js_2.ZeroAddress) {
              return null;
            }
            return result;
          } catch (error) {
            if ((0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
              return null;
            }
            throw error;
          }
        }
        if (coinType >= 0 && coinType < 2147483648) {
          let ethCoinType = coinType + 2147483648;
          const data2 = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [ethCoinType]);
          if ((0, index_js_5.isHexString)(data2, 20)) {
            return (0, index_js_1.getAddress)(data2);
          }
        }
        let coinPlugin = null;
        for (const plugin of this.provider.plugins) {
          if (!(plugin instanceof MulticoinProviderPlugin)) {
            continue;
          }
          if (plugin.supportsCoinType(coinType)) {
            coinPlugin = plugin;
            break;
          }
        }
        if (coinPlugin == null) {
          return null;
        }
        const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "addr(bytes32,uint)", [coinType]);
        if (data == null || data === "0x") {
          return null;
        }
        const address = await coinPlugin.decodeAddress(coinType, data);
        if (address != null) {
          return address;
        }
        (0, index_js_5.assert)(false, `invalid coin data`, "UNSUPPORTED_OPERATION", {
          operation: `getAddress(${coinType})`,
          info: { coinType, data }
        });
      }
      /**
       *  Resolves to the EIP-634 text record for %%key%%, or ``null``
       *  if unconfigured.
       */
      async getText(key) {
        const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "text(bytes32,string)", [key]);
        if (data == null || data === "0x") {
          return null;
        }
        return data;
      }
      /**
       *  Rsolves to the content-hash or ``null`` if unconfigured.
       */
      async getContentHash() {
        const data = await __privateMethod(this, _EnsResolver_instances, fetch_fn).call(this, "contenthash(bytes32)");
        if (data == null || data === "0x") {
          return null;
        }
        const ipfs = data.match(/^0x(e3010170|e5010172)(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
        if (ipfs) {
          const scheme = ipfs[1] === "e3010170" ? "ipfs" : "ipns";
          const length2 = parseInt(ipfs[4], 16);
          if (ipfs[5].length === length2 * 2) {
            return `${scheme}://${(0, index_js_5.encodeBase58)("0x" + ipfs[2])}`;
          }
        }
        const swarm = data.match(/^0xe40101fa011b20([0-9a-f]*)$/);
        if (swarm && swarm[1].length === 64) {
          return `bzz://${swarm[1]}`;
        }
        (0, index_js_5.assert)(false, `invalid or unsupported content hash data`, "UNSUPPORTED_OPERATION", {
          operation: "getContentHash()",
          info: { data }
        });
      }
      /**
       *  Resolves to the avatar url or ``null`` if the avatar is either
       *  unconfigured or incorrectly configured (e.g. references an NFT
       *  not owned by the address).
       *
       *  If diagnosing issues with configurations, the [[_getAvatar]]
       *  method may be useful.
       */
      async getAvatar() {
        const avatar = await this._getAvatar();
        return avatar.url;
      }
      /**
       *  When resolving an avatar, there are many steps involved, such
       *  fetching metadata and possibly validating ownership of an
       *  NFT.
       *
       *  This method can be used to examine each step and the value it
       *  was working from.
       */
      async _getAvatar() {
        const linkage = [{ type: "name", value: this.name }];
        try {
          const avatar = await this.getText("avatar");
          if (avatar == null) {
            linkage.push({ type: "!avatar", value: "" });
            return { url: null, linkage };
          }
          linkage.push({ type: "avatar", value: avatar });
          for (let i2 = 0; i2 < matchers.length; i2++) {
            const match = avatar.match(matchers[i2]);
            if (match == null) {
              continue;
            }
            const scheme = match[1].toLowerCase();
            switch (scheme) {
              case "https":
              case "data":
                linkage.push({ type: "url", value: avatar });
                return { linkage, url: avatar };
              case "ipfs": {
                const url = getIpfsLink(avatar);
                linkage.push({ type: "ipfs", value: avatar });
                linkage.push({ type: "url", value: url });
                return { linkage, url };
              }
              case "erc721":
              case "erc1155": {
                const selector = scheme === "erc721" ? "tokenURI(uint256)" : "uri(uint256)";
                linkage.push({ type: scheme, value: avatar });
                const owner = await this.getAddress();
                if (owner == null) {
                  linkage.push({ type: "!owner", value: "" });
                  return { url: null, linkage };
                }
                const comps = (match[2] || "").split("/");
                if (comps.length !== 2) {
                  linkage.push({ type: `!${scheme}caip`, value: match[2] || "" });
                  return { url: null, linkage };
                }
                const tokenId = comps[1];
                const contract = new index_js_3.Contract(comps[0], [
                  // ERC-721
                  "function tokenURI(uint) view returns (string)",
                  "function ownerOf(uint) view returns (address)",
                  // ERC-1155
                  "function uri(uint) view returns (string)",
                  "function balanceOf(address, uint256) view returns (uint)"
                ], this.provider);
                if (scheme === "erc721") {
                  const tokenOwner = await contract.ownerOf(tokenId);
                  if (owner !== tokenOwner) {
                    linkage.push({ type: "!owner", value: tokenOwner });
                    return { url: null, linkage };
                  }
                  linkage.push({ type: "owner", value: tokenOwner });
                } else if (scheme === "erc1155") {
                  const balance = await contract.balanceOf(owner, tokenId);
                  if (!balance) {
                    linkage.push({ type: "!balance", value: "0" });
                    return { url: null, linkage };
                  }
                  linkage.push({ type: "balance", value: balance.toString() });
                }
                let metadataUrl = await contract[selector](tokenId);
                if (metadataUrl == null || metadataUrl === "0x") {
                  linkage.push({ type: "!metadata-url", value: "" });
                  return { url: null, linkage };
                }
                linkage.push({ type: "metadata-url-base", value: metadataUrl });
                if (scheme === "erc1155") {
                  metadataUrl = metadataUrl.replace("{id}", (0, index_js_5.toBeHex)(tokenId, 32).substring(2));
                  linkage.push({ type: "metadata-url-expanded", value: metadataUrl });
                }
                if (metadataUrl.match(/^ipfs:/i)) {
                  metadataUrl = getIpfsLink(metadataUrl);
                }
                linkage.push({ type: "metadata-url", value: metadataUrl });
                let metadata = {};
                const response = await new index_js_5.FetchRequest(metadataUrl).send();
                response.assertOk();
                try {
                  metadata = response.bodyJson;
                } catch (error) {
                  try {
                    linkage.push({ type: "!metadata", value: response.bodyText });
                  } catch (error2) {
                    const bytes = response.body;
                    if (bytes) {
                      linkage.push({ type: "!metadata", value: (0, index_js_5.hexlify)(bytes) });
                    }
                    return { url: null, linkage };
                  }
                  return { url: null, linkage };
                }
                if (!metadata) {
                  linkage.push({ type: "!metadata", value: "" });
                  return { url: null, linkage };
                }
                linkage.push({ type: "metadata", value: JSON.stringify(metadata) });
                let imageUrl = metadata.image;
                if (typeof imageUrl !== "string") {
                  linkage.push({ type: "!imageUrl", value: "" });
                  return { url: null, linkage };
                }
                if (imageUrl.match(/^(https:\/\/|data:)/i)) {
                } else {
                  const ipfs = imageUrl.match(matcherIpfs);
                  if (ipfs == null) {
                    linkage.push({ type: "!imageUrl-ipfs", value: imageUrl });
                    return { url: null, linkage };
                  }
                  linkage.push({ type: "imageUrl-ipfs", value: imageUrl });
                  imageUrl = getIpfsLink(imageUrl);
                }
                linkage.push({ type: "url", value: imageUrl });
                return { linkage, url: imageUrl };
              }
            }
          }
        } catch (error) {
        }
        return { linkage, url: null };
      }
      static async getEnsAddress(provider) {
        const network = await provider.getNetwork();
        const ensPlugin = network.getPlugin("org.ethers.plugins.network.Ens");
        (0, index_js_5.assert)(ensPlugin, "network does not support ENS", "UNSUPPORTED_OPERATION", {
          operation: "getEnsAddress",
          info: { network }
        });
        return ensPlugin.address;
      }
      /**
       *  Resolve to the ENS resolver for %%name%% using %%provider%% or
       *  ``null`` if unconfigured.
       */
      static async fromName(provider, name) {
        var _a2;
        let currentName = name;
        while (true) {
          if (currentName === "" || currentName === ".") {
            return null;
          }
          if (name !== "eth" && currentName === "eth") {
            return null;
          }
          const addr = await __privateMethod(_a2 = _EnsResolver, _EnsResolver_static, getResolver_fn).call(_a2, provider, currentName);
          if (addr != null) {
            const resolver = new _EnsResolver(provider, addr, name);
            if (currentName !== name && !await resolver.supportsWildcard()) {
              return null;
            }
            return resolver;
          }
          currentName = currentName.split(".").slice(1).join(".");
        }
      }
    };
    _supports2544 = new WeakMap();
    _resolver = new WeakMap();
    _EnsResolver_instances = new WeakSet();
    fetch_fn = async function(funcName, params) {
      params = (params || []).slice();
      const iface = __privateGet(this, _resolver).interface;
      params.unshift((0, index_js_4.namehash)(this.name));
      let fragment = null;
      if (await this.supportsWildcard()) {
        fragment = iface.getFunction(funcName);
        (0, index_js_5.assert)(fragment, "missing fragment", "UNKNOWN_ERROR", {
          info: { funcName }
        });
        params = [
          (0, index_js_4.dnsEncode)(this.name, 255),
          iface.encodeFunctionData(fragment, params)
        ];
        funcName = "resolve(bytes,bytes)";
      }
      params.push({
        enableCcipRead: true
      });
      try {
        const result = await __privateGet(this, _resolver)[funcName](...params);
        if (fragment) {
          return iface.decodeFunctionResult(fragment, result)[0];
        }
        return result;
      } catch (error) {
        if (!(0, index_js_5.isError)(error, "CALL_EXCEPTION")) {
          throw error;
        }
      }
      return null;
    };
    _EnsResolver_static = new WeakSet();
    getResolver_fn = async function(provider, name) {
      const ensAddr = await _EnsResolver.getEnsAddress(provider);
      try {
        const contract = new index_js_3.Contract(ensAddr, [
          "function resolver(bytes32) view returns (address)"
        ], provider);
        const addr = await contract.resolver((0, index_js_4.namehash)(name), {
          enableCcipRead: true
        });
        if (addr === index_js_2.ZeroAddress) {
          return null;
        }
        return addr;
      } catch (error) {
        throw error;
      }
      return null;
    };
    __privateAdd(_EnsResolver, _EnsResolver_static);
    var EnsResolver = _EnsResolver;
    exports.EnsResolver = EnsResolver;
  }
});

// node_modules/ethers/lib.commonjs/providers/format.js
var require_format = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/format.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.formatTransactionResponse = exports.formatTransactionReceipt = exports.formatReceiptLog = exports.formatBlock = exports.formatLog = exports.formatUint256 = exports.formatHash = exports.formatData = exports.formatBoolean = exports.object = exports.arrayOf = exports.allowNull = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_crypto2();
    var index_js_3 = require_transaction2();
    var index_js_4 = require_utils5();
    var BN_0 = BigInt(0);
    function allowNull(format6, nullValue) {
      return function(value) {
        if (value == null) {
          return nullValue;
        }
        return format6(value);
      };
    }
    exports.allowNull = allowNull;
    function arrayOf(format6, allowNull2) {
      return (array) => {
        if (allowNull2 && array == null) {
          return null;
        }
        if (!Array.isArray(array)) {
          throw new Error("not an array");
        }
        return array.map((i2) => format6(i2));
      };
    }
    exports.arrayOf = arrayOf;
    function object(format6, altNames) {
      return (value) => {
        const result = {};
        for (const key in format6) {
          let srcKey = key;
          if (altNames && key in altNames && !(srcKey in value)) {
            for (const altKey of altNames[key]) {
              if (altKey in value) {
                srcKey = altKey;
                break;
              }
            }
          }
          try {
            const nv = format6[key](value[srcKey]);
            if (nv !== void 0) {
              result[key] = nv;
            }
          } catch (error) {
            const message = error instanceof Error ? error.message : "not-an-error";
            (0, index_js_4.assert)(false, `invalid value for value.${key} (${message})`, "BAD_DATA", { value });
          }
        }
        return result;
      };
    }
    exports.object = object;
    function formatBoolean(value) {
      switch (value) {
        case true:
        case "true":
          return true;
        case false:
        case "false":
          return false;
      }
      (0, index_js_4.assertArgument)(false, `invalid boolean; ${JSON.stringify(value)}`, "value", value);
    }
    exports.formatBoolean = formatBoolean;
    function formatData(value) {
      (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, true), "invalid data", "value", value);
      return value;
    }
    exports.formatData = formatData;
    function formatHash(value) {
      (0, index_js_4.assertArgument)((0, index_js_4.isHexString)(value, 32), "invalid hash", "value", value);
      return value;
    }
    exports.formatHash = formatHash;
    function formatUint256(value) {
      if (!(0, index_js_4.isHexString)(value)) {
        throw new Error("invalid uint256");
      }
      return (0, index_js_4.zeroPadValue)(value, 32);
    }
    exports.formatUint256 = formatUint256;
    var _formatLog = object({
      address: index_js_1.getAddress,
      blockHash: formatHash,
      blockNumber: index_js_4.getNumber,
      data: formatData,
      index: index_js_4.getNumber,
      removed: allowNull(formatBoolean, false),
      topics: arrayOf(formatHash),
      transactionHash: formatHash,
      transactionIndex: index_js_4.getNumber
    }, {
      index: ["logIndex"]
    });
    function formatLog2(value) {
      return _formatLog(value);
    }
    exports.formatLog = formatLog2;
    var _formatBlock = object({
      hash: allowNull(formatHash),
      parentHash: formatHash,
      parentBeaconBlockRoot: allowNull(formatHash, null),
      number: index_js_4.getNumber,
      timestamp: index_js_4.getNumber,
      nonce: allowNull(formatData),
      difficulty: index_js_4.getBigInt,
      gasLimit: index_js_4.getBigInt,
      gasUsed: index_js_4.getBigInt,
      stateRoot: allowNull(formatHash, null),
      receiptsRoot: allowNull(formatHash, null),
      blobGasUsed: allowNull(index_js_4.getBigInt, null),
      excessBlobGas: allowNull(index_js_4.getBigInt, null),
      miner: allowNull(index_js_1.getAddress),
      prevRandao: allowNull(formatHash, null),
      extraData: formatData,
      baseFeePerGas: allowNull(index_js_4.getBigInt)
    }, {
      prevRandao: ["mixHash"]
    });
    function formatBlock(value) {
      const result = _formatBlock(value);
      result.transactions = value.transactions.map((tx) => {
        if (typeof tx === "string") {
          return tx;
        }
        return formatTransactionResponse(tx);
      });
      return result;
    }
    exports.formatBlock = formatBlock;
    var _formatReceiptLog = object({
      transactionIndex: index_js_4.getNumber,
      blockNumber: index_js_4.getNumber,
      transactionHash: formatHash,
      address: index_js_1.getAddress,
      topics: arrayOf(formatHash),
      data: formatData,
      index: index_js_4.getNumber,
      blockHash: formatHash
    }, {
      index: ["logIndex"]
    });
    function formatReceiptLog(value) {
      return _formatReceiptLog(value);
    }
    exports.formatReceiptLog = formatReceiptLog;
    var _formatTransactionReceipt = object({
      to: allowNull(index_js_1.getAddress, null),
      from: allowNull(index_js_1.getAddress, null),
      contractAddress: allowNull(index_js_1.getAddress, null),
      // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
      index: index_js_4.getNumber,
      root: allowNull(index_js_4.hexlify),
      gasUsed: index_js_4.getBigInt,
      blobGasUsed: allowNull(index_js_4.getBigInt, null),
      logsBloom: allowNull(formatData),
      blockHash: formatHash,
      hash: formatHash,
      logs: arrayOf(formatReceiptLog),
      blockNumber: index_js_4.getNumber,
      //confirmations: allowNull(getNumber, null),
      cumulativeGasUsed: index_js_4.getBigInt,
      effectiveGasPrice: allowNull(index_js_4.getBigInt),
      blobGasPrice: allowNull(index_js_4.getBigInt, null),
      status: allowNull(index_js_4.getNumber),
      type: allowNull(index_js_4.getNumber, 0)
    }, {
      effectiveGasPrice: ["gasPrice"],
      hash: ["transactionHash"],
      index: ["transactionIndex"]
    });
    function formatTransactionReceipt(value) {
      return _formatTransactionReceipt(value);
    }
    exports.formatTransactionReceipt = formatTransactionReceipt;
    function formatTransactionResponse(value) {
      if (value.to && (0, index_js_4.getBigInt)(value.to) === BN_0) {
        value.to = "0x0000000000000000000000000000000000000000";
      }
      const result = object({
        hash: formatHash,
        // Some nodes do not return this, usually test nodes (like Ganache)
        index: allowNull(index_js_4.getNumber, void 0),
        type: (value2) => {
          if (value2 === "0x" || value2 == null) {
            return 0;
          }
          return (0, index_js_4.getNumber)(value2);
        },
        accessList: allowNull(index_js_3.accessListify, null),
        blobVersionedHashes: allowNull(arrayOf(formatHash, true), null),
        blockHash: allowNull(formatHash, null),
        blockNumber: allowNull(index_js_4.getNumber, null),
        transactionIndex: allowNull(index_js_4.getNumber, null),
        from: index_js_1.getAddress,
        // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas) must be set
        gasPrice: allowNull(index_js_4.getBigInt),
        maxPriorityFeePerGas: allowNull(index_js_4.getBigInt),
        maxFeePerGas: allowNull(index_js_4.getBigInt),
        maxFeePerBlobGas: allowNull(index_js_4.getBigInt, null),
        gasLimit: index_js_4.getBigInt,
        to: allowNull(index_js_1.getAddress, null),
        value: index_js_4.getBigInt,
        nonce: index_js_4.getNumber,
        data: formatData,
        creates: allowNull(index_js_1.getAddress, null),
        chainId: allowNull(index_js_4.getBigInt, null)
      }, {
        data: ["input"],
        gasLimit: ["gas"],
        index: ["transactionIndex"]
      })(value);
      if (result.to == null && result.creates == null) {
        result.creates = (0, index_js_1.getCreateAddress)(result);
      }
      if ((value.type === 1 || value.type === 2) && value.accessList == null) {
        result.accessList = [];
      }
      if (value.signature) {
        result.signature = index_js_2.Signature.from(value.signature);
      } else {
        result.signature = index_js_2.Signature.from(value);
      }
      if (result.chainId == null) {
        const chainId = result.signature.legacyChainId;
        if (chainId != null) {
          result.chainId = chainId;
        }
      }
      if (result.blockHash && (0, index_js_4.getBigInt)(result.blockHash) === BN_0) {
        result.blockHash = null;
      }
      return result;
    }
    exports.formatTransactionResponse = formatTransactionResponse;
  }
});

// node_modules/ethers/lib.commonjs/providers/plugins-network.js
var require_plugins_network = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/plugins-network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = void 0;
    var properties_js_1 = require_properties();
    var index_js_1 = require_utils5();
    var EnsAddress = "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e";
    var NetworkPlugin = class _NetworkPlugin {
      /**
       *  Creates a new **NetworkPlugin**.
       */
      constructor(name) {
        /**
         *  The name of the plugin.
         *
         *  It is recommended to use reverse-domain-notation, which permits
         *  unique names with a known authority as well as hierarchal entries.
         */
        __publicField(this, "name");
        (0, properties_js_1.defineProperties)(this, { name });
      }
      /**
       *  Creates a copy of this plugin.
       */
      clone() {
        return new _NetworkPlugin(this.name);
      }
    };
    exports.NetworkPlugin = NetworkPlugin;
    var GasCostPlugin = class _GasCostPlugin extends NetworkPlugin {
      /**
       *  Creates a new GasCostPlugin from %%effectiveBlock%% until the
       *  latest block or another GasCostPlugin supercedes that block number,
       *  with the associated %%costs%%.
       */
      constructor(effectiveBlock, costs) {
        if (effectiveBlock == null) {
          effectiveBlock = 0;
        }
        super(`org.ethers.network.plugins.GasCost#${effectiveBlock || 0}`);
        /**
         *  The block number to treat these values as valid from.
         *
         *  This allows a hardfork to have updated values included as well as
         *  mulutiple hardforks to be supported.
         */
        __publicField(this, "effectiveBlock");
        /**
         *  The transactions base fee.
         */
        __publicField(this, "txBase");
        /**
         *  The fee for creating a new account.
         */
        __publicField(this, "txCreate");
        /**
         *  The fee per zero-byte in the data.
         */
        __publicField(this, "txDataZero");
        /**
         *  The fee per non-zero-byte in the data.
         */
        __publicField(this, "txDataNonzero");
        /**
         *  The fee per storage key in the [[link-eip-2930]] access list.
         */
        __publicField(this, "txAccessListStorageKey");
        /**
         *  The fee per address in the [[link-eip-2930]] access list.
         */
        __publicField(this, "txAccessListAddress");
        const props = { effectiveBlock };
        function set(name, nullish) {
          let value = (costs || {})[name];
          if (value == null) {
            value = nullish;
          }
          (0, index_js_1.assertArgument)(typeof value === "number", `invalud value for ${name}`, "costs", costs);
          props[name] = value;
        }
        set("txBase", 21e3);
        set("txCreate", 32e3);
        set("txDataZero", 4);
        set("txDataNonzero", 16);
        set("txAccessListStorageKey", 1900);
        set("txAccessListAddress", 2400);
        (0, properties_js_1.defineProperties)(this, props);
      }
      clone() {
        return new _GasCostPlugin(this.effectiveBlock, this);
      }
    };
    exports.GasCostPlugin = GasCostPlugin;
    var EnsPlugin = class _EnsPlugin extends NetworkPlugin {
      /**
       *  Creates a new **EnsPlugin** connected to %%address%% on the
       *  %%targetNetwork%%. The default ENS address and mainnet is used
       *  if unspecified.
       */
      constructor(address, targetNetwork) {
        super("org.ethers.plugins.network.Ens");
        /**
         *  The ENS Registrty Contract address.
         */
        __publicField(this, "address");
        /**
         *  The chain ID that the ENS contract lives on.
         */
        __publicField(this, "targetNetwork");
        (0, properties_js_1.defineProperties)(this, {
          address: address || EnsAddress,
          targetNetwork: targetNetwork == null ? 1 : targetNetwork
        });
      }
      clone() {
        return new _EnsPlugin(this.address, this.targetNetwork);
      }
    };
    exports.EnsPlugin = EnsPlugin;
    var _feeDataFunc;
    var _FeeDataNetworkPlugin = class _FeeDataNetworkPlugin extends NetworkPlugin {
      /**
       *  Creates a new **FeeDataNetworkPlugin**.
       */
      constructor(feeDataFunc) {
        super("org.ethers.plugins.network.FeeData");
        __privateAdd(this, _feeDataFunc);
        __privateSet(this, _feeDataFunc, feeDataFunc);
      }
      /**
       *  The fee data function provided to the constructor.
       */
      get feeDataFunc() {
        return __privateGet(this, _feeDataFunc);
      }
      /**
       *  Resolves to the fee data.
       */
      async getFeeData(provider) {
        return await __privateGet(this, _feeDataFunc).call(this, provider);
      }
      clone() {
        return new _FeeDataNetworkPlugin(__privateGet(this, _feeDataFunc));
      }
    };
    _feeDataFunc = new WeakMap();
    var FeeDataNetworkPlugin = _FeeDataNetworkPlugin;
    exports.FeeDataNetworkPlugin = FeeDataNetworkPlugin;
    var _url, _processFunc;
    var FetchUrlFeeDataNetworkPlugin = class extends NetworkPlugin {
      /**
       *  Creates a new **FetchUrlFeeDataNetworkPlugin** which will
       *  be used when computing the fee data for the network.
       */
      constructor(url, processFunc) {
        super("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        __privateAdd(this, _url);
        __privateAdd(this, _processFunc);
        __privateSet(this, _url, url);
        __privateSet(this, _processFunc, processFunc);
      }
      /**
       *  The URL to initialize the FetchRequest with in %%processFunc%%.
       */
      get url() {
        return __privateGet(this, _url);
      }
      /**
       *  The callback to use when computing the FeeData.
       */
      get processFunc() {
        return __privateGet(this, _processFunc);
      }
      // We are immutable, so we can serve as our own clone
      clone() {
        return this;
      }
    };
    _url = new WeakMap();
    _processFunc = new WeakMap();
    exports.FetchUrlFeeDataNetworkPlugin = FetchUrlFeeDataNetworkPlugin;
  }
});

// node_modules/ethers/lib.commonjs/providers/network.js
var require_network = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/network.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Network = void 0;
    var index_js_1 = require_transaction2();
    var index_js_2 = require_utils5();
    var plugins_network_js_1 = require_plugins_network();
    var Networks = /* @__PURE__ */ new Map();
    var _name, _chainId, _plugins;
    var _Network = class _Network {
      /**
       *  Creates a new **Network** for %%name%% and %%chainId%%.
       */
      constructor(name, chainId) {
        __privateAdd(this, _name);
        __privateAdd(this, _chainId);
        __privateAdd(this, _plugins);
        __privateSet(this, _name, name);
        __privateSet(this, _chainId, (0, index_js_2.getBigInt)(chainId));
        __privateSet(this, _plugins, /* @__PURE__ */ new Map());
      }
      /**
       *  Returns a JSON-compatible representation of a Network.
       */
      toJSON() {
        return { name: this.name, chainId: String(this.chainId) };
      }
      /**
       *  The network common name.
       *
       *  This is the canonical name, as networks migh have multiple
       *  names.
       */
      get name() {
        return __privateGet(this, _name);
      }
      set name(value) {
        __privateSet(this, _name, value);
      }
      /**
       *  The network chain ID.
       */
      get chainId() {
        return __privateGet(this, _chainId);
      }
      set chainId(value) {
        __privateSet(this, _chainId, (0, index_js_2.getBigInt)(value, "chainId"));
      }
      /**
       *  Returns true if %%other%% matches this network. Any chain ID
       *  must match, and if no chain ID is present, the name must match.
       *
       *  This method does not currently check for additional properties,
       *  such as ENS address or plug-in compatibility.
       */
      matches(other) {
        if (other == null) {
          return false;
        }
        if (typeof other === "string") {
          try {
            return this.chainId === (0, index_js_2.getBigInt)(other);
          } catch (error) {
          }
          return this.name === other;
        }
        if (typeof other === "number" || typeof other === "bigint") {
          try {
            return this.chainId === (0, index_js_2.getBigInt)(other);
          } catch (error) {
          }
          return false;
        }
        if (typeof other === "object") {
          if (other.chainId != null) {
            try {
              return this.chainId === (0, index_js_2.getBigInt)(other.chainId);
            } catch (error) {
            }
            return false;
          }
          if (other.name != null) {
            return this.name === other.name;
          }
          return false;
        }
        return false;
      }
      /**
       *  Returns the list of plugins currently attached to this Network.
       */
      get plugins() {
        return Array.from(__privateGet(this, _plugins).values());
      }
      /**
       *  Attach a new %%plugin%% to this Network. The network name
       *  must be unique, excluding any fragment.
       */
      attachPlugin(plugin) {
        if (__privateGet(this, _plugins).get(plugin.name)) {
          throw new Error(`cannot replace existing plugin: ${plugin.name} `);
        }
        __privateGet(this, _plugins).set(plugin.name, plugin.clone());
        return this;
      }
      /**
       *  Return the plugin, if any, matching %%name%% exactly. Plugins
       *  with fragments will not be returned unless %%name%% includes
       *  a fragment.
       */
      getPlugin(name) {
        return __privateGet(this, _plugins).get(name) || null;
      }
      /**
       *  Gets a list of all plugins that match %%name%%, with otr without
       *  a fragment.
       */
      getPlugins(basename) {
        return this.plugins.filter((p2) => p2.name.split("#")[0] === basename);
      }
      /**
       *  Create a copy of this Network.
       */
      clone() {
        const clone = new _Network(this.name, this.chainId);
        this.plugins.forEach((plugin) => {
          clone.attachPlugin(plugin.clone());
        });
        return clone;
      }
      /**
       *  Compute the intrinsic gas required for a transaction.
       *
       *  A GasCostPlugin can be attached to override the default
       *  values.
       */
      computeIntrinsicGas(tx) {
        const costs = this.getPlugin("org.ethers.plugins.network.GasCost") || new plugins_network_js_1.GasCostPlugin();
        let gas = costs.txBase;
        if (tx.to == null) {
          gas += costs.txCreate;
        }
        if (tx.data) {
          for (let i2 = 2; i2 < tx.data.length; i2 += 2) {
            if (tx.data.substring(i2, i2 + 2) === "00") {
              gas += costs.txDataZero;
            } else {
              gas += costs.txDataNonzero;
            }
          }
        }
        if (tx.accessList) {
          const accessList = (0, index_js_1.accessListify)(tx.accessList);
          for (const addr in accessList) {
            gas += costs.txAccessListAddress + costs.txAccessListStorageKey * accessList[addr].storageKeys.length;
          }
        }
        return gas;
      }
      /**
       *  Returns a new Network for the %%network%% name or chainId.
       */
      static from(network) {
        injectCommonNetworks();
        if (network == null) {
          return _Network.from("mainnet");
        }
        if (typeof network === "number") {
          network = BigInt(network);
        }
        if (typeof network === "string" || typeof network === "bigint") {
          const networkFunc = Networks.get(network);
          if (networkFunc) {
            return networkFunc();
          }
          if (typeof network === "bigint") {
            return new _Network("unknown", network);
          }
          (0, index_js_2.assertArgument)(false, "unknown network", "network", network);
        }
        if (typeof network.clone === "function") {
          const clone = network.clone();
          return clone;
        }
        if (typeof network === "object") {
          (0, index_js_2.assertArgument)(typeof network.name === "string" && typeof network.chainId === "number", "invalid network object name or chainId", "network", network);
          const custom2 = new _Network(network.name, network.chainId);
          if (network.ensAddress || network.ensNetwork != null) {
            custom2.attachPlugin(new plugins_network_js_1.EnsPlugin(network.ensAddress, network.ensNetwork));
          }
          return custom2;
        }
        (0, index_js_2.assertArgument)(false, "invalid network", "network", network);
      }
      /**
       *  Register %%nameOrChainId%% with a function which returns
       *  an instance of a Network representing that chain.
       */
      static register(nameOrChainId, networkFunc) {
        if (typeof nameOrChainId === "number") {
          nameOrChainId = BigInt(nameOrChainId);
        }
        const existing = Networks.get(nameOrChainId);
        if (existing) {
          (0, index_js_2.assertArgument)(false, `conflicting network for ${JSON.stringify(existing.name)}`, "nameOrChainId", nameOrChainId);
        }
        Networks.set(nameOrChainId, networkFunc);
      }
    };
    _name = new WeakMap();
    _chainId = new WeakMap();
    _plugins = new WeakMap();
    var Network = _Network;
    exports.Network = Network;
    function parseUnits(_value, decimals) {
      const value = String(_value);
      if (!value.match(/^[0-9.]+$/)) {
        throw new Error(`invalid gwei value: ${_value}`);
      }
      const comps = value.split(".");
      if (comps.length === 1) {
        comps.push("");
      }
      if (comps.length !== 2) {
        throw new Error(`invalid gwei value: ${_value}`);
      }
      while (comps[1].length < decimals) {
        comps[1] += "0";
      }
      if (comps[1].length > 9) {
        let frac = BigInt(comps[1].substring(0, 9));
        if (!comps[1].substring(9).match(/^0+$/)) {
          frac++;
        }
        comps[1] = frac.toString();
      }
      return BigInt(comps[0] + comps[1]);
    }
    function getGasStationPlugin(url) {
      return new plugins_network_js_1.FetchUrlFeeDataNetworkPlugin(url, async (fetchFeeData, provider, request) => {
        request.setHeader("User-Agent", "ethers");
        let response;
        try {
          const [_response, _feeData] = await Promise.all([
            request.send(),
            fetchFeeData()
          ]);
          response = _response;
          const payload = response.bodyJson.standard;
          const feeData = {
            gasPrice: _feeData.gasPrice,
            maxFeePerGas: parseUnits(payload.maxFee, 9),
            maxPriorityFeePerGas: parseUnits(payload.maxPriorityFee, 9)
          };
          return feeData;
        } catch (error) {
          (0, index_js_2.assert)(false, `error encountered with polygon gas station (${JSON.stringify(request.url)})`, "SERVER_ERROR", { request, response, error });
        }
      });
    }
    var injected3 = false;
    function injectCommonNetworks() {
      if (injected3) {
        return;
      }
      injected3 = true;
      function registerEth(name, chainId, options) {
        const func = function() {
          const network = new Network(name, chainId);
          if (options.ensNetwork != null) {
            network.attachPlugin(new plugins_network_js_1.EnsPlugin(null, options.ensNetwork));
          }
          network.attachPlugin(new plugins_network_js_1.GasCostPlugin());
          (options.plugins || []).forEach((plugin) => {
            network.attachPlugin(plugin);
          });
          return network;
        };
        Network.register(name, func);
        Network.register(chainId, func);
        if (options.altNames) {
          options.altNames.forEach((name2) => {
            Network.register(name2, func);
          });
        }
      }
      registerEth("mainnet", 1, { ensNetwork: 1, altNames: ["homestead"] });
      registerEth("ropsten", 3, { ensNetwork: 3 });
      registerEth("rinkeby", 4, { ensNetwork: 4 });
      registerEth("goerli", 5, { ensNetwork: 5 });
      registerEth("kovan", 42, { ensNetwork: 42 });
      registerEth("sepolia", 11155111, { ensNetwork: 11155111 });
      registerEth("holesky", 17e3, { ensNetwork: 17e3 });
      registerEth("classic", 61, {});
      registerEth("classicKotti", 6, {});
      registerEth("arbitrum", 42161, {
        ensNetwork: 1
      });
      registerEth("arbitrum-goerli", 421613, {});
      registerEth("arbitrum-sepolia", 421614, {});
      registerEth("base", 8453, { ensNetwork: 1 });
      registerEth("base-goerli", 84531, {});
      registerEth("base-sepolia", 84532, {});
      registerEth("bnb", 56, { ensNetwork: 1 });
      registerEth("bnbt", 97, {});
      registerEth("linea", 59144, { ensNetwork: 1 });
      registerEth("linea-goerli", 59140, {});
      registerEth("linea-sepolia", 59141, {});
      registerEth("matic", 137, {
        ensNetwork: 1,
        plugins: [
          getGasStationPlugin("https://gasstation.polygon.technology/v2")
        ]
      });
      registerEth("matic-amoy", 80002, {});
      registerEth("matic-mumbai", 80001, {
        altNames: ["maticMumbai", "maticmum"],
        plugins: [
          getGasStationPlugin("https://gasstation-testnet.polygon.technology/v2")
        ]
      });
      registerEth("optimism", 10, {
        ensNetwork: 1,
        plugins: []
      });
      registerEth("optimism-goerli", 420, {});
      registerEth("optimism-sepolia", 11155420, {});
      registerEth("xdai", 100, { ensNetwork: 1 });
    }
  }
});

// node_modules/ethers/lib.commonjs/providers/subscriber-polling.js
var require_subscriber_polling = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/subscriber-polling.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PollingEventSubscriber = exports.PollingTransactionSubscriber = exports.PollingOrphanSubscriber = exports.PollingBlockTagSubscriber = exports.OnBlockSubscriber = exports.PollingBlockSubscriber = exports.getPollingSubscriber = void 0;
    var index_js_1 = require_utils5();
    function copy(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    function getPollingSubscriber(provider, event) {
      if (event === "block") {
        return new PollingBlockSubscriber(provider);
      }
      if ((0, index_js_1.isHexString)(event, 32)) {
        return new PollingTransactionSubscriber(provider, event);
      }
      (0, index_js_1.assert)(false, "unsupported polling event", "UNSUPPORTED_OPERATION", {
        operation: "getPollingSubscriber",
        info: { event }
      });
    }
    exports.getPollingSubscriber = getPollingSubscriber;
    var _provider, _poller, _interval, _blockNumber, _PollingBlockSubscriber_instances, poll_fn;
    var PollingBlockSubscriber = class {
      /**
       *  Create a new **PollingBlockSubscriber** attached to %%provider%%.
       */
      constructor(provider) {
        __privateAdd(this, _PollingBlockSubscriber_instances);
        __privateAdd(this, _provider);
        __privateAdd(this, _poller);
        __privateAdd(this, _interval);
        // The most recent block we have scanned for events. The value -2
        // indicates we still need to fetch an initial block number
        __privateAdd(this, _blockNumber);
        __privateSet(this, _provider, provider);
        __privateSet(this, _poller, null);
        __privateSet(this, _interval, 4e3);
        __privateSet(this, _blockNumber, -2);
      }
      /**
       *  The polling interval.
       */
      get pollingInterval() {
        return __privateGet(this, _interval);
      }
      set pollingInterval(value) {
        __privateSet(this, _interval, value);
      }
      start() {
        if (__privateGet(this, _poller)) {
          return;
        }
        __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
        __privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).call(this);
      }
      stop() {
        if (!__privateGet(this, _poller)) {
          return;
        }
        __privateGet(this, _provider)._clearTimeout(__privateGet(this, _poller));
        __privateSet(this, _poller, null);
      }
      pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
          __privateSet(this, _blockNumber, -2);
        }
      }
      resume() {
        this.start();
      }
    };
    _provider = new WeakMap();
    _poller = new WeakMap();
    _interval = new WeakMap();
    _blockNumber = new WeakMap();
    _PollingBlockSubscriber_instances = new WeakSet();
    poll_fn = async function() {
      try {
        const blockNumber = await __privateGet(this, _provider).getBlockNumber();
        if (__privateGet(this, _blockNumber) === -2) {
          __privateSet(this, _blockNumber, blockNumber);
          return;
        }
        if (blockNumber !== __privateGet(this, _blockNumber)) {
          for (let b4 = __privateGet(this, _blockNumber) + 1; b4 <= blockNumber; b4++) {
            if (__privateGet(this, _poller) == null) {
              return;
            }
            await __privateGet(this, _provider).emit("block", b4);
          }
          __privateSet(this, _blockNumber, blockNumber);
        }
      } catch (error) {
      }
      if (__privateGet(this, _poller) == null) {
        return;
      }
      __privateSet(this, _poller, __privateGet(this, _provider)._setTimeout(__privateMethod(this, _PollingBlockSubscriber_instances, poll_fn).bind(this), __privateGet(this, _interval)));
    };
    exports.PollingBlockSubscriber = PollingBlockSubscriber;
    var _provider2, _poll, _running;
    var OnBlockSubscriber = class {
      /**
       *  Create a new **OnBlockSubscriber** attached to %%provider%%.
       */
      constructor(provider) {
        __privateAdd(this, _provider2);
        __privateAdd(this, _poll);
        __privateAdd(this, _running);
        __privateSet(this, _provider2, provider);
        __privateSet(this, _running, false);
        __privateSet(this, _poll, (blockNumber) => {
          this._poll(blockNumber, __privateGet(this, _provider2));
        });
      }
      /**
       *  Called on every new block.
       */
      async _poll(blockNumber, provider) {
        throw new Error("sub-classes must override this");
      }
      start() {
        if (__privateGet(this, _running)) {
          return;
        }
        __privateSet(this, _running, true);
        __privateGet(this, _poll).call(this, -2);
        __privateGet(this, _provider2).on("block", __privateGet(this, _poll));
      }
      stop() {
        if (!__privateGet(this, _running)) {
          return;
        }
        __privateSet(this, _running, false);
        __privateGet(this, _provider2).off("block", __privateGet(this, _poll));
      }
      pause(dropWhilePaused) {
        this.stop();
      }
      resume() {
        this.start();
      }
    };
    _provider2 = new WeakMap();
    _poll = new WeakMap();
    _running = new WeakMap();
    exports.OnBlockSubscriber = OnBlockSubscriber;
    var _tag, _lastBlock;
    var PollingBlockTagSubscriber = class extends OnBlockSubscriber {
      constructor(provider, tag) {
        super(provider);
        __privateAdd(this, _tag);
        __privateAdd(this, _lastBlock);
        __privateSet(this, _tag, tag);
        __privateSet(this, _lastBlock, -2);
      }
      pause(dropWhilePaused) {
        if (dropWhilePaused) {
          __privateSet(this, _lastBlock, -2);
        }
        super.pause(dropWhilePaused);
      }
      async _poll(blockNumber, provider) {
        const block = await provider.getBlock(__privateGet(this, _tag));
        if (block == null) {
          return;
        }
        if (__privateGet(this, _lastBlock) === -2) {
          __privateSet(this, _lastBlock, block.number);
        } else if (block.number > __privateGet(this, _lastBlock)) {
          provider.emit(__privateGet(this, _tag), block.number);
          __privateSet(this, _lastBlock, block.number);
        }
      }
    };
    _tag = new WeakMap();
    _lastBlock = new WeakMap();
    exports.PollingBlockTagSubscriber = PollingBlockTagSubscriber;
    var _filter;
    var PollingOrphanSubscriber = class extends OnBlockSubscriber {
      constructor(provider, filter3) {
        super(provider);
        __privateAdd(this, _filter);
        __privateSet(this, _filter, copy(filter3));
      }
      async _poll(blockNumber, provider) {
        throw new Error("@TODO");
        console.log(__privateGet(this, _filter));
      }
    };
    _filter = new WeakMap();
    exports.PollingOrphanSubscriber = PollingOrphanSubscriber;
    var _hash;
    var PollingTransactionSubscriber = class extends OnBlockSubscriber {
      /**
       *  Create a new **PollingTransactionSubscriber** attached to
       *  %%provider%%, listening for %%hash%%.
       */
      constructor(provider, hash8) {
        super(provider);
        __privateAdd(this, _hash);
        __privateSet(this, _hash, hash8);
      }
      async _poll(blockNumber, provider) {
        const tx = await provider.getTransactionReceipt(__privateGet(this, _hash));
        if (tx) {
          provider.emit(__privateGet(this, _hash), tx);
        }
      }
    };
    _hash = new WeakMap();
    exports.PollingTransactionSubscriber = PollingTransactionSubscriber;
    var _provider3, _filter2, _poller2, _running2, _blockNumber2, _PollingEventSubscriber_instances, poll_fn2;
    var PollingEventSubscriber = class {
      /**
       *  Create a new **PollingTransactionSubscriber** attached to
       *  %%provider%%, listening for %%filter%%.
       */
      constructor(provider, filter3) {
        __privateAdd(this, _PollingEventSubscriber_instances);
        __privateAdd(this, _provider3);
        __privateAdd(this, _filter2);
        __privateAdd(this, _poller2);
        __privateAdd(this, _running2);
        // The most recent block we have scanned for events. The value -2
        // indicates we still need to fetch an initial block number
        __privateAdd(this, _blockNumber2);
        __privateSet(this, _provider3, provider);
        __privateSet(this, _filter2, copy(filter3));
        __privateSet(this, _poller2, __privateMethod(this, _PollingEventSubscriber_instances, poll_fn2).bind(this));
        __privateSet(this, _running2, false);
        __privateSet(this, _blockNumber2, -2);
      }
      start() {
        if (__privateGet(this, _running2)) {
          return;
        }
        __privateSet(this, _running2, true);
        if (__privateGet(this, _blockNumber2) === -2) {
          __privateGet(this, _provider3).getBlockNumber().then((blockNumber) => {
            __privateSet(this, _blockNumber2, blockNumber);
          });
        }
        __privateGet(this, _provider3).on("block", __privateGet(this, _poller2));
      }
      stop() {
        if (!__privateGet(this, _running2)) {
          return;
        }
        __privateSet(this, _running2, false);
        __privateGet(this, _provider3).off("block", __privateGet(this, _poller2));
      }
      pause(dropWhilePaused) {
        this.stop();
        if (dropWhilePaused) {
          __privateSet(this, _blockNumber2, -2);
        }
      }
      resume() {
        this.start();
      }
    };
    _provider3 = new WeakMap();
    _filter2 = new WeakMap();
    _poller2 = new WeakMap();
    _running2 = new WeakMap();
    _blockNumber2 = new WeakMap();
    _PollingEventSubscriber_instances = new WeakSet();
    poll_fn2 = async function(blockNumber) {
      if (__privateGet(this, _blockNumber2) === -2) {
        return;
      }
      const filter3 = copy(__privateGet(this, _filter2));
      filter3.fromBlock = __privateGet(this, _blockNumber2) + 1;
      filter3.toBlock = blockNumber;
      const logs = await __privateGet(this, _provider3).getLogs(filter3);
      if (logs.length === 0) {
        if (__privateGet(this, _blockNumber2) < blockNumber - 60) {
          __privateSet(this, _blockNumber2, blockNumber - 60);
        }
        return;
      }
      for (const log of logs) {
        __privateGet(this, _provider3).emit(__privateGet(this, _filter2), log);
        __privateSet(this, _blockNumber2, log.blockNumber);
      }
    };
    exports.PollingEventSubscriber = PollingEventSubscriber;
  }
});

// node_modules/ethers/lib.commonjs/providers/abstract-provider.js
var require_abstract_provider = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/abstract-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AbstractProvider = exports.UnmanagedSubscriber = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_constants();
    var index_js_3 = require_contract2();
    var index_js_4 = require_hash();
    var index_js_5 = require_transaction2();
    var index_js_6 = require_utils5();
    var ens_resolver_js_1 = require_ens_resolver();
    var format_js_1 = require_format();
    var network_js_1 = require_network();
    var provider_js_1 = require_provider();
    var subscriber_polling_js_1 = require_subscriber_polling();
    var BN_2 = BigInt(2);
    var MAX_CCIP_REDIRECTS = 10;
    function isPromise(value) {
      return value && typeof value.then === "function";
    }
    function getTag(prefix, value) {
      return prefix + ":" + JSON.stringify(value, (k4, v2) => {
        if (v2 == null) {
          return "null";
        }
        if (typeof v2 === "bigint") {
          return `bigint:${v2.toString()}`;
        }
        if (typeof v2 === "string") {
          return v2.toLowerCase();
        }
        if (typeof v2 === "object" && !Array.isArray(v2)) {
          const keys = Object.keys(v2);
          keys.sort();
          return keys.reduce((accum, key) => {
            accum[key] = v2[key];
            return accum;
          }, {});
        }
        return v2;
      });
    }
    var UnmanagedSubscriber = class {
      /**
       *  Create a new UnmanagedSubscriber with %%name%%.
       */
      constructor(name) {
        /**
         *  The name fof the event.
         */
        __publicField(this, "name");
        (0, index_js_6.defineProperties)(this, { name });
      }
      start() {
      }
      stop() {
      }
      pause(dropWhilePaused) {
      }
      resume() {
      }
    };
    exports.UnmanagedSubscriber = UnmanagedSubscriber;
    function copy(value) {
      return JSON.parse(JSON.stringify(value));
    }
    function concisify(items) {
      items = Array.from(new Set(items).values());
      items.sort();
      return items;
    }
    async function getSubscription(_event, provider) {
      if (_event == null) {
        throw new Error("invalid event");
      }
      if (Array.isArray(_event)) {
        _event = { topics: _event };
      }
      if (typeof _event === "string") {
        switch (_event) {
          case "block":
          case "debug":
          case "error":
          case "finalized":
          case "network":
          case "pending":
          case "safe": {
            return { type: _event, tag: _event };
          }
        }
      }
      if ((0, index_js_6.isHexString)(_event, 32)) {
        const hash8 = _event.toLowerCase();
        return { type: "transaction", tag: getTag("tx", { hash: hash8 }), hash: hash8 };
      }
      if (_event.orphan) {
        const event = _event;
        return { type: "orphan", tag: getTag("orphan", event), filter: copy(event) };
      }
      if (_event.address || _event.topics) {
        const event = _event;
        const filter3 = {
          topics: (event.topics || []).map((t2) => {
            if (t2 == null) {
              return null;
            }
            if (Array.isArray(t2)) {
              return concisify(t2.map((t3) => t3.toLowerCase()));
            }
            return t2.toLowerCase();
          })
        };
        if (event.address) {
          const addresses = [];
          const promises = [];
          const addAddress = (addr) => {
            if ((0, index_js_6.isHexString)(addr)) {
              addresses.push(addr);
            } else {
              promises.push((async () => {
                addresses.push(await (0, index_js_1.resolveAddress)(addr, provider));
              })());
            }
          };
          if (Array.isArray(event.address)) {
            event.address.forEach(addAddress);
          } else {
            addAddress(event.address);
          }
          if (promises.length) {
            await Promise.all(promises);
          }
          filter3.address = concisify(addresses.map((a3) => a3.toLowerCase()));
        }
        return { filter: filter3, tag: getTag("event", filter3), type: "event" };
      }
      (0, index_js_6.assertArgument)(false, "unknown ProviderEvent", "event", _event);
    }
    function getTime() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
    var defaultOptions = {
      cacheTimeout: 250,
      pollingInterval: 4e3
    };
    var _subs, _plugins, _pausedState, _destroyed, _networkPromise, _anyNetwork, _performCache, _lastBlockNumber, _nextTimer, _timers, _disableCcipRead, _options, _AbstractProvider_instances, perform_fn, call_fn, checkNetwork_fn, getAccountValue_fn, getBlock_fn, hasSub_fn, getSub_fn;
    var AbstractProvider = class {
      /**
       *  Create a new **AbstractProvider** connected to %%network%%, or
       *  use the various network detection capabilities to discover the
       *  [[Network]] if necessary.
       */
      constructor(_network, options) {
        __privateAdd(this, _AbstractProvider_instances);
        __privateAdd(this, _subs);
        __privateAdd(this, _plugins);
        // null=unpaused, true=paused+dropWhilePaused, false=paused
        __privateAdd(this, _pausedState);
        __privateAdd(this, _destroyed);
        __privateAdd(this, _networkPromise);
        __privateAdd(this, _anyNetwork);
        __privateAdd(this, _performCache);
        // The most recent block number if running an event or -1 if no "block" event
        __privateAdd(this, _lastBlockNumber);
        __privateAdd(this, _nextTimer);
        __privateAdd(this, _timers);
        __privateAdd(this, _disableCcipRead);
        __privateAdd(this, _options);
        __privateSet(this, _options, Object.assign({}, defaultOptions, options || {}));
        if (_network === "any") {
          __privateSet(this, _anyNetwork, true);
          __privateSet(this, _networkPromise, null);
        } else if (_network) {
          const network = network_js_1.Network.from(_network);
          __privateSet(this, _anyNetwork, false);
          __privateSet(this, _networkPromise, Promise.resolve(network));
          setTimeout(() => {
            this.emit("network", network, null);
          }, 0);
        } else {
          __privateSet(this, _anyNetwork, false);
          __privateSet(this, _networkPromise, null);
        }
        __privateSet(this, _lastBlockNumber, -1);
        __privateSet(this, _performCache, /* @__PURE__ */ new Map());
        __privateSet(this, _subs, /* @__PURE__ */ new Map());
        __privateSet(this, _plugins, /* @__PURE__ */ new Map());
        __privateSet(this, _pausedState, null);
        __privateSet(this, _destroyed, false);
        __privateSet(this, _nextTimer, 1);
        __privateSet(this, _timers, /* @__PURE__ */ new Map());
        __privateSet(this, _disableCcipRead, false);
      }
      get pollingInterval() {
        return __privateGet(this, _options).pollingInterval;
      }
      /**
       *  Returns ``this``, to allow an **AbstractProvider** to implement
       *  the [[ContractRunner]] interface.
       */
      get provider() {
        return this;
      }
      /**
       *  Returns all the registered plug-ins.
       */
      get plugins() {
        return Array.from(__privateGet(this, _plugins).values());
      }
      /**
       *  Attach a new plug-in.
       */
      attachPlugin(plugin) {
        if (__privateGet(this, _plugins).get(plugin.name)) {
          throw new Error(`cannot replace existing plugin: ${plugin.name} `);
        }
        __privateGet(this, _plugins).set(plugin.name, plugin.connect(this));
        return this;
      }
      /**
       *  Get a plugin by name.
       */
      getPlugin(name) {
        return __privateGet(this, _plugins).get(name) || null;
      }
      /**
       *  Prevent any CCIP-read operation, regardless of whether requested
       *  in a [[call]] using ``enableCcipRead``.
       */
      get disableCcipRead() {
        return __privateGet(this, _disableCcipRead);
      }
      set disableCcipRead(value) {
        __privateSet(this, _disableCcipRead, !!value);
      }
      /**
       *  Resolves to the data for executing the CCIP-read operations.
       */
      async ccipReadFetch(tx, calldata, urls) {
        if (this.disableCcipRead || urls.length === 0 || tx.to == null) {
          return null;
        }
        const sender = tx.to.toLowerCase();
        const data = calldata.toLowerCase();
        const errorMessages = [];
        for (let i2 = 0; i2 < urls.length; i2++) {
          const url = urls[i2];
          const href = url.replace("{sender}", sender).replace("{data}", data);
          const request = new index_js_6.FetchRequest(href);
          if (url.indexOf("{data}") === -1) {
            request.body = { data, sender };
          }
          this.emit("debug", { action: "sendCcipReadFetchRequest", request, index: i2, urls });
          let errorMessage = "unknown error";
          let resp;
          try {
            resp = await request.send();
          } catch (error) {
            errorMessages.push(error.message);
            this.emit("debug", { action: "receiveCcipReadFetchError", request, result: { error } });
            continue;
          }
          try {
            const result = resp.bodyJson;
            if (result.data) {
              this.emit("debug", { action: "receiveCcipReadFetchResult", request, result });
              return result.data;
            }
            if (result.message) {
              errorMessage = result.message;
            }
            this.emit("debug", { action: "receiveCcipReadFetchError", request, result });
          } catch (error) {
          }
          (0, index_js_6.assert)(resp.statusCode < 400 || resp.statusCode >= 500, `response not found during CCIP fetch: ${errorMessage}`, "OFFCHAIN_FAULT", { reason: "404_MISSING_RESOURCE", transaction: tx, info: { url, errorMessage } });
          errorMessages.push(errorMessage);
        }
        (0, index_js_6.assert)(false, `error encountered during CCIP fetch: ${errorMessages.map((m3) => JSON.stringify(m3)).join(", ")}`, "OFFCHAIN_FAULT", {
          reason: "500_SERVER_ERROR",
          transaction: tx,
          info: { urls, errorMessages }
        });
      }
      /**
       *  Provides the opportunity for a sub-class to wrap a block before
       *  returning it, to add additional properties or an alternate
       *  sub-class of [[Block]].
       */
      _wrapBlock(value, network) {
        return new provider_js_1.Block((0, format_js_1.formatBlock)(value), this);
      }
      /**
       *  Provides the opportunity for a sub-class to wrap a log before
       *  returning it, to add additional properties or an alternate
       *  sub-class of [[Log]].
       */
      _wrapLog(value, network) {
        return new provider_js_1.Log((0, format_js_1.formatLog)(value), this);
      }
      /**
       *  Provides the opportunity for a sub-class to wrap a transaction
       *  receipt before returning it, to add additional properties or an
       *  alternate sub-class of [[TransactionReceipt]].
       */
      _wrapTransactionReceipt(value, network) {
        return new provider_js_1.TransactionReceipt((0, format_js_1.formatTransactionReceipt)(value), this);
      }
      /**
       *  Provides the opportunity for a sub-class to wrap a transaction
       *  response before returning it, to add additional properties or an
       *  alternate sub-class of [[TransactionResponse]].
       */
      _wrapTransactionResponse(tx, network) {
        return new provider_js_1.TransactionResponse((0, format_js_1.formatTransactionResponse)(tx), this);
      }
      /**
       *  Resolves to the Network, forcing a network detection using whatever
       *  technique the sub-class requires.
       *
       *  Sub-classes **must** override this.
       */
      _detectNetwork() {
        (0, index_js_6.assert)(false, "sub-classes must implement this", "UNSUPPORTED_OPERATION", {
          operation: "_detectNetwork"
        });
      }
      /**
       *  Sub-classes should use this to perform all built-in operations. All
       *  methods sanitizes and normalizes the values passed into this.
       *
       *  Sub-classes **must** override this.
       */
      async _perform(req) {
        (0, index_js_6.assert)(false, `unsupported method: ${req.method}`, "UNSUPPORTED_OPERATION", {
          operation: req.method,
          info: req
        });
      }
      // State
      async getBlockNumber() {
        const blockNumber = (0, index_js_6.getNumber)(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getBlockNumber" }), "%response");
        if (__privateGet(this, _lastBlockNumber) >= 0) {
          __privateSet(this, _lastBlockNumber, blockNumber);
        }
        return blockNumber;
      }
      /**
       *  Returns or resolves to the address for %%address%%, resolving ENS
       *  names and [[Addressable]] objects and returning if already an
       *  address.
       */
      _getAddress(address) {
        return (0, index_js_1.resolveAddress)(address, this);
      }
      /**
       *  Returns or resolves to a valid block tag for %%blockTag%%, resolving
       *  negative values and returning if already a valid block tag.
       */
      _getBlockTag(blockTag) {
        if (blockTag == null) {
          return "latest";
        }
        switch (blockTag) {
          case "earliest":
            return "0x0";
          case "finalized":
          case "latest":
          case "pending":
          case "safe":
            return blockTag;
        }
        if ((0, index_js_6.isHexString)(blockTag)) {
          if ((0, index_js_6.isHexString)(blockTag, 32)) {
            return blockTag;
          }
          return (0, index_js_6.toQuantity)(blockTag);
        }
        if (typeof blockTag === "bigint") {
          blockTag = (0, index_js_6.getNumber)(blockTag, "blockTag");
        }
        if (typeof blockTag === "number") {
          if (blockTag >= 0) {
            return (0, index_js_6.toQuantity)(blockTag);
          }
          if (__privateGet(this, _lastBlockNumber) >= 0) {
            return (0, index_js_6.toQuantity)(__privateGet(this, _lastBlockNumber) + blockTag);
          }
          return this.getBlockNumber().then((b4) => (0, index_js_6.toQuantity)(b4 + blockTag));
        }
        (0, index_js_6.assertArgument)(false, "invalid blockTag", "blockTag", blockTag);
      }
      /**
       *  Returns or resolves to a filter for %%filter%%, resolving any ENS
       *  names or [[Addressable]] object and returning if already a valid
       *  filter.
       */
      _getFilter(filter3) {
        const topics = (filter3.topics || []).map((t2) => {
          if (t2 == null) {
            return null;
          }
          if (Array.isArray(t2)) {
            return concisify(t2.map((t3) => t3.toLowerCase()));
          }
          return t2.toLowerCase();
        });
        const blockHash = "blockHash" in filter3 ? filter3.blockHash : void 0;
        const resolve = (_address, fromBlock2, toBlock2) => {
          let address2 = void 0;
          switch (_address.length) {
            case 0:
              break;
            case 1:
              address2 = _address[0];
              break;
            default:
              _address.sort();
              address2 = _address;
          }
          if (blockHash) {
            if (fromBlock2 != null || toBlock2 != null) {
              throw new Error("invalid filter");
            }
          }
          const filter4 = {};
          if (address2) {
            filter4.address = address2;
          }
          if (topics.length) {
            filter4.topics = topics;
          }
          if (fromBlock2) {
            filter4.fromBlock = fromBlock2;
          }
          if (toBlock2) {
            filter4.toBlock = toBlock2;
          }
          if (blockHash) {
            filter4.blockHash = blockHash;
          }
          return filter4;
        };
        let address = [];
        if (filter3.address) {
          if (Array.isArray(filter3.address)) {
            for (const addr of filter3.address) {
              address.push(this._getAddress(addr));
            }
          } else {
            address.push(this._getAddress(filter3.address));
          }
        }
        let fromBlock = void 0;
        if ("fromBlock" in filter3) {
          fromBlock = this._getBlockTag(filter3.fromBlock);
        }
        let toBlock = void 0;
        if ("toBlock" in filter3) {
          toBlock = this._getBlockTag(filter3.toBlock);
        }
        if (address.filter((a3) => typeof a3 !== "string").length || fromBlock != null && typeof fromBlock !== "string" || toBlock != null && typeof toBlock !== "string") {
          return Promise.all([Promise.all(address), fromBlock, toBlock]).then((result) => {
            return resolve(result[0], result[1], result[2]);
          });
        }
        return resolve(address, fromBlock, toBlock);
      }
      /**
       *  Returns or resolves to a transaction for %%request%%, resolving
       *  any ENS names or [[Addressable]] and returning if already a valid
       *  transaction.
       */
      _getTransactionRequest(_request) {
        const request = (0, provider_js_1.copyRequest)(_request);
        const promises = [];
        ["to", "from"].forEach((key) => {
          if (request[key] == null) {
            return;
          }
          const addr = (0, index_js_1.resolveAddress)(request[key], this);
          if (isPromise(addr)) {
            promises.push(async function() {
              request[key] = await addr;
            }());
          } else {
            request[key] = addr;
          }
        });
        if (request.blockTag != null) {
          const blockTag = this._getBlockTag(request.blockTag);
          if (isPromise(blockTag)) {
            promises.push(async function() {
              request.blockTag = await blockTag;
            }());
          } else {
            request.blockTag = blockTag;
          }
        }
        if (promises.length) {
          return async function() {
            await Promise.all(promises);
            return request;
          }();
        }
        return request;
      }
      async getNetwork() {
        if (__privateGet(this, _networkPromise) == null) {
          const detectNetwork = (async () => {
            try {
              const network = await this._detectNetwork();
              this.emit("network", network, null);
              return network;
            } catch (error) {
              if (__privateGet(this, _networkPromise) === detectNetwork) {
                __privateSet(this, _networkPromise, null);
              }
              throw error;
            }
          })();
          __privateSet(this, _networkPromise, detectNetwork);
          return (await detectNetwork).clone();
        }
        const networkPromise = __privateGet(this, _networkPromise);
        const [expected, actual] = await Promise.all([
          networkPromise,
          this._detectNetwork()
          // The actual connected network
        ]);
        if (expected.chainId !== actual.chainId) {
          if (__privateGet(this, _anyNetwork)) {
            this.emit("network", actual, expected);
            if (__privateGet(this, _networkPromise) === networkPromise) {
              __privateSet(this, _networkPromise, Promise.resolve(actual));
            }
          } else {
            (0, index_js_6.assert)(false, `network changed: ${expected.chainId} => ${actual.chainId} `, "NETWORK_ERROR", {
              event: "changed"
            });
          }
        }
        return expected.clone();
      }
      async getFeeData() {
        const network = await this.getNetwork();
        const getFeeDataFunc = async () => {
          const { _block, gasPrice, priorityFee } = await (0, index_js_6.resolveProperties)({
            _block: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, "latest", false),
            gasPrice: (async () => {
              try {
                const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getGasPrice" });
                return (0, index_js_6.getBigInt)(value, "%response");
              } catch (error) {
              }
              return null;
            })(),
            priorityFee: (async () => {
              try {
                const value = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getPriorityFee" });
                return (0, index_js_6.getBigInt)(value, "%response");
              } catch (error) {
              }
              return null;
            })()
          });
          let maxFeePerGas = null;
          let maxPriorityFeePerGas = null;
          const block = this._wrapBlock(_block, network);
          if (block && block.baseFeePerGas) {
            maxPriorityFeePerGas = priorityFee != null ? priorityFee : BigInt("1000000000");
            maxFeePerGas = block.baseFeePerGas * BN_2 + maxPriorityFeePerGas;
          }
          return new provider_js_1.FeeData(gasPrice, maxFeePerGas, maxPriorityFeePerGas);
        };
        const plugin = network.getPlugin("org.ethers.plugins.network.FetchUrlFeeDataPlugin");
        if (plugin) {
          const req = new index_js_6.FetchRequest(plugin.url);
          const feeData = await plugin.processFunc(getFeeDataFunc, this, req);
          return new provider_js_1.FeeData(feeData.gasPrice, feeData.maxFeePerGas, feeData.maxPriorityFeePerGas);
        }
        return await getFeeDataFunc();
      }
      async estimateGas(_tx) {
        let tx = this._getTransactionRequest(_tx);
        if (isPromise(tx)) {
          tx = await tx;
        }
        return (0, index_js_6.getBigInt)(await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
          method: "estimateGas",
          transaction: tx
        }), "%response");
      }
      async call(_tx) {
        const { tx, blockTag } = await (0, index_js_6.resolveProperties)({
          tx: this._getTransactionRequest(_tx),
          blockTag: this._getBlockTag(_tx.blockTag)
        });
        return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx, blockTag, _tx.enableCcipRead ? 0 : -1));
      }
      async getBalance(address, blockTag) {
        return (0, index_js_6.getBigInt)(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getBalance" }, address, blockTag), "%response");
      }
      async getTransactionCount(address, blockTag) {
        return (0, index_js_6.getNumber)(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getTransactionCount" }, address, blockTag), "%response");
      }
      async getCode(address, blockTag) {
        return (0, index_js_6.hexlify)(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getCode" }, address, blockTag));
      }
      async getStorage(address, _position, blockTag) {
        const position = (0, index_js_6.getBigInt)(_position, "position");
        return (0, index_js_6.hexlify)(await __privateMethod(this, _AbstractProvider_instances, getAccountValue_fn).call(this, { method: "getStorage", position }, address, blockTag));
      }
      // Write
      async broadcastTransaction(signedTx) {
        const { blockNumber, hash: hash8, network } = await (0, index_js_6.resolveProperties)({
          blockNumber: this.getBlockNumber(),
          hash: this._perform({
            method: "broadcastTransaction",
            signedTransaction: signedTx
          }),
          network: this.getNetwork()
        });
        const tx = index_js_5.Transaction.from(signedTx);
        if (tx.hash !== hash8) {
          throw new Error("@TODO: the returned hash did not match");
        }
        return this._wrapTransactionResponse(tx, network).replaceableTransaction(blockNumber);
      }
      // Queries
      async getBlock(block, prefetchTxs) {
        const { network, params } = await (0, index_js_6.resolveProperties)({
          network: this.getNetwork(),
          params: __privateMethod(this, _AbstractProvider_instances, getBlock_fn).call(this, block, !!prefetchTxs)
        });
        if (params == null) {
          return null;
        }
        return this._wrapBlock(params, network);
      }
      async getTransaction(hash8) {
        const { network, params } = await (0, index_js_6.resolveProperties)({
          network: this.getNetwork(),
          params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash8 })
        });
        if (params == null) {
          return null;
        }
        return this._wrapTransactionResponse(params, network);
      }
      async getTransactionReceipt(hash8) {
        const { network, params } = await (0, index_js_6.resolveProperties)({
          network: this.getNetwork(),
          params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionReceipt", hash: hash8 })
        });
        if (params == null) {
          return null;
        }
        if (params.gasPrice == null && params.effectiveGasPrice == null) {
          const tx = await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransaction", hash: hash8 });
          if (tx == null) {
            throw new Error("report this; could not find tx or effectiveGasPrice");
          }
          params.effectiveGasPrice = tx.gasPrice;
        }
        return this._wrapTransactionReceipt(params, network);
      }
      async getTransactionResult(hash8) {
        const { result } = await (0, index_js_6.resolveProperties)({
          network: this.getNetwork(),
          result: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getTransactionResult", hash: hash8 })
        });
        if (result == null) {
          return null;
        }
        return (0, index_js_6.hexlify)(result);
      }
      // Bloom-filter Queries
      async getLogs(_filter) {
        let filter3 = this._getFilter(_filter);
        if (isPromise(filter3)) {
          filter3 = await filter3;
        }
        const { network, params } = await (0, index_js_6.resolveProperties)({
          network: this.getNetwork(),
          params: __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, { method: "getLogs", filter: filter3 })
        });
        return params.map((p2) => this._wrapLog(p2, network));
      }
      // ENS
      _getProvider(chainId) {
        (0, index_js_6.assert)(false, "provider cannot connect to target network", "UNSUPPORTED_OPERATION", {
          operation: "_getProvider()"
        });
      }
      async getResolver(name) {
        return await ens_resolver_js_1.EnsResolver.fromName(this, name);
      }
      async getAvatar(name) {
        const resolver = await this.getResolver(name);
        if (resolver) {
          return await resolver.getAvatar();
        }
        return null;
      }
      async resolveName(name) {
        const resolver = await this.getResolver(name);
        if (resolver) {
          return await resolver.getAddress();
        }
        return null;
      }
      async lookupAddress(address) {
        address = (0, index_js_1.getAddress)(address);
        const node = (0, index_js_4.namehash)(address.substring(2).toLowerCase() + ".addr.reverse");
        try {
          const ensAddr = await ens_resolver_js_1.EnsResolver.getEnsAddress(this);
          const ensContract = new index_js_3.Contract(ensAddr, [
            "function resolver(bytes32) view returns (address)"
          ], this);
          const resolver = await ensContract.resolver(node);
          if (resolver == null || resolver === index_js_2.ZeroAddress) {
            return null;
          }
          const resolverContract = new index_js_3.Contract(resolver, [
            "function name(bytes32) view returns (string)"
          ], this);
          const name = await resolverContract.name(node);
          const check = await this.resolveName(name);
          if (check !== address) {
            return null;
          }
          return name;
        } catch (error) {
          if ((0, index_js_6.isError)(error, "BAD_DATA") && error.value === "0x") {
            return null;
          }
          if ((0, index_js_6.isError)(error, "CALL_EXCEPTION")) {
            return null;
          }
          throw error;
        }
        return null;
      }
      async waitForTransaction(hash8, _confirms, timeout) {
        const confirms = _confirms != null ? _confirms : 1;
        if (confirms === 0) {
          return this.getTransactionReceipt(hash8);
        }
        return new Promise(async (resolve, reject) => {
          let timer = null;
          const listener = async (blockNumber) => {
            try {
              const receipt = await this.getTransactionReceipt(hash8);
              if (receipt != null) {
                if (blockNumber - receipt.blockNumber + 1 >= confirms) {
                  resolve(receipt);
                  if (timer) {
                    clearTimeout(timer);
                    timer = null;
                  }
                  return;
                }
              }
            } catch (error) {
              console.log("EEE", error);
            }
            this.once("block", listener);
          };
          if (timeout != null) {
            timer = setTimeout(() => {
              if (timer == null) {
                return;
              }
              timer = null;
              this.off("block", listener);
              reject((0, index_js_6.makeError)("timeout", "TIMEOUT", { reason: "timeout" }));
            }, timeout);
          }
          listener(await this.getBlockNumber());
        });
      }
      async waitForBlock(blockTag) {
        (0, index_js_6.assert)(false, "not implemented yet", "NOT_IMPLEMENTED", {
          operation: "waitForBlock"
        });
      }
      /**
       *  Clear a timer created using the [[_setTimeout]] method.
       */
      _clearTimeout(timerId) {
        const timer = __privateGet(this, _timers).get(timerId);
        if (!timer) {
          return;
        }
        if (timer.timer) {
          clearTimeout(timer.timer);
        }
        __privateGet(this, _timers).delete(timerId);
      }
      /**
       *  Create a timer that will execute %%func%% after at least %%timeout%%
       *  (in ms). If %%timeout%% is unspecified, then %%func%% will execute
       *  in the next event loop.
       *
       *  [Pausing](AbstractProvider-paused) the provider will pause any
       *  associated timers.
       */
      _setTimeout(_func, timeout) {
        if (timeout == null) {
          timeout = 0;
        }
        const timerId = __privateWrapper(this, _nextTimer)._++;
        const func = () => {
          __privateGet(this, _timers).delete(timerId);
          _func();
        };
        if (this.paused) {
          __privateGet(this, _timers).set(timerId, { timer: null, func, time: timeout });
        } else {
          const timer = setTimeout(func, timeout);
          __privateGet(this, _timers).set(timerId, { timer, func, time: getTime() });
        }
        return timerId;
      }
      /**
       *  Perform %%func%% on each subscriber.
       */
      _forEachSubscriber(func) {
        for (const sub of __privateGet(this, _subs).values()) {
          func(sub.subscriber);
        }
      }
      /**
       *  Sub-classes may override this to customize subscription
       *  implementations.
       */
      _getSubscriber(sub) {
        switch (sub.type) {
          case "debug":
          case "error":
          case "network":
            return new UnmanagedSubscriber(sub.type);
          case "block": {
            const subscriber = new subscriber_polling_js_1.PollingBlockSubscriber(this);
            subscriber.pollingInterval = this.pollingInterval;
            return subscriber;
          }
          case "safe":
          case "finalized":
            return new subscriber_polling_js_1.PollingBlockTagSubscriber(this, sub.type);
          case "event":
            return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
          case "transaction":
            return new subscriber_polling_js_1.PollingTransactionSubscriber(this, sub.hash);
          case "orphan":
            return new subscriber_polling_js_1.PollingOrphanSubscriber(this, sub.filter);
        }
        throw new Error(`unsupported event: ${sub.type}`);
      }
      /**
       *  If a [[Subscriber]] fails and needs to replace itself, this
       *  method may be used.
       *
       *  For example, this is used for providers when using the
       *  ``eth_getFilterChanges`` method, which can return null if state
       *  filters are not supported by the backend, allowing the Subscriber
       *  to swap in a [[PollingEventSubscriber]].
       */
      _recoverSubscriber(oldSub, newSub) {
        for (const sub of __privateGet(this, _subs).values()) {
          if (sub.subscriber === oldSub) {
            if (sub.started) {
              sub.subscriber.stop();
            }
            sub.subscriber = newSub;
            if (sub.started) {
              newSub.start();
            }
            if (__privateGet(this, _pausedState) != null) {
              newSub.pause(__privateGet(this, _pausedState));
            }
            break;
          }
        }
      }
      async on(event, listener) {
        const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
        sub.listeners.push({ listener, once: false });
        if (!sub.started) {
          sub.subscriber.start();
          sub.started = true;
          if (__privateGet(this, _pausedState) != null) {
            sub.subscriber.pause(__privateGet(this, _pausedState));
          }
        }
        return this;
      }
      async once(event, listener) {
        const sub = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
        sub.listeners.push({ listener, once: true });
        if (!sub.started) {
          sub.subscriber.start();
          sub.started = true;
          if (__privateGet(this, _pausedState) != null) {
            sub.subscriber.pause(__privateGet(this, _pausedState));
          }
        }
        return this;
      }
      async emit(event, ...args) {
        const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event, args);
        if (!sub || sub.listeners.length === 0) {
          return false;
        }
        ;
        const count = sub.listeners.length;
        sub.listeners = sub.listeners.filter(({ listener, once }) => {
          const payload = new index_js_6.EventPayload(this, once ? null : listener, event);
          try {
            listener.call(this, ...args, payload);
          } catch (error) {
          }
          return !once;
        });
        if (sub.listeners.length === 0) {
          if (sub.started) {
            sub.subscriber.stop();
          }
          __privateGet(this, _subs).delete(sub.tag);
        }
        return count > 0;
      }
      async listenerCount(event) {
        if (event) {
          const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
          if (!sub) {
            return 0;
          }
          return sub.listeners.length;
        }
        let total = 0;
        for (const { listeners: listeners2 } of __privateGet(this, _subs).values()) {
          total += listeners2.length;
        }
        return total;
      }
      async listeners(event) {
        if (event) {
          const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
          if (!sub) {
            return [];
          }
          return sub.listeners.map(({ listener }) => listener);
        }
        let result = [];
        for (const { listeners: listeners2 } of __privateGet(this, _subs).values()) {
          result = result.concat(listeners2.map(({ listener }) => listener));
        }
        return result;
      }
      async off(event, listener) {
        const sub = await __privateMethod(this, _AbstractProvider_instances, hasSub_fn).call(this, event);
        if (!sub) {
          return this;
        }
        if (listener) {
          const index5 = sub.listeners.map(({ listener: listener2 }) => listener2).indexOf(listener);
          if (index5 >= 0) {
            sub.listeners.splice(index5, 1);
          }
        }
        if (!listener || sub.listeners.length === 0) {
          if (sub.started) {
            sub.subscriber.stop();
          }
          __privateGet(this, _subs).delete(sub.tag);
        }
        return this;
      }
      async removeAllListeners(event) {
        if (event) {
          const { tag, started, subscriber } = await __privateMethod(this, _AbstractProvider_instances, getSub_fn).call(this, event);
          if (started) {
            subscriber.stop();
          }
          __privateGet(this, _subs).delete(tag);
        } else {
          for (const [tag, { started, subscriber }] of __privateGet(this, _subs)) {
            if (started) {
              subscriber.stop();
            }
            __privateGet(this, _subs).delete(tag);
          }
        }
        return this;
      }
      // Alias for "on"
      async addListener(event, listener) {
        return await this.on(event, listener);
      }
      // Alias for "off"
      async removeListener(event, listener) {
        return this.off(event, listener);
      }
      /**
       *  If this provider has been destroyed using the [[destroy]] method.
       *
       *  Once destroyed, all resources are reclaimed, internal event loops
       *  and timers are cleaned up and no further requests may be sent to
       *  the provider.
       */
      get destroyed() {
        return __privateGet(this, _destroyed);
      }
      /**
       *  Sub-classes may use this to shutdown any sockets or release their
       *  resources and reject any pending requests.
       *
       *  Sub-classes **must** call ``super.destroy()``.
       */
      destroy() {
        this.removeAllListeners();
        for (const timerId of __privateGet(this, _timers).keys()) {
          this._clearTimeout(timerId);
        }
        __privateSet(this, _destroyed, true);
      }
      /**
       *  Whether the provider is currently paused.
       *
       *  A paused provider will not emit any events, and generally should
       *  not make any requests to the network, but that is up to sub-classes
       *  to manage.
       *
       *  Setting ``paused = true`` is identical to calling ``.pause(false)``,
       *  which will buffer any events that occur while paused until the
       *  provider is unpaused.
       */
      get paused() {
        return __privateGet(this, _pausedState) != null;
      }
      set paused(pause) {
        if (!!pause === this.paused) {
          return;
        }
        if (this.paused) {
          this.resume();
        } else {
          this.pause(false);
        }
      }
      /**
       *  Pause the provider. If %%dropWhilePaused%%, any events that occur
       *  while paused are dropped, otherwise all events will be emitted once
       *  the provider is unpaused.
       */
      pause(dropWhilePaused) {
        __privateSet(this, _lastBlockNumber, -1);
        if (__privateGet(this, _pausedState) != null) {
          if (__privateGet(this, _pausedState) == !!dropWhilePaused) {
            return;
          }
          (0, index_js_6.assert)(false, "cannot change pause type; resume first", "UNSUPPORTED_OPERATION", {
            operation: "pause"
          });
        }
        this._forEachSubscriber((s2) => s2.pause(dropWhilePaused));
        __privateSet(this, _pausedState, !!dropWhilePaused);
        for (const timer of __privateGet(this, _timers).values()) {
          if (timer.timer) {
            clearTimeout(timer.timer);
          }
          timer.time = getTime() - timer.time;
        }
      }
      /**
       *  Resume the provider.
       */
      resume() {
        if (__privateGet(this, _pausedState) == null) {
          return;
        }
        this._forEachSubscriber((s2) => s2.resume());
        __privateSet(this, _pausedState, null);
        for (const timer of __privateGet(this, _timers).values()) {
          let timeout = timer.time;
          if (timeout < 0) {
            timeout = 0;
          }
          timer.time = getTime();
          setTimeout(timer.func, timeout);
        }
      }
    };
    _subs = new WeakMap();
    _plugins = new WeakMap();
    _pausedState = new WeakMap();
    _destroyed = new WeakMap();
    _networkPromise = new WeakMap();
    _anyNetwork = new WeakMap();
    _performCache = new WeakMap();
    _lastBlockNumber = new WeakMap();
    _nextTimer = new WeakMap();
    _timers = new WeakMap();
    _disableCcipRead = new WeakMap();
    _options = new WeakMap();
    _AbstractProvider_instances = new WeakSet();
    perform_fn = async function(req) {
      const timeout = __privateGet(this, _options).cacheTimeout;
      if (timeout < 0) {
        return await this._perform(req);
      }
      const tag = getTag(req.method, req);
      let perform = __privateGet(this, _performCache).get(tag);
      if (!perform) {
        perform = this._perform(req);
        __privateGet(this, _performCache).set(tag, perform);
        setTimeout(() => {
          if (__privateGet(this, _performCache).get(tag) === perform) {
            __privateGet(this, _performCache).delete(tag);
          }
        }, timeout);
      }
      return await perform;
    };
    call_fn = async function(tx, blockTag, attempt) {
      (0, index_js_6.assert)(attempt < MAX_CCIP_REDIRECTS, "CCIP read exceeded maximum redirections", "OFFCHAIN_FAULT", {
        reason: "TOO_MANY_REDIRECTS",
        transaction: Object.assign({}, tx, { blockTag, enableCcipRead: true })
      });
      const transaction = (0, provider_js_1.copyRequest)(tx);
      try {
        return (0, index_js_6.hexlify)(await this._perform({ method: "call", transaction, blockTag }));
      } catch (error) {
        if (!this.disableCcipRead && (0, index_js_6.isCallException)(error) && error.data && attempt >= 0 && blockTag === "latest" && transaction.to != null && (0, index_js_6.dataSlice)(error.data, 0, 4) === "0x556f1830") {
          const data = error.data;
          const txSender = await (0, index_js_1.resolveAddress)(transaction.to, this);
          let ccipArgs;
          try {
            ccipArgs = parseOffchainLookup((0, index_js_6.dataSlice)(error.data, 4));
          } catch (error2) {
            (0, index_js_6.assert)(false, error2.message, "OFFCHAIN_FAULT", {
              reason: "BAD_DATA",
              transaction,
              info: { data }
            });
          }
          (0, index_js_6.assert)(ccipArgs.sender.toLowerCase() === txSender.toLowerCase(), "CCIP Read sender mismatch", "CALL_EXCEPTION", {
            action: "call",
            data,
            reason: "OffchainLookup",
            transaction,
            invocation: null,
            revert: {
              signature: "OffchainLookup(address,string[],bytes,bytes4,bytes)",
              name: "OffchainLookup",
              args: ccipArgs.errorArgs
            }
          });
          const ccipResult = await this.ccipReadFetch(transaction, ccipArgs.calldata, ccipArgs.urls);
          (0, index_js_6.assert)(ccipResult != null, "CCIP Read failed to fetch data", "OFFCHAIN_FAULT", {
            reason: "FETCH_FAILED",
            transaction,
            info: { data: error.data, errorArgs: ccipArgs.errorArgs }
          });
          const tx2 = {
            to: txSender,
            data: (0, index_js_6.concat)([ccipArgs.selector, encodeBytes([ccipResult, ccipArgs.extraData])])
          };
          this.emit("debug", { action: "sendCcipReadCall", transaction: tx2 });
          try {
            const result = await __privateMethod(this, _AbstractProvider_instances, call_fn).call(this, tx2, blockTag, attempt + 1);
            this.emit("debug", { action: "receiveCcipReadCallResult", transaction: Object.assign({}, tx2), result });
            return result;
          } catch (error2) {
            this.emit("debug", { action: "receiveCcipReadCallError", transaction: Object.assign({}, tx2), error: error2 });
            throw error2;
          }
        }
        throw error;
      }
    };
    checkNetwork_fn = async function(promise) {
      const { value } = await (0, index_js_6.resolveProperties)({
        network: this.getNetwork(),
        value: promise
      });
      return value;
    };
    getAccountValue_fn = async function(request, _address, _blockTag) {
      let address = this._getAddress(_address);
      let blockTag = this._getBlockTag(_blockTag);
      if (typeof address !== "string" || typeof blockTag !== "string") {
        [address, blockTag] = await Promise.all([address, blockTag]);
      }
      return await __privateMethod(this, _AbstractProvider_instances, checkNetwork_fn).call(this, __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, Object.assign(request, { address, blockTag })));
    };
    getBlock_fn = async function(block, includeTransactions) {
      if ((0, index_js_6.isHexString)(block, 32)) {
        return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
          method: "getBlock",
          blockHash: block,
          includeTransactions
        });
      }
      let blockTag = this._getBlockTag(block);
      if (typeof blockTag !== "string") {
        blockTag = await blockTag;
      }
      return await __privateMethod(this, _AbstractProvider_instances, perform_fn).call(this, {
        method: "getBlock",
        blockTag,
        includeTransactions
      });
    };
    hasSub_fn = async function(event, emitArgs) {
      let sub = await getSubscription(event, this);
      if (sub.type === "event" && emitArgs && emitArgs.length > 0 && emitArgs[0].removed === true) {
        sub = await getSubscription({ orphan: "drop-log", log: emitArgs[0] }, this);
      }
      return __privateGet(this, _subs).get(sub.tag) || null;
    };
    getSub_fn = async function(event) {
      const subscription = await getSubscription(event, this);
      const tag = subscription.tag;
      let sub = __privateGet(this, _subs).get(tag);
      if (!sub) {
        const subscriber = this._getSubscriber(subscription);
        const addressableMap = /* @__PURE__ */ new WeakMap();
        const nameMap = /* @__PURE__ */ new Map();
        sub = { subscriber, tag, addressableMap, nameMap, started: false, listeners: [] };
        __privateGet(this, _subs).set(tag, sub);
      }
      return sub;
    };
    exports.AbstractProvider = AbstractProvider;
    function _parseString(result, start) {
      try {
        const bytes = _parseBytes(result, start);
        if (bytes) {
          return (0, index_js_6.toUtf8String)(bytes);
        }
      } catch (error) {
      }
      return null;
    }
    function _parseBytes(result, start) {
      if (result === "0x") {
        return null;
      }
      try {
        const offset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, start, start + 32));
        const length2 = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(result, offset, offset + 32));
        return (0, index_js_6.dataSlice)(result, offset + 32, offset + 32 + length2);
      } catch (error) {
      }
      return null;
    }
    function numPad(value) {
      const result = (0, index_js_6.toBeArray)(value);
      if (result.length > 32) {
        throw new Error("internal; should not happen");
      }
      const padded = new Uint8Array(32);
      padded.set(result, 32 - result.length);
      return padded;
    }
    function bytesPad(value) {
      if (value.length % 32 === 0) {
        return value;
      }
      const result = new Uint8Array(Math.ceil(value.length / 32) * 32);
      result.set(value);
      return result;
    }
    var empty = new Uint8Array([]);
    function encodeBytes(datas) {
      const result = [];
      let byteCount = 0;
      for (let i2 = 0; i2 < datas.length; i2++) {
        result.push(empty);
        byteCount += 32;
      }
      for (let i2 = 0; i2 < datas.length; i2++) {
        const data = (0, index_js_6.getBytes)(datas[i2]);
        result[i2] = numPad(byteCount);
        result.push(numPad(data.length));
        result.push(bytesPad(data));
        byteCount += 32 + Math.ceil(data.length / 32) * 32;
      }
      return (0, index_js_6.concat)(result);
    }
    var zeros = "0x0000000000000000000000000000000000000000000000000000000000000000";
    function parseOffchainLookup(data) {
      const result = {
        sender: "",
        urls: [],
        calldata: "",
        selector: "",
        extraData: "",
        errorArgs: []
      };
      (0, index_js_6.assert)((0, index_js_6.dataLength)(data) >= 5 * 32, "insufficient OffchainLookup data", "OFFCHAIN_FAULT", {
        reason: "insufficient OffchainLookup data"
      });
      const sender = (0, index_js_6.dataSlice)(data, 0, 32);
      (0, index_js_6.assert)((0, index_js_6.dataSlice)(sender, 0, 12) === (0, index_js_6.dataSlice)(zeros, 0, 12), "corrupt OffchainLookup sender", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup sender"
      });
      result.sender = (0, index_js_6.dataSlice)(sender, 12);
      try {
        const urls = [];
        const urlsOffset = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, 32, 64));
        const urlsLength = (0, index_js_6.getNumber)((0, index_js_6.dataSlice)(data, urlsOffset, urlsOffset + 32));
        const urlsData = (0, index_js_6.dataSlice)(data, urlsOffset + 32);
        for (let u3 = 0; u3 < urlsLength; u3++) {
          const url = _parseString(urlsData, u3 * 32);
          if (url == null) {
            throw new Error("abort");
          }
          urls.push(url);
        }
        result.urls = urls;
      } catch (error) {
        (0, index_js_6.assert)(false, "corrupt OffchainLookup urls", "OFFCHAIN_FAULT", {
          reason: "corrupt OffchainLookup urls"
        });
      }
      try {
        const calldata = _parseBytes(data, 64);
        if (calldata == null) {
          throw new Error("abort");
        }
        result.calldata = calldata;
      } catch (error) {
        (0, index_js_6.assert)(false, "corrupt OffchainLookup calldata", "OFFCHAIN_FAULT", {
          reason: "corrupt OffchainLookup calldata"
        });
      }
      (0, index_js_6.assert)((0, index_js_6.dataSlice)(data, 100, 128) === (0, index_js_6.dataSlice)(zeros, 0, 28), "corrupt OffchainLookup callbaackSelector", "OFFCHAIN_FAULT", {
        reason: "corrupt OffchainLookup callbaackSelector"
      });
      result.selector = (0, index_js_6.dataSlice)(data, 96, 100);
      try {
        const extraData = _parseBytes(data, 128);
        if (extraData == null) {
          throw new Error("abort");
        }
        result.extraData = extraData;
      } catch (error) {
        (0, index_js_6.assert)(false, "corrupt OffchainLookup extraData", "OFFCHAIN_FAULT", {
          reason: "corrupt OffchainLookup extraData"
        });
      }
      result.errorArgs = "sender,urls,calldata,selector,extraData".split(/,/).map((k4) => result[k4]);
      return result;
    }
  }
});

// node_modules/ethers/lib.commonjs/providers/abstract-signer.js
var require_abstract_signer = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/abstract-signer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.VoidSigner = exports.AbstractSigner = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_transaction2();
    var index_js_3 = require_utils5();
    var provider_js_1 = require_provider();
    function checkProvider(signer, operation) {
      if (signer.provider) {
        return signer.provider;
      }
      (0, index_js_3.assert)(false, "missing provider", "UNSUPPORTED_OPERATION", { operation });
    }
    async function populate(signer, tx) {
      let pop = (0, provider_js_1.copyRequest)(tx);
      if (pop.to != null) {
        pop.to = (0, index_js_1.resolveAddress)(pop.to, signer);
      }
      if (pop.from != null) {
        const from26 = pop.from;
        pop.from = Promise.all([
          signer.getAddress(),
          (0, index_js_1.resolveAddress)(from26, signer)
        ]).then(([address, from27]) => {
          (0, index_js_3.assertArgument)(address.toLowerCase() === from27.toLowerCase(), "transaction from mismatch", "tx.from", from27);
          return address;
        });
      } else {
        pop.from = signer.getAddress();
      }
      return await (0, index_js_3.resolveProperties)(pop);
    }
    var AbstractSigner = class {
      /**
       *  Creates a new Signer connected to %%provider%%.
       */
      constructor(provider) {
        /**
         *  The provider this signer is connected to.
         */
        __publicField(this, "provider");
        (0, index_js_3.defineProperties)(this, { provider: provider || null });
      }
      async getNonce(blockTag) {
        return checkProvider(this, "getTransactionCount").getTransactionCount(await this.getAddress(), blockTag);
      }
      async populateCall(tx) {
        const pop = await populate(this, tx);
        return pop;
      }
      async populateTransaction(tx) {
        const provider = checkProvider(this, "populateTransaction");
        const pop = await populate(this, tx);
        if (pop.nonce == null) {
          pop.nonce = await this.getNonce("pending");
        }
        if (pop.gasLimit == null) {
          pop.gasLimit = await this.estimateGas(pop);
        }
        const network = await this.provider.getNetwork();
        if (pop.chainId != null) {
          const chainId = (0, index_js_3.getBigInt)(pop.chainId);
          (0, index_js_3.assertArgument)(chainId === network.chainId, "transaction chainId mismatch", "tx.chainId", tx.chainId);
        } else {
          pop.chainId = network.chainId;
        }
        const hasEip1559 = pop.maxFeePerGas != null || pop.maxPriorityFeePerGas != null;
        if (pop.gasPrice != null && (pop.type === 2 || hasEip1559)) {
          (0, index_js_3.assertArgument)(false, "eip-1559 transaction do not support gasPrice", "tx", tx);
        } else if ((pop.type === 0 || pop.type === 1) && hasEip1559) {
          (0, index_js_3.assertArgument)(false, "pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "tx", tx);
        }
        if ((pop.type === 2 || pop.type == null) && (pop.maxFeePerGas != null && pop.maxPriorityFeePerGas != null)) {
          pop.type = 2;
        } else if (pop.type === 0 || pop.type === 1) {
          const feeData = await provider.getFeeData();
          (0, index_js_3.assert)(feeData.gasPrice != null, "network does not support gasPrice", "UNSUPPORTED_OPERATION", {
            operation: "getGasPrice"
          });
          if (pop.gasPrice == null) {
            pop.gasPrice = feeData.gasPrice;
          }
        } else {
          const feeData = await provider.getFeeData();
          if (pop.type == null) {
            if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
              pop.type = 2;
              if (pop.gasPrice != null) {
                const gasPrice = pop.gasPrice;
                delete pop.gasPrice;
                pop.maxFeePerGas = gasPrice;
                pop.maxPriorityFeePerGas = gasPrice;
              } else {
                if (pop.maxFeePerGas == null) {
                  pop.maxFeePerGas = feeData.maxFeePerGas;
                }
                if (pop.maxPriorityFeePerGas == null) {
                  pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                }
              }
            } else if (feeData.gasPrice != null) {
              (0, index_js_3.assert)(!hasEip1559, "network does not support EIP-1559", "UNSUPPORTED_OPERATION", {
                operation: "populateTransaction"
              });
              if (pop.gasPrice == null) {
                pop.gasPrice = feeData.gasPrice;
              }
              pop.type = 0;
            } else {
              (0, index_js_3.assert)(false, "failed to get consistent fee data", "UNSUPPORTED_OPERATION", {
                operation: "signer.getFeeData"
              });
            }
          } else if (pop.type === 2 || pop.type === 3) {
            if (pop.maxFeePerGas == null) {
              pop.maxFeePerGas = feeData.maxFeePerGas;
            }
            if (pop.maxPriorityFeePerGas == null) {
              pop.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
            }
          }
        }
        return await (0, index_js_3.resolveProperties)(pop);
      }
      async estimateGas(tx) {
        return checkProvider(this, "estimateGas").estimateGas(await this.populateCall(tx));
      }
      async call(tx) {
        return checkProvider(this, "call").call(await this.populateCall(tx));
      }
      async resolveName(name) {
        const provider = checkProvider(this, "resolveName");
        return await provider.resolveName(name);
      }
      async sendTransaction(tx) {
        const provider = checkProvider(this, "sendTransaction");
        const pop = await this.populateTransaction(tx);
        delete pop.from;
        const txObj = index_js_2.Transaction.from(pop);
        return await provider.broadcastTransaction(await this.signTransaction(txObj));
      }
    };
    exports.AbstractSigner = AbstractSigner;
    var _VoidSigner_instances, throwUnsupported_fn;
    var _VoidSigner = class _VoidSigner extends AbstractSigner {
      /**
       *  Creates a new **VoidSigner** with %%address%% attached to
       *  %%provider%%.
       */
      constructor(address, provider) {
        super(provider);
        __privateAdd(this, _VoidSigner_instances);
        /**
         *  The signer address.
         */
        __publicField(this, "address");
        (0, index_js_3.defineProperties)(this, { address });
      }
      async getAddress() {
        return this.address;
      }
      connect(provider) {
        return new _VoidSigner(this.address, provider);
      }
      async signTransaction(tx) {
        __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "transactions", "signTransaction");
      }
      async signMessage(message) {
        __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "messages", "signMessage");
      }
      async signTypedData(domain, types3, value) {
        __privateMethod(this, _VoidSigner_instances, throwUnsupported_fn).call(this, "typed-data", "signTypedData");
      }
    };
    _VoidSigner_instances = new WeakSet();
    throwUnsupported_fn = function(suffix, operation) {
      (0, index_js_3.assert)(false, `VoidSigner cannot sign ${suffix}`, "UNSUPPORTED_OPERATION", { operation });
    };
    var VoidSigner = _VoidSigner;
    exports.VoidSigner = VoidSigner;
  }
});

// node_modules/ethers/lib.commonjs/providers/community.js
var require_community = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/community.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.showThrottleMessage = void 0;
    var shown = /* @__PURE__ */ new Set();
    function showThrottleMessage(service) {
      if (shown.has(service)) {
        return;
      }
      shown.add(service);
      console.log("========= NOTICE =========");
      console.log(`Request-Rate Exceeded for ${service} (this message will not be repeated)`);
      console.log("");
      console.log("The default API keys for each service are provided as a highly-throttled,");
      console.log("community resource for low-traffic projects and early prototyping.");
      console.log("");
      console.log("While your application will continue to function, we highly recommended");
      console.log("signing up for your own API keys to improve performance, increase your");
      console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
      console.log("");
      console.log("For more details: https://docs.ethers.org/api-keys/");
      console.log("==========================");
    }
    exports.showThrottleMessage = showThrottleMessage;
  }
});

// node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js
var require_subscriber_filterid = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/subscriber-filterid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FilterIdPendingSubscriber = exports.FilterIdEventSubscriber = exports.FilterIdSubscriber = void 0;
    var index_js_1 = require_utils5();
    var subscriber_polling_js_1 = require_subscriber_polling();
    function copy(obj) {
      return JSON.parse(JSON.stringify(obj));
    }
    var _provider, _filterIdPromise, _poller, _running, _network, _hault, _FilterIdSubscriber_instances, poll_fn, teardown_fn;
    var FilterIdSubscriber = class {
      /**
       *  Creates a new **FilterIdSubscriber** which will used [[_subscribe]]
       *  and [[_emitResults]] to setup the subscription and provide the event
       *  to the %%provider%%.
       */
      constructor(provider) {
        __privateAdd(this, _FilterIdSubscriber_instances);
        __privateAdd(this, _provider);
        __privateAdd(this, _filterIdPromise);
        __privateAdd(this, _poller);
        __privateAdd(this, _running);
        __privateAdd(this, _network);
        __privateAdd(this, _hault);
        __privateSet(this, _provider, provider);
        __privateSet(this, _filterIdPromise, null);
        __privateSet(this, _poller, __privateMethod(this, _FilterIdSubscriber_instances, poll_fn).bind(this));
        __privateSet(this, _running, false);
        __privateSet(this, _network, null);
        __privateSet(this, _hault, false);
      }
      /**
       *  Sub-classes **must** override this to begin the subscription.
       */
      _subscribe(provider) {
        throw new Error("subclasses must override this");
      }
      /**
       *  Sub-classes **must** override this handle the events.
       */
      _emitResults(provider, result) {
        throw new Error("subclasses must override this");
      }
      /**
       *  Sub-classes **must** override this handle recovery on errors.
       */
      _recover(provider) {
        throw new Error("subclasses must override this");
      }
      start() {
        if (__privateGet(this, _running)) {
          return;
        }
        __privateSet(this, _running, true);
        __privateMethod(this, _FilterIdSubscriber_instances, poll_fn).call(this, -2);
      }
      stop() {
        if (!__privateGet(this, _running)) {
          return;
        }
        __privateSet(this, _running, false);
        __privateSet(this, _hault, true);
        __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
        __privateGet(this, _provider).off("block", __privateGet(this, _poller));
      }
      pause(dropWhilePaused) {
        if (dropWhilePaused) {
          __privateMethod(this, _FilterIdSubscriber_instances, teardown_fn).call(this);
        }
        __privateGet(this, _provider).off("block", __privateGet(this, _poller));
      }
      resume() {
        this.start();
      }
    };
    _provider = new WeakMap();
    _filterIdPromise = new WeakMap();
    _poller = new WeakMap();
    _running = new WeakMap();
    _network = new WeakMap();
    _hault = new WeakMap();
    _FilterIdSubscriber_instances = new WeakSet();
    poll_fn = async function(blockNumber) {
      try {
        if (__privateGet(this, _filterIdPromise) == null) {
          __privateSet(this, _filterIdPromise, this._subscribe(__privateGet(this, _provider)));
        }
        let filterId = null;
        try {
          filterId = await __privateGet(this, _filterIdPromise);
        } catch (error) {
          if (!(0, index_js_1.isError)(error, "UNSUPPORTED_OPERATION") || error.operation !== "eth_newFilter") {
            throw error;
          }
        }
        if (filterId == null) {
          __privateSet(this, _filterIdPromise, null);
          __privateGet(this, _provider)._recoverSubscriber(this, this._recover(__privateGet(this, _provider)));
          return;
        }
        const network = await __privateGet(this, _provider).getNetwork();
        if (!__privateGet(this, _network)) {
          __privateSet(this, _network, network);
        }
        if (__privateGet(this, _network).chainId !== network.chainId) {
          throw new Error("chaid changed");
        }
        if (__privateGet(this, _hault)) {
          return;
        }
        const result = await __privateGet(this, _provider).send("eth_getFilterChanges", [filterId]);
        await this._emitResults(__privateGet(this, _provider), result);
      } catch (error) {
        console.log("@TODO", error);
      }
      __privateGet(this, _provider).once("block", __privateGet(this, _poller));
    };
    teardown_fn = function() {
      const filterIdPromise = __privateGet(this, _filterIdPromise);
      if (filterIdPromise) {
        __privateSet(this, _filterIdPromise, null);
        filterIdPromise.then((filterId) => {
          if (__privateGet(this, _provider).destroyed) {
            return;
          }
          __privateGet(this, _provider).send("eth_uninstallFilter", [filterId]);
        });
      }
    };
    exports.FilterIdSubscriber = FilterIdSubscriber;
    var _event;
    var FilterIdEventSubscriber = class extends FilterIdSubscriber {
      /**
       *  Creates a new **FilterIdEventSubscriber** attached to %%provider%%
       *  listening for %%filter%%.
       */
      constructor(provider, filter3) {
        super(provider);
        __privateAdd(this, _event);
        __privateSet(this, _event, copy(filter3));
      }
      _recover(provider) {
        return new subscriber_polling_js_1.PollingEventSubscriber(provider, __privateGet(this, _event));
      }
      async _subscribe(provider) {
        const filterId = await provider.send("eth_newFilter", [__privateGet(this, _event)]);
        return filterId;
      }
      async _emitResults(provider, results2) {
        for (const result of results2) {
          provider.emit(__privateGet(this, _event), provider._wrapLog(result, provider._network));
        }
      }
    };
    _event = new WeakMap();
    exports.FilterIdEventSubscriber = FilterIdEventSubscriber;
    var FilterIdPendingSubscriber = class extends FilterIdSubscriber {
      async _subscribe(provider) {
        return await provider.send("eth_newPendingTransactionFilter", []);
      }
      async _emitResults(provider, results2) {
        for (const result of results2) {
          provider.emit("pending", result);
        }
      }
    };
    exports.FilterIdPendingSubscriber = FilterIdPendingSubscriber;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js
var require_provider_jsonrpc = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-jsonrpc.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.JsonRpcProvider = exports.JsonRpcApiPollingProvider = exports.JsonRpcApiProvider = exports.JsonRpcSigner = void 0;
    var index_js_1 = require_abi();
    var index_js_2 = require_address2();
    var index_js_3 = require_hash();
    var index_js_4 = require_transaction2();
    var index_js_5 = require_utils5();
    var abstract_provider_js_1 = require_abstract_provider();
    var abstract_signer_js_1 = require_abstract_signer();
    var network_js_1 = require_network();
    var subscriber_filterid_js_1 = require_subscriber_filterid();
    var subscriber_polling_js_1 = require_subscriber_polling();
    var Primitive = "bigint,boolean,function,number,string,symbol".split(/,/g);
    function deepCopy(value) {
      if (value == null || Primitive.indexOf(typeof value) >= 0) {
        return value;
      }
      if (typeof value.getAddress === "function") {
        return value;
      }
      if (Array.isArray(value)) {
        return value.map(deepCopy);
      }
      if (typeof value === "object") {
        return Object.keys(value).reduce((accum, key) => {
          accum[key] = value[key];
          return accum;
        }, {});
      }
      throw new Error(`should not happen: ${value} (${typeof value})`);
    }
    function stall(duration) {
      return new Promise((resolve) => {
        setTimeout(resolve, duration);
      });
    }
    function getLowerCase(value) {
      if (value) {
        return value.toLowerCase();
      }
      return value;
    }
    function isPollable(value) {
      return value && typeof value.pollingInterval === "number";
    }
    var defaultOptions = {
      polling: false,
      staticNetwork: null,
      batchStallTime: 10,
      batchMaxSize: 1 << 20,
      batchMaxCount: 100,
      cacheTimeout: 250,
      pollingInterval: 4e3
    };
    var JsonRpcSigner = class extends abstract_signer_js_1.AbstractSigner {
      constructor(provider, address) {
        super(provider);
        __publicField(this, "address");
        address = (0, index_js_2.getAddress)(address);
        (0, index_js_5.defineProperties)(this, { address });
      }
      connect(provider) {
        (0, index_js_5.assert)(false, "cannot reconnect JsonRpcSigner", "UNSUPPORTED_OPERATION", {
          operation: "signer.connect"
        });
      }
      async getAddress() {
        return this.address;
      }
      // JSON-RPC will automatially fill in nonce, etc. so we just check from
      async populateTransaction(tx) {
        return await this.populateCall(tx);
      }
      // Returns just the hash of the transaction after sent, which is what
      // the bare JSON-RPC API does;
      async sendUncheckedTransaction(_tx) {
        const tx = deepCopy(_tx);
        const promises = [];
        if (tx.from) {
          const _from = tx.from;
          promises.push((async () => {
            const from26 = await (0, index_js_2.resolveAddress)(_from, this.provider);
            (0, index_js_5.assertArgument)(from26 != null && from26.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
            tx.from = from26;
          })());
        } else {
          tx.from = this.address;
        }
        if (tx.gasLimit == null) {
          promises.push((async () => {
            tx.gasLimit = await this.provider.estimateGas({ ...tx, from: this.address });
          })());
        }
        if (tx.to != null) {
          const _to = tx.to;
          promises.push((async () => {
            tx.to = await (0, index_js_2.resolveAddress)(_to, this.provider);
          })());
        }
        if (promises.length) {
          await Promise.all(promises);
        }
        const hexTx = this.provider.getRpcTransaction(tx);
        return this.provider.send("eth_sendTransaction", [hexTx]);
      }
      async sendTransaction(tx) {
        const blockNumber = await this.provider.getBlockNumber();
        const hash8 = await this.sendUncheckedTransaction(tx);
        return await new Promise((resolve, reject) => {
          const timeouts = [1e3, 100];
          let invalids = 0;
          const checkTx = async () => {
            try {
              const tx2 = await this.provider.getTransaction(hash8);
              if (tx2 != null) {
                resolve(tx2.replaceableTransaction(blockNumber));
                return;
              }
            } catch (error) {
              if ((0, index_js_5.isError)(error, "CANCELLED") || (0, index_js_5.isError)(error, "BAD_DATA") || (0, index_js_5.isError)(error, "NETWORK_ERROR") || (0, index_js_5.isError)(error, "UNSUPPORTED_OPERATION")) {
                if (error.info == null) {
                  error.info = {};
                }
                error.info.sendTransactionHash = hash8;
                reject(error);
                return;
              }
              if ((0, index_js_5.isError)(error, "INVALID_ARGUMENT")) {
                invalids++;
                if (error.info == null) {
                  error.info = {};
                }
                error.info.sendTransactionHash = hash8;
                if (invalids > 10) {
                  reject(error);
                  return;
                }
              }
              this.provider.emit("error", (0, index_js_5.makeError)("failed to fetch transation after sending (will try again)", "UNKNOWN_ERROR", { error }));
            }
            this.provider._setTimeout(() => {
              checkTx();
            }, timeouts.pop() || 4e3);
          };
          checkTx();
        });
      }
      async signTransaction(_tx) {
        const tx = deepCopy(_tx);
        if (tx.from) {
          const from26 = await (0, index_js_2.resolveAddress)(tx.from, this.provider);
          (0, index_js_5.assertArgument)(from26 != null && from26.toLowerCase() === this.address.toLowerCase(), "from address mismatch", "transaction", _tx);
          tx.from = from26;
        } else {
          tx.from = this.address;
        }
        const hexTx = this.provider.getRpcTransaction(tx);
        return await this.provider.send("eth_signTransaction", [hexTx]);
      }
      async signMessage(_message) {
        const message = typeof _message === "string" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;
        return await this.provider.send("personal_sign", [
          (0, index_js_5.hexlify)(message),
          this.address.toLowerCase()
        ]);
      }
      async signTypedData(domain, types3, _value) {
        const value = deepCopy(_value);
        const populated = await index_js_3.TypedDataEncoder.resolveNames(domain, types3, value, async (value2) => {
          const address = await (0, index_js_2.resolveAddress)(value2);
          (0, index_js_5.assertArgument)(address != null, "TypedData does not support null address", "value", value2);
          return address;
        });
        return await this.provider.send("eth_signTypedData_v4", [
          this.address.toLowerCase(),
          JSON.stringify(index_js_3.TypedDataEncoder.getPayload(populated.domain, types3, populated.value))
        ]);
      }
      async unlock(password) {
        return this.provider.send("personal_unlockAccount", [
          this.address.toLowerCase(),
          password,
          null
        ]);
      }
      // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
      async _legacySignMessage(_message) {
        const message = typeof _message === "string" ? (0, index_js_5.toUtf8Bytes)(_message) : _message;
        return await this.provider.send("eth_sign", [
          this.address.toLowerCase(),
          (0, index_js_5.hexlify)(message)
        ]);
      }
    };
    exports.JsonRpcSigner = JsonRpcSigner;
    var _options, _nextId, _payloads, _drainTimer, _notReady, _network, _pendingDetectNetwork, _JsonRpcApiProvider_instances, scheduleDrain_fn;
    var JsonRpcApiProvider = class extends abstract_provider_js_1.AbstractProvider {
      constructor(network, options) {
        super(network, options);
        __privateAdd(this, _JsonRpcApiProvider_instances);
        __privateAdd(this, _options);
        // The next ID to use for the JSON-RPC ID field
        __privateAdd(this, _nextId);
        // Payloads are queued and triggered in batches using the drainTimer
        __privateAdd(this, _payloads);
        __privateAdd(this, _drainTimer);
        __privateAdd(this, _notReady);
        __privateAdd(this, _network);
        __privateAdd(this, _pendingDetectNetwork);
        __privateSet(this, _nextId, 1);
        __privateSet(this, _options, Object.assign({}, defaultOptions, options || {}));
        __privateSet(this, _payloads, []);
        __privateSet(this, _drainTimer, null);
        __privateSet(this, _network, null);
        __privateSet(this, _pendingDetectNetwork, null);
        {
          let resolve = null;
          const promise = new Promise((_resolve) => {
            resolve = _resolve;
          });
          __privateSet(this, _notReady, { promise, resolve });
        }
        const staticNetwork = this._getOption("staticNetwork");
        if (typeof staticNetwork === "boolean") {
          (0, index_js_5.assertArgument)(!staticNetwork || network !== "any", "staticNetwork cannot be used on special network 'any'", "options", options);
          if (staticNetwork && network != null) {
            __privateSet(this, _network, network_js_1.Network.from(network));
          }
        } else if (staticNetwork) {
          (0, index_js_5.assertArgument)(network == null || staticNetwork.matches(network), "staticNetwork MUST match network object", "options", options);
          __privateSet(this, _network, staticNetwork);
        }
      }
      /**
       *  Returns the value associated with the option %%key%%.
       *
       *  Sub-classes can use this to inquire about configuration options.
       */
      _getOption(key) {
        return __privateGet(this, _options)[key];
      }
      /**
       *  Gets the [[Network]] this provider has committed to. On each call, the network
       *  is detected, and if it has changed, the call will reject.
       */
      get _network() {
        (0, index_js_5.assert)(__privateGet(this, _network), "network is not available yet", "NETWORK_ERROR");
        return __privateGet(this, _network);
      }
      /**
       *  Resolves to the non-normalized value by performing %%req%%.
       *
       *  Sub-classes may override this to modify behavior of actions,
       *  and should generally call ``super._perform`` as a fallback.
       */
      async _perform(req) {
        if (req.method === "call" || req.method === "estimateGas") {
          let tx = req.transaction;
          if (tx && tx.type != null && (0, index_js_5.getBigInt)(tx.type)) {
            if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
              const feeData = await this.getFeeData();
              if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                req = Object.assign({}, req, {
                  transaction: Object.assign({}, tx, { type: void 0 })
                });
              }
            }
          }
        }
        const request = this.getRpcRequest(req);
        if (request != null) {
          return await this.send(request.method, request.args);
        }
        return super._perform(req);
      }
      /**
       *  Sub-classes may override this; it detects the *actual* network that
       *  we are **currently** connected to.
       *
       *  Keep in mind that [[send]] may only be used once [[ready]], otherwise the
       *  _send primitive must be used instead.
       */
      async _detectNetwork() {
        const network = this._getOption("staticNetwork");
        if (network) {
          if (network === true) {
            if (__privateGet(this, _network)) {
              return __privateGet(this, _network);
            }
          } else {
            return network;
          }
        }
        if (__privateGet(this, _pendingDetectNetwork)) {
          return await __privateGet(this, _pendingDetectNetwork);
        }
        if (this.ready) {
          __privateSet(this, _pendingDetectNetwork, (async () => {
            try {
              const result = network_js_1.Network.from((0, index_js_5.getBigInt)(await this.send("eth_chainId", [])));
              __privateSet(this, _pendingDetectNetwork, null);
              return result;
            } catch (error) {
              __privateSet(this, _pendingDetectNetwork, null);
              throw error;
            }
          })());
          return await __privateGet(this, _pendingDetectNetwork);
        }
        __privateSet(this, _pendingDetectNetwork, (async () => {
          const payload = {
            id: __privateWrapper(this, _nextId)._++,
            method: "eth_chainId",
            params: [],
            jsonrpc: "2.0"
          };
          this.emit("debug", { action: "sendRpcPayload", payload });
          let result;
          try {
            result = (await this._send(payload))[0];
            __privateSet(this, _pendingDetectNetwork, null);
          } catch (error) {
            __privateSet(this, _pendingDetectNetwork, null);
            this.emit("debug", { action: "receiveRpcError", error });
            throw error;
          }
          this.emit("debug", { action: "receiveRpcResult", result });
          if ("result" in result) {
            return network_js_1.Network.from((0, index_js_5.getBigInt)(result.result));
          }
          throw this.getRpcError(payload, result);
        })());
        return await __privateGet(this, _pendingDetectNetwork);
      }
      /**
       *  Sub-classes **MUST** call this. Until [[_start]] has been called, no calls
       *  will be passed to [[_send]] from [[send]]. If it is overridden, then
       *  ``super._start()`` **MUST** be called.
       *
       *  Calling it multiple times is safe and has no effect.
       */
      _start() {
        if (__privateGet(this, _notReady) == null || __privateGet(this, _notReady).resolve == null) {
          return;
        }
        __privateGet(this, _notReady).resolve();
        __privateSet(this, _notReady, null);
        (async () => {
          while (__privateGet(this, _network) == null && !this.destroyed) {
            try {
              __privateSet(this, _network, await this._detectNetwork());
            } catch (error) {
              if (this.destroyed) {
                break;
              }
              console.log("JsonRpcProvider failed to detect network and cannot start up; retry in 1s (perhaps the URL is wrong or the node is not started)");
              this.emit("error", (0, index_js_5.makeError)("failed to bootstrap network detection", "NETWORK_ERROR", { event: "initial-network-discovery", info: { error } }));
              await stall(1e3);
            }
          }
          __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
        })();
      }
      /**
       *  Resolves once the [[_start]] has been called. This can be used in
       *  sub-classes to defer sending data until the connection has been
       *  established.
       */
      async _waitUntilReady() {
        if (__privateGet(this, _notReady) == null) {
          return;
        }
        return await __privateGet(this, _notReady).promise;
      }
      /**
       *  Return a Subscriber that will manage the %%sub%%.
       *
       *  Sub-classes may override this to modify the behavior of
       *  subscription management.
       */
      _getSubscriber(sub) {
        if (sub.type === "pending") {
          return new subscriber_filterid_js_1.FilterIdPendingSubscriber(this);
        }
        if (sub.type === "event") {
          if (this._getOption("polling")) {
            return new subscriber_polling_js_1.PollingEventSubscriber(this, sub.filter);
          }
          return new subscriber_filterid_js_1.FilterIdEventSubscriber(this, sub.filter);
        }
        if (sub.type === "orphan" && sub.filter.orphan === "drop-log") {
          return new abstract_provider_js_1.UnmanagedSubscriber("orphan");
        }
        return super._getSubscriber(sub);
      }
      /**
       *  Returns true only if the [[_start]] has been called.
       */
      get ready() {
        return __privateGet(this, _notReady) == null;
      }
      /**
       *  Returns %%tx%% as a normalized JSON-RPC transaction request,
       *  which has all values hexlified and any numeric values converted
       *  to Quantity values.
       */
      getRpcTransaction(tx) {
        const result = {};
        ["chainId", "gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach((key) => {
          if (tx[key] == null) {
            return;
          }
          let dstKey = key;
          if (key === "gasLimit") {
            dstKey = "gas";
          }
          result[dstKey] = (0, index_js_5.toQuantity)((0, index_js_5.getBigInt)(tx[key], `tx.${key}`));
        });
        ["from", "to", "data"].forEach((key) => {
          if (tx[key] == null) {
            return;
          }
          result[key] = (0, index_js_5.hexlify)(tx[key]);
        });
        if (tx.accessList) {
          result["accessList"] = (0, index_js_4.accessListify)(tx.accessList);
        }
        if (tx.blobVersionedHashes) {
          result["blobVersionedHashes"] = tx.blobVersionedHashes.map((h) => h.toLowerCase());
        }
        return result;
      }
      /**
       *  Returns the request method and arguments required to perform
       *  %%req%%.
       */
      getRpcRequest(req) {
        switch (req.method) {
          case "chainId":
            return { method: "eth_chainId", args: [] };
          case "getBlockNumber":
            return { method: "eth_blockNumber", args: [] };
          case "getGasPrice":
            return { method: "eth_gasPrice", args: [] };
          case "getPriorityFee":
            return { method: "eth_maxPriorityFeePerGas", args: [] };
          case "getBalance":
            return {
              method: "eth_getBalance",
              args: [getLowerCase(req.address), req.blockTag]
            };
          case "getTransactionCount":
            return {
              method: "eth_getTransactionCount",
              args: [getLowerCase(req.address), req.blockTag]
            };
          case "getCode":
            return {
              method: "eth_getCode",
              args: [getLowerCase(req.address), req.blockTag]
            };
          case "getStorage":
            return {
              method: "eth_getStorageAt",
              args: [
                getLowerCase(req.address),
                "0x" + req.position.toString(16),
                req.blockTag
              ]
            };
          case "broadcastTransaction":
            return {
              method: "eth_sendRawTransaction",
              args: [req.signedTransaction]
            };
          case "getBlock":
            if ("blockTag" in req) {
              return {
                method: "eth_getBlockByNumber",
                args: [req.blockTag, !!req.includeTransactions]
              };
            } else if ("blockHash" in req) {
              return {
                method: "eth_getBlockByHash",
                args: [req.blockHash, !!req.includeTransactions]
              };
            }
            break;
          case "getTransaction":
            return {
              method: "eth_getTransactionByHash",
              args: [req.hash]
            };
          case "getTransactionReceipt":
            return {
              method: "eth_getTransactionReceipt",
              args: [req.hash]
            };
          case "call":
            return {
              method: "eth_call",
              args: [this.getRpcTransaction(req.transaction), req.blockTag]
            };
          case "estimateGas": {
            return {
              method: "eth_estimateGas",
              args: [this.getRpcTransaction(req.transaction)]
            };
          }
          case "getLogs":
            if (req.filter && req.filter.address != null) {
              if (Array.isArray(req.filter.address)) {
                req.filter.address = req.filter.address.map(getLowerCase);
              } else {
                req.filter.address = getLowerCase(req.filter.address);
              }
            }
            return { method: "eth_getLogs", args: [req.filter] };
        }
        return null;
      }
      /**
       *  Returns an ethers-style Error for the given JSON-RPC error
       *  %%payload%%, coalescing the various strings and error shapes
       *  that different nodes return, coercing them into a machine-readable
       *  standardized error.
       */
      getRpcError(payload, _error) {
        const { method } = payload;
        const { error } = _error;
        if (method === "eth_estimateGas" && error.message) {
          const msg = error.message;
          if (!msg.match(/revert/i) && msg.match(/insufficient funds/i)) {
            return (0, index_js_5.makeError)("insufficient funds", "INSUFFICIENT_FUNDS", {
              transaction: payload.params[0],
              info: { payload, error }
            });
          }
        }
        if (method === "eth_call" || method === "eth_estimateGas") {
          const result = spelunkData(error);
          const e2 = index_js_1.AbiCoder.getBuiltinCallException(method === "eth_call" ? "call" : "estimateGas", payload.params[0], result ? result.data : null);
          e2.info = { error, payload };
          return e2;
        }
        const message = JSON.stringify(spelunkMessage(error));
        if (typeof error.message === "string" && error.message.match(/user denied|ethers-user-denied/i)) {
          const actionMap = {
            eth_sign: "signMessage",
            personal_sign: "signMessage",
            eth_signTypedData_v4: "signTypedData",
            eth_signTransaction: "signTransaction",
            eth_sendTransaction: "sendTransaction",
            eth_requestAccounts: "requestAccess",
            wallet_requestAccounts: "requestAccess"
          };
          return (0, index_js_5.makeError)(`user rejected action`, "ACTION_REJECTED", {
            action: actionMap[method] || "unknown",
            reason: "rejected",
            info: { payload, error }
          });
        }
        if (method === "eth_sendRawTransaction" || method === "eth_sendTransaction") {
          const transaction = payload.params[0];
          if (message.match(/insufficient funds|base fee exceeds gas limit/i)) {
            return (0, index_js_5.makeError)("insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
              transaction,
              info: { error }
            });
          }
          if (message.match(/nonce/i) && message.match(/too low/i)) {
            return (0, index_js_5.makeError)("nonce has already been used", "NONCE_EXPIRED", { transaction, info: { error } });
          }
          if (message.match(/replacement transaction/i) && message.match(/underpriced/i)) {
            return (0, index_js_5.makeError)("replacement fee too low", "REPLACEMENT_UNDERPRICED", { transaction, info: { error } });
          }
          if (message.match(/only replay-protected/i)) {
            return (0, index_js_5.makeError)("legacy pre-eip-155 transactions not supported", "UNSUPPORTED_OPERATION", {
              operation: method,
              info: { transaction, info: { error } }
            });
          }
        }
        let unsupported = !!message.match(/the method .* does not exist/i);
        if (!unsupported) {
          if (error && error.details && error.details.startsWith("Unauthorized method:")) {
            unsupported = true;
          }
        }
        if (unsupported) {
          return (0, index_js_5.makeError)("unsupported operation", "UNSUPPORTED_OPERATION", {
            operation: payload.method,
            info: { error, payload }
          });
        }
        return (0, index_js_5.makeError)("could not coalesce error", "UNKNOWN_ERROR", { error, payload });
      }
      /**
       *  Requests the %%method%% with %%params%% via the JSON-RPC protocol
       *  over the underlying channel. This can be used to call methods
       *  on the backend that do not have a high-level API within the Provider
       *  API.
       *
       *  This method queues requests according to the batch constraints
       *  in the options, assigns the request a unique ID.
       *
       *  **Do NOT override** this method in sub-classes; instead
       *  override [[_send]] or force the options values in the
       *  call to the constructor to modify this method's behavior.
       */
      send(method, params) {
        if (this.destroyed) {
          return Promise.reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: method }));
        }
        const id3 = __privateWrapper(this, _nextId)._++;
        const promise = new Promise((resolve, reject) => {
          __privateGet(this, _payloads).push({
            resolve,
            reject,
            payload: { method, params, id: id3, jsonrpc: "2.0" }
          });
        });
        __privateMethod(this, _JsonRpcApiProvider_instances, scheduleDrain_fn).call(this);
        return promise;
      }
      /**
       *  Resolves to the [[Signer]] account for  %%address%% managed by
       *  the client.
       *
       *  If the %%address%% is a number, it is used as an index in the
       *  the accounts from [[listAccounts]].
       *
       *  This can only be used on clients which manage accounts (such as
       *  Geth with imported account or MetaMask).
       *
       *  Throws if the account doesn't exist.
       */
      async getSigner(address) {
        if (address == null) {
          address = 0;
        }
        const accountsPromise = this.send("eth_accounts", []);
        if (typeof address === "number") {
          const accounts2 = await accountsPromise;
          if (address >= accounts2.length) {
            throw new Error("no such account");
          }
          return new JsonRpcSigner(this, accounts2[address]);
        }
        const { accounts } = await (0, index_js_5.resolveProperties)({
          network: this.getNetwork(),
          accounts: accountsPromise
        });
        address = (0, index_js_2.getAddress)(address);
        for (const account of accounts) {
          if ((0, index_js_2.getAddress)(account) === address) {
            return new JsonRpcSigner(this, address);
          }
        }
        throw new Error("invalid account");
      }
      async listAccounts() {
        const accounts = await this.send("eth_accounts", []);
        return accounts.map((a3) => new JsonRpcSigner(this, a3));
      }
      destroy() {
        if (__privateGet(this, _drainTimer)) {
          clearTimeout(__privateGet(this, _drainTimer));
          __privateSet(this, _drainTimer, null);
        }
        for (const { payload, reject } of __privateGet(this, _payloads)) {
          reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload.method }));
        }
        __privateSet(this, _payloads, []);
        super.destroy();
      }
    };
    _options = new WeakMap();
    _nextId = new WeakMap();
    _payloads = new WeakMap();
    _drainTimer = new WeakMap();
    _notReady = new WeakMap();
    _network = new WeakMap();
    _pendingDetectNetwork = new WeakMap();
    _JsonRpcApiProvider_instances = new WeakSet();
    scheduleDrain_fn = function() {
      if (__privateGet(this, _drainTimer)) {
        return;
      }
      const stallTime = this._getOption("batchMaxCount") === 1 ? 0 : this._getOption("batchStallTime");
      __privateSet(this, _drainTimer, setTimeout(() => {
        __privateSet(this, _drainTimer, null);
        const payloads = __privateGet(this, _payloads);
        __privateSet(this, _payloads, []);
        while (payloads.length) {
          const batch = [payloads.shift()];
          while (payloads.length) {
            if (batch.length === __privateGet(this, _options).batchMaxCount) {
              break;
            }
            batch.push(payloads.shift());
            const bytes = JSON.stringify(batch.map((p2) => p2.payload));
            if (bytes.length > __privateGet(this, _options).batchMaxSize) {
              payloads.unshift(batch.pop());
              break;
            }
          }
          (async () => {
            const payload = batch.length === 1 ? batch[0].payload : batch.map((p2) => p2.payload);
            this.emit("debug", { action: "sendRpcPayload", payload });
            try {
              const result = await this._send(payload);
              this.emit("debug", { action: "receiveRpcResult", result });
              for (const { resolve, reject, payload: payload2 } of batch) {
                if (this.destroyed) {
                  reject((0, index_js_5.makeError)("provider destroyed; cancelled request", "UNSUPPORTED_OPERATION", { operation: payload2.method }));
                  continue;
                }
                const resp = result.filter((r2) => r2.id === payload2.id)[0];
                if (resp == null) {
                  const error = (0, index_js_5.makeError)("missing response for request", "BAD_DATA", {
                    value: result,
                    info: { payload: payload2 }
                  });
                  this.emit("error", error);
                  reject(error);
                  continue;
                }
                if ("error" in resp) {
                  reject(this.getRpcError(payload2, resp));
                  continue;
                }
                resolve(resp.result);
              }
            } catch (error) {
              this.emit("debug", { action: "receiveRpcError", error });
              for (const { reject } of batch) {
                reject(error);
              }
            }
          })();
        }
      }, stallTime));
    };
    exports.JsonRpcApiProvider = JsonRpcApiProvider;
    var _pollingInterval;
    var JsonRpcApiPollingProvider = class extends JsonRpcApiProvider {
      constructor(network, options) {
        super(network, options);
        __privateAdd(this, _pollingInterval);
        let pollingInterval = this._getOption("pollingInterval");
        if (pollingInterval == null) {
          pollingInterval = defaultOptions.pollingInterval;
        }
        __privateSet(this, _pollingInterval, pollingInterval);
      }
      _getSubscriber(sub) {
        const subscriber = super._getSubscriber(sub);
        if (isPollable(subscriber)) {
          subscriber.pollingInterval = __privateGet(this, _pollingInterval);
        }
        return subscriber;
      }
      /**
       *  The polling interval (default: 4000 ms)
       */
      get pollingInterval() {
        return __privateGet(this, _pollingInterval);
      }
      set pollingInterval(value) {
        if (!Number.isInteger(value) || value < 0) {
          throw new Error("invalid interval");
        }
        __privateSet(this, _pollingInterval, value);
        this._forEachSubscriber((sub) => {
          if (isPollable(sub)) {
            sub.pollingInterval = __privateGet(this, _pollingInterval);
          }
        });
      }
    };
    _pollingInterval = new WeakMap();
    exports.JsonRpcApiPollingProvider = JsonRpcApiPollingProvider;
    var _connect;
    var JsonRpcProvider = class extends JsonRpcApiPollingProvider {
      constructor(url, network, options) {
        if (url == null) {
          url = "http://localhost:8545";
        }
        super(network, options);
        __privateAdd(this, _connect);
        if (typeof url === "string") {
          __privateSet(this, _connect, new index_js_5.FetchRequest(url));
        } else {
          __privateSet(this, _connect, url.clone());
        }
      }
      _getConnection() {
        return __privateGet(this, _connect).clone();
      }
      async send(method, params) {
        await this._start();
        return await super.send(method, params);
      }
      async _send(payload) {
        const request = this._getConnection();
        request.body = JSON.stringify(payload);
        request.setHeader("content-type", "application/json");
        const response = await request.send();
        response.assertOk();
        let resp = response.bodyJson;
        if (!Array.isArray(resp)) {
          resp = [resp];
        }
        return resp;
      }
    };
    _connect = new WeakMap();
    exports.JsonRpcProvider = JsonRpcProvider;
    function spelunkData(value) {
      if (value == null) {
        return null;
      }
      if (typeof value.message === "string" && value.message.match(/revert/i) && (0, index_js_5.isHexString)(value.data)) {
        return { message: value.message, data: value.data };
      }
      if (typeof value === "object") {
        for (const key in value) {
          const result = spelunkData(value[key]);
          if (result) {
            return result;
          }
        }
        return null;
      }
      if (typeof value === "string") {
        try {
          return spelunkData(JSON.parse(value));
        } catch (error) {
        }
      }
      return null;
    }
    function _spelunkMessage(value, result) {
      if (value == null) {
        return;
      }
      if (typeof value.message === "string") {
        result.push(value.message);
      }
      if (typeof value === "object") {
        for (const key in value) {
          _spelunkMessage(value[key], result);
        }
      }
      if (typeof value === "string") {
        try {
          return _spelunkMessage(JSON.parse(value), result);
        } catch (error) {
        }
      }
    }
    function spelunkMessage(value) {
      const result = [];
      _spelunkMessage(value, result);
      return result;
    }
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-ankr.js
var require_provider_ankr = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-ankr.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AnkrProvider = void 0;
    var index_js_1 = require_utils5();
    var community_js_1 = require_community();
    var network_js_1 = require_network();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var defaultApiKey = "9f7d929b018cdffb338517efa06f58359e86ff1ffd350bc889738523659e7972";
    function getHost(name) {
      switch (name) {
        case "mainnet":
          return "rpc.ankr.com/eth";
        case "goerli":
          return "rpc.ankr.com/eth_goerli";
        case "sepolia":
          return "rpc.ankr.com/eth_sepolia";
        case "arbitrum":
          return "rpc.ankr.com/arbitrum";
        case "base":
          return "rpc.ankr.com/base";
        case "base-goerli":
          return "rpc.ankr.com/base_goerli";
        case "base-sepolia":
          return "rpc.ankr.com/base_sepolia";
        case "bnb":
          return "rpc.ankr.com/bsc";
        case "bnbt":
          return "rpc.ankr.com/bsc_testnet_chapel";
        case "matic":
          return "rpc.ankr.com/polygon";
        case "matic-mumbai":
          return "rpc.ankr.com/polygon_mumbai";
        case "optimism":
          return "rpc.ankr.com/optimism";
        case "optimism-goerli":
          return "rpc.ankr.com/optimism_testnet";
        case "optimism-sepolia":
          return "rpc.ankr.com/optimism_sepolia";
      }
      (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
    }
    var AnkrProvider = class _AnkrProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
      /**
       *  Create a new **AnkrProvider**.
       *
       *  By default connecting to ``mainnet`` with a highly throttled
       *  API key.
       */
      constructor(_network, apiKey) {
        if (_network == null) {
          _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (apiKey == null) {
          apiKey = defaultApiKey;
        }
        const options = { polling: true, staticNetwork: network };
        const request = _AnkrProvider.getRequest(network, apiKey);
        super(request, network, options);
        /**
         *  The API key for the Ankr connection.
         */
        __publicField(this, "apiKey");
        (0, index_js_1.defineProperties)(this, { apiKey });
      }
      _getProvider(chainId) {
        try {
          return new _AnkrProvider(chainId, this.apiKey);
        } catch (error) {
        }
        return super._getProvider(chainId);
      }
      /**
       *  Returns a prepared request for connecting to %%network%% with
       *  %%apiKey%%.
       */
      static getRequest(network, apiKey) {
        if (apiKey == null) {
          apiKey = defaultApiKey;
        }
        const request = new index_js_1.FetchRequest(`https://${getHost(network.name)}/${apiKey}`);
        request.allowGzip = true;
        if (apiKey === defaultApiKey) {
          request.retryFunc = async (request2, response, attempt) => {
            (0, community_js_1.showThrottleMessage)("AnkrProvider");
            return true;
          };
        }
        return request;
      }
      getRpcError(payload, error) {
        if (payload.method === "eth_sendRawTransaction") {
          if (error && error.error && error.error.message === "INTERNAL_ERROR: could not replace existing tx") {
            error.error.message = "replacement transaction underpriced";
          }
        }
        return super.getRpcError(payload, error);
      }
      isCommunityResource() {
        return this.apiKey === defaultApiKey;
      }
    };
    exports.AnkrProvider = AnkrProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-alchemy.js
var require_provider_alchemy = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-alchemy.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AlchemyProvider = void 0;
    var index_js_1 = require_utils5();
    var community_js_1 = require_community();
    var network_js_1 = require_network();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
    function getHost(name) {
      switch (name) {
        case "mainnet":
          return "eth-mainnet.alchemyapi.io";
        case "goerli":
          return "eth-goerli.g.alchemy.com";
        case "sepolia":
          return "eth-sepolia.g.alchemy.com";
        case "arbitrum":
          return "arb-mainnet.g.alchemy.com";
        case "arbitrum-goerli":
          return "arb-goerli.g.alchemy.com";
        case "arbitrum-sepolia":
          return "arb-sepolia.g.alchemy.com";
        case "base":
          return "base-mainnet.g.alchemy.com";
        case "base-goerli":
          return "base-goerli.g.alchemy.com";
        case "base-sepolia":
          return "base-sepolia.g.alchemy.com";
        case "matic":
          return "polygon-mainnet.g.alchemy.com";
        case "matic-amoy":
          return "polygon-amoy.g.alchemy.com";
        case "matic-mumbai":
          return "polygon-mumbai.g.alchemy.com";
        case "optimism":
          return "opt-mainnet.g.alchemy.com";
        case "optimism-goerli":
          return "opt-goerli.g.alchemy.com";
        case "optimism-sepolia":
          return "opt-sepolia.g.alchemy.com";
      }
      (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
    }
    var AlchemyProvider = class _AlchemyProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
      constructor(_network, apiKey) {
        if (_network == null) {
          _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (apiKey == null) {
          apiKey = defaultApiKey;
        }
        const request = _AlchemyProvider.getRequest(network, apiKey);
        super(request, network, { staticNetwork: network });
        __publicField(this, "apiKey");
        (0, index_js_1.defineProperties)(this, { apiKey });
      }
      _getProvider(chainId) {
        try {
          return new _AlchemyProvider(chainId, this.apiKey);
        } catch (error) {
        }
        return super._getProvider(chainId);
      }
      async _perform(req) {
        if (req.method === "getTransactionResult") {
          const { trace, tx } = await (0, index_js_1.resolveProperties)({
            trace: this.send("trace_transaction", [req.hash]),
            tx: this.getTransaction(req.hash)
          });
          if (trace == null || tx == null) {
            return null;
          }
          let data;
          let error = false;
          try {
            data = trace[0].result.output;
            error = trace[0].error === "Reverted";
          } catch (error2) {
          }
          if (data) {
            (0, index_js_1.assert)(!error, "an error occurred during transaction executions", "CALL_EXCEPTION", {
              action: "getTransactionResult",
              data,
              reason: null,
              transaction: tx,
              invocation: null,
              revert: null
              // @TODO
            });
            return data;
          }
          (0, index_js_1.assert)(false, "could not parse trace result", "BAD_DATA", { value: trace });
        }
        return await super._perform(req);
      }
      isCommunityResource() {
        return this.apiKey === defaultApiKey;
      }
      static getRequest(network, apiKey) {
        if (apiKey == null) {
          apiKey = defaultApiKey;
        }
        const request = new index_js_1.FetchRequest(`https://${getHost(network.name)}/v2/${apiKey}`);
        request.allowGzip = true;
        if (apiKey === defaultApiKey) {
          request.retryFunc = async (request2, response, attempt) => {
            (0, community_js_1.showThrottleMessage)("alchemy");
            return true;
          };
        }
        return request;
      }
    };
    exports.AlchemyProvider = AlchemyProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-chainstack.js
var require_provider_chainstack = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-chainstack.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ChainstackProvider = void 0;
    var index_js_1 = require_utils5();
    var community_js_1 = require_community();
    var network_js_1 = require_network();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    function getApiKey(name) {
      switch (name) {
        case "mainnet":
          return "39f1d67cedf8b7831010a665328c9197";
        case "arbitrum":
          return "0550c209db33c3abf4cc927e1e18cea1";
        case "bnb":
          return "98b5a77e531614387366f6fc5da097f8";
        case "matic":
          return "cd9d4d70377471aa7c142ec4a4205249";
      }
      (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
    }
    function getHost(name) {
      switch (name) {
        case "mainnet":
          return "ethereum-mainnet.core.chainstack.com";
        case "arbitrum":
          return "arbitrum-mainnet.core.chainstack.com";
        case "bnb":
          return "bsc-mainnet.core.chainstack.com";
        case "matic":
          return "polygon-mainnet.core.chainstack.com";
      }
      (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
    }
    var ChainstackProvider = class _ChainstackProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
      /**
       *  Creates a new **ChainstackProvider**.
       */
      constructor(_network, apiKey) {
        if (_network == null) {
          _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (apiKey == null) {
          apiKey = getApiKey(network.name);
        }
        const request = _ChainstackProvider.getRequest(network, apiKey);
        super(request, network, { staticNetwork: network });
        /**
         *  The API key for the Chainstack connection.
         */
        __publicField(this, "apiKey");
        (0, index_js_1.defineProperties)(this, { apiKey });
      }
      _getProvider(chainId) {
        try {
          return new _ChainstackProvider(chainId, this.apiKey);
        } catch (error) {
        }
        return super._getProvider(chainId);
      }
      isCommunityResource() {
        return this.apiKey === getApiKey(this._network.name);
      }
      /**
       *  Returns a prepared request for connecting to %%network%%
       *  with %%apiKey%% and %%projectSecret%%.
       */
      static getRequest(network, apiKey) {
        if (apiKey == null) {
          apiKey = getApiKey(network.name);
        }
        const request = new index_js_1.FetchRequest(`https://${getHost(network.name)}/${apiKey}`);
        request.allowGzip = true;
        if (apiKey === getApiKey(network.name)) {
          request.retryFunc = async (request2, response, attempt) => {
            (0, community_js_1.showThrottleMessage)("ChainstackProvider");
            return true;
          };
        }
        return request;
      }
    };
    exports.ChainstackProvider = ChainstackProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js
var require_provider_cloudflare = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-cloudflare.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CloudflareProvider = void 0;
    var index_js_1 = require_utils5();
    var network_js_1 = require_network();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var CloudflareProvider = class extends provider_jsonrpc_js_1.JsonRpcProvider {
      constructor(_network) {
        if (_network == null) {
          _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        (0, index_js_1.assertArgument)(network.name === "mainnet", "unsupported network", "network", _network);
        super("https://cloudflare-eth.com/", network, { staticNetwork: network });
      }
    };
    exports.CloudflareProvider = CloudflareProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-etherscan.js
var require_provider_etherscan = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-etherscan.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.EtherscanProvider = exports.EtherscanPlugin = void 0;
    var index_js_1 = require_abi();
    var index_js_2 = require_contract2();
    var index_js_3 = require_transaction2();
    var index_js_4 = require_utils5();
    var abstract_provider_js_1 = require_abstract_provider();
    var network_js_1 = require_network();
    var plugins_network_js_1 = require_plugins_network();
    var community_js_1 = require_community();
    var THROTTLE = 2e3;
    function isPromise(value) {
      return value && typeof value.then === "function";
    }
    var EtherscanPluginId = "org.ethers.plugins.provider.Etherscan";
    var EtherscanPlugin = class _EtherscanPlugin extends plugins_network_js_1.NetworkPlugin {
      /**
       *  Creates a new **EtherscanProvider** which will use
       *  %%baseUrl%%.
       */
      constructor(baseUrl) {
        super(EtherscanPluginId);
        /**
         *  The Etherscan API base URL.
         */
        __publicField(this, "baseUrl");
        (0, index_js_4.defineProperties)(this, { baseUrl });
      }
      clone() {
        return new _EtherscanPlugin(this.baseUrl);
      }
    };
    exports.EtherscanPlugin = EtherscanPlugin;
    var skipKeys = ["enableCcipRead"];
    var nextId = 1;
    var _plugin;
    var EtherscanProvider = class extends abstract_provider_js_1.AbstractProvider {
      /**
       *  Creates a new **EtherscanBaseProvider**.
       */
      constructor(_network, _apiKey) {
        const apiKey = _apiKey != null ? _apiKey : null;
        super();
        /**
         *  The connected network.
         */
        __publicField(this, "network");
        /**
         *  The API key or null if using the community provided bandwidth.
         */
        __publicField(this, "apiKey");
        __privateAdd(this, _plugin);
        const network = network_js_1.Network.from(_network);
        __privateSet(this, _plugin, network.getPlugin(EtherscanPluginId));
        (0, index_js_4.defineProperties)(this, { apiKey, network });
        this.getBaseUrl();
      }
      /**
       *  Returns the base URL.
       *
       *  If an [[EtherscanPlugin]] is configured on the
       *  [[EtherscanBaseProvider_network]], returns the plugin's
       *  baseUrl.
       */
      getBaseUrl() {
        if (__privateGet(this, _plugin)) {
          return __privateGet(this, _plugin).baseUrl;
        }
        switch (this.network.name) {
          case "mainnet":
            return "https://api.etherscan.io";
          case "goerli":
            return "https://api-goerli.etherscan.io";
          case "sepolia":
            return "https://api-sepolia.etherscan.io";
          case "holesky":
            return "https://api-holesky.etherscan.io";
          case "arbitrum":
            return "https://api.arbiscan.io";
          case "arbitrum-goerli":
            return "https://api-goerli.arbiscan.io";
          case "base":
            return "https://api.basescan.org";
          case "base-sepolia":
            return "https://api-sepolia.basescan.org";
          case "bnb":
            return "https://api.bscscan.com";
          case "bnbt":
            return "https://api-testnet.bscscan.com";
          case "matic":
            return "https://api.polygonscan.com";
          case "matic-amoy":
            return "https://api-amoy.polygonscan.com";
          case "matic-mumbai":
            return "https://api-testnet.polygonscan.com";
          case "optimism":
            return "https://api-optimistic.etherscan.io";
          case "optimism-goerli":
            return "https://api-goerli-optimistic.etherscan.io";
          default:
        }
        (0, index_js_4.assertArgument)(false, "unsupported network", "network", this.network);
      }
      /**
       *  Returns the URL for the %%module%% and %%params%%.
       */
      getUrl(module2, params) {
        const query = Object.keys(params).reduce((accum, key) => {
          const value = params[key];
          if (value != null) {
            accum += `&${key}=${value}`;
          }
          return accum;
        }, "");
        const apiKey = this.apiKey ? `&apikey=${this.apiKey}` : "";
        return `${this.getBaseUrl()}/api?module=${module2}${query}${apiKey}`;
      }
      /**
       *  Returns the URL for using POST requests.
       */
      getPostUrl() {
        return `${this.getBaseUrl()}/api`;
      }
      /**
       *  Returns the parameters for using POST requests.
       */
      getPostData(module2, params) {
        params.module = module2;
        params.apikey = this.apiKey;
        return params;
      }
      async detectNetwork() {
        return this.network;
      }
      /**
       *  Resolves to the result of calling %%module%% with %%params%%.
       *
       *  If %%post%%, the request is made as a POST request.
       */
      async fetch(module2, params, post) {
        const id3 = nextId++;
        const url = post ? this.getPostUrl() : this.getUrl(module2, params);
        const payload = post ? this.getPostData(module2, params) : null;
        this.emit("debug", { action: "sendRequest", id: id3, url, payload });
        const request = new index_js_4.FetchRequest(url);
        request.setThrottleParams({ slotInterval: 1e3 });
        request.retryFunc = (req, resp, attempt) => {
          if (this.isCommunityResource()) {
            (0, community_js_1.showThrottleMessage)("Etherscan");
          }
          return Promise.resolve(true);
        };
        request.processFunc = async (request2, response2) => {
          const result2 = response2.hasBody() ? JSON.parse((0, index_js_4.toUtf8String)(response2.body)) : {};
          const throttle3 = (typeof result2.result === "string" ? result2.result : "").toLowerCase().indexOf("rate limit") >= 0;
          if (module2 === "proxy") {
            if (result2 && result2.status == 0 && result2.message == "NOTOK" && throttle3) {
              this.emit("debug", { action: "receiveError", id: id3, reason: "proxy-NOTOK", error: result2 });
              response2.throwThrottleError(result2.result, THROTTLE);
            }
          } else {
            if (throttle3) {
              this.emit("debug", { action: "receiveError", id: id3, reason: "null result", error: result2.result });
              response2.throwThrottleError(result2.result, THROTTLE);
            }
          }
          return response2;
        };
        if (payload) {
          request.setHeader("content-type", "application/x-www-form-urlencoded; charset=UTF-8");
          request.body = Object.keys(payload).map((k4) => `${k4}=${payload[k4]}`).join("&");
        }
        const response = await request.send();
        try {
          response.assertOk();
        } catch (error) {
          this.emit("debug", { action: "receiveError", id: id3, error, reason: "assertOk" });
          (0, index_js_4.assert)(false, "response error", "SERVER_ERROR", { request, response });
        }
        if (!response.hasBody()) {
          this.emit("debug", { action: "receiveError", id: id3, error: "missing body", reason: "null body" });
          (0, index_js_4.assert)(false, "missing response", "SERVER_ERROR", { request, response });
        }
        const result = JSON.parse((0, index_js_4.toUtf8String)(response.body));
        if (module2 === "proxy") {
          if (result.jsonrpc != "2.0") {
            this.emit("debug", { action: "receiveError", id: id3, result, reason: "invalid JSON-RPC" });
            (0, index_js_4.assert)(false, "invalid JSON-RPC response (missing jsonrpc='2.0')", "SERVER_ERROR", { request, response, info: { result } });
          }
          if (result.error) {
            this.emit("debug", { action: "receiveError", id: id3, result, reason: "JSON-RPC error" });
            (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
          }
          this.emit("debug", { action: "receiveRequest", id: id3, result });
          return result.result;
        } else {
          if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
            this.emit("debug", { action: "receiveRequest", id: id3, result });
            return result.result;
          }
          if (result.status != 1 || typeof result.message === "string" && !result.message.match(/^OK/)) {
            this.emit("debug", { action: "receiveError", id: id3, result });
            (0, index_js_4.assert)(false, "error response", "SERVER_ERROR", { request, response, info: { result } });
          }
          this.emit("debug", { action: "receiveRequest", id: id3, result });
          return result.result;
        }
      }
      /**
       *  Returns %%transaction%% normalized for the Etherscan API.
       */
      _getTransactionPostData(transaction) {
        const result = {};
        for (let key in transaction) {
          if (skipKeys.indexOf(key) >= 0) {
            continue;
          }
          if (transaction[key] == null) {
            continue;
          }
          let value = transaction[key];
          if (key === "type" && value === 0) {
            continue;
          }
          if (key === "blockTag" && value === "latest") {
            continue;
          }
          if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
            value = (0, index_js_4.toQuantity)(value);
          } else if (key === "accessList") {
            value = "[" + (0, index_js_3.accessListify)(value).map((set) => {
              return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
            }).join(",") + "]";
          } else if (key === "blobVersionedHashes") {
            if (value.length === 0) {
              continue;
            }
            (0, index_js_4.assert)(false, "Etherscan API does not support blobVersionedHashes", "UNSUPPORTED_OPERATION", {
              operation: "_getTransactionPostData",
              info: { transaction }
            });
          } else {
            value = (0, index_js_4.hexlify)(value);
          }
          result[key] = value;
        }
        return result;
      }
      /**
       *  Throws the normalized Etherscan error.
       */
      _checkError(req, error, transaction) {
        let message = "";
        if ((0, index_js_4.isError)(error, "SERVER_ERROR")) {
          try {
            message = error.info.result.error.message;
          } catch (e2) {
          }
          if (!message) {
            try {
              message = error.info.message;
            } catch (e2) {
            }
          }
        }
        if (req.method === "estimateGas") {
          if (!message.match(/revert/i) && message.match(/insufficient funds/i)) {
            (0, index_js_4.assert)(false, "insufficient funds", "INSUFFICIENT_FUNDS", {
              transaction: req.transaction
            });
          }
        }
        if (req.method === "call" || req.method === "estimateGas") {
          if (message.match(/execution reverted/i)) {
            let data = "";
            try {
              data = error.info.result.error.data;
            } catch (error2) {
            }
            const e2 = index_js_1.AbiCoder.getBuiltinCallException(req.method, req.transaction, data);
            e2.info = { request: req, error };
            throw e2;
          }
        }
        if (message) {
          if (req.method === "broadcastTransaction") {
            const transaction2 = index_js_3.Transaction.from(req.signedTransaction);
            if (message.match(/replacement/i) && message.match(/underpriced/i)) {
              (0, index_js_4.assert)(false, "replacement fee too low", "REPLACEMENT_UNDERPRICED", {
                transaction: transaction2
              });
            }
            if (message.match(/insufficient funds/)) {
              (0, index_js_4.assert)(false, "insufficient funds for intrinsic transaction cost", "INSUFFICIENT_FUNDS", {
                transaction: transaction2
              });
            }
            if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
              (0, index_js_4.assert)(false, "nonce has already been used", "NONCE_EXPIRED", {
                transaction: transaction2
              });
            }
          }
        }
        throw error;
      }
      async _detectNetwork() {
        return this.network;
      }
      async _perform(req) {
        switch (req.method) {
          case "chainId":
            return this.network.chainId;
          case "getBlockNumber":
            return this.fetch("proxy", { action: "eth_blockNumber" });
          case "getGasPrice":
            return this.fetch("proxy", { action: "eth_gasPrice" });
          case "getPriorityFee":
            if (this.network.name === "mainnet") {
              return "1000000000";
            } else if (this.network.name === "optimism") {
              return "1000000";
            } else {
              throw new Error("fallback onto the AbstractProvider default");
            }
          case "getBalance":
            return this.fetch("account", {
              action: "balance",
              address: req.address,
              tag: req.blockTag
            });
          case "getTransactionCount":
            return this.fetch("proxy", {
              action: "eth_getTransactionCount",
              address: req.address,
              tag: req.blockTag
            });
          case "getCode":
            return this.fetch("proxy", {
              action: "eth_getCode",
              address: req.address,
              tag: req.blockTag
            });
          case "getStorage":
            return this.fetch("proxy", {
              action: "eth_getStorageAt",
              address: req.address,
              position: req.position,
              tag: req.blockTag
            });
          case "broadcastTransaction":
            return this.fetch("proxy", {
              action: "eth_sendRawTransaction",
              hex: req.signedTransaction
            }, true).catch((error) => {
              return this._checkError(req, error, req.signedTransaction);
            });
          case "getBlock":
            if ("blockTag" in req) {
              return this.fetch("proxy", {
                action: "eth_getBlockByNumber",
                tag: req.blockTag,
                boolean: req.includeTransactions ? "true" : "false"
              });
            }
            (0, index_js_4.assert)(false, "getBlock by blockHash not supported by Etherscan", "UNSUPPORTED_OPERATION", {
              operation: "getBlock(blockHash)"
            });
          case "getTransaction":
            return this.fetch("proxy", {
              action: "eth_getTransactionByHash",
              txhash: req.hash
            });
          case "getTransactionReceipt":
            return this.fetch("proxy", {
              action: "eth_getTransactionReceipt",
              txhash: req.hash
            });
          case "call": {
            if (req.blockTag !== "latest") {
              throw new Error("EtherscanProvider does not support blockTag for call");
            }
            const postData = this._getTransactionPostData(req.transaction);
            postData.module = "proxy";
            postData.action = "eth_call";
            try {
              return await this.fetch("proxy", postData, true);
            } catch (error) {
              return this._checkError(req, error, req.transaction);
            }
          }
          case "estimateGas": {
            const postData = this._getTransactionPostData(req.transaction);
            postData.module = "proxy";
            postData.action = "eth_estimateGas";
            try {
              return await this.fetch("proxy", postData, true);
            } catch (error) {
              return this._checkError(req, error, req.transaction);
            }
          }
          default:
            break;
        }
        return super._perform(req);
      }
      async getNetwork() {
        return this.network;
      }
      /**
       *  Resolves to the current price of ether.
       *
       *  This returns ``0`` on any network other than ``mainnet``.
       */
      async getEtherPrice() {
        if (this.network.name !== "mainnet") {
          return 0;
        }
        return parseFloat((await this.fetch("stats", { action: "ethprice" })).ethusd);
      }
      /**
       *  Resolves to a [Contract]] for %%address%%, using the
       *  Etherscan API to retreive the Contract ABI.
       */
      async getContract(_address) {
        let address = this._getAddress(_address);
        if (isPromise(address)) {
          address = await address;
        }
        try {
          const resp = await this.fetch("contract", {
            action: "getabi",
            address
          });
          const abi = JSON.parse(resp);
          return new index_js_2.Contract(address, abi, this);
        } catch (error) {
          return null;
        }
      }
      isCommunityResource() {
        return this.apiKey == null;
      }
    };
    _plugin = new WeakMap();
    exports.EtherscanProvider = EtherscanProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/ws-browser.js
var require_ws_browser = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/ws-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocket = void 0;
    function getGlobal() {
      if (typeof self !== "undefined") {
        return self;
      }
      if (typeof window !== "undefined") {
        return window;
      }
      if (typeof global !== "undefined") {
        return global;
      }
      throw new Error("unable to locate global object");
    }
    var _WebSocket = getGlobal().WebSocket;
    exports.WebSocket = _WebSocket;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-socket.js
var require_provider_socket = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-socket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketProvider = exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = void 0;
    var abstract_provider_js_1 = require_abstract_provider();
    var index_js_1 = require_utils5();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var _provider, _filter, _filterId, _paused, _emitPromise;
    var SocketSubscriber = class {
      /**
       *  Creates a new **SocketSubscriber** attached to %%provider%% listening
       *  to %%filter%%.
       */
      constructor(provider, filter3) {
        __privateAdd(this, _provider);
        __privateAdd(this, _filter);
        __privateAdd(this, _filterId);
        __privateAdd(this, _paused);
        __privateAdd(this, _emitPromise);
        __privateSet(this, _provider, provider);
        __privateSet(this, _filter, JSON.stringify(filter3));
        __privateSet(this, _filterId, null);
        __privateSet(this, _paused, null);
        __privateSet(this, _emitPromise, null);
      }
      /**
       *  The filter.
       */
      get filter() {
        return JSON.parse(__privateGet(this, _filter));
      }
      start() {
        __privateSet(this, _filterId, __privateGet(this, _provider).send("eth_subscribe", this.filter).then((filterId) => {
          ;
          __privateGet(this, _provider)._register(filterId, this);
          return filterId;
        }));
      }
      stop() {
        __privateGet(this, _filterId).then((filterId) => {
          if (__privateGet(this, _provider).destroyed) {
            return;
          }
          __privateGet(this, _provider).send("eth_unsubscribe", [filterId]);
        });
        __privateSet(this, _filterId, null);
      }
      // @TODO: pause should trap the current blockNumber, unsub, and on resume use getLogs
      //        and resume
      pause(dropWhilePaused) {
        (0, index_js_1.assert)(dropWhilePaused, "preserve logs while paused not supported by SocketSubscriber yet", "UNSUPPORTED_OPERATION", { operation: "pause(false)" });
        __privateSet(this, _paused, !!dropWhilePaused);
      }
      resume() {
        __privateSet(this, _paused, null);
      }
      /**
       *  @_ignore:
       */
      _handleMessage(message) {
        if (__privateGet(this, _filterId) == null) {
          return;
        }
        if (__privateGet(this, _paused) === null) {
          let emitPromise = __privateGet(this, _emitPromise);
          if (emitPromise == null) {
            emitPromise = this._emit(__privateGet(this, _provider), message);
          } else {
            emitPromise = emitPromise.then(async () => {
              await this._emit(__privateGet(this, _provider), message);
            });
          }
          __privateSet(this, _emitPromise, emitPromise.then(() => {
            if (__privateGet(this, _emitPromise) === emitPromise) {
              __privateSet(this, _emitPromise, null);
            }
          }));
        }
      }
      /**
       *  Sub-classes **must** override this to emit the events on the
       *  provider.
       */
      async _emit(provider, message) {
        throw new Error("sub-classes must implemente this; _emit");
      }
    };
    _provider = new WeakMap();
    _filter = new WeakMap();
    _filterId = new WeakMap();
    _paused = new WeakMap();
    _emitPromise = new WeakMap();
    exports.SocketSubscriber = SocketSubscriber;
    var SocketBlockSubscriber = class extends SocketSubscriber {
      /**
       *  @_ignore:
       */
      constructor(provider) {
        super(provider, ["newHeads"]);
      }
      async _emit(provider, message) {
        provider.emit("block", parseInt(message.number));
      }
    };
    exports.SocketBlockSubscriber = SocketBlockSubscriber;
    var SocketPendingSubscriber = class extends SocketSubscriber {
      /**
       *  @_ignore:
       */
      constructor(provider) {
        super(provider, ["newPendingTransactions"]);
      }
      async _emit(provider, message) {
        provider.emit("pending", message);
      }
    };
    exports.SocketPendingSubscriber = SocketPendingSubscriber;
    var _logFilter;
    var SocketEventSubscriber = class extends SocketSubscriber {
      /**
       *  @_ignore:
       */
      constructor(provider, filter3) {
        super(provider, ["logs", filter3]);
        __privateAdd(this, _logFilter);
        __privateSet(this, _logFilter, JSON.stringify(filter3));
      }
      /**
       *  The filter.
       */
      get logFilter() {
        return JSON.parse(__privateGet(this, _logFilter));
      }
      async _emit(provider, message) {
        provider.emit(this.logFilter, provider._wrapLog(message, provider._network));
      }
    };
    _logFilter = new WeakMap();
    exports.SocketEventSubscriber = SocketEventSubscriber;
    var _callbacks, _subs, _pending;
    var SocketProvider = class extends provider_jsonrpc_js_1.JsonRpcApiProvider {
      /**
       *  Creates a new **SocketProvider** connected to %%network%%.
       *
       *  If unspecified, the network will be discovered.
       */
      constructor(network, _options) {
        const options = Object.assign({}, _options != null ? _options : {});
        (0, index_js_1.assertArgument)(options.batchMaxCount == null || options.batchMaxCount === 1, "sockets-based providers do not support batches", "options.batchMaxCount", _options);
        options.batchMaxCount = 1;
        if (options.staticNetwork == null) {
          options.staticNetwork = true;
        }
        super(network, options);
        __privateAdd(this, _callbacks);
        // Maps each filterId to its subscriber
        __privateAdd(this, _subs);
        // If any events come in before a subscriber has finished
        // registering, queue them
        __privateAdd(this, _pending);
        __privateSet(this, _callbacks, /* @__PURE__ */ new Map());
        __privateSet(this, _subs, /* @__PURE__ */ new Map());
        __privateSet(this, _pending, /* @__PURE__ */ new Map());
      }
      // This value is only valid after _start has been called
      /*
      get _network(): Network {
          if (this.#network == null) {
              throw new Error("this shouldn't happen");
          }
          return this.#network.clone();
      }
      */
      _getSubscriber(sub) {
        switch (sub.type) {
          case "close":
            return new abstract_provider_js_1.UnmanagedSubscriber("close");
          case "block":
            return new SocketBlockSubscriber(this);
          case "pending":
            return new SocketPendingSubscriber(this);
          case "event":
            return new SocketEventSubscriber(this, sub.filter);
          case "orphan":
            if (sub.filter.orphan === "drop-log") {
              return new abstract_provider_js_1.UnmanagedSubscriber("drop-log");
            }
        }
        return super._getSubscriber(sub);
      }
      /**
       *  Register a new subscriber. This is used internalled by Subscribers
       *  and generally is unecessary unless extending capabilities.
       */
      _register(filterId, subscriber) {
        __privateGet(this, _subs).set(filterId, subscriber);
        const pending = __privateGet(this, _pending).get(filterId);
        if (pending) {
          for (const message of pending) {
            subscriber._handleMessage(message);
          }
          __privateGet(this, _pending).delete(filterId);
        }
      }
      async _send(payload) {
        (0, index_js_1.assertArgument)(!Array.isArray(payload), "WebSocket does not support batch send", "payload", payload);
        const promise = new Promise((resolve, reject) => {
          __privateGet(this, _callbacks).set(payload.id, { payload, resolve, reject });
        });
        await this._waitUntilReady();
        await this._write(JSON.stringify(payload));
        return [await promise];
      }
      // Sub-classes must call this once they are connected
      /*
          async _start(): Promise<void> {
              if (this.#ready) { return; }
      
              for (const { payload } of this.#callbacks.values()) {
                  await this._write(JSON.stringify(payload));
              }
      
              this.#ready = (async function() {
                  await super._start();
              })();
          }
          */
      /**
       *  Sub-classes **must** call this with messages received over their
       *  transport to be processed and dispatched.
       */
      async _processMessage(message) {
        const result = JSON.parse(message);
        if (result && typeof result === "object" && "id" in result) {
          const callback = __privateGet(this, _callbacks).get(result.id);
          if (callback == null) {
            this.emit("error", (0, index_js_1.makeError)("received result for unknown id", "UNKNOWN_ERROR", {
              reasonCode: "UNKNOWN_ID",
              result
            }));
            return;
          }
          __privateGet(this, _callbacks).delete(result.id);
          callback.resolve(result);
        } else if (result && result.method === "eth_subscription") {
          const filterId = result.params.subscription;
          const subscriber = __privateGet(this, _subs).get(filterId);
          if (subscriber) {
            subscriber._handleMessage(result.params.result);
          } else {
            let pending = __privateGet(this, _pending).get(filterId);
            if (pending == null) {
              pending = [];
              __privateGet(this, _pending).set(filterId, pending);
            }
            pending.push(result.params.result);
          }
        } else {
          this.emit("error", (0, index_js_1.makeError)("received unexpected message", "UNKNOWN_ERROR", {
            reasonCode: "UNEXPECTED_MESSAGE",
            result
          }));
          return;
        }
      }
      /**
       *  Sub-classes **must** override this to send %%message%% over their
       *  transport.
       */
      async _write(message) {
        throw new Error("sub-classes must override this");
      }
    };
    _callbacks = new WeakMap();
    _subs = new WeakMap();
    _pending = new WeakMap();
    exports.SocketProvider = SocketProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-websocket.js
var require_provider_websocket = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-websocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WebSocketProvider = void 0;
    var ws_js_1 = require_ws_browser();
    var provider_socket_js_1 = require_provider_socket();
    var _connect, _websocket;
    var WebSocketProvider = class extends provider_socket_js_1.SocketProvider {
      constructor(url, network, options) {
        super(network, options);
        __privateAdd(this, _connect);
        __privateAdd(this, _websocket);
        if (typeof url === "string") {
          __privateSet(this, _connect, () => {
            return new ws_js_1.WebSocket(url);
          });
          __privateSet(this, _websocket, __privateGet(this, _connect).call(this));
        } else if (typeof url === "function") {
          __privateSet(this, _connect, url);
          __privateSet(this, _websocket, url());
        } else {
          __privateSet(this, _connect, null);
          __privateSet(this, _websocket, url);
        }
        this.websocket.onopen = async () => {
          try {
            await this._start();
            this.resume();
          } catch (error) {
            console.log("failed to start WebsocketProvider", error);
          }
        };
        this.websocket.onmessage = (message) => {
          this._processMessage(message.data);
        };
      }
      get websocket() {
        if (__privateGet(this, _websocket) == null) {
          throw new Error("websocket closed");
        }
        return __privateGet(this, _websocket);
      }
      async _write(message) {
        this.websocket.send(message);
      }
      async destroy() {
        if (__privateGet(this, _websocket) != null) {
          __privateGet(this, _websocket).close();
          __privateSet(this, _websocket, null);
        }
        super.destroy();
      }
    };
    _connect = new WeakMap();
    _websocket = new WeakMap();
    exports.WebSocketProvider = WebSocketProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-infura.js
var require_provider_infura = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-infura.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.InfuraProvider = exports.InfuraWebSocketProvider = void 0;
    var index_js_1 = require_utils5();
    var community_js_1 = require_community();
    var network_js_1 = require_network();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var provider_websocket_js_1 = require_provider_websocket();
    var defaultProjectId = "84842078b09946638c03157f83405213";
    function getHost(name) {
      switch (name) {
        case "mainnet":
          return "mainnet.infura.io";
        case "goerli":
          return "goerli.infura.io";
        case "sepolia":
          return "sepolia.infura.io";
        case "arbitrum":
          return "arbitrum-mainnet.infura.io";
        case "arbitrum-goerli":
          return "arbitrum-goerli.infura.io";
        case "arbitrum-sepolia":
          return "arbitrum-sepolia.infura.io";
        case "base":
          return "base-mainnet.infura.io";
        case "base-goerlia":
        case "base-goerli":
          return "base-goerli.infura.io";
        case "base-sepolia":
          return "base-sepolia.infura.io";
        case "bnb":
          return "bsc-mainnet.infura.io";
        case "bnbt":
          return "bsc-testnet.infura.io";
        case "linea":
          return "linea-mainnet.infura.io";
        case "linea-goerli":
          return "linea-goerli.infura.io";
        case "linea-sepolia":
          return "linea-sepolia.infura.io";
        case "matic":
          return "polygon-mainnet.infura.io";
        case "matic-amoy":
          return "polygon-amoy.infura.io";
        case "matic-mumbai":
          return "polygon-mumbai.infura.io";
        case "optimism":
          return "optimism-mainnet.infura.io";
        case "optimism-goerli":
          return "optimism-goerli.infura.io";
        case "optimism-sepolia":
          return "optimism-sepolia.infura.io";
      }
      (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
    }
    var InfuraWebSocketProvider = class extends provider_websocket_js_1.WebSocketProvider {
      /**
       *  Creates a new **InfuraWebSocketProvider**.
       */
      constructor(network, projectId) {
        const provider = new InfuraProvider(network, projectId);
        const req = provider._getConnection();
        (0, index_js_1.assert)(!req.credentials, "INFURA WebSocket project secrets unsupported", "UNSUPPORTED_OPERATION", { operation: "InfuraProvider.getWebSocketProvider()" });
        const url = req.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(url, provider._network);
        /**
         *  The Project ID for the INFURA connection.
         */
        __publicField(this, "projectId");
        /**
         *  The Project Secret.
         *
         *  If null, no authenticated requests are made. This should not
         *  be used outside of private contexts.
         */
        __publicField(this, "projectSecret");
        (0, index_js_1.defineProperties)(this, {
          projectId: provider.projectId,
          projectSecret: provider.projectSecret
        });
      }
      isCommunityResource() {
        return this.projectId === defaultProjectId;
      }
    };
    exports.InfuraWebSocketProvider = InfuraWebSocketProvider;
    var InfuraProvider = class _InfuraProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
      /**
       *  Creates a new **InfuraProvider**.
       */
      constructor(_network, projectId, projectSecret) {
        if (_network == null) {
          _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (projectId == null) {
          projectId = defaultProjectId;
        }
        if (projectSecret == null) {
          projectSecret = null;
        }
        const request = _InfuraProvider.getRequest(network, projectId, projectSecret);
        super(request, network, { staticNetwork: network });
        /**
         *  The Project ID for the INFURA connection.
         */
        __publicField(this, "projectId");
        /**
         *  The Project Secret.
         *
         *  If null, no authenticated requests are made. This should not
         *  be used outside of private contexts.
         */
        __publicField(this, "projectSecret");
        (0, index_js_1.defineProperties)(this, { projectId, projectSecret });
      }
      _getProvider(chainId) {
        try {
          return new _InfuraProvider(chainId, this.projectId, this.projectSecret);
        } catch (error) {
        }
        return super._getProvider(chainId);
      }
      isCommunityResource() {
        return this.projectId === defaultProjectId;
      }
      /**
       *  Creates a new **InfuraWebSocketProvider**.
       */
      static getWebSocketProvider(network, projectId) {
        return new InfuraWebSocketProvider(network, projectId);
      }
      /**
       *  Returns a prepared request for connecting to %%network%%
       *  with %%projectId%% and %%projectSecret%%.
       */
      static getRequest(network, projectId, projectSecret) {
        if (projectId == null) {
          projectId = defaultProjectId;
        }
        if (projectSecret == null) {
          projectSecret = null;
        }
        const request = new index_js_1.FetchRequest(`https://${getHost(network.name)}/v3/${projectId}`);
        request.allowGzip = true;
        if (projectSecret) {
          request.setCredentials("", projectSecret);
        }
        if (projectId === defaultProjectId) {
          request.retryFunc = async (request2, response, attempt) => {
            (0, community_js_1.showThrottleMessage)("InfuraProvider");
            return true;
          };
        }
        return request;
      }
    };
    exports.InfuraProvider = InfuraProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-quicknode.js
var require_provider_quicknode = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-quicknode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QuickNodeProvider = void 0;
    var index_js_1 = require_utils5();
    var community_js_1 = require_community();
    var network_js_1 = require_network();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var defaultToken = "919b412a057b5e9c9b6dce193c5a60242d6efadb";
    function getHost(name) {
      switch (name) {
        case "mainnet":
          return "ethers.quiknode.pro";
        case "goerli":
          return "ethers.ethereum-goerli.quiknode.pro";
        case "sepolia":
          return "ethers.ethereum-sepolia.quiknode.pro";
        case "holesky":
          return "ethers.ethereum-holesky.quiknode.pro";
        case "arbitrum":
          return "ethers.arbitrum-mainnet.quiknode.pro";
        case "arbitrum-goerli":
          return "ethers.arbitrum-goerli.quiknode.pro";
        case "arbitrum-sepolia":
          return "ethers.arbitrum-sepolia.quiknode.pro";
        case "base":
          return "ethers.base-mainnet.quiknode.pro";
        case "base-goerli":
          return "ethers.base-goerli.quiknode.pro";
        case "base-spolia":
          return "ethers.base-sepolia.quiknode.pro";
        case "bnb":
          return "ethers.bsc.quiknode.pro";
        case "bnbt":
          return "ethers.bsc-testnet.quiknode.pro";
        case "matic":
          return "ethers.matic.quiknode.pro";
        case "matic-mumbai":
          return "ethers.matic-testnet.quiknode.pro";
        case "optimism":
          return "ethers.optimism.quiknode.pro";
        case "optimism-goerli":
          return "ethers.optimism-goerli.quiknode.pro";
        case "optimism-sepolia":
          return "ethers.optimism-sepolia.quiknode.pro";
        case "xdai":
          return "ethers.xdai.quiknode.pro";
      }
      (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
    }
    var QuickNodeProvider = class _QuickNodeProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
      /**
       *  Creates a new **QuickNodeProvider**.
       */
      constructor(_network, token) {
        if (_network == null) {
          _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (token == null) {
          token = defaultToken;
        }
        const request = _QuickNodeProvider.getRequest(network, token);
        super(request, network, { staticNetwork: network });
        /**
         *  The API token.
         */
        __publicField(this, "token");
        (0, index_js_1.defineProperties)(this, { token });
      }
      _getProvider(chainId) {
        try {
          return new _QuickNodeProvider(chainId, this.token);
        } catch (error) {
        }
        return super._getProvider(chainId);
      }
      isCommunityResource() {
        return this.token === defaultToken;
      }
      /**
       *  Returns a new request prepared for %%network%% and the
       *  %%token%%.
       */
      static getRequest(network, token) {
        if (token == null) {
          token = defaultToken;
        }
        const request = new index_js_1.FetchRequest(`https://${getHost(network.name)}/${token}`);
        request.allowGzip = true;
        if (token === defaultToken) {
          request.retryFunc = async (request2, response, attempt) => {
            (0, community_js_1.showThrottleMessage)("QuickNodeProvider");
            return true;
          };
        }
        return request;
      }
    };
    exports.QuickNodeProvider = QuickNodeProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-fallback.js
var require_provider_fallback = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-fallback.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.FallbackProvider = void 0;
    var index_js_1 = require_utils5();
    var abstract_provider_js_1 = require_abstract_provider();
    var network_js_1 = require_network();
    var BN_1 = BigInt("1");
    var BN_2 = BigInt("2");
    function shuffle(array) {
      for (let i2 = array.length - 1; i2 > 0; i2--) {
        const j3 = Math.floor(Math.random() * (i2 + 1));
        const tmp = array[i2];
        array[i2] = array[j3];
        array[j3] = tmp;
      }
    }
    function stall(duration) {
      return new Promise((resolve) => {
        setTimeout(resolve, duration);
      });
    }
    function getTime() {
      return (/* @__PURE__ */ new Date()).getTime();
    }
    function stringify2(value) {
      return JSON.stringify(value, (key, value2) => {
        if (typeof value2 === "bigint") {
          return { type: "bigint", value: value2.toString() };
        }
        return value2;
      });
    }
    var defaultConfig2 = { stallTimeout: 400, priority: 1, weight: 1 };
    var defaultState = {
      blockNumber: -2,
      requests: 0,
      lateResponses: 0,
      errorResponses: 0,
      outOfSync: -1,
      unsupportedEvents: 0,
      rollingDuration: 0,
      score: 0,
      _network: null,
      _updateNumber: null,
      _totalTime: 0,
      _lastFatalError: null,
      _lastFatalErrorTimestamp: 0
    };
    async function waitForSync(config, blockNumber) {
      while (config.blockNumber < 0 || config.blockNumber < blockNumber) {
        if (!config._updateNumber) {
          config._updateNumber = (async () => {
            try {
              const blockNumber2 = await config.provider.getBlockNumber();
              if (blockNumber2 > config.blockNumber) {
                config.blockNumber = blockNumber2;
              }
            } catch (error) {
              config.blockNumber = -2;
              config._lastFatalError = error;
              config._lastFatalErrorTimestamp = getTime();
            }
            config._updateNumber = null;
          })();
        }
        await config._updateNumber;
        config.outOfSync++;
        if (config._lastFatalError) {
          break;
        }
      }
    }
    function _normalize(value) {
      if (value == null) {
        return "null";
      }
      if (Array.isArray(value)) {
        return "[" + value.map(_normalize).join(",") + "]";
      }
      if (typeof value === "object" && typeof value.toJSON === "function") {
        return _normalize(value.toJSON());
      }
      switch (typeof value) {
        case "boolean":
        case "symbol":
          return value.toString();
        case "bigint":
        case "number":
          return BigInt(value).toString();
        case "string":
          return JSON.stringify(value);
        case "object": {
          const keys = Object.keys(value);
          keys.sort();
          return "{" + keys.map((k4) => `${JSON.stringify(k4)}:${_normalize(value[k4])}`).join(",") + "}";
        }
      }
      console.log("Could not serialize", value);
      throw new Error("Hmm...");
    }
    function normalizeResult(method, value) {
      if ("error" in value) {
        const error = value.error;
        let tag;
        if ((0, index_js_1.isError)(error, "CALL_EXCEPTION")) {
          tag = _normalize(Object.assign({}, error, {
            shortMessage: void 0,
            reason: void 0,
            info: void 0
          }));
        } else {
          tag = _normalize(error);
        }
        return { tag, value: error };
      }
      const result = value.result;
      return { tag: _normalize(result), value: result };
    }
    function checkQuorum(quorum, results2) {
      const tally = /* @__PURE__ */ new Map();
      for (const { value, tag, weight } of results2) {
        const t2 = tally.get(tag) || { value, weight: 0 };
        t2.weight += weight;
        tally.set(tag, t2);
      }
      let best = null;
      for (const r2 of tally.values()) {
        if (r2.weight >= quorum && (!best || r2.weight > best.weight)) {
          best = r2;
        }
      }
      if (best) {
        return best.value;
      }
      return void 0;
    }
    function getMedian(quorum, results2) {
      let resultWeight = 0;
      const errorMap = /* @__PURE__ */ new Map();
      let bestError = null;
      const values = [];
      for (const { value, tag, weight } of results2) {
        if (value instanceof Error) {
          const e2 = errorMap.get(tag) || { value, weight: 0 };
          e2.weight += weight;
          errorMap.set(tag, e2);
          if (bestError == null || e2.weight > bestError.weight) {
            bestError = e2;
          }
        } else {
          values.push(BigInt(value));
          resultWeight += weight;
        }
      }
      if (resultWeight < quorum) {
        if (bestError && bestError.weight >= quorum) {
          return bestError.value;
        }
        return void 0;
      }
      values.sort((a3, b4) => a3 < b4 ? -1 : b4 > a3 ? 1 : 0);
      const mid = Math.floor(values.length / 2);
      if (values.length % 2) {
        return values[mid];
      }
      return (values[mid - 1] + values[mid] + BN_1) / BN_2;
    }
    function getAnyResult(quorum, results2) {
      const result = checkQuorum(quorum, results2);
      if (result !== void 0) {
        return result;
      }
      for (const r2 of results2) {
        if (r2.value) {
          return r2.value;
        }
      }
      return void 0;
    }
    function getFuzzyMode(quorum, results2) {
      if (quorum === 1) {
        return (0, index_js_1.getNumber)(getMedian(quorum, results2), "%internal");
      }
      const tally = /* @__PURE__ */ new Map();
      const add4 = (result, weight) => {
        const t2 = tally.get(result) || { result, weight: 0 };
        t2.weight += weight;
        tally.set(result, t2);
      };
      for (const { weight, value } of results2) {
        const r2 = (0, index_js_1.getNumber)(value);
        add4(r2 - 1, weight);
        add4(r2, weight);
        add4(r2 + 1, weight);
      }
      let bestWeight = 0;
      let bestResult = void 0;
      for (const { weight, result } of tally.values()) {
        if (weight >= quorum && (weight > bestWeight || bestResult != null && weight === bestWeight && result > bestResult)) {
          bestWeight = weight;
          bestResult = result;
        }
      }
      return bestResult;
    }
    var _configs, _height, _initialSyncPromise, _FallbackProvider_instances, getNextConfig_fn, addRunner_fn, initialSync_fn, checkQuorum_fn, waitForQuorum_fn;
    var FallbackProvider = class extends abstract_provider_js_1.AbstractProvider {
      /**
       *  Creates a new **FallbackProvider** with %%providers%% connected to
       *  %%network%%.
       *
       *  If a [[Provider]] is included in %%providers%%, defaults are used
       *  for the configuration.
       */
      constructor(providers, network, options) {
        super(network, options);
        __privateAdd(this, _FallbackProvider_instances);
        /**
         *  The number of backends that must agree on a value before it is
         *  accpeted.
         */
        __publicField(this, "quorum");
        /**
         *  @_ignore:
         */
        __publicField(this, "eventQuorum");
        /**
         *  @_ignore:
         */
        __publicField(this, "eventWorkers");
        __privateAdd(this, _configs);
        __privateAdd(this, _height);
        __privateAdd(this, _initialSyncPromise);
        __privateSet(this, _configs, providers.map((p2) => {
          if (p2 instanceof abstract_provider_js_1.AbstractProvider) {
            return Object.assign({ provider: p2 }, defaultConfig2, defaultState);
          } else {
            return Object.assign({}, defaultConfig2, p2, defaultState);
          }
        }));
        __privateSet(this, _height, -2);
        __privateSet(this, _initialSyncPromise, null);
        if (options && options.quorum != null) {
          this.quorum = options.quorum;
        } else {
          this.quorum = Math.ceil(__privateGet(this, _configs).reduce((accum, config) => {
            accum += config.weight;
            return accum;
          }, 0) / 2);
        }
        this.eventQuorum = 1;
        this.eventWorkers = 1;
        (0, index_js_1.assertArgument)(this.quorum <= __privateGet(this, _configs).reduce((a3, c3) => a3 + c3.weight, 0), "quorum exceed provider weight", "quorum", this.quorum);
      }
      get providerConfigs() {
        return __privateGet(this, _configs).map((c3) => {
          const result = Object.assign({}, c3);
          for (const key in result) {
            if (key[0] === "_") {
              delete result[key];
            }
          }
          return result;
        });
      }
      async _detectNetwork() {
        return network_js_1.Network.from((0, index_js_1.getBigInt)(await this._perform({ method: "chainId" })));
      }
      // @TODO: Add support to select providers to be the event subscriber
      //_getSubscriber(sub: Subscription): Subscriber {
      //    throw new Error("@TODO");
      //}
      /**
       *  Transforms a %%req%% into the correct method call on %%provider%%.
       */
      async _translatePerform(provider, req) {
        switch (req.method) {
          case "broadcastTransaction":
            return await provider.broadcastTransaction(req.signedTransaction);
          case "call":
            return await provider.call(Object.assign({}, req.transaction, { blockTag: req.blockTag }));
          case "chainId":
            return (await provider.getNetwork()).chainId;
          case "estimateGas":
            return await provider.estimateGas(req.transaction);
          case "getBalance":
            return await provider.getBalance(req.address, req.blockTag);
          case "getBlock": {
            const block = "blockHash" in req ? req.blockHash : req.blockTag;
            return await provider.getBlock(block, req.includeTransactions);
          }
          case "getBlockNumber":
            return await provider.getBlockNumber();
          case "getCode":
            return await provider.getCode(req.address, req.blockTag);
          case "getGasPrice":
            return (await provider.getFeeData()).gasPrice;
          case "getPriorityFee":
            return (await provider.getFeeData()).maxPriorityFeePerGas;
          case "getLogs":
            return await provider.getLogs(req.filter);
          case "getStorage":
            return await provider.getStorage(req.address, req.position, req.blockTag);
          case "getTransaction":
            return await provider.getTransaction(req.hash);
          case "getTransactionCount":
            return await provider.getTransactionCount(req.address, req.blockTag);
          case "getTransactionReceipt":
            return await provider.getTransactionReceipt(req.hash);
          case "getTransactionResult":
            return await provider.getTransactionResult(req.hash);
        }
      }
      async _perform(req) {
        if (req.method === "broadcastTransaction") {
          const results2 = __privateGet(this, _configs).map((c3) => null);
          const broadcasts = __privateGet(this, _configs).map(async ({ provider, weight }, index5) => {
            try {
              const result3 = await provider._perform(req);
              results2[index5] = Object.assign(normalizeResult(req.method, { result: result3 }), { weight });
            } catch (error) {
              results2[index5] = Object.assign(normalizeResult(req.method, { error }), { weight });
            }
          });
          while (true) {
            const done = results2.filter((r2) => r2 != null);
            for (const { value } of done) {
              if (!(value instanceof Error)) {
                return value;
              }
            }
            const result3 = checkQuorum(this.quorum, results2.filter((r2) => r2 != null));
            if ((0, index_js_1.isError)(result3, "INSUFFICIENT_FUNDS")) {
              throw result3;
            }
            const waiting = broadcasts.filter((b4, i2) => results2[i2] == null);
            if (waiting.length === 0) {
              break;
            }
            await Promise.race(waiting);
          }
          const result2 = getAnyResult(this.quorum, results2);
          (0, index_js_1.assert)(result2 !== void 0, "problem multi-broadcasting", "SERVER_ERROR", {
            request: "%sub-requests",
            info: { request: req, results: results2.map(stringify2) }
          });
          if (result2 instanceof Error) {
            throw result2;
          }
          return result2;
        }
        await __privateMethod(this, _FallbackProvider_instances, initialSync_fn).call(this);
        const running = /* @__PURE__ */ new Set();
        let inflightQuorum = 0;
        while (true) {
          const runner = __privateMethod(this, _FallbackProvider_instances, addRunner_fn).call(this, running, req);
          if (runner == null) {
            break;
          }
          inflightQuorum += runner.config.weight;
          if (inflightQuorum >= this.quorum) {
            break;
          }
        }
        const result = await __privateMethod(this, _FallbackProvider_instances, waitForQuorum_fn).call(this, running, req);
        for (const runner of running) {
          if (runner.perform && runner.result == null) {
            runner.config.lateResponses++;
          }
        }
        return result;
      }
      async destroy() {
        for (const { provider } of __privateGet(this, _configs)) {
          provider.destroy();
        }
        super.destroy();
      }
    };
    _configs = new WeakMap();
    _height = new WeakMap();
    _initialSyncPromise = new WeakMap();
    _FallbackProvider_instances = new WeakSet();
    // Grab the next (random) config that is not already part of
    // the running set
    getNextConfig_fn = function(running) {
      const configs = Array.from(running).map((r2) => r2.config);
      const allConfigs = __privateGet(this, _configs).slice();
      shuffle(allConfigs);
      allConfigs.sort((a3, b4) => a3.priority - b4.priority);
      for (const config of allConfigs) {
        if (config._lastFatalError) {
          continue;
        }
        if (configs.indexOf(config) === -1) {
          return config;
        }
      }
      return null;
    };
    // Adds a new runner (if available) to running.
    addRunner_fn = function(running, req) {
      const config = __privateMethod(this, _FallbackProvider_instances, getNextConfig_fn).call(this, running);
      if (config == null) {
        return null;
      }
      const runner = {
        config,
        result: null,
        didBump: false,
        perform: null,
        staller: null
      };
      const now = getTime();
      runner.perform = (async () => {
        try {
          config.requests++;
          const result = await this._translatePerform(config.provider, req);
          runner.result = { result };
        } catch (error) {
          config.errorResponses++;
          runner.result = { error };
        }
        const dt2 = getTime() - now;
        config._totalTime += dt2;
        config.rollingDuration = 0.95 * config.rollingDuration + 0.05 * dt2;
        runner.perform = null;
      })();
      runner.staller = (async () => {
        await stall(config.stallTimeout);
        runner.staller = null;
      })();
      running.add(runner);
      return runner;
    };
    initialSync_fn = async function() {
      let initialSync = __privateGet(this, _initialSyncPromise);
      if (!initialSync) {
        const promises = [];
        __privateGet(this, _configs).forEach((config) => {
          promises.push((async () => {
            await waitForSync(config, 0);
            if (!config._lastFatalError) {
              config._network = await config.provider.getNetwork();
            }
          })());
        });
        __privateSet(this, _initialSyncPromise, initialSync = (async () => {
          await Promise.all(promises);
          let chainId = null;
          for (const config of __privateGet(this, _configs)) {
            if (config._lastFatalError) {
              continue;
            }
            const network = config._network;
            if (chainId == null) {
              chainId = network.chainId;
            } else if (network.chainId !== chainId) {
              (0, index_js_1.assert)(false, "cannot mix providers on different networks", "UNSUPPORTED_OPERATION", {
                operation: "new FallbackProvider"
              });
            }
          }
        })());
      }
      await initialSync;
    };
    checkQuorum_fn = async function(running, req) {
      const results2 = [];
      for (const runner of running) {
        if (runner.result != null) {
          const { tag, value } = normalizeResult(req.method, runner.result);
          results2.push({ tag, value, weight: runner.config.weight });
        }
      }
      if (results2.reduce((a3, r2) => a3 + r2.weight, 0) < this.quorum) {
        return void 0;
      }
      switch (req.method) {
        case "getBlockNumber": {
          if (__privateGet(this, _height) === -2) {
            __privateSet(this, _height, Math.ceil((0, index_js_1.getNumber)(getMedian(this.quorum, __privateGet(this, _configs).filter((c3) => !c3._lastFatalError).map((c3) => ({
              value: c3.blockNumber,
              tag: (0, index_js_1.getNumber)(c3.blockNumber).toString(),
              weight: c3.weight
            }))))));
          }
          const mode3 = getFuzzyMode(this.quorum, results2);
          if (mode3 === void 0) {
            return void 0;
          }
          if (mode3 > __privateGet(this, _height)) {
            __privateSet(this, _height, mode3);
          }
          return __privateGet(this, _height);
        }
        case "getGasPrice":
        case "getPriorityFee":
        case "estimateGas":
          return getMedian(this.quorum, results2);
        case "getBlock":
          if ("blockTag" in req && req.blockTag === "pending") {
            return getAnyResult(this.quorum, results2);
          }
          return checkQuorum(this.quorum, results2);
        case "call":
        case "chainId":
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorage":
        case "getTransaction":
        case "getTransactionReceipt":
        case "getLogs":
          return checkQuorum(this.quorum, results2);
        case "broadcastTransaction":
          return getAnyResult(this.quorum, results2);
      }
      (0, index_js_1.assert)(false, "unsupported method", "UNSUPPORTED_OPERATION", {
        operation: `_perform(${stringify2(req.method)})`
      });
    };
    waitForQuorum_fn = async function(running, req) {
      if (running.size === 0) {
        throw new Error("no runners?!");
      }
      const interesting = [];
      let newRunners = 0;
      for (const runner of running) {
        if (runner.perform) {
          interesting.push(runner.perform);
        }
        if (runner.staller) {
          interesting.push(runner.staller);
          continue;
        }
        if (runner.didBump) {
          continue;
        }
        runner.didBump = true;
        newRunners++;
      }
      const value = await __privateMethod(this, _FallbackProvider_instances, checkQuorum_fn).call(this, running, req);
      if (value !== void 0) {
        if (value instanceof Error) {
          throw value;
        }
        return value;
      }
      for (let i2 = 0; i2 < newRunners; i2++) {
        __privateMethod(this, _FallbackProvider_instances, addRunner_fn).call(this, running, req);
      }
      (0, index_js_1.assert)(interesting.length > 0, "quorum not met", "SERVER_ERROR", {
        request: "%sub-requests",
        info: { request: req, results: Array.from(running).map((r2) => stringify2(r2.result)) }
      });
      await Promise.race(interesting);
      return await __privateMethod(this, _FallbackProvider_instances, waitForQuorum_fn).call(this, running, req);
    };
    exports.FallbackProvider = FallbackProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/default-provider.js
var require_default_provider = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/default-provider.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getDefaultProvider = void 0;
    var index_js_1 = require_utils5();
    var provider_ankr_js_1 = require_provider_ankr();
    var provider_alchemy_js_1 = require_provider_alchemy();
    var provider_chainstack_js_1 = require_provider_chainstack();
    var provider_cloudflare_js_1 = require_provider_cloudflare();
    var provider_etherscan_js_1 = require_provider_etherscan();
    var provider_infura_js_1 = require_provider_infura();
    var provider_quicknode_js_1 = require_provider_quicknode();
    var provider_fallback_js_1 = require_provider_fallback();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var network_js_1 = require_network();
    var provider_websocket_js_1 = require_provider_websocket();
    function isWebSocketLike(value) {
      return value && typeof value.send === "function" && typeof value.close === "function";
    }
    var Testnets = "goerli kovan sepolia classicKotti optimism-goerli arbitrum-goerli matic-mumbai bnbt".split(" ");
    function getDefaultProvider(network, options) {
      if (options == null) {
        options = {};
      }
      const allowService = (name) => {
        if (options[name] === "-") {
          return false;
        }
        if (typeof options.exclusive === "string") {
          return name === options.exclusive;
        }
        if (Array.isArray(options.exclusive)) {
          return options.exclusive.indexOf(name) !== -1;
        }
        return true;
      };
      if (typeof network === "string" && network.match(/^https?:/)) {
        return new provider_jsonrpc_js_1.JsonRpcProvider(network);
      }
      if (typeof network === "string" && network.match(/^wss?:/) || isWebSocketLike(network)) {
        return new provider_websocket_js_1.WebSocketProvider(network);
      }
      let staticNetwork = null;
      try {
        staticNetwork = network_js_1.Network.from(network);
      } catch (error) {
      }
      const providers = [];
      if (allowService("publicPolygon") && staticNetwork) {
        if (staticNetwork.name === "matic") {
          providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https://polygon-rpc.com/", staticNetwork, { staticNetwork }));
        } else if (staticNetwork.name === "matic-amoy") {
          providers.push(new provider_jsonrpc_js_1.JsonRpcProvider("https://rpc-amoy.polygon.technology/", staticNetwork, { staticNetwork }));
        }
      }
      if (allowService("alchemy")) {
        try {
          providers.push(new provider_alchemy_js_1.AlchemyProvider(network, options.alchemy));
        } catch (error) {
        }
      }
      if (allowService("ankr") && options.ankr != null) {
        try {
          providers.push(new provider_ankr_js_1.AnkrProvider(network, options.ankr));
        } catch (error) {
        }
      }
      if (allowService("chainstack")) {
        try {
          providers.push(new provider_chainstack_js_1.ChainstackProvider(network, options.chainstack));
        } catch (error) {
        }
      }
      if (allowService("cloudflare")) {
        try {
          providers.push(new provider_cloudflare_js_1.CloudflareProvider(network));
        } catch (error) {
        }
      }
      if (allowService("etherscan")) {
        try {
          providers.push(new provider_etherscan_js_1.EtherscanProvider(network, options.etherscan));
        } catch (error) {
        }
      }
      if (allowService("infura")) {
        try {
          let projectId = options.infura;
          let projectSecret = void 0;
          if (typeof projectId === "object") {
            projectSecret = projectId.projectSecret;
            projectId = projectId.projectId;
          }
          providers.push(new provider_infura_js_1.InfuraProvider(network, projectId, projectSecret));
        } catch (error) {
        }
      }
      if (allowService("quicknode")) {
        try {
          let token = options.quicknode;
          providers.push(new provider_quicknode_js_1.QuickNodeProvider(network, token));
        } catch (error) {
        }
      }
      (0, index_js_1.assert)(providers.length, "unsupported default network", "UNSUPPORTED_OPERATION", {
        operation: "getDefaultProvider"
      });
      if (providers.length === 1) {
        return providers[0];
      }
      let quorum = Math.floor(providers.length / 2);
      if (quorum > 2) {
        quorum = 2;
      }
      if (staticNetwork && Testnets.indexOf(staticNetwork.name) !== -1) {
        quorum = 1;
      }
      if (options && options.quorum) {
        quorum = options.quorum;
      }
      return new provider_fallback_js_1.FallbackProvider(providers, void 0, { quorum });
    }
    exports.getDefaultProvider = getDefaultProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js
var require_signer_noncemanager = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/signer-noncemanager.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NonceManager = void 0;
    var index_js_1 = require_utils5();
    var abstract_signer_js_1 = require_abstract_signer();
    var _noncePromise, _delta;
    var _NonceManager = class _NonceManager extends abstract_signer_js_1.AbstractSigner {
      /**
       *  Creates a new **NonceManager** to manage %%signer%%.
       */
      constructor(signer) {
        super(signer.provider);
        /**
         *  The Signer being managed.
         */
        __publicField(this, "signer");
        __privateAdd(this, _noncePromise);
        __privateAdd(this, _delta);
        (0, index_js_1.defineProperties)(this, { signer });
        __privateSet(this, _noncePromise, null);
        __privateSet(this, _delta, 0);
      }
      async getAddress() {
        return this.signer.getAddress();
      }
      connect(provider) {
        return new _NonceManager(this.signer.connect(provider));
      }
      async getNonce(blockTag) {
        if (blockTag === "pending") {
          if (__privateGet(this, _noncePromise) == null) {
            __privateSet(this, _noncePromise, super.getNonce("pending"));
          }
          const delta = __privateGet(this, _delta);
          return await __privateGet(this, _noncePromise) + delta;
        }
        return super.getNonce(blockTag);
      }
      /**
       *  Manually increment the nonce. This may be useful when managng
       *  offline transactions.
       */
      increment() {
        __privateWrapper(this, _delta)._++;
      }
      /**
       *  Resets the nonce, causing the **NonceManager** to reload the current
       *  nonce from the blockchain on the next transaction.
       */
      reset() {
        __privateSet(this, _delta, 0);
        __privateSet(this, _noncePromise, null);
      }
      async sendTransaction(tx) {
        const noncePromise = this.getNonce("pending");
        this.increment();
        tx = await this.signer.populateTransaction(tx);
        tx.nonce = await noncePromise;
        return await this.signer.sendTransaction(tx);
      }
      signTransaction(tx) {
        return this.signer.signTransaction(tx);
      }
      signMessage(message) {
        return this.signer.signMessage(message);
      }
      signTypedData(domain, types3, value) {
        return this.signer.signTypedData(domain, types3, value);
      }
    };
    _noncePromise = new WeakMap();
    _delta = new WeakMap();
    var NonceManager = _NonceManager;
    exports.NonceManager = NonceManager;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-browser.js
var require_provider_browser = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserProvider = void 0;
    var index_js_1 = require_utils5();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var _request;
    var BrowserProvider = class extends provider_jsonrpc_js_1.JsonRpcApiPollingProvider {
      /**
       *  Connect to the %%ethereum%% provider, optionally forcing the
       *  %%network%%.
       */
      constructor(ethereum, network, _options) {
        const options = Object.assign({}, _options != null ? _options : {}, { batchMaxCount: 1 });
        (0, index_js_1.assertArgument)(ethereum && ethereum.request, "invalid EIP-1193 provider", "ethereum", ethereum);
        super(network, options);
        __privateAdd(this, _request);
        __privateSet(this, _request, async (method, params) => {
          const payload = { method, params };
          this.emit("debug", { action: "sendEip1193Request", payload });
          try {
            const result = await ethereum.request(payload);
            this.emit("debug", { action: "receiveEip1193Result", result });
            return result;
          } catch (e2) {
            const error = new Error(e2.message);
            error.code = e2.code;
            error.data = e2.data;
            error.payload = payload;
            this.emit("debug", { action: "receiveEip1193Error", error });
            throw error;
          }
        });
      }
      async send(method, params) {
        await this._start();
        return await super.send(method, params);
      }
      async _send(payload) {
        (0, index_js_1.assertArgument)(!Array.isArray(payload), "EIP-1193 does not support batch request", "payload", payload);
        try {
          const result = await __privateGet(this, _request).call(this, payload.method, payload.params || []);
          return [{ id: payload.id, result }];
        } catch (e2) {
          return [{
            id: payload.id,
            error: { code: e2.code, data: e2.data, message: e2.message }
          }];
        }
      }
      getRpcError(payload, error) {
        error = JSON.parse(JSON.stringify(error));
        switch (error.error.code || -1) {
          case 4001:
            error.error.message = `ethers-user-denied: ${error.error.message}`;
            break;
          case 4200:
            error.error.message = `ethers-unsupported: ${error.error.message}`;
            break;
        }
        return super.getRpcError(payload, error);
      }
      /**
       *  Resolves to ``true`` if the provider manages the %%address%%.
       */
      async hasSigner(address) {
        if (address == null) {
          address = 0;
        }
        const accounts = await this.send("eth_accounts", []);
        if (typeof address === "number") {
          return accounts.length > address;
        }
        address = address.toLowerCase();
        return accounts.filter((a3) => a3.toLowerCase() === address).length !== 0;
      }
      async getSigner(address) {
        if (address == null) {
          address = 0;
        }
        if (!await this.hasSigner(address)) {
          try {
            await __privateGet(this, _request).call(this, "eth_requestAccounts", []);
          } catch (error) {
            const payload = error.payload;
            throw this.getRpcError(payload, { id: payload.id, error });
          }
        }
        return await super.getSigner(address);
      }
    };
    _request = new WeakMap();
    exports.BrowserProvider = BrowserProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-pocket.js
var require_provider_pocket = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-pocket.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.PocketProvider = void 0;
    var index_js_1 = require_utils5();
    var community_js_1 = require_community();
    var network_js_1 = require_network();
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    var defaultApplicationId = "62e1ad51b37b8e00394bda3b";
    function getHost(name) {
      switch (name) {
        case "mainnet":
          return "eth-mainnet.gateway.pokt.network";
        case "goerli":
          return "eth-goerli.gateway.pokt.network";
        case "matic":
          return "poly-mainnet.gateway.pokt.network";
        case "matic-mumbai":
          return "polygon-mumbai-rpc.gateway.pokt.network";
      }
      (0, index_js_1.assertArgument)(false, "unsupported network", "network", name);
    }
    var PocketProvider = class _PocketProvider extends provider_jsonrpc_js_1.JsonRpcProvider {
      /**
       *  Create a new **PocketProvider**.
       *
       *  By default connecting to ``mainnet`` with a highly throttled
       *  API key.
       */
      constructor(_network, applicationId, applicationSecret) {
        if (_network == null) {
          _network = "mainnet";
        }
        const network = network_js_1.Network.from(_network);
        if (applicationId == null) {
          applicationId = defaultApplicationId;
        }
        if (applicationSecret == null) {
          applicationSecret = null;
        }
        const options = { staticNetwork: network };
        const request = _PocketProvider.getRequest(network, applicationId, applicationSecret);
        super(request, network, options);
        /**
         *  The Application ID for the Pocket connection.
         */
        __publicField(this, "applicationId");
        /**
         *  The Application Secret for making authenticated requests
         *  to the Pocket connection.
         */
        __publicField(this, "applicationSecret");
        (0, index_js_1.defineProperties)(this, { applicationId, applicationSecret });
      }
      _getProvider(chainId) {
        try {
          return new _PocketProvider(chainId, this.applicationId, this.applicationSecret);
        } catch (error) {
        }
        return super._getProvider(chainId);
      }
      /**
       *  Returns a prepared request for connecting to %%network%% with
       *  %%applicationId%%.
       */
      static getRequest(network, applicationId, applicationSecret) {
        if (applicationId == null) {
          applicationId = defaultApplicationId;
        }
        const request = new index_js_1.FetchRequest(`https://${getHost(network.name)}/v1/lb/${applicationId}`);
        request.allowGzip = true;
        if (applicationSecret) {
          request.setCredentials("", applicationSecret);
        }
        if (applicationId === defaultApplicationId) {
          request.retryFunc = async (request2, response, attempt) => {
            (0, community_js_1.showThrottleMessage)("PocketProvider");
            return true;
          };
        }
        return request;
      }
      isCommunityResource() {
        return this.applicationId === defaultApplicationId;
      }
    };
    exports.PocketProvider = PocketProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/provider-ipcsocket-browser.js
var require_provider_ipcsocket_browser = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/provider-ipcsocket-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IpcSocketProvider = void 0;
    var IpcSocketProvider = void 0;
    exports.IpcSocketProvider = IpcSocketProvider;
  }
});

// node_modules/ethers/lib.commonjs/providers/index.js
var require_providers = __commonJS({
  "node_modules/ethers/lib.commonjs/providers/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SocketEventSubscriber = exports.SocketPendingSubscriber = exports.SocketBlockSubscriber = exports.SocketSubscriber = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanPlugin = exports.EtherscanProvider = exports.ChainstackProvider = exports.CloudflareProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.copyRequest = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EnsPlugin = exports.GasCostPlugin = exports.NetworkPlugin = exports.NonceManager = exports.Network = exports.MulticoinProviderPlugin = exports.EnsResolver = exports.getDefaultProvider = exports.showThrottleMessage = exports.VoidSigner = exports.AbstractSigner = exports.UnmanagedSubscriber = exports.AbstractProvider = void 0;
    var abstract_provider_js_1 = require_abstract_provider();
    Object.defineProperty(exports, "AbstractProvider", { enumerable: true, get: function() {
      return abstract_provider_js_1.AbstractProvider;
    } });
    Object.defineProperty(exports, "UnmanagedSubscriber", { enumerable: true, get: function() {
      return abstract_provider_js_1.UnmanagedSubscriber;
    } });
    var abstract_signer_js_1 = require_abstract_signer();
    Object.defineProperty(exports, "AbstractSigner", { enumerable: true, get: function() {
      return abstract_signer_js_1.AbstractSigner;
    } });
    Object.defineProperty(exports, "VoidSigner", { enumerable: true, get: function() {
      return abstract_signer_js_1.VoidSigner;
    } });
    var community_js_1 = require_community();
    Object.defineProperty(exports, "showThrottleMessage", { enumerable: true, get: function() {
      return community_js_1.showThrottleMessage;
    } });
    var default_provider_js_1 = require_default_provider();
    Object.defineProperty(exports, "getDefaultProvider", { enumerable: true, get: function() {
      return default_provider_js_1.getDefaultProvider;
    } });
    var ens_resolver_js_1 = require_ens_resolver();
    Object.defineProperty(exports, "EnsResolver", { enumerable: true, get: function() {
      return ens_resolver_js_1.EnsResolver;
    } });
    Object.defineProperty(exports, "MulticoinProviderPlugin", { enumerable: true, get: function() {
      return ens_resolver_js_1.MulticoinProviderPlugin;
    } });
    var network_js_1 = require_network();
    Object.defineProperty(exports, "Network", { enumerable: true, get: function() {
      return network_js_1.Network;
    } });
    var signer_noncemanager_js_1 = require_signer_noncemanager();
    Object.defineProperty(exports, "NonceManager", { enumerable: true, get: function() {
      return signer_noncemanager_js_1.NonceManager;
    } });
    var plugins_network_js_1 = require_plugins_network();
    Object.defineProperty(exports, "NetworkPlugin", { enumerable: true, get: function() {
      return plugins_network_js_1.NetworkPlugin;
    } });
    Object.defineProperty(exports, "GasCostPlugin", { enumerable: true, get: function() {
      return plugins_network_js_1.GasCostPlugin;
    } });
    Object.defineProperty(exports, "EnsPlugin", { enumerable: true, get: function() {
      return plugins_network_js_1.EnsPlugin;
    } });
    Object.defineProperty(exports, "FeeDataNetworkPlugin", { enumerable: true, get: function() {
      return plugins_network_js_1.FeeDataNetworkPlugin;
    } });
    Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", { enumerable: true, get: function() {
      return plugins_network_js_1.FetchUrlFeeDataNetworkPlugin;
    } });
    var provider_js_1 = require_provider();
    Object.defineProperty(exports, "Block", { enumerable: true, get: function() {
      return provider_js_1.Block;
    } });
    Object.defineProperty(exports, "FeeData", { enumerable: true, get: function() {
      return provider_js_1.FeeData;
    } });
    Object.defineProperty(exports, "Log", { enumerable: true, get: function() {
      return provider_js_1.Log;
    } });
    Object.defineProperty(exports, "TransactionReceipt", { enumerable: true, get: function() {
      return provider_js_1.TransactionReceipt;
    } });
    Object.defineProperty(exports, "TransactionResponse", { enumerable: true, get: function() {
      return provider_js_1.TransactionResponse;
    } });
    Object.defineProperty(exports, "copyRequest", { enumerable: true, get: function() {
      return provider_js_1.copyRequest;
    } });
    var provider_fallback_js_1 = require_provider_fallback();
    Object.defineProperty(exports, "FallbackProvider", { enumerable: true, get: function() {
      return provider_fallback_js_1.FallbackProvider;
    } });
    var provider_jsonrpc_js_1 = require_provider_jsonrpc();
    Object.defineProperty(exports, "JsonRpcApiProvider", { enumerable: true, get: function() {
      return provider_jsonrpc_js_1.JsonRpcApiProvider;
    } });
    Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function() {
      return provider_jsonrpc_js_1.JsonRpcProvider;
    } });
    Object.defineProperty(exports, "JsonRpcSigner", { enumerable: true, get: function() {
      return provider_jsonrpc_js_1.JsonRpcSigner;
    } });
    var provider_browser_js_1 = require_provider_browser();
    Object.defineProperty(exports, "BrowserProvider", { enumerable: true, get: function() {
      return provider_browser_js_1.BrowserProvider;
    } });
    var provider_alchemy_js_1 = require_provider_alchemy();
    Object.defineProperty(exports, "AlchemyProvider", { enumerable: true, get: function() {
      return provider_alchemy_js_1.AlchemyProvider;
    } });
    var provider_ankr_js_1 = require_provider_ankr();
    Object.defineProperty(exports, "AnkrProvider", { enumerable: true, get: function() {
      return provider_ankr_js_1.AnkrProvider;
    } });
    var provider_cloudflare_js_1 = require_provider_cloudflare();
    Object.defineProperty(exports, "CloudflareProvider", { enumerable: true, get: function() {
      return provider_cloudflare_js_1.CloudflareProvider;
    } });
    var provider_chainstack_js_1 = require_provider_chainstack();
    Object.defineProperty(exports, "ChainstackProvider", { enumerable: true, get: function() {
      return provider_chainstack_js_1.ChainstackProvider;
    } });
    var provider_etherscan_js_1 = require_provider_etherscan();
    Object.defineProperty(exports, "EtherscanProvider", { enumerable: true, get: function() {
      return provider_etherscan_js_1.EtherscanProvider;
    } });
    Object.defineProperty(exports, "EtherscanPlugin", { enumerable: true, get: function() {
      return provider_etherscan_js_1.EtherscanPlugin;
    } });
    var provider_infura_js_1 = require_provider_infura();
    Object.defineProperty(exports, "InfuraProvider", { enumerable: true, get: function() {
      return provider_infura_js_1.InfuraProvider;
    } });
    Object.defineProperty(exports, "InfuraWebSocketProvider", { enumerable: true, get: function() {
      return provider_infura_js_1.InfuraWebSocketProvider;
    } });
    var provider_pocket_js_1 = require_provider_pocket();
    Object.defineProperty(exports, "PocketProvider", { enumerable: true, get: function() {
      return provider_pocket_js_1.PocketProvider;
    } });
    var provider_quicknode_js_1 = require_provider_quicknode();
    Object.defineProperty(exports, "QuickNodeProvider", { enumerable: true, get: function() {
      return provider_quicknode_js_1.QuickNodeProvider;
    } });
    var provider_ipcsocket_js_1 = require_provider_ipcsocket_browser();
    Object.defineProperty(exports, "IpcSocketProvider", { enumerable: true, get: function() {
      return provider_ipcsocket_js_1.IpcSocketProvider;
    } });
    var provider_socket_js_1 = require_provider_socket();
    Object.defineProperty(exports, "SocketProvider", { enumerable: true, get: function() {
      return provider_socket_js_1.SocketProvider;
    } });
    var provider_websocket_js_1 = require_provider_websocket();
    Object.defineProperty(exports, "WebSocketProvider", { enumerable: true, get: function() {
      return provider_websocket_js_1.WebSocketProvider;
    } });
    var provider_socket_js_2 = require_provider_socket();
    Object.defineProperty(exports, "SocketSubscriber", { enumerable: true, get: function() {
      return provider_socket_js_2.SocketSubscriber;
    } });
    Object.defineProperty(exports, "SocketBlockSubscriber", { enumerable: true, get: function() {
      return provider_socket_js_2.SocketBlockSubscriber;
    } });
    Object.defineProperty(exports, "SocketPendingSubscriber", { enumerable: true, get: function() {
      return provider_socket_js_2.SocketPendingSubscriber;
    } });
    Object.defineProperty(exports, "SocketEventSubscriber", { enumerable: true, get: function() {
      return provider_socket_js_2.SocketEventSubscriber;
    } });
  }
});

// node_modules/ethers/lib.commonjs/wallet/base-wallet.js
var require_base_wallet = __commonJS({
  "node_modules/ethers/lib.commonjs/wallet/base-wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BaseWallet = void 0;
    var index_js_1 = require_address2();
    var index_js_2 = require_hash();
    var index_js_3 = require_providers();
    var index_js_4 = require_transaction2();
    var index_js_5 = require_utils5();
    var _signingKey;
    var _BaseWallet = class _BaseWallet extends index_js_3.AbstractSigner {
      /**
       *  Creates a new BaseWallet for %%privateKey%%, optionally
       *  connected to %%provider%%.
       *
       *  If %%provider%% is not specified, only offline methods can
       *  be used.
       */
      constructor(privateKey, provider) {
        super(provider);
        /**
         *  The wallet address.
         */
        __publicField(this, "address");
        __privateAdd(this, _signingKey);
        (0, index_js_5.assertArgument)(privateKey && typeof privateKey.sign === "function", "invalid private key", "privateKey", "[ REDACTED ]");
        __privateSet(this, _signingKey, privateKey);
        const address = (0, index_js_4.computeAddress)(this.signingKey.publicKey);
        (0, index_js_5.defineProperties)(this, { address });
      }
      // Store private values behind getters to reduce visibility
      // in console.log
      /**
       *  The [[SigningKey]] used for signing payloads.
       */
      get signingKey() {
        return __privateGet(this, _signingKey);
      }
      /**
       *  The private key for this wallet.
       */
      get privateKey() {
        return this.signingKey.privateKey;
      }
      async getAddress() {
        return this.address;
      }
      connect(provider) {
        return new _BaseWallet(__privateGet(this, _signingKey), provider);
      }
      async signTransaction(tx) {
        tx = (0, index_js_3.copyRequest)(tx);
        const { to: to4, from: from26 } = await (0, index_js_5.resolveProperties)({
          to: tx.to ? (0, index_js_1.resolveAddress)(tx.to, this.provider) : void 0,
          from: tx.from ? (0, index_js_1.resolveAddress)(tx.from, this.provider) : void 0
        });
        if (to4 != null) {
          tx.to = to4;
        }
        if (from26 != null) {
          tx.from = from26;
        }
        if (tx.from != null) {
          (0, index_js_5.assertArgument)((0, index_js_1.getAddress)(tx.from) === this.address, "transaction from address mismatch", "tx.from", tx.from);
          delete tx.from;
        }
        const btx = index_js_4.Transaction.from(tx);
        btx.signature = this.signingKey.sign(btx.unsignedHash);
        return btx.serialized;
      }
      async signMessage(message) {
        return this.signMessageSync(message);
      }
      // @TODO: Add a secialized signTx and signTyped sync that enforces
      // all parameters are known?
      /**
       *  Returns the signature for %%message%% signed with this wallet.
       */
      signMessageSync(message) {
        return this.signingKey.sign((0, index_js_2.hashMessage)(message)).serialized;
      }
      async signTypedData(domain, types3, value) {
        const populated = await index_js_2.TypedDataEncoder.resolveNames(domain, types3, value, async (name) => {
          (0, index_js_5.assert)(this.provider != null, "cannot resolve ENS names without a provider", "UNSUPPORTED_OPERATION", {
            operation: "resolveName",
            info: { name }
          });
          const address = await this.provider.resolveName(name);
          (0, index_js_5.assert)(address != null, "unconfigured ENS name", "UNCONFIGURED_NAME", {
            value: name
          });
          return address;
        });
        return this.signingKey.sign(index_js_2.TypedDataEncoder.hash(populated.domain, types3, populated.value)).serialized;
      }
    };
    _signingKey = new WeakMap();
    var BaseWallet = _BaseWallet;
    exports.BaseWallet = BaseWallet;
  }
});

// node_modules/ethers/lib.commonjs/wordlists/decode-owl.js
var require_decode_owl = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/decode-owl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeOwl = exports.decode = void 0;
    var index_js_1 = require_utils5();
    var subsChrs = " !#$%&'()*+,-./<=>?@[]^_`{|}~";
    var Word = /^[a-z]*$/i;
    function unfold(words, sep) {
      let initial = 97;
      return words.reduce((accum, word) => {
        if (word === sep) {
          initial++;
        } else if (word.match(Word)) {
          accum.push(String.fromCharCode(initial) + word);
        } else {
          initial = 97;
          accum.push(word);
        }
        return accum;
      }, []);
    }
    function decode4(data, subs) {
      for (let i2 = subsChrs.length - 1; i2 >= 0; i2--) {
        data = data.split(subsChrs[i2]).join(subs.substring(2 * i2, 2 * i2 + 2));
      }
      const clumps = [];
      const leftover = data.replace(/(:|([0-9])|([A-Z][a-z]*))/g, (all3, item, semi, word) => {
        if (semi) {
          for (let i2 = parseInt(semi); i2 >= 0; i2--) {
            clumps.push(";");
          }
        } else {
          clumps.push(item.toLowerCase());
        }
        return "";
      });
      if (leftover) {
        throw new Error(`leftovers: ${JSON.stringify(leftover)}`);
      }
      return unfold(unfold(clumps, ";"), ":");
    }
    exports.decode = decode4;
    function decodeOwl(data) {
      (0, index_js_1.assertArgument)(data[0] === "0", "unsupported auwl data", "data", data);
      return decode4(data.substring(1 + 2 * subsChrs.length), data.substring(1, 1 + 2 * subsChrs.length));
    }
    exports.decodeOwl = decodeOwl;
  }
});

// node_modules/ethers/lib.commonjs/wordlists/wordlist.js
var require_wordlist = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/wordlist.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wordlist = void 0;
    var index_js_1 = require_utils5();
    var Wordlist = class {
      /**
       *  Creates a new Wordlist instance.
       *
       *  Sub-classes MUST call this if they provide their own constructor,
       *  passing in the locale string of the language.
       *
       *  Generally there is no need to create instances of a Wordlist,
       *  since each language-specific Wordlist creates an instance and
       *  there is no state kept internally, so they are safe to share.
       */
      constructor(locale) {
        __publicField(this, "locale");
        (0, index_js_1.defineProperties)(this, { locale });
      }
      /**
       *  Sub-classes may override this to provide a language-specific
       *  method for spliting %%phrase%% into individual words.
       *
       *  By default, %%phrase%% is split using any sequences of
       *  white-space as defined by regular expressions (i.e. ``/\s+/``).
       */
      split(phrase) {
        return phrase.toLowerCase().split(/\s+/g);
      }
      /**
       *  Sub-classes may override this to provider a language-specific
       *  method for joining %%words%% into a phrase.
       *
       *  By default, %%words%% are joined by a single space.
       */
      join(words) {
        return words.join(" ");
      }
    };
    exports.Wordlist = Wordlist;
  }
});

// node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js
var require_wordlist_owl = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/wordlist-owl.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WordlistOwl = void 0;
    var index_js_1 = require_hash();
    var index_js_2 = require_utils5();
    var decode_owl_js_1 = require_decode_owl();
    var wordlist_js_1 = require_wordlist();
    var _data, _checksum, _words, _WordlistOwl_instances, loadWords_fn;
    var WordlistOwl = class extends wordlist_js_1.Wordlist {
      /**
       *  Creates a new Wordlist for %%locale%% using the OWL %%data%%
       *  and validated against the %%checksum%%.
       */
      constructor(locale, data, checksum2) {
        super(locale);
        __privateAdd(this, _WordlistOwl_instances);
        __privateAdd(this, _data);
        __privateAdd(this, _checksum);
        __privateAdd(this, _words);
        __privateSet(this, _data, data);
        __privateSet(this, _checksum, checksum2);
        __privateSet(this, _words, null);
      }
      /**
       *  The OWL-encoded data.
       */
      get _data() {
        return __privateGet(this, _data);
      }
      /**
       *  Decode all the words for the wordlist.
       */
      _decodeWords() {
        return (0, decode_owl_js_1.decodeOwl)(__privateGet(this, _data));
      }
      getWord(index5) {
        const words = __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this);
        (0, index_js_2.assertArgument)(index5 >= 0 && index5 < words.length, `invalid word index: ${index5}`, "index", index5);
        return words[index5];
      }
      getWordIndex(word) {
        return __privateMethod(this, _WordlistOwl_instances, loadWords_fn).call(this).indexOf(word);
      }
    };
    _data = new WeakMap();
    _checksum = new WeakMap();
    _words = new WeakMap();
    _WordlistOwl_instances = new WeakSet();
    loadWords_fn = function() {
      if (__privateGet(this, _words) == null) {
        const words = this._decodeWords();
        const checksum2 = (0, index_js_1.id)(words.join("\n") + "\n");
        if (checksum2 !== __privateGet(this, _checksum)) {
          throw new Error(`BIP39 Wordlist for ${this.locale} FAILED`);
        }
        __privateSet(this, _words, words);
      }
      return __privateGet(this, _words);
    };
    exports.WordlistOwl = WordlistOwl;
  }
});

// node_modules/ethers/lib.commonjs/wordlists/lang-en.js
var require_lang_en = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/lang-en.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LangEn = void 0;
    var wordlist_owl_js_1 = require_wordlist_owl();
    var words = "0erleonalorenseinceregesticitStanvetearctssi#ch2Athck&tneLl0And#Il.yLeOutO=S|S%b/ra@SurdU'0Ce[Cid|CountCu'Hie=IdOu,-Qui*Ro[TT]T%T*[Tu$0AptDD-tD*[Ju,M.UltV<)Vi)0Rob-0FairF%dRaid0A(EEntRee0Ead0MRRp%tS!_rmBumCoholErtI&LLeyLowMo,O}PhaReadySoT Ways0A>urAz(gOngOuntU'd0Aly,Ch%Ci|G G!GryIm$K!Noun)Nu$O` Sw T&naTiqueXietyY1ArtOlogyPe?P!Pro=Ril1ChCt-EaEnaGueMMedM%MyOundR<+Re,Ri=RowTTefa@Ti,Tw%k0KPe@SaultSetSi,SumeThma0H!>OmTa{T&dT.udeTra@0Ct]D.Gu,NtTh%ToTumn0Era+OcadoOid0AkeA*AyEsomeFulKw?d0Is:ByChel%C#D+GL<)Lc#y~MbooN<aNn RRelyRga(R*lSeS-SketTt!3A^AnAutyCau'ComeEfF%eG(Ha=H(dLie=LowLtN^Nef./TrayTt Twe&Y#d3Cyc!DKeNdOlogyRdR`Tt _{AdeAmeAnketA,EakE[IndOodO[omOu'UeUrUsh_rdAtDyIlMbNeNusOkO,Rd R(gRrowSsTtomUn)XY_{etA(AndA[A=EadEezeI{Id+IefIghtIngIskOccoliOk&OnzeOomO` OwnUsh2Bb!DdyD+tFf$oIldLbLkL!tNd!Nk Rd&Rg R,SS(e[SyTt Y Zz:Bba+B(B!CtusGeKe~LmM aMpNN$N)lNdyNn#NoeNvasNy#Pab!P.$Pta(RRb#RdRgoRpetRryRtSeShS(o/!Su$TT$ogT^Teg%yTt!UghtU'Ut]Ve3Il(gL yM|NsusNturyRe$Rta(_irAlkAmp]An+AosApt Ar+A'AtEapE{Ee'EfErryE,I{&IefIldIm}yOi)Oo'R#-U{!UnkUrn0G?Nnam#Rc!Tiz&TyVil_imApArifyAwAyE<ErkEv I{I|IffImbIn-IpO{OgO'O`OudOwnUbUmpU, Ut^_^A,C#utDeFfeeIlInL!@L%LumnMb(eMeMf%tM-Mm#Mp<yNc tNdu@NfirmNg*[N}@Nsid NtrolNv()OkOlPp PyR$ReRnR*@/Tt#U^UntryUp!Ur'Us(V Yo>_{Ad!AftAmA}AshAt AwlAzyEamEd.EekEwI{etImeIspIt-OpO[Ou^OwdUci$UelUi'Umb!Un^UshYY,$2BeLtu*PPbo?dRiousRr|Rta(R=Sh]/omTe3C!:DMa+MpN)Ng R(gShUght WnY3AlBa>BrisCadeCemb CideCl(eC%a>C*a'ErF&'F(eFyG*eLayLiv M<dMi'Ni$Nti,NyP?tP&dPos.P`PutyRi=ScribeS tSignSkSpair/royTailTe@VelopVi)Vo>3AgramAlAm#dAryCeE'lEtFf G.$Gn.yLemmaNn NosaurRe@RtSag*eScov Sea'ShSmi[S%d Splay/<)V tVideV%)Zzy5Ct%Cum|G~Lph(Ma(Na>NkeyN%OrSeUb!Ve_ftAg#AmaA,-AwEamE[IftIllInkIpI=OpUmY2CkMbNeR(g/T^Ty1Arf1Nam-:G G!RlyRnR`Sily/Sy1HoOlogyOnomy0GeItUca>1F%t0G1GhtTh 2BowD E@r-Eg<tEm|Eph<tEvat%I>Se0B?kBodyBra)Er+Ot]PloyPow Pty0Ab!A@DD![D%'EmyErgyF%)Ga+G(eH<)JoyLi,OughR-hRollSu*T Ti*TryVelope1Isode0U$Uip0AA'OdeOs]R%Upt0CapeSayS&)Ta>0Ern$H-s1Id&)IlOkeOl=1A@Amp!Ce[Ch<+C.eCludeCu'Ecu>Erci'Hau,Hib.I!I,ItOt-P<dPe@Pi*Pla(Po'P*[T&dTra0EEbrow:Br-CeCultyDeIntI`~L'MeMilyMousNNcyNtasyRmSh]TT$Th TigueUltV%.e3Atu*Bru?yD $EEdElMa!N)/iv$T^V W3B Ct]EldGu*LeLmLt N$NdNeNg NishReRmR,Sc$ShTT}[X_gAmeAshAtAv%EeIghtIpOatO{O%Ow UidUshY_mCusGIlLd~owOdOtR)Re,R+tRkRtu}RumRw?dSsil/ UndX_gi!AmeEqu|EshI&dIn+OgOntO,OwnOz&U.2ElNNnyRna)RyTu*:D+tInLaxy~ yMePRa+Rba+Rd&Rl-Rm|SSpTeTh U+Ze3N $NiusN*Nt!Nu(e/u*2O,0AntFtGg!Ng RaffeRlVe_dAn)A*A[IdeImp'ObeOomOryO=OwUe_tDde[LdOdO'RillaSpelSsipV nWn_bA)A(AntApeA[Av.yEatE&IdIefItOc yOupOwUnt_rdE[IdeIltIt?N3M:B.IrLfMm M, NdPpyRb%RdRshR=,TVeWkZ?d3AdAl`ArtAvyD+hogIght~oLmetLpNRo3Dd&Gh~NtPRe/%y5BbyCkeyLdLeLiday~owMeNeyOdPeRnRr%R'Sp.$/TelUrV 5BGeM<Mb!M%Nd*dNgryNtRd!RryRtSb<d3Brid:1EOn0EaEntifyLe2N%e4LLeg$L}[0A+Ita>M&'Mu}Pa@Po'Pro=Pul'0ChCludeComeC*a'DexD-a>Do%Du,ryF<tFl-tF%mHa!H .Iti$Je@JuryMa>N Noc|PutQuiryS<eSe@SideSpi*/$lTa@T e,ToVe,V.eVol=3On0L<dOla>Sue0Em1Ory:CketGu?RZz3AlousAns~yWel9BInKeUr}yY5D+I)MpNg!Ni%Nk/:Ng?oo3EnEpT^upY3CkDD}yNdNgdomSsTT^&TeTt&Wi4EeIfeO{Ow:BBelB%Dd DyKeMpNgua+PtopR+T T(UghUndryVaWWnWsu.Y Zy3Ad AfArnA=Ctu*FtGG$G&dIsu*M#NdNg`NsOp?dSs#Tt Vel3ArB tyBr?yC&'FeFtGhtKeMbM.NkOnQuid/Tt!VeZ?d5AdAnB, C$CkG-NelyNgOpTt yUdUn+VeY$5CkyGga+Mb N?N^Xury3R-s:Ch(eDG-G}tIdIlInJ%KeMm$NNa+Nda>NgoNs]Nu$P!Rb!R^Rg(R(eRketRria+SkSs/ T^T i$ThTrixTt XimumZe3AdowAnAsu*AtCh<-D$DiaLodyLtMb M%yNt]NuRcyR+R.RryShSsa+T$Thod3Dd!DnightLk~]M-NdNimumN%Nu>Rac!Rr%S ySs/akeXXedXtu*5Bi!DelDifyMM|N.%NkeyN, N`OnR$ReRn(gSqu.oTh T]T%Unta(U'VeVie5ChFf(LeLtiplySc!SeumShroomS-/Tu$3Self/ yTh:I=MePk(Rrow/yT]Tu*3ArCkEdGati=G!@I` PhewR=/TTw%kUtr$V WsXt3CeGht5B!I'M(eeOd!Rm$R`SeTab!TeTh(gTi)VelW5C!?Mb R'T:K0EyJe@Li+Scu*S =Ta(Vious0CurE<Tob 0Or1FF Fi)T&2L1Ay0DI=Ymp-0It0CeEI#L(eLy1EnEraIn]Po'T]1An+B.Ch?dD D(?yG<I|Ig($Ph<0Tr-h0H 0Tdo%T TputTside0AlEnEr0NN 0Yg&0/ 0O}:CtDd!GeIrLa)LmNdaNelN-N` P RadeR|RkRrotRtySsT^ThTi|TrolTt nU'VeYm|3A)AnutArAs<tL-<NN$tyNcilOp!Pp Rfe@Rm.Rs#T2O}OtoRa'Ys-$0AnoCn-Ctu*E)GGe#~LotNkO} Pe/olT^Zza_)A}tA,-A>AyEa'Ed+U{UgUn+2EmEtIntL?LeLi)NdNyOlPul?Rt]S.]Ssib!/TatoTt yV tyWd W _@i)Ai'Ed-tEf Epa*Es|EttyEv|I)IdeIm?yIntI%.yIs#Iva>IzeOb!mO)[Odu)Of.OgramOje@Omo>OofOp tyOsp O>@OudOvide2Bl-Dd(g~LpL'Mpk(N^PilPpyR^a'R.yRpo'R'ShTZz!3Ramid:99Al.yAntumArt E,]I{ItIzO>:Bb.Cco#CeCkD?DioIlInI'~yMpN^NdomN+PidReTeTh V&WZ%3AdyAlAs#BelBuildC$lCei=CipeC%dCyc!Du)F!@F%mFu'G]G*tGul?Je@LaxLea'LiefLyMa(Memb M(dMo=Nd NewNtOp&PairPeatPla)P%tQui*ScueSemb!Si,Sour)Sp#'SultTi*T*atTurnUn]Ve$ViewW?d2Y`m0BBb#CeChDeD+F!GhtGidNgOtPp!SkTu$V$V 5AdA,BotBu,CketM<)OfOkieOmSeTa>UghUndU>Y$5Bb DeGLeNNwayR$:DDd!D}[FeIlLadLm#L#LtLu>MeMp!NdTisfyToshiU)Usa+VeY1A!AnA*Att E}HemeHoolI&)I[%sOrp]OutRapRe&RiptRub1AAr^As#AtC#dC*tCt]Cur.yEdEkGm|Le@~M(?Ni%N'Nt&)RiesRvi)Ss]Tt!TupV&_dowAftAllowA*EdEllEriffIeldIftI}IpIv O{OeOotOpOrtOuld O=RimpRugUff!Y0Bl(gCkDeE+GhtGnL|Lk~yLv Mil?Mp!N)NgR&/ Tua>XZe1A>Et^IIllInIrtUll0AbAmEepEnd I)IdeIghtImOg<OtOwUsh0AllArtI!OkeOo`0A{AkeApIffOw0ApCc Ci$CkDaFtL?Ldi LidLut]L=Me#eNgOnRryRtUlUndUpUr)U`0A)A*Ati$AwnEakEci$EedEllEndH eI)Id IkeInIr.L.OilOns%O#OrtOtRayReadR(gY0Ua*UeezeUir*l_b!AdiumAffA+AirsAmpAndArtA>AyEakEelEmEpE*oI{IllIngO{Oma^O}OolOryO=Ra>gyReetRikeR#gRugg!Ud|UffUmb!Y!0Bje@Bm.BwayC)[ChDd&Ff G?G+,ItMm NNnyN'tP PplyP*meReRfa)R+Rpri'RroundR=ySpe@/a(1AllowAmpApArmE?EetIftImIngIt^Ord1MbolMptomRup/em:B!Ck!GIlL|LkNkPeR+tSk/eTtooXi3A^Am~NN<tNnisNtRm/Xt_nkAtEmeEnE%yE*EyIngIsOughtReeRi=RowUmbUnd 0CketDeG LtMb MeNyPRedSsueT!5A,BaccoDayDdl EGe` I!tK&MatoM%rowNeNgueNightOlO`PP-Pp!R^RnadoRtoi'SsT$Uri,W?dW WnY_{AdeAff-Ag-A(Ansf ApAshA=lAyEatEeEndI$IbeI{Igg ImIpOphyOub!U{UeUlyUmpetU,U`Y2BeIt]Mb!NaN}lRkeyRnRt!1El=EntyI)InI,O1PeP-$:5Ly5B*lla0Ab!Awa*C!Cov D DoFairFoldHappyIf%mIqueItIv 'KnownLo{TilUsu$Veil1Da>GradeHoldOnP Set1B<Ge0A+EEdEfulE![U$0Il.y:C<tCuumGueLidL!yL=NNishP%Rious/Ult3H-!L=tNd%Ntu*NueRbRifyRs]RyS'lT <3Ab!Br<tCiousCt%yDeoEw~a+Nta+Ol(Rtu$RusSaS.Su$T$Vid5C$I)IdLc<oLumeTeYa+:GeG#ItLk~LnutNtRfa*RmRri%ShSp/eT VeY3Al`Ap#ArA'lA` BDd(gEk&dIrdLcome/T_!AtEatEelEnE*IpIsp 0DeD`FeLd~NNdowNeNgNkNn Nt ReSdomSeShT}[5LfM<Nd OdOlRdRkRldRryR`_pE{E,!I,I>Ong::Rd3Ar~ow9UUngU`:3BraRo9NeO";
    var checksum2 = "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60";
    var wordlist11 = null;
    var LangEn = class _LangEn extends wordlist_owl_js_1.WordlistOwl {
      /**
       *  Creates a new instance of the English language Wordlist.
       *
       *  This should be unnecessary most of the time as the exported
       *  [[langEn]] should suffice.
       *
       *  @_ignore:
       */
      constructor() {
        super("en", words, checksum2);
      }
      /**
       *  Returns a singleton instance of a ``LangEn``, creating it
       *  if this is the first time being called.
       */
      static wordlist() {
        if (wordlist11 == null) {
          wordlist11 = new _LangEn();
        }
        return wordlist11;
      }
    };
    exports.LangEn = LangEn;
  }
});

// node_modules/ethers/lib.commonjs/wallet/mnemonic.js
var require_mnemonic = __commonJS({
  "node_modules/ethers/lib.commonjs/wallet/mnemonic.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Mnemonic = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_utils5();
    var lang_en_js_1 = require_lang_en();
    function getUpperMask(bits) {
      return (1 << bits) - 1 << 8 - bits & 255;
    }
    function getLowerMask(bits) {
      return (1 << bits) - 1 & 255;
    }
    function mnemonicToEntropy2(mnemonic, wordlist11) {
      (0, index_js_2.assertNormalize)("NFKD");
      if (wordlist11 == null) {
        wordlist11 = lang_en_js_1.LangEn.wordlist();
      }
      const words = wordlist11.split(mnemonic);
      (0, index_js_2.assertArgument)(words.length % 3 === 0 && words.length >= 12 && words.length <= 24, "invalid mnemonic length", "mnemonic", "[ REDACTED ]");
      const entropy = new Uint8Array(Math.ceil(11 * words.length / 8));
      let offset = 0;
      for (let i2 = 0; i2 < words.length; i2++) {
        let index5 = wordlist11.getWordIndex(words[i2].normalize("NFKD"));
        (0, index_js_2.assertArgument)(index5 >= 0, `invalid mnemonic word at index ${i2}`, "mnemonic", "[ REDACTED ]");
        for (let bit = 0; bit < 11; bit++) {
          if (index5 & 1 << 10 - bit) {
            entropy[offset >> 3] |= 1 << 7 - offset % 8;
          }
          offset++;
        }
      }
      const entropyBits = 32 * words.length / 3;
      const checksumBits = words.length / 3;
      const checksumMask = getUpperMask(checksumBits);
      const checksum2 = (0, index_js_2.getBytes)((0, index_js_1.sha256)(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
      (0, index_js_2.assertArgument)(checksum2 === (entropy[entropy.length - 1] & checksumMask), "invalid mnemonic checksum", "mnemonic", "[ REDACTED ]");
      return (0, index_js_2.hexlify)(entropy.slice(0, entropyBits / 8));
    }
    function entropyToMnemonic2(entropy, wordlist11) {
      (0, index_js_2.assertArgument)(entropy.length % 4 === 0 && entropy.length >= 16 && entropy.length <= 32, "invalid entropy size", "entropy", "[ REDACTED ]");
      if (wordlist11 == null) {
        wordlist11 = lang_en_js_1.LangEn.wordlist();
      }
      const indices = [0];
      let remainingBits = 11;
      for (let i2 = 0; i2 < entropy.length; i2++) {
        if (remainingBits > 8) {
          indices[indices.length - 1] <<= 8;
          indices[indices.length - 1] |= entropy[i2];
          remainingBits -= 8;
        } else {
          indices[indices.length - 1] <<= remainingBits;
          indices[indices.length - 1] |= entropy[i2] >> 8 - remainingBits;
          indices.push(entropy[i2] & getLowerMask(8 - remainingBits));
          remainingBits += 3;
        }
      }
      const checksumBits = entropy.length / 4;
      const checksum2 = parseInt((0, index_js_1.sha256)(entropy).substring(2, 4), 16) & getUpperMask(checksumBits);
      indices[indices.length - 1] <<= checksumBits;
      indices[indices.length - 1] |= checksum2 >> 8 - checksumBits;
      return wordlist11.join(indices.map((index5) => wordlist11.getWord(index5)));
    }
    var _guard = {};
    var Mnemonic = class _Mnemonic {
      /**
       *  @private
       */
      constructor(guard, entropy, phrase, password, wordlist11) {
        /**
         *  The mnemonic phrase of 12, 15, 18, 21 or 24 words.
         *
         *  Use the [[wordlist]] ``split`` method to get the individual words.
         */
        __publicField(this, "phrase");
        /**
         *  The password used for this mnemonic. If no password is used this
         *  is the empty string (i.e. ``""``) as per the specification.
         */
        __publicField(this, "password");
        /**
         *  The wordlist for this mnemonic.
         */
        __publicField(this, "wordlist");
        /**
         *  The underlying entropy which the mnemonic encodes.
         */
        __publicField(this, "entropy");
        if (password == null) {
          password = "";
        }
        if (wordlist11 == null) {
          wordlist11 = lang_en_js_1.LangEn.wordlist();
        }
        (0, index_js_2.assertPrivate)(guard, _guard, "Mnemonic");
        (0, index_js_2.defineProperties)(this, { phrase, password, wordlist: wordlist11, entropy });
      }
      /**
       *  Returns the seed for the mnemonic.
       */
      computeSeed() {
        const salt = (0, index_js_2.toUtf8Bytes)("mnemonic" + this.password, "NFKD");
        return (0, index_js_1.pbkdf2)((0, index_js_2.toUtf8Bytes)(this.phrase, "NFKD"), salt, 2048, 64, "sha512");
      }
      /**
       *  Creates a new Mnemonic for the %%phrase%%.
       *
       *  The default %%password%% is the empty string and the default
       *  wordlist is the [English wordlists](LangEn).
       */
      static fromPhrase(phrase, password, wordlist11) {
        const entropy = mnemonicToEntropy2(phrase, wordlist11);
        phrase = entropyToMnemonic2((0, index_js_2.getBytes)(entropy), wordlist11);
        return new _Mnemonic(_guard, entropy, phrase, password, wordlist11);
      }
      /**
       *  Create a new **Mnemonic** from the %%entropy%%.
       *
       *  The default %%password%% is the empty string and the default
       *  wordlist is the [English wordlists](LangEn).
       */
      static fromEntropy(_entropy, password, wordlist11) {
        const entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
        const phrase = entropyToMnemonic2(entropy, wordlist11);
        return new _Mnemonic(_guard, (0, index_js_2.hexlify)(entropy), phrase, password, wordlist11);
      }
      /**
       *  Returns the phrase for %%mnemonic%%.
       */
      static entropyToPhrase(_entropy, wordlist11) {
        const entropy = (0, index_js_2.getBytes)(_entropy, "entropy");
        return entropyToMnemonic2(entropy, wordlist11);
      }
      /**
       *  Returns the entropy for %%phrase%%.
       */
      static phraseToEntropy(phrase, wordlist11) {
        return mnemonicToEntropy2(phrase, wordlist11);
      }
      /**
       *  Returns true if %%phrase%% is a valid [[link-bip-39]] phrase.
       *
       *  This checks all the provided words belong to the %%wordlist%%,
       *  that the length is valid and the checksum is correct.
       */
      static isValidMnemonic(phrase, wordlist11) {
        try {
          mnemonicToEntropy2(phrase, wordlist11);
          return true;
        } catch (error) {
        }
        return false;
      }
    };
    exports.Mnemonic = Mnemonic;
  }
});

// node_modules/aes-js/lib.commonjs/aes.js
var require_aes = __commonJS({
  "node_modules/aes-js/lib.commonjs/aes.js"(exports) {
    "use strict";
    var __classPrivateFieldGet4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f3) {
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
    };
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f3) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
    };
    var _AES_key;
    var _AES_Kd;
    var _AES_Ke;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.AES = void 0;
    var numberOfRounds = { 16: 10, 24: 12, 32: 14 };
    var rcon = [1, 2, 4, 8, 16, 32, 64, 128, 27, 54, 108, 216, 171, 77, 154, 47, 94, 188, 99, 198, 151, 53, 106, 212, 179, 125, 250, 239, 197, 145];
    var S2 = [99, 124, 119, 123, 242, 107, 111, 197, 48, 1, 103, 43, 254, 215, 171, 118, 202, 130, 201, 125, 250, 89, 71, 240, 173, 212, 162, 175, 156, 164, 114, 192, 183, 253, 147, 38, 54, 63, 247, 204, 52, 165, 229, 241, 113, 216, 49, 21, 4, 199, 35, 195, 24, 150, 5, 154, 7, 18, 128, 226, 235, 39, 178, 117, 9, 131, 44, 26, 27, 110, 90, 160, 82, 59, 214, 179, 41, 227, 47, 132, 83, 209, 0, 237, 32, 252, 177, 91, 106, 203, 190, 57, 74, 76, 88, 207, 208, 239, 170, 251, 67, 77, 51, 133, 69, 249, 2, 127, 80, 60, 159, 168, 81, 163, 64, 143, 146, 157, 56, 245, 188, 182, 218, 33, 16, 255, 243, 210, 205, 12, 19, 236, 95, 151, 68, 23, 196, 167, 126, 61, 100, 93, 25, 115, 96, 129, 79, 220, 34, 42, 144, 136, 70, 238, 184, 20, 222, 94, 11, 219, 224, 50, 58, 10, 73, 6, 36, 92, 194, 211, 172, 98, 145, 149, 228, 121, 231, 200, 55, 109, 141, 213, 78, 169, 108, 86, 244, 234, 101, 122, 174, 8, 186, 120, 37, 46, 28, 166, 180, 198, 232, 221, 116, 31, 75, 189, 139, 138, 112, 62, 181, 102, 72, 3, 246, 14, 97, 53, 87, 185, 134, 193, 29, 158, 225, 248, 152, 17, 105, 217, 142, 148, 155, 30, 135, 233, 206, 85, 40, 223, 140, 161, 137, 13, 191, 230, 66, 104, 65, 153, 45, 15, 176, 84, 187, 22];
    var Si2 = [82, 9, 106, 213, 48, 54, 165, 56, 191, 64, 163, 158, 129, 243, 215, 251, 124, 227, 57, 130, 155, 47, 255, 135, 52, 142, 67, 68, 196, 222, 233, 203, 84, 123, 148, 50, 166, 194, 35, 61, 238, 76, 149, 11, 66, 250, 195, 78, 8, 46, 161, 102, 40, 217, 36, 178, 118, 91, 162, 73, 109, 139, 209, 37, 114, 248, 246, 100, 134, 104, 152, 22, 212, 164, 92, 204, 93, 101, 182, 146, 108, 112, 72, 80, 253, 237, 185, 218, 94, 21, 70, 87, 167, 141, 157, 132, 144, 216, 171, 0, 140, 188, 211, 10, 247, 228, 88, 5, 184, 179, 69, 6, 208, 44, 30, 143, 202, 63, 15, 2, 193, 175, 189, 3, 1, 19, 138, 107, 58, 145, 17, 65, 79, 103, 220, 234, 151, 242, 207, 206, 240, 180, 230, 115, 150, 172, 116, 34, 231, 173, 53, 133, 226, 249, 55, 232, 28, 117, 223, 110, 71, 241, 26, 113, 29, 41, 197, 137, 111, 183, 98, 14, 170, 24, 190, 27, 252, 86, 62, 75, 198, 210, 121, 32, 154, 219, 192, 254, 120, 205, 90, 244, 31, 221, 168, 51, 136, 7, 199, 49, 177, 18, 16, 89, 39, 128, 236, 95, 96, 81, 127, 169, 25, 181, 74, 13, 45, 229, 122, 159, 147, 201, 156, 239, 160, 224, 59, 77, 174, 42, 245, 176, 200, 235, 187, 60, 131, 83, 153, 97, 23, 43, 4, 126, 186, 119, 214, 38, 225, 105, 20, 99, 85, 33, 12, 125];
    var T12 = [3328402341, 4168907908, 4000806809, 4135287693, 4294111757, 3597364157, 3731845041, 2445657428, 1613770832, 33620227, 3462883241, 1445669757, 3892248089, 3050821474, 1303096294, 3967186586, 2412431941, 528646813, 2311702848, 4202528135, 4026202645, 2992200171, 2387036105, 4226871307, 1101901292, 3017069671, 1604494077, 1169141738, 597466303, 1403299063, 3832705686, 2613100635, 1974974402, 3791519004, 1033081774, 1277568618, 1815492186, 2118074177, 4126668546, 2211236943, 1748251740, 1369810420, 3521504564, 4193382664, 3799085459, 2883115123, 1647391059, 706024767, 134480908, 2512897874, 1176707941, 2646852446, 806885416, 932615841, 168101135, 798661301, 235341577, 605164086, 461406363, 3756188221, 3454790438, 1311188841, 2142417613, 3933566367, 302582043, 495158174, 1479289972, 874125870, 907746093, 3698224818, 3025820398, 1537253627, 2756858614, 1983593293, 3084310113, 2108928974, 1378429307, 3722699582, 1580150641, 327451799, 2790478837, 3117535592, 0, 3253595436, 1075847264, 3825007647, 2041688520, 3059440621, 3563743934, 2378943302, 1740553945, 1916352843, 2487896798, 2555137236, 2958579944, 2244988746, 3151024235, 3320835882, 1336584933, 3992714006, 2252555205, 2588757463, 1714631509, 293963156, 2319795663, 3925473552, 67240454, 4269768577, 2689618160, 2017213508, 631218106, 1269344483, 2723238387, 1571005438, 2151694528, 93294474, 1066570413, 563977660, 1882732616, 4059428100, 1673313503, 2008463041, 2950355573, 1109467491, 537923632, 3858759450, 4260623118, 3218264685, 2177748300, 403442708, 638784309, 3287084079, 3193921505, 899127202, 2286175436, 773265209, 2479146071, 1437050866, 4236148354, 2050833735, 3362022572, 3126681063, 840505643, 3866325909, 3227541664, 427917720, 2655997905, 2749160575, 1143087718, 1412049534, 999329963, 193497219, 2353415882, 3354324521, 1807268051, 672404540, 2816401017, 3160301282, 369822493, 2916866934, 3688947771, 1681011286, 1949973070, 336202270, 2454276571, 201721354, 1210328172, 3093060836, 2680341085, 3184776046, 1135389935, 3294782118, 965841320, 831886756, 3554993207, 4068047243, 3588745010, 2345191491, 1849112409, 3664604599, 26054028, 2983581028, 2622377682, 1235855840, 3630984372, 2891339514, 4092916743, 3488279077, 3395642799, 4101667470, 1202630377, 268961816, 1874508501, 4034427016, 1243948399, 1546530418, 941366308, 1470539505, 1941222599, 2546386513, 3421038627, 2715671932, 3899946140, 1042226977, 2521517021, 1639824860, 227249030, 260737669, 3765465232, 2084453954, 1907733956, 3429263018, 2420656344, 100860677, 4160157185, 470683154, 3261161891, 1781871967, 2924959737, 1773779408, 394692241, 2579611992, 974986535, 664706745, 3655459128, 3958962195, 731420851, 571543859, 3530123707, 2849626480, 126783113, 865375399, 765172662, 1008606754, 361203602, 3387549984, 2278477385, 2857719295, 1344809080, 2782912378, 59542671, 1503764984, 160008576, 437062935, 1707065306, 3622233649, 2218934982, 3496503480, 2185314755, 697932208, 1512910199, 504303377, 2075177163, 2824099068, 1841019862, 739644986];
    var T22 = [2781242211, 2230877308, 2582542199, 2381740923, 234877682, 3184946027, 2984144751, 1418839493, 1348481072, 50462977, 2848876391, 2102799147, 434634494, 1656084439, 3863849899, 2599188086, 1167051466, 2636087938, 1082771913, 2281340285, 368048890, 3954334041, 3381544775, 201060592, 3963727277, 1739838676, 4250903202, 3930435503, 3206782108, 4149453988, 2531553906, 1536934080, 3262494647, 484572669, 2923271059, 1783375398, 1517041206, 1098792767, 49674231, 1334037708, 1550332980, 4098991525, 886171109, 150598129, 2481090929, 1940642008, 1398944049, 1059722517, 201851908, 1385547719, 1699095331, 1587397571, 674240536, 2704774806, 252314885, 3039795866, 151914247, 908333586, 2602270848, 1038082786, 651029483, 1766729511, 3447698098, 2682942837, 454166793, 2652734339, 1951935532, 775166490, 758520603, 3000790638, 4004797018, 4217086112, 4137964114, 1299594043, 1639438038, 3464344499, 2068982057, 1054729187, 1901997871, 2534638724, 4121318227, 1757008337, 0, 750906861, 1614815264, 535035132, 3363418545, 3988151131, 3201591914, 1183697867, 3647454910, 1265776953, 3734260298, 3566750796, 3903871064, 1250283471, 1807470800, 717615087, 3847203498, 384695291, 3313910595, 3617213773, 1432761139, 2484176261, 3481945413, 283769337, 100925954, 2180939647, 4037038160, 1148730428, 3123027871, 3813386408, 4087501137, 4267549603, 3229630528, 2315620239, 2906624658, 3156319645, 1215313976, 82966005, 3747855548, 3245848246, 1974459098, 1665278241, 807407632, 451280895, 251524083, 1841287890, 1283575245, 337120268, 891687699, 801369324, 3787349855, 2721421207, 3431482436, 959321879, 1469301956, 4065699751, 2197585534, 1199193405, 2898814052, 3887750493, 724703513, 2514908019, 2696962144, 2551808385, 3516813135, 2141445340, 1715741218, 2119445034, 2872807568, 2198571144, 3398190662, 700968686, 3547052216, 1009259540, 2041044702, 3803995742, 487983883, 1991105499, 1004265696, 1449407026, 1316239930, 504629770, 3683797321, 168560134, 1816667172, 3837287516, 1570751170, 1857934291, 4014189740, 2797888098, 2822345105, 2754712981, 936633572, 2347923833, 852879335, 1133234376, 1500395319, 3084545389, 2348912013, 1689376213, 3533459022, 3762923945, 3034082412, 4205598294, 133428468, 634383082, 2949277029, 2398386810, 3913789102, 403703816, 3580869306, 2297460856, 1867130149, 1918643758, 607656988, 4049053350, 3346248884, 1368901318, 600565992, 2090982877, 2632479860, 557719327, 3717614411, 3697393085, 2249034635, 2232388234, 2430627952, 1115438654, 3295786421, 2865522278, 3633334344, 84280067, 33027830, 303828494, 2747425121, 1600795957, 4188952407, 3496589753, 2434238086, 1486471617, 658119965, 3106381470, 953803233, 334231800, 3005978776, 857870609, 3151128937, 1890179545, 2298973838, 2805175444, 3056442267, 574365214, 2450884487, 550103529, 1233637070, 4289353045, 2018519080, 2057691103, 2399374476, 4166623649, 2148108681, 387583245, 3664101311, 836232934, 3330556482, 3100665960, 3280093505, 2955516313, 2002398509, 287182607, 3413881008, 4238890068, 3597515707, 975967766];
    var T32 = [1671808611, 2089089148, 2006576759, 2072901243, 4061003762, 1807603307, 1873927791, 3310653893, 810573872, 16974337, 1739181671, 729634347, 4263110654, 3613570519, 2883997099, 1989864566, 3393556426, 2191335298, 3376449993, 2106063485, 4195741690, 1508618841, 1204391495, 4027317232, 2917941677, 3563566036, 2734514082, 2951366063, 2629772188, 2767672228, 1922491506, 3227229120, 3082974647, 4246528509, 2477669779, 644500518, 911895606, 1061256767, 4144166391, 3427763148, 878471220, 2784252325, 3845444069, 4043897329, 1905517169, 3631459288, 827548209, 356461077, 67897348, 3344078279, 593839651, 3277757891, 405286936, 2527147926, 84871685, 2595565466, 118033927, 305538066, 2157648768, 3795705826, 3945188843, 661212711, 2999812018, 1973414517, 152769033, 2208177539, 745822252, 439235610, 455947803, 1857215598, 1525593178, 2700827552, 1391895634, 994932283, 3596728278, 3016654259, 695947817, 3812548067, 795958831, 2224493444, 1408607827, 3513301457, 0, 3979133421, 543178784, 4229948412, 2982705585, 1542305371, 1790891114, 3410398667, 3201918910, 961245753, 1256100938, 1289001036, 1491644504, 3477767631, 3496721360, 4012557807, 2867154858, 4212583931, 1137018435, 1305975373, 861234739, 2241073541, 1171229253, 4178635257, 33948674, 2139225727, 1357946960, 1011120188, 2679776671, 2833468328, 1374921297, 2751356323, 1086357568, 2408187279, 2460827538, 2646352285, 944271416, 4110742005, 3168756668, 3066132406, 3665145818, 560153121, 271589392, 4279952895, 4077846003, 3530407890, 3444343245, 202643468, 322250259, 3962553324, 1608629855, 2543990167, 1154254916, 389623319, 3294073796, 2817676711, 2122513534, 1028094525, 1689045092, 1575467613, 422261273, 1939203699, 1621147744, 2174228865, 1339137615, 3699352540, 577127458, 712922154, 2427141008, 2290289544, 1187679302, 3995715566, 3100863416, 339486740, 3732514782, 1591917662, 186455563, 3681988059, 3762019296, 844522546, 978220090, 169743370, 1239126601, 101321734, 611076132, 1558493276, 3260915650, 3547250131, 2901361580, 1655096418, 2443721105, 2510565781, 3828863972, 2039214713, 3878868455, 3359869896, 928607799, 1840765549, 2374762893, 3580146133, 1322425422, 2850048425, 1823791212, 1459268694, 4094161908, 3928346602, 1706019429, 2056189050, 2934523822, 135794696, 3134549946, 2022240376, 628050469, 779246638, 472135708, 2800834470, 3032970164, 3327236038, 3894660072, 3715932637, 1956440180, 522272287, 1272813131, 3185336765, 2340818315, 2323976074, 1888542832, 1044544574, 3049550261, 1722469478, 1222152264, 50660867, 4127324150, 236067854, 1638122081, 895445557, 1475980887, 3117443513, 2257655686, 3243809217, 489110045, 2662934430, 3778599393, 4162055160, 2561878936, 288563729, 1773916777, 3648039385, 2391345038, 2493985684, 2612407707, 505560094, 2274497927, 3911240169, 3460925390, 1442818645, 678973480, 3749357023, 2358182796, 2717407649, 2306869641, 219617805, 3218761151, 3862026214, 1120306242, 1756942440, 1103331905, 2578459033, 762796589, 252780047, 2966125488, 1425844308, 3151392187, 372911126];
    var T4 = [1667474886, 2088535288, 2004326894, 2071694838, 4075949567, 1802223062, 1869591006, 3318043793, 808472672, 16843522, 1734846926, 724270422, 4278065639, 3621216949, 2880169549, 1987484396, 3402253711, 2189597983, 3385409673, 2105378810, 4210693615, 1499065266, 1195886990, 4042263547, 2913856577, 3570689971, 2728590687, 2947541573, 2627518243, 2762274643, 1920112356, 3233831835, 3082273397, 4261223649, 2475929149, 640051788, 909531756, 1061110142, 4160160501, 3435941763, 875846760, 2779116625, 3857003729, 4059105529, 1903268834, 3638064043, 825316194, 353713962, 67374088, 3351728789, 589522246, 3284360861, 404236336, 2526454071, 84217610, 2593830191, 117901582, 303183396, 2155911963, 3806477791, 3958056653, 656894286, 2998062463, 1970642922, 151591698, 2206440989, 741110872, 437923380, 454765878, 1852748508, 1515908788, 2694904667, 1381168804, 993742198, 3604373943, 3014905469, 690584402, 3823320797, 791638366, 2223281939, 1398011302, 3520161977, 0, 3991743681, 538992704, 4244381667, 2981218425, 1532751286, 1785380564, 3419096717, 3200178535, 960056178, 1246420628, 1280103576, 1482221744, 3486468741, 3503319995, 4025428677, 2863326543, 4227536621, 1128514950, 1296947098, 859002214, 2240123921, 1162203018, 4193849577, 33687044, 2139062782, 1347481760, 1010582648, 2678045221, 2829640523, 1364325282, 2745433693, 1077985408, 2408548869, 2459086143, 2644360225, 943212656, 4126475505, 3166494563, 3065430391, 3671750063, 555836226, 269496352, 4294908645, 4092792573, 3537006015, 3452783745, 202118168, 320025894, 3974901699, 1600119230, 2543297077, 1145359496, 387397934, 3301201811, 2812801621, 2122220284, 1027426170, 1684319432, 1566435258, 421079858, 1936954854, 1616945344, 2172753945, 1330631070, 3705438115, 572679748, 707427924, 2425400123, 2290647819, 1179044492, 4008585671, 3099120491, 336870440, 3739122087, 1583276732, 185277718, 3688593069, 3772791771, 842159716, 976899700, 168435220, 1229577106, 101059084, 606366792, 1549591736, 3267517855, 3553849021, 2897014595, 1650632388, 2442242105, 2509612081, 3840161747, 2038008818, 3890688725, 3368567691, 926374254, 1835907034, 2374863873, 3587531953, 1313788572, 2846482505, 1819063512, 1448540844, 4109633523, 3941213647, 1701162954, 2054852340, 2930698567, 134748176, 3132806511, 2021165296, 623210314, 774795868, 471606328, 2795958615, 3031746419, 3334885783, 3907527627, 3722280097, 1953799400, 522133822, 1263263126, 3183336545, 2341176845, 2324333839, 1886425312, 1044267644, 3048588401, 1718004428, 1212733584, 50529542, 4143317495, 235803164, 1633788866, 892690282, 1465383342, 3115962473, 2256965911, 3250673817, 488449850, 2661202215, 3789633753, 4177007595, 2560144171, 286339874, 1768537042, 3654906025, 2391705863, 2492770099, 2610673197, 505291324, 2273808917, 3924369609, 3469625735, 1431699370, 673740880, 3755965093, 2358021891, 2711746649, 2307489801, 218961690, 3217021541, 3873845719, 1111672452, 1751693520, 1094828930, 2576986153, 757954394, 252645662, 2964376443, 1414855848, 3149649517, 370555436];
    var T5 = [1374988112, 2118214995, 437757123, 975658646, 1001089995, 530400753, 2902087851, 1273168787, 540080725, 2910219766, 2295101073, 4110568485, 1340463100, 3307916247, 641025152, 3043140495, 3736164937, 632953703, 1172967064, 1576976609, 3274667266, 2169303058, 2370213795, 1809054150, 59727847, 361929877, 3211623147, 2505202138, 3569255213, 1484005843, 1239443753, 2395588676, 1975683434, 4102977912, 2572697195, 666464733, 3202437046, 4035489047, 3374361702, 2110667444, 1675577880, 3843699074, 2538681184, 1649639237, 2976151520, 3144396420, 4269907996, 4178062228, 1883793496, 2403728665, 2497604743, 1383856311, 2876494627, 1917518562, 3810496343, 1716890410, 3001755655, 800440835, 2261089178, 3543599269, 807962610, 599762354, 33778362, 3977675356, 2328828971, 2809771154, 4077384432, 1315562145, 1708848333, 101039829, 3509871135, 3299278474, 875451293, 2733856160, 92987698, 2767645557, 193195065, 1080094634, 1584504582, 3178106961, 1042385657, 2531067453, 3711829422, 1306967366, 2438237621, 1908694277, 67556463, 1615861247, 429456164, 3602770327, 2302690252, 1742315127, 2968011453, 126454664, 3877198648, 2043211483, 2709260871, 2084704233, 4169408201, 0, 159417987, 841739592, 504459436, 1817866830, 4245618683, 260388950, 1034867998, 908933415, 168810852, 1750902305, 2606453969, 607530554, 202008497, 2472011535, 3035535058, 463180190, 2160117071, 1641816226, 1517767529, 470948374, 3801332234, 3231722213, 1008918595, 303765277, 235474187, 4069246893, 766945465, 337553864, 1475418501, 2943682380, 4003061179, 2743034109, 4144047775, 1551037884, 1147550661, 1543208500, 2336434550, 3408119516, 3069049960, 3102011747, 3610369226, 1113818384, 328671808, 2227573024, 2236228733, 3535486456, 2935566865, 3341394285, 496906059, 3702665459, 226906860, 2009195472, 733156972, 2842737049, 294930682, 1206477858, 2835123396, 2700099354, 1451044056, 573804783, 2269728455, 3644379585, 2362090238, 2564033334, 2801107407, 2776292904, 3669462566, 1068351396, 742039012, 1350078989, 1784663195, 1417561698, 4136440770, 2430122216, 775550814, 2193862645, 2673705150, 1775276924, 1876241833, 3475313331, 3366754619, 270040487, 3902563182, 3678124923, 3441850377, 1851332852, 3969562369, 2203032232, 3868552805, 2868897406, 566021896, 4011190502, 3135740889, 1248802510, 3936291284, 699432150, 832877231, 708780849, 3332740144, 899835584, 1951317047, 4236429990, 3767586992, 866637845, 4043610186, 1106041591, 2144161806, 395441711, 1984812685, 1139781709, 3433712980, 3835036895, 2664543715, 1282050075, 3240894392, 1181045119, 2640243204, 25965917, 4203181171, 4211818798, 3009879386, 2463879762, 3910161971, 1842759443, 2597806476, 933301370, 1509430414, 3943906441, 3467192302, 3076639029, 3776767469, 2051518780, 2631065433, 1441952575, 404016761, 1942435775, 1408749034, 1610459739, 3745345300, 2017778566, 3400528769, 3110650942, 941896748, 3265478751, 371049330, 3168937228, 675039627, 4279080257, 967311729, 135050206, 3635733660, 1683407248, 2076935265, 3576870512, 1215061108, 3501741890];
    var T6 = [1347548327, 1400783205, 3273267108, 2520393566, 3409685355, 4045380933, 2880240216, 2471224067, 1428173050, 4138563181, 2441661558, 636813900, 4233094615, 3620022987, 2149987652, 2411029155, 1239331162, 1730525723, 2554718734, 3781033664, 46346101, 310463728, 2743944855, 3328955385, 3875770207, 2501218972, 3955191162, 3667219033, 768917123, 3545789473, 692707433, 1150208456, 1786102409, 2029293177, 1805211710, 3710368113, 3065962831, 401639597, 1724457132, 3028143674, 409198410, 2196052529, 1620529459, 1164071807, 3769721975, 2226875310, 486441376, 2499348523, 1483753576, 428819965, 2274680428, 3075636216, 598438867, 3799141122, 1474502543, 711349675, 129166120, 53458370, 2592523643, 2782082824, 4063242375, 2988687269, 3120694122, 1559041666, 730517276, 2460449204, 4042459122, 2706270690, 3446004468, 3573941694, 533804130, 2328143614, 2637442643, 2695033685, 839224033, 1973745387, 957055980, 2856345839, 106852767, 1371368976, 4181598602, 1033297158, 2933734917, 1179510461, 3046200461, 91341917, 1862534868, 4284502037, 605657339, 2547432937, 3431546947, 2003294622, 3182487618, 2282195339, 954669403, 3682191598, 1201765386, 3917234703, 3388507166, 0, 2198438022, 1211247597, 2887651696, 1315723890, 4227665663, 1443857720, 507358933, 657861945, 1678381017, 560487590, 3516619604, 975451694, 2970356327, 261314535, 3535072918, 2652609425, 1333838021, 2724322336, 1767536459, 370938394, 182621114, 3854606378, 1128014560, 487725847, 185469197, 2918353863, 3106780840, 3356761769, 2237133081, 1286567175, 3152976349, 4255350624, 2683765030, 3160175349, 3309594171, 878443390, 1988838185, 3704300486, 1756818940, 1673061617, 3403100636, 272786309, 1075025698, 545572369, 2105887268, 4174560061, 296679730, 1841768865, 1260232239, 4091327024, 3960309330, 3497509347, 1814803222, 2578018489, 4195456072, 575138148, 3299409036, 446754879, 3629546796, 4011996048, 3347532110, 3252238545, 4270639778, 915985419, 3483825537, 681933534, 651868046, 2755636671, 3828103837, 223377554, 2607439820, 1649704518, 3270937875, 3901806776, 1580087799, 4118987695, 3198115200, 2087309459, 2842678573, 3016697106, 1003007129, 2802849917, 1860738147, 2077965243, 164439672, 4100872472, 32283319, 2827177882, 1709610350, 2125135846, 136428751, 3874428392, 3652904859, 3460984630, 3572145929, 3593056380, 2939266226, 824852259, 818324884, 3224740454, 930369212, 2801566410, 2967507152, 355706840, 1257309336, 4148292826, 243256656, 790073846, 2373340630, 1296297904, 1422699085, 3756299780, 3818836405, 457992840, 3099667487, 2135319889, 77422314, 1560382517, 1945798516, 788204353, 1521706781, 1385356242, 870912086, 325965383, 2358957921, 2050466060, 2388260884, 2313884476, 4006521127, 901210569, 3990953189, 1014646705, 1503449823, 1062597235, 2031621326, 3212035895, 3931371469, 1533017514, 350174575, 2256028891, 2177544179, 1052338372, 741876788, 1606591296, 1914052035, 213705253, 2334669897, 1107234197, 1899603969, 3725069491, 2631447780, 2422494913, 1635502980, 1893020342, 1950903388, 1120974935];
    var T7 = [2807058932, 1699970625, 2764249623, 1586903591, 1808481195, 1173430173, 1487645946, 59984867, 4199882800, 1844882806, 1989249228, 1277555970, 3623636965, 3419915562, 1149249077, 2744104290, 1514790577, 459744698, 244860394, 3235995134, 1963115311, 4027744588, 2544078150, 4190530515, 1608975247, 2627016082, 2062270317, 1507497298, 2200818878, 567498868, 1764313568, 3359936201, 2305455554, 2037970062, 1047239e3, 1910319033, 1337376481, 2904027272, 2892417312, 984907214, 1243112415, 830661914, 861968209, 2135253587, 2011214180, 2927934315, 2686254721, 731183368, 1750626376, 4246310725, 1820824798, 4172763771, 3542330227, 48394827, 2404901663, 2871682645, 671593195, 3254988725, 2073724613, 145085239, 2280796200, 2779915199, 1790575107, 2187128086, 472615631, 3029510009, 4075877127, 3802222185, 4107101658, 3201631749, 1646252340, 4270507174, 1402811438, 1436590835, 3778151818, 3950355702, 3963161475, 4020912224, 2667994737, 273792366, 2331590177, 104699613, 95345982, 3175501286, 2377486676, 1560637892, 3564045318, 369057872, 4213447064, 3919042237, 1137477952, 2658625497, 1119727848, 2340947849, 1530455833, 4007360968, 172466556, 266959938, 516552836, 0, 2256734592, 3980931627, 1890328081, 1917742170, 4294704398, 945164165, 3575528878, 958871085, 3647212047, 2787207260, 1423022939, 775562294, 1739656202, 3876557655, 2530391278, 2443058075, 3310321856, 547512796, 1265195639, 437656594, 3121275539, 719700128, 3762502690, 387781147, 218828297, 3350065803, 2830708150, 2848461854, 428169201, 122466165, 3720081049, 1627235199, 648017665, 4122762354, 1002783846, 2117360635, 695634755, 3336358691, 4234721005, 4049844452, 3704280881, 2232435299, 574624663, 287343814, 612205898, 1039717051, 840019705, 2708326185, 793451934, 821288114, 1391201670, 3822090177, 376187827, 3113855344, 1224348052, 1679968233, 2361698556, 1058709744, 752375421, 2431590963, 1321699145, 3519142200, 2734591178, 188127444, 2177869557, 3727205754, 2384911031, 3215212461, 2648976442, 2450346104, 3432737375, 1180849278, 331544205, 3102249176, 4150144569, 2952102595, 2159976285, 2474404304, 766078933, 313773861, 2570832044, 2108100632, 1668212892, 3145456443, 2013908262, 418672217, 3070356634, 2594734927, 1852171925, 3867060991, 3473416636, 3907448597, 2614737639, 919489135, 164948639, 2094410160, 2997825956, 590424639, 2486224549, 1723872674, 3157750862, 3399941250, 3501252752, 3625268135, 2555048196, 3673637356, 1343127501, 4130281361, 3599595085, 2957853679, 1297403050, 81781910, 3051593425, 2283490410, 532201772, 1367295589, 3926170974, 895287692, 1953757831, 1093597963, 492483431, 3528626907, 1446242576, 1192455638, 1636604631, 209336225, 344873464, 1015671571, 669961897, 3375740769, 3857572124, 2973530695, 3747192018, 1933530610, 3464042516, 935293895, 3454686199, 2858115069, 1863638845, 3683022916, 4085369519, 3292445032, 875313188, 1080017571, 3279033885, 621591778, 1233856572, 2504130317, 24197544, 3017672716, 3835484340, 3247465558, 2220981195, 3060847922, 1551124588, 1463996600];
    var T8 = [4104605777, 1097159550, 396673818, 660510266, 2875968315, 2638606623, 4200115116, 3808662347, 821712160, 1986918061, 3430322568, 38544885, 3856137295, 718002117, 893681702, 1654886325, 2975484382, 3122358053, 3926825029, 4274053469, 796197571, 1290801793, 1184342925, 3556361835, 2405426947, 2459735317, 1836772287, 1381620373, 3196267988, 1948373848, 3764988233, 3385345166, 3263785589, 2390325492, 1480485785, 3111247143, 3780097726, 2293045232, 548169417, 3459953789, 3746175075, 439452389, 1362321559, 1400849762, 1685577905, 1806599355, 2174754046, 137073913, 1214797936, 1174215055, 3731654548, 2079897426, 1943217067, 1258480242, 529487843, 1437280870, 3945269170, 3049390895, 3313212038, 923313619, 679998e3, 3215307299, 57326082, 377642221, 3474729866, 2041877159, 133361907, 1776460110, 3673476453, 96392454, 878845905, 2801699524, 777231668, 4082475170, 2330014213, 4142626212, 2213296395, 1626319424, 1906247262, 1846563261, 562755902, 3708173718, 1040559837, 3871163981, 1418573201, 3294430577, 114585348, 1343618912, 2566595609, 3186202582, 1078185097, 3651041127, 3896688048, 2307622919, 425408743, 3371096953, 2081048481, 1108339068, 2216610296, 0, 2156299017, 736970802, 292596766, 1517440620, 251657213, 2235061775, 2933202493, 758720310, 265905162, 1554391400, 1532285339, 908999204, 174567692, 1474760595, 4002861748, 2610011675, 3234156416, 3693126241, 2001430874, 303699484, 2478443234, 2687165888, 585122620, 454499602, 151849742, 2345119218, 3064510765, 514443284, 4044981591, 1963412655, 2581445614, 2137062819, 19308535, 1928707164, 1715193156, 4219352155, 1126790795, 600235211, 3992742070, 3841024952, 836553431, 1669664834, 2535604243, 3323011204, 1243905413, 3141400786, 4180808110, 698445255, 2653899549, 2989552604, 2253581325, 3252932727, 3004591147, 1891211689, 2487810577, 3915653703, 4237083816, 4030667424, 2100090966, 865136418, 1229899655, 953270745, 3399679628, 3557504664, 4118925222, 2061379749, 3079546586, 2915017791, 983426092, 2022837584, 1607244650, 2118541908, 2366882550, 3635996816, 972512814, 3283088770, 1568718495, 3499326569, 3576539503, 621982671, 2895723464, 410887952, 2623762152, 1002142683, 645401037, 1494807662, 2595684844, 1335535747, 2507040230, 4293295786, 3167684641, 367585007, 3885750714, 1865862730, 2668221674, 2960971305, 2763173681, 1059270954, 2777952454, 2724642869, 1320957812, 2194319100, 2429595872, 2815956275, 77089521, 3973773121, 3444575871, 2448830231, 1305906550, 4021308739, 2857194700, 2516901860, 3518358430, 1787304780, 740276417, 1699839814, 1592394909, 2352307457, 2272556026, 188821243, 1729977011, 3687994002, 274084841, 3594982253, 3613494426, 2701949495, 4162096729, 322734571, 2837966542, 1640576439, 484830689, 1202797690, 3537852828, 4067639125, 349075736, 3342319475, 4157467219, 4255800159, 1030690015, 1155237496, 2951971274, 1757691577, 607398968, 2738905026, 499347990, 3794078908, 1011452712, 227885567, 2818666809, 213114376, 3034881240, 1455525988, 3414450555, 850817237, 1817998408, 3092726480];
    var U1 = [0, 235474187, 470948374, 303765277, 941896748, 908933415, 607530554, 708780849, 1883793496, 2118214995, 1817866830, 1649639237, 1215061108, 1181045119, 1417561698, 1517767529, 3767586992, 4003061179, 4236429990, 4069246893, 3635733660, 3602770327, 3299278474, 3400528769, 2430122216, 2664543715, 2362090238, 2193862645, 2835123396, 2801107407, 3035535058, 3135740889, 3678124923, 3576870512, 3341394285, 3374361702, 3810496343, 3977675356, 4279080257, 4043610186, 2876494627, 2776292904, 3076639029, 3110650942, 2472011535, 2640243204, 2403728665, 2169303058, 1001089995, 899835584, 666464733, 699432150, 59727847, 226906860, 530400753, 294930682, 1273168787, 1172967064, 1475418501, 1509430414, 1942435775, 2110667444, 1876241833, 1641816226, 2910219766, 2743034109, 2976151520, 3211623147, 2505202138, 2606453969, 2302690252, 2269728455, 3711829422, 3543599269, 3240894392, 3475313331, 3843699074, 3943906441, 4178062228, 4144047775, 1306967366, 1139781709, 1374988112, 1610459739, 1975683434, 2076935265, 1775276924, 1742315127, 1034867998, 866637845, 566021896, 800440835, 92987698, 193195065, 429456164, 395441711, 1984812685, 2017778566, 1784663195, 1683407248, 1315562145, 1080094634, 1383856311, 1551037884, 101039829, 135050206, 437757123, 337553864, 1042385657, 807962610, 573804783, 742039012, 2531067453, 2564033334, 2328828971, 2227573024, 2935566865, 2700099354, 3001755655, 3168937228, 3868552805, 3902563182, 4203181171, 4102977912, 3736164937, 3501741890, 3265478751, 3433712980, 1106041591, 1340463100, 1576976609, 1408749034, 2043211483, 2009195472, 1708848333, 1809054150, 832877231, 1068351396, 766945465, 599762354, 159417987, 126454664, 361929877, 463180190, 2709260871, 2943682380, 3178106961, 3009879386, 2572697195, 2538681184, 2236228733, 2336434550, 3509871135, 3745345300, 3441850377, 3274667266, 3910161971, 3877198648, 4110568485, 4211818798, 2597806476, 2497604743, 2261089178, 2295101073, 2733856160, 2902087851, 3202437046, 2968011453, 3936291284, 3835036895, 4136440770, 4169408201, 3535486456, 3702665459, 3467192302, 3231722213, 2051518780, 1951317047, 1716890410, 1750902305, 1113818384, 1282050075, 1584504582, 1350078989, 168810852, 67556463, 371049330, 404016761, 841739592, 1008918595, 775550814, 540080725, 3969562369, 3801332234, 4035489047, 4269907996, 3569255213, 3669462566, 3366754619, 3332740144, 2631065433, 2463879762, 2160117071, 2395588676, 2767645557, 2868897406, 3102011747, 3069049960, 202008497, 33778362, 270040487, 504459436, 875451293, 975658646, 675039627, 641025152, 2084704233, 1917518562, 1615861247, 1851332852, 1147550661, 1248802510, 1484005843, 1451044056, 933301370, 967311729, 733156972, 632953703, 260388950, 25965917, 328671808, 496906059, 1206477858, 1239443753, 1543208500, 1441952575, 2144161806, 1908694277, 1675577880, 1842759443, 3610369226, 3644379585, 3408119516, 3307916247, 4011190502, 3776767469, 4077384432, 4245618683, 2809771154, 2842737049, 3144396420, 3043140495, 2673705150, 2438237621, 2203032232, 2370213795];
    var U2 = [0, 185469197, 370938394, 487725847, 741876788, 657861945, 975451694, 824852259, 1483753576, 1400783205, 1315723890, 1164071807, 1950903388, 2135319889, 1649704518, 1767536459, 2967507152, 3152976349, 2801566410, 2918353863, 2631447780, 2547432937, 2328143614, 2177544179, 3901806776, 3818836405, 4270639778, 4118987695, 3299409036, 3483825537, 3535072918, 3652904859, 2077965243, 1893020342, 1841768865, 1724457132, 1474502543, 1559041666, 1107234197, 1257309336, 598438867, 681933534, 901210569, 1052338372, 261314535, 77422314, 428819965, 310463728, 3409685355, 3224740454, 3710368113, 3593056380, 3875770207, 3960309330, 4045380933, 4195456072, 2471224067, 2554718734, 2237133081, 2388260884, 3212035895, 3028143674, 2842678573, 2724322336, 4138563181, 4255350624, 3769721975, 3955191162, 3667219033, 3516619604, 3431546947, 3347532110, 2933734917, 2782082824, 3099667487, 3016697106, 2196052529, 2313884476, 2499348523, 2683765030, 1179510461, 1296297904, 1347548327, 1533017514, 1786102409, 1635502980, 2087309459, 2003294622, 507358933, 355706840, 136428751, 53458370, 839224033, 957055980, 605657339, 790073846, 2373340630, 2256028891, 2607439820, 2422494913, 2706270690, 2856345839, 3075636216, 3160175349, 3573941694, 3725069491, 3273267108, 3356761769, 4181598602, 4063242375, 4011996048, 3828103837, 1033297158, 915985419, 730517276, 545572369, 296679730, 446754879, 129166120, 213705253, 1709610350, 1860738147, 1945798516, 2029293177, 1239331162, 1120974935, 1606591296, 1422699085, 4148292826, 4233094615, 3781033664, 3931371469, 3682191598, 3497509347, 3446004468, 3328955385, 2939266226, 2755636671, 3106780840, 2988687269, 2198438022, 2282195339, 2501218972, 2652609425, 1201765386, 1286567175, 1371368976, 1521706781, 1805211710, 1620529459, 2105887268, 1988838185, 533804130, 350174575, 164439672, 46346101, 870912086, 954669403, 636813900, 788204353, 2358957921, 2274680428, 2592523643, 2441661558, 2695033685, 2880240216, 3065962831, 3182487618, 3572145929, 3756299780, 3270937875, 3388507166, 4174560061, 4091327024, 4006521127, 3854606378, 1014646705, 930369212, 711349675, 560487590, 272786309, 457992840, 106852767, 223377554, 1678381017, 1862534868, 1914052035, 2031621326, 1211247597, 1128014560, 1580087799, 1428173050, 32283319, 182621114, 401639597, 486441376, 768917123, 651868046, 1003007129, 818324884, 1503449823, 1385356242, 1333838021, 1150208456, 1973745387, 2125135846, 1673061617, 1756818940, 2970356327, 3120694122, 2802849917, 2887651696, 2637442643, 2520393566, 2334669897, 2149987652, 3917234703, 3799141122, 4284502037, 4100872472, 3309594171, 3460984630, 3545789473, 3629546796, 2050466060, 1899603969, 1814803222, 1730525723, 1443857720, 1560382517, 1075025698, 1260232239, 575138148, 692707433, 878443390, 1062597235, 243256656, 91341917, 409198410, 325965383, 3403100636, 3252238545, 3704300486, 3620022987, 3874428392, 3990953189, 4042459122, 4227665663, 2460449204, 2578018489, 2226875310, 2411029155, 3198115200, 3046200461, 2827177882, 2743944855];
    var U3 = [0, 218828297, 437656594, 387781147, 875313188, 958871085, 775562294, 590424639, 1750626376, 1699970625, 1917742170, 2135253587, 1551124588, 1367295589, 1180849278, 1265195639, 3501252752, 3720081049, 3399941250, 3350065803, 3835484340, 3919042237, 4270507174, 4085369519, 3102249176, 3051593425, 2734591178, 2952102595, 2361698556, 2177869557, 2530391278, 2614737639, 3145456443, 3060847922, 2708326185, 2892417312, 2404901663, 2187128086, 2504130317, 2555048196, 3542330227, 3727205754, 3375740769, 3292445032, 3876557655, 3926170974, 4246310725, 4027744588, 1808481195, 1723872674, 1910319033, 2094410160, 1608975247, 1391201670, 1173430173, 1224348052, 59984867, 244860394, 428169201, 344873464, 935293895, 984907214, 766078933, 547512796, 1844882806, 1627235199, 2011214180, 2062270317, 1507497298, 1423022939, 1137477952, 1321699145, 95345982, 145085239, 532201772, 313773861, 830661914, 1015671571, 731183368, 648017665, 3175501286, 2957853679, 2807058932, 2858115069, 2305455554, 2220981195, 2474404304, 2658625497, 3575528878, 3625268135, 3473416636, 3254988725, 3778151818, 3963161475, 4213447064, 4130281361, 3599595085, 3683022916, 3432737375, 3247465558, 3802222185, 4020912224, 4172763771, 4122762354, 3201631749, 3017672716, 2764249623, 2848461854, 2331590177, 2280796200, 2431590963, 2648976442, 104699613, 188127444, 472615631, 287343814, 840019705, 1058709744, 671593195, 621591778, 1852171925, 1668212892, 1953757831, 2037970062, 1514790577, 1463996600, 1080017571, 1297403050, 3673637356, 3623636965, 3235995134, 3454686199, 4007360968, 3822090177, 4107101658, 4190530515, 2997825956, 3215212461, 2830708150, 2779915199, 2256734592, 2340947849, 2627016082, 2443058075, 172466556, 122466165, 273792366, 492483431, 1047239e3, 861968209, 612205898, 695634755, 1646252340, 1863638845, 2013908262, 1963115311, 1446242576, 1530455833, 1277555970, 1093597963, 1636604631, 1820824798, 2073724613, 1989249228, 1436590835, 1487645946, 1337376481, 1119727848, 164948639, 81781910, 331544205, 516552836, 1039717051, 821288114, 669961897, 719700128, 2973530695, 3157750862, 2871682645, 2787207260, 2232435299, 2283490410, 2667994737, 2450346104, 3647212047, 3564045318, 3279033885, 3464042516, 3980931627, 3762502690, 4150144569, 4199882800, 3070356634, 3121275539, 2904027272, 2686254721, 2200818878, 2384911031, 2570832044, 2486224549, 3747192018, 3528626907, 3310321856, 3359936201, 3950355702, 3867060991, 4049844452, 4234721005, 1739656202, 1790575107, 2108100632, 1890328081, 1402811438, 1586903591, 1233856572, 1149249077, 266959938, 48394827, 369057872, 418672217, 1002783846, 919489135, 567498868, 752375421, 209336225, 24197544, 376187827, 459744698, 945164165, 895287692, 574624663, 793451934, 1679968233, 1764313568, 2117360635, 1933530610, 1343127501, 1560637892, 1243112415, 1192455638, 3704280881, 3519142200, 3336358691, 3419915562, 3907448597, 3857572124, 4075877127, 4294704398, 3029510009, 3113855344, 2927934315, 2744104290, 2159976285, 2377486676, 2594734927, 2544078150];
    var U4 = [0, 151849742, 303699484, 454499602, 607398968, 758720310, 908999204, 1059270954, 1214797936, 1097159550, 1517440620, 1400849762, 1817998408, 1699839814, 2118541908, 2001430874, 2429595872, 2581445614, 2194319100, 2345119218, 3034881240, 3186202582, 2801699524, 2951971274, 3635996816, 3518358430, 3399679628, 3283088770, 4237083816, 4118925222, 4002861748, 3885750714, 1002142683, 850817237, 698445255, 548169417, 529487843, 377642221, 227885567, 77089521, 1943217067, 2061379749, 1640576439, 1757691577, 1474760595, 1592394909, 1174215055, 1290801793, 2875968315, 2724642869, 3111247143, 2960971305, 2405426947, 2253581325, 2638606623, 2487810577, 3808662347, 3926825029, 4044981591, 4162096729, 3342319475, 3459953789, 3576539503, 3693126241, 1986918061, 2137062819, 1685577905, 1836772287, 1381620373, 1532285339, 1078185097, 1229899655, 1040559837, 923313619, 740276417, 621982671, 439452389, 322734571, 137073913, 19308535, 3871163981, 4021308739, 4104605777, 4255800159, 3263785589, 3414450555, 3499326569, 3651041127, 2933202493, 2815956275, 3167684641, 3049390895, 2330014213, 2213296395, 2566595609, 2448830231, 1305906550, 1155237496, 1607244650, 1455525988, 1776460110, 1626319424, 2079897426, 1928707164, 96392454, 213114376, 396673818, 514443284, 562755902, 679998e3, 865136418, 983426092, 3708173718, 3557504664, 3474729866, 3323011204, 4180808110, 4030667424, 3945269170, 3794078908, 2507040230, 2623762152, 2272556026, 2390325492, 2975484382, 3092726480, 2738905026, 2857194700, 3973773121, 3856137295, 4274053469, 4157467219, 3371096953, 3252932727, 3673476453, 3556361835, 2763173681, 2915017791, 3064510765, 3215307299, 2156299017, 2307622919, 2459735317, 2610011675, 2081048481, 1963412655, 1846563261, 1729977011, 1480485785, 1362321559, 1243905413, 1126790795, 878845905, 1030690015, 645401037, 796197571, 274084841, 425408743, 38544885, 188821243, 3613494426, 3731654548, 3313212038, 3430322568, 4082475170, 4200115116, 3780097726, 3896688048, 2668221674, 2516901860, 2366882550, 2216610296, 3141400786, 2989552604, 2837966542, 2687165888, 1202797690, 1320957812, 1437280870, 1554391400, 1669664834, 1787304780, 1906247262, 2022837584, 265905162, 114585348, 499347990, 349075736, 736970802, 585122620, 972512814, 821712160, 2595684844, 2478443234, 2293045232, 2174754046, 3196267988, 3079546586, 2895723464, 2777952454, 3537852828, 3687994002, 3234156416, 3385345166, 4142626212, 4293295786, 3841024952, 3992742070, 174567692, 57326082, 410887952, 292596766, 777231668, 660510266, 1011452712, 893681702, 1108339068, 1258480242, 1343618912, 1494807662, 1715193156, 1865862730, 1948373848, 2100090966, 2701949495, 2818666809, 3004591147, 3122358053, 2235061775, 2352307457, 2535604243, 2653899549, 3915653703, 3764988233, 4219352155, 4067639125, 3444575871, 3294430577, 3746175075, 3594982253, 836553431, 953270745, 600235211, 718002117, 367585007, 484830689, 133361907, 251657213, 2041877159, 1891211689, 1806599355, 1654886325, 1568718495, 1418573201, 1335535747, 1184342925];
    function convertToInt32(bytes) {
      const result = [];
      for (let i2 = 0; i2 < bytes.length; i2 += 4) {
        result.push(bytes[i2] << 24 | bytes[i2 + 1] << 16 | bytes[i2 + 2] << 8 | bytes[i2 + 3]);
      }
      return result;
    }
    var AES = class _AES {
      get key() {
        return __classPrivateFieldGet4(this, _AES_key, "f").slice();
      }
      constructor(key) {
        _AES_key.set(this, void 0);
        _AES_Kd.set(this, void 0);
        _AES_Ke.set(this, void 0);
        if (!(this instanceof _AES)) {
          throw Error("AES must be instanitated with `new`");
        }
        __classPrivateFieldSet2(this, _AES_key, new Uint8Array(key), "f");
        const rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
          throw new TypeError("invalid key size (must be 16, 24 or 32 bytes)");
        }
        __classPrivateFieldSet2(this, _AES_Ke, [], "f");
        __classPrivateFieldSet2(this, _AES_Kd, [], "f");
        for (let i2 = 0; i2 <= rounds; i2++) {
          __classPrivateFieldGet4(this, _AES_Ke, "f").push([0, 0, 0, 0]);
          __classPrivateFieldGet4(this, _AES_Kd, "f").push([0, 0, 0, 0]);
        }
        const roundKeyCount = (rounds + 1) * 4;
        const KC = this.key.length / 4;
        const tk = convertToInt32(this.key);
        let index5;
        for (let i2 = 0; i2 < KC; i2++) {
          index5 = i2 >> 2;
          __classPrivateFieldGet4(this, _AES_Ke, "f")[index5][i2 % 4] = tk[i2];
          __classPrivateFieldGet4(this, _AES_Kd, "f")[rounds - index5][i2 % 4] = tk[i2];
        }
        let rconpointer = 0;
        let t2 = KC, tt2;
        while (t2 < roundKeyCount) {
          tt2 = tk[KC - 1];
          tk[0] ^= S2[tt2 >> 16 & 255] << 24 ^ S2[tt2 >> 8 & 255] << 16 ^ S2[tt2 & 255] << 8 ^ S2[tt2 >> 24 & 255] ^ rcon[rconpointer] << 24;
          rconpointer += 1;
          if (KC != 8) {
            for (let i3 = 1; i3 < KC; i3++) {
              tk[i3] ^= tk[i3 - 1];
            }
          } else {
            for (let i3 = 1; i3 < KC / 2; i3++) {
              tk[i3] ^= tk[i3 - 1];
            }
            tt2 = tk[KC / 2 - 1];
            tk[KC / 2] ^= S2[tt2 & 255] ^ S2[tt2 >> 8 & 255] << 8 ^ S2[tt2 >> 16 & 255] << 16 ^ S2[tt2 >> 24 & 255] << 24;
            for (let i3 = KC / 2 + 1; i3 < KC; i3++) {
              tk[i3] ^= tk[i3 - 1];
            }
          }
          let i2 = 0, r2, c3;
          while (i2 < KC && t2 < roundKeyCount) {
            r2 = t2 >> 2;
            c3 = t2 % 4;
            __classPrivateFieldGet4(this, _AES_Ke, "f")[r2][c3] = tk[i2];
            __classPrivateFieldGet4(this, _AES_Kd, "f")[rounds - r2][c3] = tk[i2++];
            t2++;
          }
        }
        for (let r2 = 1; r2 < rounds; r2++) {
          for (let c3 = 0; c3 < 4; c3++) {
            tt2 = __classPrivateFieldGet4(this, _AES_Kd, "f")[r2][c3];
            __classPrivateFieldGet4(this, _AES_Kd, "f")[r2][c3] = U1[tt2 >> 24 & 255] ^ U2[tt2 >> 16 & 255] ^ U3[tt2 >> 8 & 255] ^ U4[tt2 & 255];
          }
        }
      }
      encrypt(plaintext) {
        if (plaintext.length != 16) {
          throw new TypeError("invalid plaintext size (must be 16 bytes)");
        }
        const rounds = __classPrivateFieldGet4(this, _AES_Ke, "f").length - 1;
        const a3 = [0, 0, 0, 0];
        let t2 = convertToInt32(plaintext);
        for (let i2 = 0; i2 < 4; i2++) {
          t2[i2] ^= __classPrivateFieldGet4(this, _AES_Ke, "f")[0][i2];
        }
        for (let r2 = 1; r2 < rounds; r2++) {
          for (let i2 = 0; i2 < 4; i2++) {
            a3[i2] = T12[t2[i2] >> 24 & 255] ^ T22[t2[(i2 + 1) % 4] >> 16 & 255] ^ T32[t2[(i2 + 2) % 4] >> 8 & 255] ^ T4[t2[(i2 + 3) % 4] & 255] ^ __classPrivateFieldGet4(this, _AES_Ke, "f")[r2][i2];
          }
          t2 = a3.slice();
        }
        const result = new Uint8Array(16);
        let tt2 = 0;
        for (let i2 = 0; i2 < 4; i2++) {
          tt2 = __classPrivateFieldGet4(this, _AES_Ke, "f")[rounds][i2];
          result[4 * i2] = (S2[t2[i2] >> 24 & 255] ^ tt2 >> 24) & 255;
          result[4 * i2 + 1] = (S2[t2[(i2 + 1) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
          result[4 * i2 + 2] = (S2[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
          result[4 * i2 + 3] = (S2[t2[(i2 + 3) % 4] & 255] ^ tt2) & 255;
        }
        return result;
      }
      decrypt(ciphertext) {
        if (ciphertext.length != 16) {
          throw new TypeError("invalid ciphertext size (must be 16 bytes)");
        }
        const rounds = __classPrivateFieldGet4(this, _AES_Kd, "f").length - 1;
        const a3 = [0, 0, 0, 0];
        let t2 = convertToInt32(ciphertext);
        for (let i2 = 0; i2 < 4; i2++) {
          t2[i2] ^= __classPrivateFieldGet4(this, _AES_Kd, "f")[0][i2];
        }
        for (let r2 = 1; r2 < rounds; r2++) {
          for (let i2 = 0; i2 < 4; i2++) {
            a3[i2] = T5[t2[i2] >> 24 & 255] ^ T6[t2[(i2 + 3) % 4] >> 16 & 255] ^ T7[t2[(i2 + 2) % 4] >> 8 & 255] ^ T8[t2[(i2 + 1) % 4] & 255] ^ __classPrivateFieldGet4(this, _AES_Kd, "f")[r2][i2];
          }
          t2 = a3.slice();
        }
        const result = new Uint8Array(16);
        let tt2 = 0;
        for (let i2 = 0; i2 < 4; i2++) {
          tt2 = __classPrivateFieldGet4(this, _AES_Kd, "f")[rounds][i2];
          result[4 * i2] = (Si2[t2[i2] >> 24 & 255] ^ tt2 >> 24) & 255;
          result[4 * i2 + 1] = (Si2[t2[(i2 + 3) % 4] >> 16 & 255] ^ tt2 >> 16) & 255;
          result[4 * i2 + 2] = (Si2[t2[(i2 + 2) % 4] >> 8 & 255] ^ tt2 >> 8) & 255;
          result[4 * i2 + 3] = (Si2[t2[(i2 + 1) % 4] & 255] ^ tt2) & 255;
        }
        return result;
      }
    };
    exports.AES = AES;
    _AES_key = /* @__PURE__ */ new WeakMap(), _AES_Kd = /* @__PURE__ */ new WeakMap(), _AES_Ke = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/aes-js/lib.commonjs/mode.js
var require_mode2 = __commonJS({
  "node_modules/aes-js/lib.commonjs/mode.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ModeOfOperation = void 0;
    var aes_js_1 = require_aes();
    var ModeOfOperation = class {
      constructor(name, key, cls) {
        if (cls && !(this instanceof cls)) {
          throw new Error(`${name} must be instantiated with "new"`);
        }
        Object.defineProperties(this, {
          aes: { enumerable: true, value: new aes_js_1.AES(key) },
          name: { enumerable: true, value: name }
        });
      }
    };
    exports.ModeOfOperation = ModeOfOperation;
  }
});

// node_modules/aes-js/lib.commonjs/mode-cbc.js
var require_mode_cbc = __commonJS({
  "node_modules/aes-js/lib.commonjs/mode-cbc.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f3) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f3) {
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
    };
    var _CBC_iv;
    var _CBC_lastBlock;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CBC = void 0;
    var mode_js_1 = require_mode2();
    var CBC = class _CBC extends mode_js_1.ModeOfOperation {
      constructor(key, iv) {
        super("ECC", key, _CBC);
        _CBC_iv.set(this, void 0);
        _CBC_lastBlock.set(this, void 0);
        if (iv) {
          if (iv.length % 16) {
            throw new TypeError("invalid iv size (must be 16 bytes)");
          }
          __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(iv), "f");
        } else {
          __classPrivateFieldSet2(this, _CBC_iv, new Uint8Array(16), "f");
        }
        __classPrivateFieldSet2(this, _CBC_lastBlock, this.iv, "f");
      }
      get iv() {
        return new Uint8Array(__classPrivateFieldGet4(this, _CBC_iv, "f"));
      }
      encrypt(plaintext) {
        if (plaintext.length % 16) {
          throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        const ciphertext = new Uint8Array(plaintext.length);
        for (let i2 = 0; i2 < plaintext.length; i2 += 16) {
          for (let j3 = 0; j3 < 16; j3++) {
            __classPrivateFieldGet4(this, _CBC_lastBlock, "f")[j3] ^= plaintext[i2 + j3];
          }
          __classPrivateFieldSet2(this, _CBC_lastBlock, this.aes.encrypt(__classPrivateFieldGet4(this, _CBC_lastBlock, "f")), "f");
          ciphertext.set(__classPrivateFieldGet4(this, _CBC_lastBlock, "f"), i2);
        }
        return ciphertext;
      }
      decrypt(ciphertext) {
        if (ciphertext.length % 16) {
          throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        const plaintext = new Uint8Array(ciphertext.length);
        for (let i2 = 0; i2 < ciphertext.length; i2 += 16) {
          const block = this.aes.decrypt(ciphertext.subarray(i2, i2 + 16));
          for (let j3 = 0; j3 < 16; j3++) {
            plaintext[i2 + j3] = block[j3] ^ __classPrivateFieldGet4(this, _CBC_lastBlock, "f")[j3];
            __classPrivateFieldGet4(this, _CBC_lastBlock, "f")[j3] = ciphertext[i2 + j3];
          }
        }
        return plaintext;
      }
    };
    exports.CBC = CBC;
    _CBC_iv = /* @__PURE__ */ new WeakMap(), _CBC_lastBlock = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/aes-js/lib.commonjs/mode-cfb.js
var require_mode_cfb = __commonJS({
  "node_modules/aes-js/lib.commonjs/mode-cfb.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f3) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f3) {
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
    };
    var _CFB_instances;
    var _CFB_iv;
    var _CFB_shiftRegister;
    var _CFB_shift;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CFB = void 0;
    var mode_js_1 = require_mode2();
    var CFB = class _CFB extends mode_js_1.ModeOfOperation {
      constructor(key, iv, segmentSize = 8) {
        super("CFB", key, _CFB);
        _CFB_instances.add(this);
        _CFB_iv.set(this, void 0);
        _CFB_shiftRegister.set(this, void 0);
        if (!Number.isInteger(segmentSize) || segmentSize % 8) {
          throw new TypeError("invalid segmentSize");
        }
        Object.defineProperties(this, {
          segmentSize: { enumerable: true, value: segmentSize }
        });
        if (iv) {
          if (iv.length % 16) {
            throw new TypeError("invalid iv size (must be 16 bytes)");
          }
          __classPrivateFieldSet2(this, _CFB_iv, new Uint8Array(iv), "f");
        } else {
          __classPrivateFieldSet2(this, _CFB_iv, new Uint8Array(16), "f");
        }
        __classPrivateFieldSet2(this, _CFB_shiftRegister, this.iv, "f");
      }
      get iv() {
        return new Uint8Array(__classPrivateFieldGet4(this, _CFB_iv, "f"));
      }
      encrypt(plaintext) {
        if (8 * plaintext.length % this.segmentSize) {
          throw new TypeError("invalid plaintext size (must be multiple of segmentSize bytes)");
        }
        const segmentSize = this.segmentSize / 8;
        const ciphertext = new Uint8Array(plaintext);
        for (let i2 = 0; i2 < ciphertext.length; i2 += segmentSize) {
          const xorSegment = this.aes.encrypt(__classPrivateFieldGet4(this, _CFB_shiftRegister, "f"));
          for (let j3 = 0; j3 < segmentSize; j3++) {
            ciphertext[i2 + j3] ^= xorSegment[j3];
          }
          __classPrivateFieldGet4(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i2));
        }
        return ciphertext;
      }
      decrypt(ciphertext) {
        if (8 * ciphertext.length % this.segmentSize) {
          throw new TypeError("invalid ciphertext size (must be multiple of segmentSize bytes)");
        }
        const segmentSize = this.segmentSize / 8;
        const plaintext = new Uint8Array(ciphertext);
        for (let i2 = 0; i2 < plaintext.length; i2 += segmentSize) {
          const xorSegment = this.aes.encrypt(__classPrivateFieldGet4(this, _CFB_shiftRegister, "f"));
          for (let j3 = 0; j3 < segmentSize; j3++) {
            plaintext[i2 + j3] ^= xorSegment[j3];
          }
          __classPrivateFieldGet4(this, _CFB_instances, "m", _CFB_shift).call(this, ciphertext.subarray(i2));
        }
        return plaintext;
      }
    };
    exports.CFB = CFB;
    _CFB_iv = /* @__PURE__ */ new WeakMap(), _CFB_shiftRegister = /* @__PURE__ */ new WeakMap(), _CFB_instances = /* @__PURE__ */ new WeakSet(), _CFB_shift = function _CFB_shift2(data) {
      const segmentSize = this.segmentSize / 8;
      __classPrivateFieldGet4(this, _CFB_shiftRegister, "f").set(__classPrivateFieldGet4(this, _CFB_shiftRegister, "f").subarray(segmentSize));
      __classPrivateFieldGet4(this, _CFB_shiftRegister, "f").set(data.subarray(0, segmentSize), 16 - segmentSize);
    };
  }
});

// node_modules/aes-js/lib.commonjs/mode-ctr.js
var require_mode_ctr = __commonJS({
  "node_modules/aes-js/lib.commonjs/mode-ctr.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f3) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f3) {
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
    };
    var _CTR_remaining;
    var _CTR_remainingIndex;
    var _CTR_counter;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.CTR = void 0;
    var mode_js_1 = require_mode2();
    var CTR = class _CTR extends mode_js_1.ModeOfOperation {
      constructor(key, initialValue) {
        super("CTR", key, _CTR);
        _CTR_remaining.set(this, void 0);
        _CTR_remainingIndex.set(this, void 0);
        _CTR_counter.set(this, void 0);
        __classPrivateFieldSet2(this, _CTR_counter, new Uint8Array(16), "f");
        __classPrivateFieldGet4(this, _CTR_counter, "f").fill(0);
        __classPrivateFieldSet2(this, _CTR_remaining, __classPrivateFieldGet4(this, _CTR_counter, "f"), "f");
        __classPrivateFieldSet2(this, _CTR_remainingIndex, 16, "f");
        if (initialValue == null) {
          initialValue = 1;
        }
        if (typeof initialValue === "number") {
          this.setCounterValue(initialValue);
        } else {
          this.setCounterBytes(initialValue);
        }
      }
      get counter() {
        return new Uint8Array(__classPrivateFieldGet4(this, _CTR_counter, "f"));
      }
      setCounterValue(value) {
        if (!Number.isInteger(value) || value < 0 || value > Number.MAX_SAFE_INTEGER) {
          throw new TypeError("invalid counter initial integer value");
        }
        for (let index5 = 15; index5 >= 0; --index5) {
          __classPrivateFieldGet4(this, _CTR_counter, "f")[index5] = value % 256;
          value = Math.floor(value / 256);
        }
      }
      setCounterBytes(value) {
        if (value.length !== 16) {
          throw new TypeError("invalid counter initial Uint8Array value length");
        }
        __classPrivateFieldGet4(this, _CTR_counter, "f").set(value);
      }
      increment() {
        for (let i2 = 15; i2 >= 0; i2--) {
          if (__classPrivateFieldGet4(this, _CTR_counter, "f")[i2] === 255) {
            __classPrivateFieldGet4(this, _CTR_counter, "f")[i2] = 0;
          } else {
            __classPrivateFieldGet4(this, _CTR_counter, "f")[i2]++;
            break;
          }
        }
      }
      encrypt(plaintext) {
        var _a2, _b;
        const crypttext = new Uint8Array(plaintext);
        for (let i2 = 0; i2 < crypttext.length; i2++) {
          if (__classPrivateFieldGet4(this, _CTR_remainingIndex, "f") === 16) {
            __classPrivateFieldSet2(this, _CTR_remaining, this.aes.encrypt(__classPrivateFieldGet4(this, _CTR_counter, "f")), "f");
            __classPrivateFieldSet2(this, _CTR_remainingIndex, 0, "f");
            this.increment();
          }
          crypttext[i2] ^= __classPrivateFieldGet4(this, _CTR_remaining, "f")[__classPrivateFieldSet2(this, _CTR_remainingIndex, (_b = __classPrivateFieldGet4(this, _CTR_remainingIndex, "f"), _a2 = _b++, _b), "f"), _a2];
        }
        return crypttext;
      }
      decrypt(ciphertext) {
        return this.encrypt(ciphertext);
      }
    };
    exports.CTR = CTR;
    _CTR_remaining = /* @__PURE__ */ new WeakMap(), _CTR_remainingIndex = /* @__PURE__ */ new WeakMap(), _CTR_counter = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/aes-js/lib.commonjs/mode-ecb.js
var require_mode_ecb = __commonJS({
  "node_modules/aes-js/lib.commonjs/mode-ecb.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ECB = void 0;
    var mode_js_1 = require_mode2();
    var ECB = class _ECB extends mode_js_1.ModeOfOperation {
      constructor(key) {
        super("ECB", key, _ECB);
      }
      encrypt(plaintext) {
        if (plaintext.length % 16) {
          throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        const crypttext = new Uint8Array(plaintext.length);
        for (let i2 = 0; i2 < plaintext.length; i2 += 16) {
          crypttext.set(this.aes.encrypt(plaintext.subarray(i2, i2 + 16)), i2);
        }
        return crypttext;
      }
      decrypt(crypttext) {
        if (crypttext.length % 16) {
          throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        const plaintext = new Uint8Array(crypttext.length);
        for (let i2 = 0; i2 < crypttext.length; i2 += 16) {
          plaintext.set(this.aes.decrypt(crypttext.subarray(i2, i2 + 16)), i2);
        }
        return plaintext;
      }
    };
    exports.ECB = ECB;
  }
});

// node_modules/aes-js/lib.commonjs/mode-ofb.js
var require_mode_ofb = __commonJS({
  "node_modules/aes-js/lib.commonjs/mode-ofb.js"(exports) {
    "use strict";
    var __classPrivateFieldSet2 = exports && exports.__classPrivateFieldSet || function(receiver, state, value, kind, f3) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f3.call(receiver, value) : f3 ? f3.value = value : state.set(receiver, value), value;
    };
    var __classPrivateFieldGet4 = exports && exports.__classPrivateFieldGet || function(receiver, state, kind, f3) {
      if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
    };
    var _OFB_iv;
    var _OFB_lastPrecipher;
    var _OFB_lastPrecipherIndex;
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.OFB = void 0;
    var mode_js_1 = require_mode2();
    var OFB = class _OFB extends mode_js_1.ModeOfOperation {
      constructor(key, iv) {
        super("OFB", key, _OFB);
        _OFB_iv.set(this, void 0);
        _OFB_lastPrecipher.set(this, void 0);
        _OFB_lastPrecipherIndex.set(this, void 0);
        if (iv) {
          if (iv.length % 16) {
            throw new TypeError("invalid iv size (must be 16 bytes)");
          }
          __classPrivateFieldSet2(this, _OFB_iv, new Uint8Array(iv), "f");
        } else {
          __classPrivateFieldSet2(this, _OFB_iv, new Uint8Array(16), "f");
        }
        __classPrivateFieldSet2(this, _OFB_lastPrecipher, this.iv, "f");
        __classPrivateFieldSet2(this, _OFB_lastPrecipherIndex, 16, "f");
      }
      get iv() {
        return new Uint8Array(__classPrivateFieldGet4(this, _OFB_iv, "f"));
      }
      encrypt(plaintext) {
        var _a2, _b;
        if (plaintext.length % 16) {
          throw new TypeError("invalid plaintext size (must be multiple of 16 bytes)");
        }
        const ciphertext = new Uint8Array(plaintext);
        for (let i2 = 0; i2 < ciphertext.length; i2++) {
          if (__classPrivateFieldGet4(this, _OFB_lastPrecipherIndex, "f") === 16) {
            __classPrivateFieldSet2(this, _OFB_lastPrecipher, this.aes.encrypt(__classPrivateFieldGet4(this, _OFB_lastPrecipher, "f")), "f");
            __classPrivateFieldSet2(this, _OFB_lastPrecipherIndex, 0, "f");
          }
          ciphertext[i2] ^= __classPrivateFieldGet4(this, _OFB_lastPrecipher, "f")[__classPrivateFieldSet2(this, _OFB_lastPrecipherIndex, (_b = __classPrivateFieldGet4(this, _OFB_lastPrecipherIndex, "f"), _a2 = _b++, _b), "f"), _a2];
        }
        return ciphertext;
      }
      decrypt(ciphertext) {
        if (ciphertext.length % 16) {
          throw new TypeError("invalid ciphertext size (must be multiple of 16 bytes)");
        }
        return this.encrypt(ciphertext);
      }
    };
    exports.OFB = OFB;
    _OFB_iv = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipher = /* @__PURE__ */ new WeakMap(), _OFB_lastPrecipherIndex = /* @__PURE__ */ new WeakMap();
  }
});

// node_modules/aes-js/lib.commonjs/padding.js
var require_padding = __commonJS({
  "node_modules/aes-js/lib.commonjs/padding.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pkcs7Strip = exports.pkcs7Pad = void 0;
    function pkcs7Pad(data) {
      const padder = 16 - data.length % 16;
      const result = new Uint8Array(data.length + padder);
      result.set(data);
      for (let i2 = data.length; i2 < result.length; i2++) {
        result[i2] = padder;
      }
      return result;
    }
    exports.pkcs7Pad = pkcs7Pad;
    function pkcs7Strip(data) {
      if (data.length < 16) {
        throw new TypeError("PKCS#7 invalid length");
      }
      const padder = data[data.length - 1];
      if (padder > 16) {
        throw new TypeError("PKCS#7 padding byte out of range");
      }
      const length2 = data.length - padder;
      for (let i2 = 0; i2 < padder; i2++) {
        if (data[length2 + i2] !== padder) {
          throw new TypeError("PKCS#7 invalid padding byte");
        }
      }
      return new Uint8Array(data.subarray(0, length2));
    }
    exports.pkcs7Strip = pkcs7Strip;
  }
});

// node_modules/aes-js/lib.commonjs/index.js
var require_lib = __commonJS({
  "node_modules/aes-js/lib.commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.pkcs7Strip = exports.pkcs7Pad = exports.OFB = exports.ECB = exports.CTR = exports.CFB = exports.CBC = exports.ModeOfOperation = exports.AES = void 0;
    var aes_js_1 = require_aes();
    Object.defineProperty(exports, "AES", { enumerable: true, get: function() {
      return aes_js_1.AES;
    } });
    var mode_js_1 = require_mode2();
    Object.defineProperty(exports, "ModeOfOperation", { enumerable: true, get: function() {
      return mode_js_1.ModeOfOperation;
    } });
    var mode_cbc_js_1 = require_mode_cbc();
    Object.defineProperty(exports, "CBC", { enumerable: true, get: function() {
      return mode_cbc_js_1.CBC;
    } });
    var mode_cfb_js_1 = require_mode_cfb();
    Object.defineProperty(exports, "CFB", { enumerable: true, get: function() {
      return mode_cfb_js_1.CFB;
    } });
    var mode_ctr_js_1 = require_mode_ctr();
    Object.defineProperty(exports, "CTR", { enumerable: true, get: function() {
      return mode_ctr_js_1.CTR;
    } });
    var mode_ecb_js_1 = require_mode_ecb();
    Object.defineProperty(exports, "ECB", { enumerable: true, get: function() {
      return mode_ecb_js_1.ECB;
    } });
    var mode_ofb_js_1 = require_mode_ofb();
    Object.defineProperty(exports, "OFB", { enumerable: true, get: function() {
      return mode_ofb_js_1.OFB;
    } });
    var padding_js_1 = require_padding();
    Object.defineProperty(exports, "pkcs7Pad", { enumerable: true, get: function() {
      return padding_js_1.pkcs7Pad;
    } });
    Object.defineProperty(exports, "pkcs7Strip", { enumerable: true, get: function() {
      return padding_js_1.pkcs7Strip;
    } });
  }
});

// node_modules/ethers/lib.commonjs/wallet/utils.js
var require_utils8 = __commonJS({
  "node_modules/ethers/lib.commonjs/wallet/utils.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.spelunk = exports.getPassword = exports.zpad = exports.looseArrayify = void 0;
    var index_js_1 = require_utils5();
    function looseArrayify(hexString) {
      if (typeof hexString === "string" && !hexString.startsWith("0x")) {
        hexString = "0x" + hexString;
      }
      return (0, index_js_1.getBytesCopy)(hexString);
    }
    exports.looseArrayify = looseArrayify;
    function zpad(value, length2) {
      value = String(value);
      while (value.length < length2) {
        value = "0" + value;
      }
      return value;
    }
    exports.zpad = zpad;
    function getPassword(password) {
      if (typeof password === "string") {
        return (0, index_js_1.toUtf8Bytes)(password, "NFKC");
      }
      return (0, index_js_1.getBytesCopy)(password);
    }
    exports.getPassword = getPassword;
    function spelunk(object, _path) {
      const match = _path.match(/^([a-z0-9$_.-]*)(:([a-z]+))?(!)?$/i);
      (0, index_js_1.assertArgument)(match != null, "invalid path", "path", _path);
      const path2 = match[1];
      const type6 = match[3];
      const reqd = match[4] === "!";
      let cur = object;
      for (const comp of path2.toLowerCase().split(".")) {
        if (Array.isArray(cur)) {
          if (!comp.match(/^[0-9]+$/)) {
            break;
          }
          cur = cur[parseInt(comp)];
        } else if (typeof cur === "object") {
          let found = null;
          for (const key in cur) {
            if (key.toLowerCase() === comp) {
              found = cur[key];
              break;
            }
          }
          cur = found;
        } else {
          cur = null;
        }
        if (cur == null) {
          break;
        }
      }
      (0, index_js_1.assertArgument)(!reqd || cur != null, "missing required value", "path", path2);
      if (type6 && cur != null) {
        if (type6 === "int") {
          if (typeof cur === "string" && cur.match(/^-?[0-9]+$/)) {
            return parseInt(cur);
          } else if (Number.isSafeInteger(cur)) {
            return cur;
          }
        }
        if (type6 === "number") {
          if (typeof cur === "string" && cur.match(/^-?[0-9.]*$/)) {
            return parseFloat(cur);
          }
        }
        if (type6 === "data") {
          if (typeof cur === "string") {
            return looseArrayify(cur);
          }
        }
        if (type6 === "array" && Array.isArray(cur)) {
          return cur;
        }
        if (type6 === typeof cur) {
          return cur;
        }
        (0, index_js_1.assertArgument)(false, `wrong type found for ${type6} `, "path", path2);
      }
      return cur;
    }
    exports.spelunk = spelunk;
  }
});

// node_modules/ethers/lib.commonjs/wallet/json-keystore.js
var require_json_keystore = __commonJS({
  "node_modules/ethers/lib.commonjs/wallet/json-keystore.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.encryptKeystoreJson = exports.encryptKeystoreJsonSync = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = void 0;
    var aes_js_1 = require_lib();
    var index_js_1 = require_address2();
    var index_js_2 = require_crypto2();
    var index_js_3 = require_transaction2();
    var index_js_4 = require_utils5();
    var utils_js_1 = require_utils8();
    var _version_js_1 = require_version2();
    var defaultPath = "m/44'/60'/0'/0/0";
    function isKeystoreJson(json) {
      try {
        const data = JSON.parse(json);
        const version7 = data.version != null ? parseInt(data.version) : 0;
        if (version7 === 3) {
          return true;
        }
      } catch (error) {
      }
      return false;
    }
    exports.isKeystoreJson = isKeystoreJson;
    function decrypt2(data, key, ciphertext) {
      const cipher = (0, utils_js_1.spelunk)(data, "crypto.cipher:string");
      if (cipher === "aes-128-ctr") {
        const iv = (0, utils_js_1.spelunk)(data, "crypto.cipherparams.iv:data!");
        const aesCtr = new aes_js_1.CTR(key, iv);
        return (0, index_js_4.hexlify)(aesCtr.decrypt(ciphertext));
      }
      (0, index_js_4.assert)(false, "unsupported cipher", "UNSUPPORTED_OPERATION", {
        operation: "decrypt"
      });
    }
    function getAccount2(data, _key) {
      const key = (0, index_js_4.getBytes)(_key);
      const ciphertext = (0, utils_js_1.spelunk)(data, "crypto.ciphertext:data!");
      const computedMAC = (0, index_js_4.hexlify)((0, index_js_2.keccak256)((0, index_js_4.concat)([key.slice(16, 32), ciphertext]))).substring(2);
      (0, index_js_4.assertArgument)(computedMAC === (0, utils_js_1.spelunk)(data, "crypto.mac:string!").toLowerCase(), "incorrect password", "password", "[ REDACTED ]");
      const privateKey = decrypt2(data, key.slice(0, 16), ciphertext);
      const address = (0, index_js_3.computeAddress)(privateKey);
      if (data.address) {
        let check = data.address.toLowerCase();
        if (!check.startsWith("0x")) {
          check = "0x" + check;
        }
        (0, index_js_4.assertArgument)((0, index_js_1.getAddress)(check) === address, "keystore address/privateKey mismatch", "address", data.address);
      }
      const account = { address, privateKey };
      const version7 = (0, utils_js_1.spelunk)(data, "x-ethers.version:string");
      if (version7 === "0.1") {
        const mnemonicKey = key.slice(32, 64);
        const mnemonicCiphertext = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCiphertext:data!");
        const mnemonicIv = (0, utils_js_1.spelunk)(data, "x-ethers.mnemonicCounter:data!");
        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
        account.mnemonic = {
          path: (0, utils_js_1.spelunk)(data, "x-ethers.path:string") || defaultPath,
          locale: (0, utils_js_1.spelunk)(data, "x-ethers.locale:string") || "en",
          entropy: (0, index_js_4.hexlify)((0, index_js_4.getBytes)(mnemonicAesCtr.decrypt(mnemonicCiphertext)))
        };
      }
      return account;
    }
    function getDecryptKdfParams(data) {
      const kdf = (0, utils_js_1.spelunk)(data, "crypto.kdf:string");
      if (kdf && typeof kdf === "string") {
        if (kdf.toLowerCase() === "scrypt") {
          const salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
          const N2 = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.n:int!");
          const r2 = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.r:int!");
          const p2 = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.p:int!");
          (0, index_js_4.assertArgument)(N2 > 0 && (N2 & N2 - 1) === 0, "invalid kdf.N", "kdf.N", N2);
          (0, index_js_4.assertArgument)(r2 > 0 && p2 > 0, "invalid kdf", "kdf", kdf);
          const dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
          (0, index_js_4.assertArgument)(dkLen === 32, "invalid kdf.dklen", "kdf.dflen", dkLen);
          return { name: "scrypt", salt, N: N2, r: r2, p: p2, dkLen: 64 };
        } else if (kdf.toLowerCase() === "pbkdf2") {
          const salt = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.salt:data!");
          const prf = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.prf:string!");
          const algorithm = prf.split("-").pop();
          (0, index_js_4.assertArgument)(algorithm === "sha256" || algorithm === "sha512", "invalid kdf.pdf", "kdf.pdf", prf);
          const count = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.c:int!");
          const dkLen = (0, utils_js_1.spelunk)(data, "crypto.kdfparams.dklen:int!");
          (0, index_js_4.assertArgument)(dkLen === 32, "invalid kdf.dklen", "kdf.dklen", dkLen);
          return { name: "pbkdf2", salt, count, dkLen, algorithm };
        }
      }
      (0, index_js_4.assertArgument)(false, "unsupported key-derivation function", "kdf", kdf);
    }
    function decryptKeystoreJsonSync(json, _password) {
      const data = JSON.parse(json);
      const password = (0, utils_js_1.getPassword)(_password);
      const params = getDecryptKdfParams(data);
      if (params.name === "pbkdf2") {
        const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
        const key2 = (0, index_js_2.pbkdf2)(password, salt2, count, dkLen2, algorithm);
        return getAccount2(data, key2);
      }
      (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
      const { salt, N: N2, r: r2, p: p2, dkLen } = params;
      const key = (0, index_js_2.scryptSync)(password, salt, N2, r2, p2, dkLen);
      return getAccount2(data, key);
    }
    exports.decryptKeystoreJsonSync = decryptKeystoreJsonSync;
    function stall(duration) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve();
        }, duration);
      });
    }
    async function decryptKeystoreJson(json, _password, progress3) {
      const data = JSON.parse(json);
      const password = (0, utils_js_1.getPassword)(_password);
      const params = getDecryptKdfParams(data);
      if (params.name === "pbkdf2") {
        if (progress3) {
          progress3(0);
          await stall(0);
        }
        const { salt: salt2, count, dkLen: dkLen2, algorithm } = params;
        const key2 = (0, index_js_2.pbkdf2)(password, salt2, count, dkLen2, algorithm);
        if (progress3) {
          progress3(1);
          await stall(0);
        }
        return getAccount2(data, key2);
      }
      (0, index_js_4.assert)(params.name === "scrypt", "cannot be reached", "UNKNOWN_ERROR", { params });
      const { salt, N: N2, r: r2, p: p2, dkLen } = params;
      const key = await (0, index_js_2.scrypt)(password, salt, N2, r2, p2, dkLen, progress3);
      return getAccount2(data, key);
    }
    exports.decryptKeystoreJson = decryptKeystoreJson;
    function getEncryptKdfParams(options) {
      const salt = options.salt != null ? (0, index_js_4.getBytes)(options.salt, "options.salt") : (0, index_js_2.randomBytes)(32);
      let N2 = 1 << 17, r2 = 8, p2 = 1;
      if (options.scrypt) {
        if (options.scrypt.N) {
          N2 = options.scrypt.N;
        }
        if (options.scrypt.r) {
          r2 = options.scrypt.r;
        }
        if (options.scrypt.p) {
          p2 = options.scrypt.p;
        }
      }
      (0, index_js_4.assertArgument)(typeof N2 === "number" && N2 > 0 && Number.isSafeInteger(N2) && (BigInt(N2) & BigInt(N2 - 1)) === BigInt(0), "invalid scrypt N parameter", "options.N", N2);
      (0, index_js_4.assertArgument)(typeof r2 === "number" && r2 > 0 && Number.isSafeInteger(r2), "invalid scrypt r parameter", "options.r", r2);
      (0, index_js_4.assertArgument)(typeof p2 === "number" && p2 > 0 && Number.isSafeInteger(p2), "invalid scrypt p parameter", "options.p", p2);
      return { name: "scrypt", dkLen: 32, salt, N: N2, r: r2, p: p2 };
    }
    function _encryptKeystore(key, kdf, account, options) {
      const privateKey = (0, index_js_4.getBytes)(account.privateKey, "privateKey");
      const iv = options.iv != null ? (0, index_js_4.getBytes)(options.iv, "options.iv") : (0, index_js_2.randomBytes)(16);
      (0, index_js_4.assertArgument)(iv.length === 16, "invalid options.iv length", "options.iv", options.iv);
      const uuidRandom = options.uuid != null ? (0, index_js_4.getBytes)(options.uuid, "options.uuid") : (0, index_js_2.randomBytes)(16);
      (0, index_js_4.assertArgument)(uuidRandom.length === 16, "invalid options.uuid length", "options.uuid", options.iv);
      const derivedKey = key.slice(0, 16);
      const macPrefix = key.slice(16, 32);
      const aesCtr = new aes_js_1.CTR(derivedKey, iv);
      const ciphertext = (0, index_js_4.getBytes)(aesCtr.encrypt(privateKey));
      const mac = (0, index_js_2.keccak256)((0, index_js_4.concat)([macPrefix, ciphertext]));
      const data = {
        address: account.address.substring(2).toLowerCase(),
        id: (0, index_js_4.uuidV4)(uuidRandom),
        version: 3,
        Crypto: {
          cipher: "aes-128-ctr",
          cipherparams: {
            iv: (0, index_js_4.hexlify)(iv).substring(2)
          },
          ciphertext: (0, index_js_4.hexlify)(ciphertext).substring(2),
          kdf: "scrypt",
          kdfparams: {
            salt: (0, index_js_4.hexlify)(kdf.salt).substring(2),
            n: kdf.N,
            dklen: 32,
            p: kdf.p,
            r: kdf.r
          },
          mac: mac.substring(2)
        }
      };
      if (account.mnemonic) {
        const client = options.client != null ? options.client : `ethers/${_version_js_1.version}`;
        const path2 = account.mnemonic.path || defaultPath;
        const locale = account.mnemonic.locale || "en";
        const mnemonicKey = key.slice(32, 64);
        const entropy = (0, index_js_4.getBytes)(account.mnemonic.entropy, "account.mnemonic.entropy");
        const mnemonicIv = (0, index_js_2.randomBytes)(16);
        const mnemonicAesCtr = new aes_js_1.CTR(mnemonicKey, mnemonicIv);
        const mnemonicCiphertext = (0, index_js_4.getBytes)(mnemonicAesCtr.encrypt(entropy));
        const now = /* @__PURE__ */ new Date();
        const timestamp = now.getUTCFullYear() + "-" + (0, utils_js_1.zpad)(now.getUTCMonth() + 1, 2) + "-" + (0, utils_js_1.zpad)(now.getUTCDate(), 2) + "T" + (0, utils_js_1.zpad)(now.getUTCHours(), 2) + "-" + (0, utils_js_1.zpad)(now.getUTCMinutes(), 2) + "-" + (0, utils_js_1.zpad)(now.getUTCSeconds(), 2) + ".0Z";
        const gethFilename = "UTC--" + timestamp + "--" + data.address;
        data["x-ethers"] = {
          client,
          gethFilename,
          path: path2,
          locale,
          mnemonicCounter: (0, index_js_4.hexlify)(mnemonicIv).substring(2),
          mnemonicCiphertext: (0, index_js_4.hexlify)(mnemonicCiphertext).substring(2),
          version: "0.1"
        };
      }
      return JSON.stringify(data);
    }
    function encryptKeystoreJsonSync(account, password, options) {
      if (options == null) {
        options = {};
      }
      const passwordBytes = (0, utils_js_1.getPassword)(password);
      const kdf = getEncryptKdfParams(options);
      const key = (0, index_js_2.scryptSync)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64);
      return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);
    }
    exports.encryptKeystoreJsonSync = encryptKeystoreJsonSync;
    async function encryptKeystoreJson(account, password, options) {
      if (options == null) {
        options = {};
      }
      const passwordBytes = (0, utils_js_1.getPassword)(password);
      const kdf = getEncryptKdfParams(options);
      const key = await (0, index_js_2.scrypt)(passwordBytes, kdf.salt, kdf.N, kdf.r, kdf.p, 64, options.progressCallback);
      return _encryptKeystore((0, index_js_4.getBytes)(key), kdf, account, options);
    }
    exports.encryptKeystoreJson = encryptKeystoreJson;
  }
});

// node_modules/ethers/lib.commonjs/wallet/hdwallet.js
var require_hdwallet = __commonJS({
  "node_modules/ethers/lib.commonjs/wallet/hdwallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getIndexedAccountPath = exports.getAccountPath = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.defaultPath = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_providers();
    var index_js_3 = require_transaction2();
    var index_js_4 = require_utils5();
    var lang_en_js_1 = require_lang_en();
    var base_wallet_js_1 = require_base_wallet();
    var mnemonic_js_1 = require_mnemonic();
    var json_keystore_js_1 = require_json_keystore();
    exports.defaultPath = "m/44'/60'/0'/0/0";
    var MasterSecret = new Uint8Array([66, 105, 116, 99, 111, 105, 110, 32, 115, 101, 101, 100]);
    var HardenedBit = 2147483648;
    var N2 = BigInt("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
    var Nibbles = "0123456789abcdef";
    function zpad(value, length2) {
      let result = "";
      while (value) {
        result = Nibbles[value % 16] + result;
        value = Math.trunc(value / 16);
      }
      while (result.length < length2 * 2) {
        result = "0" + result;
      }
      return "0x" + result;
    }
    function encodeBase58Check(_value) {
      const value = (0, index_js_4.getBytes)(_value);
      const check = (0, index_js_4.dataSlice)((0, index_js_1.sha256)((0, index_js_1.sha256)(value)), 0, 4);
      const bytes = (0, index_js_4.concat)([value, check]);
      return (0, index_js_4.encodeBase58)(bytes);
    }
    var _guard = {};
    function ser_I(index5, chainCode, publicKey, privateKey) {
      const data = new Uint8Array(37);
      if (index5 & HardenedBit) {
        (0, index_js_4.assert)(privateKey != null, "cannot derive child of neutered node", "UNSUPPORTED_OPERATION", {
          operation: "deriveChild"
        });
        data.set((0, index_js_4.getBytes)(privateKey), 1);
      } else {
        data.set((0, index_js_4.getBytes)(publicKey));
      }
      for (let i2 = 24; i2 >= 0; i2 -= 8) {
        data[33 + (i2 >> 3)] = index5 >> 24 - i2 & 255;
      }
      const I3 = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", chainCode, data));
      return { IL: I3.slice(0, 32), IR: I3.slice(32) };
    }
    function derivePath(node, path2) {
      const components = path2.split("/");
      (0, index_js_4.assertArgument)(components.length > 0, "invalid path", "path", path2);
      if (components[0] === "m") {
        (0, index_js_4.assertArgument)(node.depth === 0, `cannot derive root path (i.e. path starting with "m/") for a node at non-zero depth ${node.depth}`, "path", path2);
        components.shift();
      }
      let result = node;
      for (let i2 = 0; i2 < components.length; i2++) {
        const component = components[i2];
        if (component.match(/^[0-9]+'$/)) {
          const index5 = parseInt(component.substring(0, component.length - 1));
          (0, index_js_4.assertArgument)(index5 < HardenedBit, "invalid path index", `path[${i2}]`, component);
          result = result.deriveChild(HardenedBit + index5);
        } else if (component.match(/^[0-9]+$/)) {
          const index5 = parseInt(component);
          (0, index_js_4.assertArgument)(index5 < HardenedBit, "invalid path index", `path[${i2}]`, component);
          result = result.deriveChild(index5);
        } else {
          (0, index_js_4.assertArgument)(false, "invalid path component", `path[${i2}]`, component);
        }
      }
      return result;
    }
    var _HDNodeWallet_instances, account_fn, _HDNodeWallet_static, fromSeed_fn;
    var _HDNodeWallet = class _HDNodeWallet extends base_wallet_js_1.BaseWallet {
      /**
       *  @private
       */
      constructor(guard, signingKey, parentFingerprint, chainCode, path2, index5, depth, mnemonic, provider) {
        super(signingKey, provider);
        __privateAdd(this, _HDNodeWallet_instances);
        /**
         *  The compressed public key.
         */
        __publicField(this, "publicKey");
        /**
         *  The fingerprint.
         *
         *  A fingerprint allows quick qay to detect parent and child nodes,
         *  but developers should be prepared to deal with collisions as it
         *  is only 4 bytes.
         */
        __publicField(this, "fingerprint");
        /**
         *  The parent fingerprint.
         */
        __publicField(this, "parentFingerprint");
        /**
         *  The mnemonic used to create this HD Node, if available.
         *
         *  Sources such as extended keys do not encode the mnemonic, in
         *  which case this will be ``null``.
         */
        __publicField(this, "mnemonic");
        /**
         *  The chaincode, which is effectively a public key used
         *  to derive children.
         */
        __publicField(this, "chainCode");
        /**
         *  The derivation path of this wallet.
         *
         *  Since extended keys do not provide full path details, this
         *  may be ``null``, if instantiated from a source that does not
         *  encode it.
         */
        __publicField(this, "path");
        /**
         *  The child index of this wallet. Values over ``2 *\* 31`` indicate
         *  the node is hardened.
         */
        __publicField(this, "index");
        /**
         *  The depth of this wallet, which is the number of components
         *  in its path.
         */
        __publicField(this, "depth");
        (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeWallet");
        (0, index_js_4.defineProperties)(this, { publicKey: signingKey.compressedPublicKey });
        const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(this.publicKey)), 0, 4);
        (0, index_js_4.defineProperties)(this, {
          parentFingerprint,
          fingerprint,
          chainCode,
          path: path2,
          index: index5,
          depth
        });
        (0, index_js_4.defineProperties)(this, { mnemonic });
      }
      connect(provider) {
        return new _HDNodeWallet(_guard, this.signingKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.mnemonic, provider);
      }
      /**
       *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
       *  %%password%%.
       *
       *  If %%progressCallback%% is specified, it will receive periodic
       *  updates as the encryption process progreses.
       */
      async encrypt(password, progressCallback) {
        return await (0, json_keystore_js_1.encryptKeystoreJson)(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password, { progressCallback });
      }
      /**
       *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
       *  %%password%%.
       *
       *  It is preferred to use the [async version](encrypt) instead,
       *  which allows a [[ProgressCallback]] to keep the user informed.
       *
       *  This method will block the event loop (freezing all UI) until
       *  it is complete, which may be a non-trivial duration.
       */
      encryptSync(password) {
        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(__privateMethod(this, _HDNodeWallet_instances, account_fn).call(this), password);
      }
      /**
       *  The extended key.
       *
       *  This key will begin with the prefix ``xpriv`` and can be used to
       *  reconstruct this HD Node to derive its children.
       */
      get extendedKey() {
        (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
        return encodeBase58Check((0, index_js_4.concat)([
          "0x0488ADE4",
          zpad(this.depth, 1),
          this.parentFingerprint,
          zpad(this.index, 4),
          this.chainCode,
          (0, index_js_4.concat)(["0x00", this.privateKey])
        ]));
      }
      /**
       *  Returns true if this wallet has a path, providing a Type Guard
       *  that the path is non-null.
       */
      hasPath() {
        return this.path != null;
      }
      /**
       *  Returns a neutered HD Node, which removes the private details
       *  of an HD Node.
       *
       *  A neutered node has no private key, but can be used to derive
       *  child addresses and other public data about the HD Node.
       */
      neuter() {
        return new HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, this.provider);
      }
      /**
       *  Return the child for %%index%%.
       */
      deriveChild(_index) {
        const index5 = (0, index_js_4.getNumber)(_index, "index");
        (0, index_js_4.assertArgument)(index5 <= 4294967295, "invalid index", "index", index5);
        let path2 = this.path;
        if (path2) {
          path2 += "/" + (index5 & ~HardenedBit);
          if (index5 & HardenedBit) {
            path2 += "'";
          }
        }
        const { IR, IL } = ser_I(index5, this.chainCode, this.publicKey, this.privateKey);
        const ki2 = new index_js_1.SigningKey((0, index_js_4.toBeHex)(((0, index_js_4.toBigInt)(IL) + BigInt(this.privateKey)) % N2, 32));
        return new _HDNodeWallet(_guard, ki2, this.fingerprint, (0, index_js_4.hexlify)(IR), path2, index5, this.depth + 1, this.mnemonic, this.provider);
      }
      /**
       *  Return the HDNode for %%path%% from this node.
       */
      derivePath(path2) {
        return derivePath(this, path2);
      }
      /**
       *  Creates a new HD Node from %%extendedKey%%.
       *
       *  If the %%extendedKey%% will either have a prefix or ``xpub`` or
       *  ``xpriv``, returning a neutered HD Node ([[HDNodeVoidWallet]])
       *  or full HD Node ([[HDNodeWallet) respectively.
       */
      static fromExtendedKey(extendedKey) {
        const bytes = (0, index_js_4.toBeArray)((0, index_js_4.decodeBase58)(extendedKey));
        (0, index_js_4.assertArgument)(bytes.length === 82 || encodeBase58Check(bytes.slice(0, 78)) === extendedKey, "invalid extended key", "extendedKey", "[ REDACTED ]");
        const depth = bytes[4];
        const parentFingerprint = (0, index_js_4.hexlify)(bytes.slice(5, 9));
        const index5 = parseInt((0, index_js_4.hexlify)(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = (0, index_js_4.hexlify)(bytes.slice(13, 45));
        const key = bytes.slice(45, 78);
        switch ((0, index_js_4.hexlify)(bytes.slice(0, 4))) {
          case "0x0488b21e":
          case "0x043587cf": {
            const publicKey = (0, index_js_4.hexlify)(key);
            return new HDNodeVoidWallet(_guard, (0, index_js_3.computeAddress)(publicKey), publicKey, parentFingerprint, chainCode, null, index5, depth, null);
          }
          case "0x0488ade4":
          case "0x04358394 ":
            if (key[0] !== 0) {
              break;
            }
            return new _HDNodeWallet(_guard, new index_js_1.SigningKey(key.slice(1)), parentFingerprint, chainCode, null, index5, depth, null, null);
        }
        (0, index_js_4.assertArgument)(false, "invalid extended key prefix", "extendedKey", "[ REDACTED ]");
      }
      /**
       *  Creates a new random HDNode.
       */
      static createRandom(password, path2, wordlist11) {
        var _a2;
        if (password == null) {
          password = "";
        }
        if (path2 == null) {
          path2 = exports.defaultPath;
        }
        if (wordlist11 == null) {
          wordlist11 = lang_en_js_1.LangEn.wordlist();
        }
        const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy((0, index_js_1.randomBytes)(16), password, wordlist11);
        return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path2);
      }
      /**
       *  Create an HD Node from %%mnemonic%%.
       */
      static fromMnemonic(mnemonic, path2) {
        var _a2;
        if (!path2) {
          path2 = exports.defaultPath;
        }
        return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path2);
      }
      /**
       *  Creates an HD Node from a mnemonic %%phrase%%.
       */
      static fromPhrase(phrase, password, path2, wordlist11) {
        var _a2;
        if (password == null) {
          password = "";
        }
        if (path2 == null) {
          path2 = exports.defaultPath;
        }
        if (wordlist11 == null) {
          wordlist11 = lang_en_js_1.LangEn.wordlist();
        }
        const mnemonic = mnemonic_js_1.Mnemonic.fromPhrase(phrase, password, wordlist11);
        return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, mnemonic.computeSeed(), mnemonic).derivePath(path2);
      }
      /**
       *  Creates an HD Node from a %%seed%%.
       */
      static fromSeed(seed) {
        var _a2;
        return __privateMethod(_a2 = _HDNodeWallet, _HDNodeWallet_static, fromSeed_fn).call(_a2, seed, null);
      }
    };
    _HDNodeWallet_instances = new WeakSet();
    account_fn = function() {
      const account = { address: this.address, privateKey: this.privateKey };
      const m3 = this.mnemonic;
      if (this.path && m3 && m3.wordlist.locale === "en" && m3.password === "") {
        account.mnemonic = {
          path: this.path,
          locale: "en",
          entropy: m3.entropy
        };
      }
      return account;
    };
    _HDNodeWallet_static = new WeakSet();
    fromSeed_fn = function(_seed, mnemonic) {
      (0, index_js_4.assertArgument)((0, index_js_4.isBytesLike)(_seed), "invalid seed", "seed", "[REDACTED]");
      const seed = (0, index_js_4.getBytes)(_seed, "seed");
      (0, index_js_4.assertArgument)(seed.length >= 16 && seed.length <= 64, "invalid seed", "seed", "[REDACTED]");
      const I3 = (0, index_js_4.getBytes)((0, index_js_1.computeHmac)("sha512", MasterSecret, seed));
      const signingKey = new index_js_1.SigningKey((0, index_js_4.hexlify)(I3.slice(0, 32)));
      return new _HDNodeWallet(_guard, signingKey, "0x00000000", (0, index_js_4.hexlify)(I3.slice(32)), "m", 0, 0, mnemonic, null);
    };
    __privateAdd(_HDNodeWallet, _HDNodeWallet_static);
    var HDNodeWallet = _HDNodeWallet;
    exports.HDNodeWallet = HDNodeWallet;
    var HDNodeVoidWallet = class _HDNodeVoidWallet extends index_js_2.VoidSigner {
      /**
       *  @private
       */
      constructor(guard, address, publicKey, parentFingerprint, chainCode, path2, index5, depth, provider) {
        super(address, provider);
        /**
         *  The compressed public key.
         */
        __publicField(this, "publicKey");
        /**
         *  The fingerprint.
         *
         *  A fingerprint allows quick qay to detect parent and child nodes,
         *  but developers should be prepared to deal with collisions as it
         *  is only 4 bytes.
         */
        __publicField(this, "fingerprint");
        /**
         *  The parent node fingerprint.
         */
        __publicField(this, "parentFingerprint");
        /**
         *  The chaincode, which is effectively a public key used
         *  to derive children.
         */
        __publicField(this, "chainCode");
        /**
         *  The derivation path of this wallet.
         *
         *  Since extended keys do not provider full path details, this
         *  may be ``null``, if instantiated from a source that does not
         *  enocde it.
         */
        __publicField(this, "path");
        /**
         *  The child index of this wallet. Values over ``2 *\* 31`` indicate
         *  the node is hardened.
         */
        __publicField(this, "index");
        /**
         *  The depth of this wallet, which is the number of components
         *  in its path.
         */
        __publicField(this, "depth");
        (0, index_js_4.assertPrivate)(guard, _guard, "HDNodeVoidWallet");
        (0, index_js_4.defineProperties)(this, { publicKey });
        const fingerprint = (0, index_js_4.dataSlice)((0, index_js_1.ripemd160)((0, index_js_1.sha256)(publicKey)), 0, 4);
        (0, index_js_4.defineProperties)(this, {
          publicKey,
          fingerprint,
          parentFingerprint,
          chainCode,
          path: path2,
          index: index5,
          depth
        });
      }
      connect(provider) {
        return new _HDNodeVoidWallet(_guard, this.address, this.publicKey, this.parentFingerprint, this.chainCode, this.path, this.index, this.depth, provider);
      }
      /**
       *  The extended key.
       *
       *  This key will begin with the prefix ``xpub`` and can be used to
       *  reconstruct this neutered key to derive its children addresses.
       */
      get extendedKey() {
        (0, index_js_4.assert)(this.depth < 256, "Depth too deep", "UNSUPPORTED_OPERATION", { operation: "extendedKey" });
        return encodeBase58Check((0, index_js_4.concat)([
          "0x0488B21E",
          zpad(this.depth, 1),
          this.parentFingerprint,
          zpad(this.index, 4),
          this.chainCode,
          this.publicKey
        ]));
      }
      /**
       *  Returns true if this wallet has a path, providing a Type Guard
       *  that the path is non-null.
       */
      hasPath() {
        return this.path != null;
      }
      /**
       *  Return the child for %%index%%.
       */
      deriveChild(_index) {
        const index5 = (0, index_js_4.getNumber)(_index, "index");
        (0, index_js_4.assertArgument)(index5 <= 4294967295, "invalid index", "index", index5);
        let path2 = this.path;
        if (path2) {
          path2 += "/" + (index5 & ~HardenedBit);
          if (index5 & HardenedBit) {
            path2 += "'";
          }
        }
        const { IR, IL } = ser_I(index5, this.chainCode, this.publicKey, null);
        const Ki2 = index_js_1.SigningKey.addPoints(IL, this.publicKey, true);
        const address = (0, index_js_3.computeAddress)(Ki2);
        return new _HDNodeVoidWallet(_guard, address, Ki2, this.fingerprint, (0, index_js_4.hexlify)(IR), path2, index5, this.depth + 1, this.provider);
      }
      /**
       *  Return the signer for %%path%% from this node.
       */
      derivePath(path2) {
        return derivePath(this, path2);
      }
    };
    exports.HDNodeVoidWallet = HDNodeVoidWallet;
    function getAccountPath(_index) {
      const index5 = (0, index_js_4.getNumber)(_index, "index");
      (0, index_js_4.assertArgument)(index5 >= 0 && index5 < HardenedBit, "invalid account index", "index", index5);
      return `m/44'/60'/${index5}'/0/0`;
    }
    exports.getAccountPath = getAccountPath;
    function getIndexedAccountPath(_index) {
      const index5 = (0, index_js_4.getNumber)(_index, "index");
      (0, index_js_4.assertArgument)(index5 >= 0 && index5 < HardenedBit, "invalid account index", "index", index5);
      return `m/44'/60'/0'/0/${index5}`;
    }
    exports.getIndexedAccountPath = getIndexedAccountPath;
  }
});

// node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js
var require_json_crowdsale = __commonJS({
  "node_modules/ethers/lib.commonjs/wallet/json-crowdsale.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = void 0;
    var aes_js_1 = require_lib();
    var index_js_1 = require_address2();
    var index_js_2 = require_crypto2();
    var index_js_3 = require_hash();
    var index_js_4 = require_utils5();
    var utils_js_1 = require_utils8();
    function isCrowdsaleJson(json) {
      try {
        const data = JSON.parse(json);
        if (data.encseed) {
          return true;
        }
      } catch (error) {
      }
      return false;
    }
    exports.isCrowdsaleJson = isCrowdsaleJson;
    function decryptCrowdsaleJson(json, _password) {
      const data = JSON.parse(json);
      const password = (0, utils_js_1.getPassword)(_password);
      const address = (0, index_js_1.getAddress)((0, utils_js_1.spelunk)(data, "ethaddr:string!"));
      const encseed = (0, utils_js_1.looseArrayify)((0, utils_js_1.spelunk)(data, "encseed:string!"));
      (0, index_js_4.assertArgument)(encseed && encseed.length % 16 === 0, "invalid encseed", "json", json);
      const key = (0, index_js_4.getBytes)((0, index_js_2.pbkdf2)(password, password, 2e3, 32, "sha256")).slice(0, 16);
      const iv = encseed.slice(0, 16);
      const encryptedSeed = encseed.slice(16);
      const aesCbc = new aes_js_1.CBC(key, iv);
      const seed = (0, aes_js_1.pkcs7Strip)((0, index_js_4.getBytes)(aesCbc.decrypt(encryptedSeed)));
      let seedHex = "";
      for (let i2 = 0; i2 < seed.length; i2++) {
        seedHex += String.fromCharCode(seed[i2]);
      }
      return { address, privateKey: (0, index_js_3.id)(seedHex) };
    }
    exports.decryptCrowdsaleJson = decryptCrowdsaleJson;
  }
});

// node_modules/ethers/lib.commonjs/wallet/wallet.js
var require_wallet = __commonJS({
  "node_modules/ethers/lib.commonjs/wallet/wallet.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wallet = void 0;
    var index_js_1 = require_crypto2();
    var index_js_2 = require_utils5();
    var base_wallet_js_1 = require_base_wallet();
    var hdwallet_js_1 = require_hdwallet();
    var json_crowdsale_js_1 = require_json_crowdsale();
    var json_keystore_js_1 = require_json_keystore();
    var mnemonic_js_1 = require_mnemonic();
    function stall(duration) {
      return new Promise((resolve) => {
        setTimeout(() => {
          resolve();
        }, duration);
      });
    }
    var _Wallet_static, fromAccount_fn;
    var _Wallet = class _Wallet extends base_wallet_js_1.BaseWallet {
      /**
       *  Create a new wallet for the private %%key%%, optionally connected
       *  to %%provider%%.
       */
      constructor(key, provider) {
        if (typeof key === "string" && !key.startsWith("0x")) {
          key = "0x" + key;
        }
        let signingKey = typeof key === "string" ? new index_js_1.SigningKey(key) : key;
        super(signingKey, provider);
      }
      connect(provider) {
        return new _Wallet(this.signingKey, provider);
      }
      /**
       *  Resolves to a [JSON Keystore Wallet](json-wallets) encrypted with
       *  %%password%%.
       *
       *  If %%progressCallback%% is specified, it will receive periodic
       *  updates as the encryption process progreses.
       */
      async encrypt(password, progressCallback) {
        const account = { address: this.address, privateKey: this.privateKey };
        return await (0, json_keystore_js_1.encryptKeystoreJson)(account, password, { progressCallback });
      }
      /**
       *  Returns a [JSON Keystore Wallet](json-wallets) encryped with
       *  %%password%%.
       *
       *  It is preferred to use the [async version](encrypt) instead,
       *  which allows a [[ProgressCallback]] to keep the user informed.
       *
       *  This method will block the event loop (freezing all UI) until
       *  it is complete, which may be a non-trivial duration.
       */
      encryptSync(password) {
        const account = { address: this.address, privateKey: this.privateKey };
        return (0, json_keystore_js_1.encryptKeystoreJsonSync)(account, password);
      }
      /**
       *  Creates (asynchronously) a **Wallet** by decrypting the %%json%%
       *  with %%password%%.
       *
       *  If %%progress%% is provided, it is called periodically during
       *  decryption so that any UI can be updated.
       */
      static async fromEncryptedJson(json, password, progress3) {
        var _a2;
        let account = null;
        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {
          account = await (0, json_keystore_js_1.decryptKeystoreJson)(json, password, progress3);
        } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
          if (progress3) {
            progress3(0);
            await stall(0);
          }
          account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
          if (progress3) {
            progress3(1);
            await stall(0);
          }
        }
        return __privateMethod(_a2 = _Wallet, _Wallet_static, fromAccount_fn).call(_a2, account);
      }
      /**
       *  Creates a **Wallet** by decrypting the %%json%% with %%password%%.
       *
       *  The [[fromEncryptedJson]] method is preferred, as this method
       *  will lock up and freeze the UI during decryption, which may take
       *  some time.
       */
      static fromEncryptedJsonSync(json, password) {
        var _a2;
        let account = null;
        if ((0, json_keystore_js_1.isKeystoreJson)(json)) {
          account = (0, json_keystore_js_1.decryptKeystoreJsonSync)(json, password);
        } else if ((0, json_crowdsale_js_1.isCrowdsaleJson)(json)) {
          account = (0, json_crowdsale_js_1.decryptCrowdsaleJson)(json, password);
        } else {
          (0, index_js_2.assertArgument)(false, "invalid JSON wallet", "json", "[ REDACTED ]");
        }
        return __privateMethod(_a2 = _Wallet, _Wallet_static, fromAccount_fn).call(_a2, account);
      }
      /**
       *  Creates a new random [[HDNodeWallet]] using the available
       *  [cryptographic random source](randomBytes).
       *
       *  If there is no crytographic random source, this will throw.
       */
      static createRandom(provider) {
        const wallet = hdwallet_js_1.HDNodeWallet.createRandom();
        if (provider) {
          return wallet.connect(provider);
        }
        return wallet;
      }
      /**
       *  Creates a [[HDNodeWallet]] for %%phrase%%.
       */
      static fromPhrase(phrase, provider) {
        const wallet = hdwallet_js_1.HDNodeWallet.fromPhrase(phrase);
        if (provider) {
          return wallet.connect(provider);
        }
        return wallet;
      }
    };
    _Wallet_static = new WeakSet();
    fromAccount_fn = function(account) {
      (0, index_js_2.assertArgument)(account, "invalid JSON wallet", "json", "[ REDACTED ]");
      if ("mnemonic" in account && account.mnemonic && account.mnemonic.locale === "en") {
        const mnemonic = mnemonic_js_1.Mnemonic.fromEntropy(account.mnemonic.entropy);
        const wallet2 = hdwallet_js_1.HDNodeWallet.fromMnemonic(mnemonic, account.mnemonic.path);
        if (wallet2.address === account.address && wallet2.privateKey === account.privateKey) {
          return wallet2;
        }
        console.log("WARNING: JSON mismatch address/privateKey != mnemonic; fallback onto private key");
      }
      const wallet = new _Wallet(account.privateKey);
      (0, index_js_2.assertArgument)(wallet.address === account.address, "address/privateKey mismatch", "json", "[ REDACTED ]");
      return wallet;
    };
    __privateAdd(_Wallet, _Wallet_static);
    var Wallet2 = _Wallet;
    exports.Wallet = Wallet2;
  }
});

// node_modules/ethers/lib.commonjs/wallet/index.js
var require_wallet2 = __commonJS({
  "node_modules/ethers/lib.commonjs/wallet/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Wallet = exports.Mnemonic = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.isKeystoreJson = exports.decryptCrowdsaleJson = exports.isCrowdsaleJson = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.BaseWallet = void 0;
    var base_wallet_js_1 = require_base_wallet();
    Object.defineProperty(exports, "BaseWallet", { enumerable: true, get: function() {
      return base_wallet_js_1.BaseWallet;
    } });
    var hdwallet_js_1 = require_hdwallet();
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return hdwallet_js_1.defaultPath;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return hdwallet_js_1.getAccountPath;
    } });
    Object.defineProperty(exports, "getIndexedAccountPath", { enumerable: true, get: function() {
      return hdwallet_js_1.getIndexedAccountPath;
    } });
    Object.defineProperty(exports, "HDNodeWallet", { enumerable: true, get: function() {
      return hdwallet_js_1.HDNodeWallet;
    } });
    Object.defineProperty(exports, "HDNodeVoidWallet", { enumerable: true, get: function() {
      return hdwallet_js_1.HDNodeVoidWallet;
    } });
    var json_crowdsale_js_1 = require_json_crowdsale();
    Object.defineProperty(exports, "isCrowdsaleJson", { enumerable: true, get: function() {
      return json_crowdsale_js_1.isCrowdsaleJson;
    } });
    Object.defineProperty(exports, "decryptCrowdsaleJson", { enumerable: true, get: function() {
      return json_crowdsale_js_1.decryptCrowdsaleJson;
    } });
    var json_keystore_js_1 = require_json_keystore();
    Object.defineProperty(exports, "isKeystoreJson", { enumerable: true, get: function() {
      return json_keystore_js_1.isKeystoreJson;
    } });
    Object.defineProperty(exports, "decryptKeystoreJsonSync", { enumerable: true, get: function() {
      return json_keystore_js_1.decryptKeystoreJsonSync;
    } });
    Object.defineProperty(exports, "decryptKeystoreJson", { enumerable: true, get: function() {
      return json_keystore_js_1.decryptKeystoreJson;
    } });
    Object.defineProperty(exports, "encryptKeystoreJson", { enumerable: true, get: function() {
      return json_keystore_js_1.encryptKeystoreJson;
    } });
    Object.defineProperty(exports, "encryptKeystoreJsonSync", { enumerable: true, get: function() {
      return json_keystore_js_1.encryptKeystoreJsonSync;
    } });
    var mnemonic_js_1 = require_mnemonic();
    Object.defineProperty(exports, "Mnemonic", { enumerable: true, get: function() {
      return mnemonic_js_1.Mnemonic;
    } });
    var wallet_js_1 = require_wallet();
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return wallet_js_1.Wallet;
    } });
  }
});

// node_modules/ethers/lib.commonjs/wordlists/bit-reader.js
var require_bit_reader = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/bit-reader.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeBits = void 0;
    var Base64 = ")!@#$%^&*(ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz-_";
    function decodeBits(width, data) {
      const maxValue = (1 << width) - 1;
      const result = [];
      let accum = 0, bits = 0, flood = 0;
      for (let i2 = 0; i2 < data.length; i2++) {
        accum = accum << 6 | Base64.indexOf(data[i2]);
        bits += 6;
        while (bits >= width) {
          const value = accum >> bits - width;
          accum &= (1 << bits - width) - 1;
          bits -= width;
          if (value === 0) {
            flood += maxValue;
          } else {
            result.push(value + flood);
            flood = 0;
          }
        }
      }
      return result;
    }
    exports.decodeBits = decodeBits;
  }
});

// node_modules/ethers/lib.commonjs/wordlists/decode-owla.js
var require_decode_owla = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/decode-owla.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.decodeOwlA = void 0;
    var index_js_1 = require_utils5();
    var bit_reader_js_1 = require_bit_reader();
    var decode_owl_js_1 = require_decode_owl();
    function decodeOwlA(data, accents) {
      let words = (0, decode_owl_js_1.decodeOwl)(data).join(",");
      accents.split(/,/g).forEach((accent) => {
        const match = accent.match(/^([a-z]*)([0-9]+)([0-9])(.*)$/);
        (0, index_js_1.assertArgument)(match !== null, "internal error parsing accents", "accents", accents);
        let posOffset = 0;
        const positions = (0, bit_reader_js_1.decodeBits)(parseInt(match[3]), match[4]);
        const charCode = parseInt(match[2]);
        const regex = new RegExp(`([${match[1]}])`, "g");
        words = words.replace(regex, (all3, letter) => {
          const rem = --positions[posOffset];
          if (rem === 0) {
            letter = String.fromCharCode(letter.charCodeAt(0), charCode);
            posOffset++;
          }
          return letter;
        });
      });
      return words.split(",");
    }
    exports.decodeOwlA = decodeOwlA;
  }
});

// node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js
var require_wordlist_owla = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/wordlist-owla.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WordlistOwlA = void 0;
    var wordlist_owl_js_1 = require_wordlist_owl();
    var decode_owla_js_1 = require_decode_owla();
    var _accent;
    var WordlistOwlA = class extends wordlist_owl_js_1.WordlistOwl {
      /**
       *  Creates a new Wordlist for %%locale%% using the OWLA %%data%%
       *  and %%accent%% data and validated against the %%checksum%%.
       */
      constructor(locale, data, accent, checksum2) {
        super(locale, data, checksum2);
        __privateAdd(this, _accent);
        __privateSet(this, _accent, accent);
      }
      /**
       *  The OWLA-encoded accent data.
       */
      get _accent() {
        return __privateGet(this, _accent);
      }
      /**
       *  Decode all the words for the wordlist.
       */
      _decodeWords() {
        return (0, decode_owla_js_1.decodeOwlA)(this._data, this._accent);
      }
    };
    _accent = new WeakMap();
    exports.WordlistOwlA = WordlistOwlA;
  }
});

// node_modules/ethers/lib.commonjs/wordlists/wordlists-browser.js
var require_wordlists_browser = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/wordlists-browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlists = void 0;
    var lang_en_js_1 = require_lang_en();
    exports.wordlists = {
      en: lang_en_js_1.LangEn.wordlist()
    };
  }
});

// node_modules/ethers/lib.commonjs/wordlists/index.js
var require_wordlists = __commonJS({
  "node_modules/ethers/lib.commonjs/wordlists/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = void 0;
    var wordlist_js_1 = require_wordlist();
    Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function() {
      return wordlist_js_1.Wordlist;
    } });
    var lang_en_js_1 = require_lang_en();
    Object.defineProperty(exports, "LangEn", { enumerable: true, get: function() {
      return lang_en_js_1.LangEn;
    } });
    var wordlist_owl_js_1 = require_wordlist_owl();
    Object.defineProperty(exports, "WordlistOwl", { enumerable: true, get: function() {
      return wordlist_owl_js_1.WordlistOwl;
    } });
    var wordlist_owla_js_1 = require_wordlist_owla();
    Object.defineProperty(exports, "WordlistOwlA", { enumerable: true, get: function() {
      return wordlist_owla_js_1.WordlistOwlA;
    } });
    var wordlists_js_1 = require_wordlists_browser();
    Object.defineProperty(exports, "wordlists", { enumerable: true, get: function() {
      return wordlists_js_1.wordlists;
    } });
  }
});

// node_modules/ethers/lib.commonjs/ethers.js
var require_ethers = __commonJS({
  "node_modules/ethers/lib.commonjs/ethers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ripemd160 = exports.keccak256 = exports.randomBytes = exports.computeHmac = exports.UndecodedEventLog = exports.EventLog = exports.ContractUnknownEventPayload = exports.ContractTransactionResponse = exports.ContractTransactionReceipt = exports.ContractEventPayload = exports.ContractFactory = exports.Contract = exports.BaseContract = exports.MessagePrefix = exports.EtherSymbol = exports.ZeroHash = exports.N = exports.MaxInt256 = exports.MinInt256 = exports.MaxUint256 = exports.WeiPerEther = exports.ZeroAddress = exports.resolveAddress = exports.isAddress = exports.isAddressable = exports.getCreate2Address = exports.getCreateAddress = exports.getIcapAddress = exports.getAddress = exports.Typed = exports.TransactionDescription = exports.Result = exports.LogDescription = exports.Interface = exports.Indexed = exports.ErrorDescription = exports.checkResultErrors = exports.StructFragment = exports.ParamType = exports.NamedFragment = exports.FunctionFragment = exports.FallbackFragment = exports.Fragment = exports.EventFragment = exports.ErrorFragment = exports.ConstructorFragment = exports.AbiCoder = exports.encodeBytes32String = exports.decodeBytes32String = exports.version = void 0;
    exports.EnsPlugin = exports.Network = exports.EnsResolver = exports.WebSocketProvider = exports.SocketProvider = exports.IpcSocketProvider = exports.QuickNodeProvider = exports.PocketProvider = exports.InfuraWebSocketProvider = exports.InfuraProvider = exports.EtherscanProvider = exports.CloudflareProvider = exports.ChainstackProvider = exports.AnkrProvider = exports.AlchemyProvider = exports.BrowserProvider = exports.JsonRpcSigner = exports.JsonRpcProvider = exports.JsonRpcApiProvider = exports.FallbackProvider = exports.AbstractProvider = exports.VoidSigner = exports.NonceManager = exports.AbstractSigner = exports.TransactionResponse = exports.TransactionReceipt = exports.Log = exports.FeeData = exports.Block = exports.getDefaultProvider = exports.verifyTypedData = exports.TypedDataEncoder = exports.solidityPackedSha256 = exports.solidityPackedKeccak256 = exports.solidityPacked = exports.verifyMessage = exports.hashMessage = exports.dnsEncode = exports.namehash = exports.isValidName = exports.ensNormalize = exports.id = exports.SigningKey = exports.Signature = exports.lock = exports.scryptSync = exports.scrypt = exports.pbkdf2 = exports.sha512 = exports.sha256 = void 0;
    exports.getUint = exports.getNumber = exports.getBigInt = exports.FixedNumber = exports.FetchCancelSignal = exports.FetchResponse = exports.FetchRequest = exports.EventPayload = exports.isError = exports.isCallException = exports.makeError = exports.assertPrivate = exports.assertNormalize = exports.assertArgumentCount = exports.assertArgument = exports.assert = exports.resolveProperties = exports.defineProperties = exports.zeroPadValue = exports.zeroPadBytes = exports.stripZerosLeft = exports.isBytesLike = exports.isHexString = exports.hexlify = exports.getBytesCopy = exports.getBytes = exports.dataSlice = exports.dataLength = exports.concat = exports.encodeBase64 = exports.decodeBase64 = exports.encodeBase58 = exports.decodeBase58 = exports.Transaction = exports.recoverAddress = exports.computeAddress = exports.accessListify = exports.showThrottleMessage = exports.copyRequest = exports.UnmanagedSubscriber = exports.SocketSubscriber = exports.SocketPendingSubscriber = exports.SocketEventSubscriber = exports.SocketBlockSubscriber = exports.MulticoinProviderPlugin = exports.NetworkPlugin = exports.GasCostPlugin = exports.FetchUrlFeeDataNetworkPlugin = exports.FeeDataNetworkPlugin = exports.EtherscanPlugin = void 0;
    exports.wordlists = exports.WordlistOwlA = exports.WordlistOwl = exports.LangEn = exports.Wordlist = exports.encryptKeystoreJsonSync = exports.encryptKeystoreJson = exports.decryptKeystoreJson = exports.decryptKeystoreJsonSync = exports.decryptCrowdsaleJson = exports.isKeystoreJson = exports.isCrowdsaleJson = exports.getIndexedAccountPath = exports.getAccountPath = exports.defaultPath = exports.Wallet = exports.HDNodeVoidWallet = exports.HDNodeWallet = exports.BaseWallet = exports.Mnemonic = exports.uuidV4 = exports.encodeRlp = exports.decodeRlp = exports.Utf8ErrorFuncs = exports.toUtf8String = exports.toUtf8CodePoints = exports.toUtf8Bytes = exports.parseUnits = exports.formatUnits = exports.parseEther = exports.formatEther = exports.mask = exports.toTwos = exports.fromTwos = exports.toQuantity = exports.toNumber = exports.toBeHex = exports.toBigInt = exports.toBeArray = void 0;
    var _version_js_1 = require_version2();
    Object.defineProperty(exports, "version", { enumerable: true, get: function() {
      return _version_js_1.version;
    } });
    var index_js_1 = require_abi();
    Object.defineProperty(exports, "decodeBytes32String", { enumerable: true, get: function() {
      return index_js_1.decodeBytes32String;
    } });
    Object.defineProperty(exports, "encodeBytes32String", { enumerable: true, get: function() {
      return index_js_1.encodeBytes32String;
    } });
    Object.defineProperty(exports, "AbiCoder", { enumerable: true, get: function() {
      return index_js_1.AbiCoder;
    } });
    Object.defineProperty(exports, "ConstructorFragment", { enumerable: true, get: function() {
      return index_js_1.ConstructorFragment;
    } });
    Object.defineProperty(exports, "ErrorFragment", { enumerable: true, get: function() {
      return index_js_1.ErrorFragment;
    } });
    Object.defineProperty(exports, "EventFragment", { enumerable: true, get: function() {
      return index_js_1.EventFragment;
    } });
    Object.defineProperty(exports, "Fragment", { enumerable: true, get: function() {
      return index_js_1.Fragment;
    } });
    Object.defineProperty(exports, "FallbackFragment", { enumerable: true, get: function() {
      return index_js_1.FallbackFragment;
    } });
    Object.defineProperty(exports, "FunctionFragment", { enumerable: true, get: function() {
      return index_js_1.FunctionFragment;
    } });
    Object.defineProperty(exports, "NamedFragment", { enumerable: true, get: function() {
      return index_js_1.NamedFragment;
    } });
    Object.defineProperty(exports, "ParamType", { enumerable: true, get: function() {
      return index_js_1.ParamType;
    } });
    Object.defineProperty(exports, "StructFragment", { enumerable: true, get: function() {
      return index_js_1.StructFragment;
    } });
    Object.defineProperty(exports, "checkResultErrors", { enumerable: true, get: function() {
      return index_js_1.checkResultErrors;
    } });
    Object.defineProperty(exports, "ErrorDescription", { enumerable: true, get: function() {
      return index_js_1.ErrorDescription;
    } });
    Object.defineProperty(exports, "Indexed", { enumerable: true, get: function() {
      return index_js_1.Indexed;
    } });
    Object.defineProperty(exports, "Interface", { enumerable: true, get: function() {
      return index_js_1.Interface;
    } });
    Object.defineProperty(exports, "LogDescription", { enumerable: true, get: function() {
      return index_js_1.LogDescription;
    } });
    Object.defineProperty(exports, "Result", { enumerable: true, get: function() {
      return index_js_1.Result;
    } });
    Object.defineProperty(exports, "TransactionDescription", { enumerable: true, get: function() {
      return index_js_1.TransactionDescription;
    } });
    Object.defineProperty(exports, "Typed", { enumerable: true, get: function() {
      return index_js_1.Typed;
    } });
    var index_js_2 = require_address2();
    Object.defineProperty(exports, "getAddress", { enumerable: true, get: function() {
      return index_js_2.getAddress;
    } });
    Object.defineProperty(exports, "getIcapAddress", { enumerable: true, get: function() {
      return index_js_2.getIcapAddress;
    } });
    Object.defineProperty(exports, "getCreateAddress", { enumerable: true, get: function() {
      return index_js_2.getCreateAddress;
    } });
    Object.defineProperty(exports, "getCreate2Address", { enumerable: true, get: function() {
      return index_js_2.getCreate2Address;
    } });
    Object.defineProperty(exports, "isAddressable", { enumerable: true, get: function() {
      return index_js_2.isAddressable;
    } });
    Object.defineProperty(exports, "isAddress", { enumerable: true, get: function() {
      return index_js_2.isAddress;
    } });
    Object.defineProperty(exports, "resolveAddress", { enumerable: true, get: function() {
      return index_js_2.resolveAddress;
    } });
    var index_js_3 = require_constants();
    Object.defineProperty(exports, "ZeroAddress", { enumerable: true, get: function() {
      return index_js_3.ZeroAddress;
    } });
    Object.defineProperty(exports, "WeiPerEther", { enumerable: true, get: function() {
      return index_js_3.WeiPerEther;
    } });
    Object.defineProperty(exports, "MaxUint256", { enumerable: true, get: function() {
      return index_js_3.MaxUint256;
    } });
    Object.defineProperty(exports, "MinInt256", { enumerable: true, get: function() {
      return index_js_3.MinInt256;
    } });
    Object.defineProperty(exports, "MaxInt256", { enumerable: true, get: function() {
      return index_js_3.MaxInt256;
    } });
    Object.defineProperty(exports, "N", { enumerable: true, get: function() {
      return index_js_3.N;
    } });
    Object.defineProperty(exports, "ZeroHash", { enumerable: true, get: function() {
      return index_js_3.ZeroHash;
    } });
    Object.defineProperty(exports, "EtherSymbol", { enumerable: true, get: function() {
      return index_js_3.EtherSymbol;
    } });
    Object.defineProperty(exports, "MessagePrefix", { enumerable: true, get: function() {
      return index_js_3.MessagePrefix;
    } });
    var index_js_4 = require_contract2();
    Object.defineProperty(exports, "BaseContract", { enumerable: true, get: function() {
      return index_js_4.BaseContract;
    } });
    Object.defineProperty(exports, "Contract", { enumerable: true, get: function() {
      return index_js_4.Contract;
    } });
    Object.defineProperty(exports, "ContractFactory", { enumerable: true, get: function() {
      return index_js_4.ContractFactory;
    } });
    Object.defineProperty(exports, "ContractEventPayload", { enumerable: true, get: function() {
      return index_js_4.ContractEventPayload;
    } });
    Object.defineProperty(exports, "ContractTransactionReceipt", { enumerable: true, get: function() {
      return index_js_4.ContractTransactionReceipt;
    } });
    Object.defineProperty(exports, "ContractTransactionResponse", { enumerable: true, get: function() {
      return index_js_4.ContractTransactionResponse;
    } });
    Object.defineProperty(exports, "ContractUnknownEventPayload", { enumerable: true, get: function() {
      return index_js_4.ContractUnknownEventPayload;
    } });
    Object.defineProperty(exports, "EventLog", { enumerable: true, get: function() {
      return index_js_4.EventLog;
    } });
    Object.defineProperty(exports, "UndecodedEventLog", { enumerable: true, get: function() {
      return index_js_4.UndecodedEventLog;
    } });
    var index_js_5 = require_crypto2();
    Object.defineProperty(exports, "computeHmac", { enumerable: true, get: function() {
      return index_js_5.computeHmac;
    } });
    Object.defineProperty(exports, "randomBytes", { enumerable: true, get: function() {
      return index_js_5.randomBytes;
    } });
    Object.defineProperty(exports, "keccak256", { enumerable: true, get: function() {
      return index_js_5.keccak256;
    } });
    Object.defineProperty(exports, "ripemd160", { enumerable: true, get: function() {
      return index_js_5.ripemd160;
    } });
    Object.defineProperty(exports, "sha256", { enumerable: true, get: function() {
      return index_js_5.sha256;
    } });
    Object.defineProperty(exports, "sha512", { enumerable: true, get: function() {
      return index_js_5.sha512;
    } });
    Object.defineProperty(exports, "pbkdf2", { enumerable: true, get: function() {
      return index_js_5.pbkdf2;
    } });
    Object.defineProperty(exports, "scrypt", { enumerable: true, get: function() {
      return index_js_5.scrypt;
    } });
    Object.defineProperty(exports, "scryptSync", { enumerable: true, get: function() {
      return index_js_5.scryptSync;
    } });
    Object.defineProperty(exports, "lock", { enumerable: true, get: function() {
      return index_js_5.lock;
    } });
    Object.defineProperty(exports, "Signature", { enumerable: true, get: function() {
      return index_js_5.Signature;
    } });
    Object.defineProperty(exports, "SigningKey", { enumerable: true, get: function() {
      return index_js_5.SigningKey;
    } });
    var index_js_6 = require_hash();
    Object.defineProperty(exports, "id", { enumerable: true, get: function() {
      return index_js_6.id;
    } });
    Object.defineProperty(exports, "ensNormalize", { enumerable: true, get: function() {
      return index_js_6.ensNormalize;
    } });
    Object.defineProperty(exports, "isValidName", { enumerable: true, get: function() {
      return index_js_6.isValidName;
    } });
    Object.defineProperty(exports, "namehash", { enumerable: true, get: function() {
      return index_js_6.namehash;
    } });
    Object.defineProperty(exports, "dnsEncode", { enumerable: true, get: function() {
      return index_js_6.dnsEncode;
    } });
    Object.defineProperty(exports, "hashMessage", { enumerable: true, get: function() {
      return index_js_6.hashMessage;
    } });
    Object.defineProperty(exports, "verifyMessage", { enumerable: true, get: function() {
      return index_js_6.verifyMessage;
    } });
    Object.defineProperty(exports, "solidityPacked", { enumerable: true, get: function() {
      return index_js_6.solidityPacked;
    } });
    Object.defineProperty(exports, "solidityPackedKeccak256", { enumerable: true, get: function() {
      return index_js_6.solidityPackedKeccak256;
    } });
    Object.defineProperty(exports, "solidityPackedSha256", { enumerable: true, get: function() {
      return index_js_6.solidityPackedSha256;
    } });
    Object.defineProperty(exports, "TypedDataEncoder", { enumerable: true, get: function() {
      return index_js_6.TypedDataEncoder;
    } });
    Object.defineProperty(exports, "verifyTypedData", { enumerable: true, get: function() {
      return index_js_6.verifyTypedData;
    } });
    var index_js_7 = require_providers();
    Object.defineProperty(exports, "getDefaultProvider", { enumerable: true, get: function() {
      return index_js_7.getDefaultProvider;
    } });
    Object.defineProperty(exports, "Block", { enumerable: true, get: function() {
      return index_js_7.Block;
    } });
    Object.defineProperty(exports, "FeeData", { enumerable: true, get: function() {
      return index_js_7.FeeData;
    } });
    Object.defineProperty(exports, "Log", { enumerable: true, get: function() {
      return index_js_7.Log;
    } });
    Object.defineProperty(exports, "TransactionReceipt", { enumerable: true, get: function() {
      return index_js_7.TransactionReceipt;
    } });
    Object.defineProperty(exports, "TransactionResponse", { enumerable: true, get: function() {
      return index_js_7.TransactionResponse;
    } });
    Object.defineProperty(exports, "AbstractSigner", { enumerable: true, get: function() {
      return index_js_7.AbstractSigner;
    } });
    Object.defineProperty(exports, "NonceManager", { enumerable: true, get: function() {
      return index_js_7.NonceManager;
    } });
    Object.defineProperty(exports, "VoidSigner", { enumerable: true, get: function() {
      return index_js_7.VoidSigner;
    } });
    Object.defineProperty(exports, "AbstractProvider", { enumerable: true, get: function() {
      return index_js_7.AbstractProvider;
    } });
    Object.defineProperty(exports, "FallbackProvider", { enumerable: true, get: function() {
      return index_js_7.FallbackProvider;
    } });
    Object.defineProperty(exports, "JsonRpcApiProvider", { enumerable: true, get: function() {
      return index_js_7.JsonRpcApiProvider;
    } });
    Object.defineProperty(exports, "JsonRpcProvider", { enumerable: true, get: function() {
      return index_js_7.JsonRpcProvider;
    } });
    Object.defineProperty(exports, "JsonRpcSigner", { enumerable: true, get: function() {
      return index_js_7.JsonRpcSigner;
    } });
    Object.defineProperty(exports, "BrowserProvider", { enumerable: true, get: function() {
      return index_js_7.BrowserProvider;
    } });
    Object.defineProperty(exports, "AlchemyProvider", { enumerable: true, get: function() {
      return index_js_7.AlchemyProvider;
    } });
    Object.defineProperty(exports, "AnkrProvider", { enumerable: true, get: function() {
      return index_js_7.AnkrProvider;
    } });
    Object.defineProperty(exports, "ChainstackProvider", { enumerable: true, get: function() {
      return index_js_7.ChainstackProvider;
    } });
    Object.defineProperty(exports, "CloudflareProvider", { enumerable: true, get: function() {
      return index_js_7.CloudflareProvider;
    } });
    Object.defineProperty(exports, "EtherscanProvider", { enumerable: true, get: function() {
      return index_js_7.EtherscanProvider;
    } });
    Object.defineProperty(exports, "InfuraProvider", { enumerable: true, get: function() {
      return index_js_7.InfuraProvider;
    } });
    Object.defineProperty(exports, "InfuraWebSocketProvider", { enumerable: true, get: function() {
      return index_js_7.InfuraWebSocketProvider;
    } });
    Object.defineProperty(exports, "PocketProvider", { enumerable: true, get: function() {
      return index_js_7.PocketProvider;
    } });
    Object.defineProperty(exports, "QuickNodeProvider", { enumerable: true, get: function() {
      return index_js_7.QuickNodeProvider;
    } });
    Object.defineProperty(exports, "IpcSocketProvider", { enumerable: true, get: function() {
      return index_js_7.IpcSocketProvider;
    } });
    Object.defineProperty(exports, "SocketProvider", { enumerable: true, get: function() {
      return index_js_7.SocketProvider;
    } });
    Object.defineProperty(exports, "WebSocketProvider", { enumerable: true, get: function() {
      return index_js_7.WebSocketProvider;
    } });
    Object.defineProperty(exports, "EnsResolver", { enumerable: true, get: function() {
      return index_js_7.EnsResolver;
    } });
    Object.defineProperty(exports, "Network", { enumerable: true, get: function() {
      return index_js_7.Network;
    } });
    Object.defineProperty(exports, "EnsPlugin", { enumerable: true, get: function() {
      return index_js_7.EnsPlugin;
    } });
    Object.defineProperty(exports, "EtherscanPlugin", { enumerable: true, get: function() {
      return index_js_7.EtherscanPlugin;
    } });
    Object.defineProperty(exports, "FeeDataNetworkPlugin", { enumerable: true, get: function() {
      return index_js_7.FeeDataNetworkPlugin;
    } });
    Object.defineProperty(exports, "FetchUrlFeeDataNetworkPlugin", { enumerable: true, get: function() {
      return index_js_7.FetchUrlFeeDataNetworkPlugin;
    } });
    Object.defineProperty(exports, "GasCostPlugin", { enumerable: true, get: function() {
      return index_js_7.GasCostPlugin;
    } });
    Object.defineProperty(exports, "NetworkPlugin", { enumerable: true, get: function() {
      return index_js_7.NetworkPlugin;
    } });
    Object.defineProperty(exports, "MulticoinProviderPlugin", { enumerable: true, get: function() {
      return index_js_7.MulticoinProviderPlugin;
    } });
    Object.defineProperty(exports, "SocketBlockSubscriber", { enumerable: true, get: function() {
      return index_js_7.SocketBlockSubscriber;
    } });
    Object.defineProperty(exports, "SocketEventSubscriber", { enumerable: true, get: function() {
      return index_js_7.SocketEventSubscriber;
    } });
    Object.defineProperty(exports, "SocketPendingSubscriber", { enumerable: true, get: function() {
      return index_js_7.SocketPendingSubscriber;
    } });
    Object.defineProperty(exports, "SocketSubscriber", { enumerable: true, get: function() {
      return index_js_7.SocketSubscriber;
    } });
    Object.defineProperty(exports, "UnmanagedSubscriber", { enumerable: true, get: function() {
      return index_js_7.UnmanagedSubscriber;
    } });
    Object.defineProperty(exports, "copyRequest", { enumerable: true, get: function() {
      return index_js_7.copyRequest;
    } });
    Object.defineProperty(exports, "showThrottleMessage", { enumerable: true, get: function() {
      return index_js_7.showThrottleMessage;
    } });
    var index_js_8 = require_transaction2();
    Object.defineProperty(exports, "accessListify", { enumerable: true, get: function() {
      return index_js_8.accessListify;
    } });
    Object.defineProperty(exports, "computeAddress", { enumerable: true, get: function() {
      return index_js_8.computeAddress;
    } });
    Object.defineProperty(exports, "recoverAddress", { enumerable: true, get: function() {
      return index_js_8.recoverAddress;
    } });
    Object.defineProperty(exports, "Transaction", { enumerable: true, get: function() {
      return index_js_8.Transaction;
    } });
    var index_js_9 = require_utils5();
    Object.defineProperty(exports, "decodeBase58", { enumerable: true, get: function() {
      return index_js_9.decodeBase58;
    } });
    Object.defineProperty(exports, "encodeBase58", { enumerable: true, get: function() {
      return index_js_9.encodeBase58;
    } });
    Object.defineProperty(exports, "decodeBase64", { enumerable: true, get: function() {
      return index_js_9.decodeBase64;
    } });
    Object.defineProperty(exports, "encodeBase64", { enumerable: true, get: function() {
      return index_js_9.encodeBase64;
    } });
    Object.defineProperty(exports, "concat", { enumerable: true, get: function() {
      return index_js_9.concat;
    } });
    Object.defineProperty(exports, "dataLength", { enumerable: true, get: function() {
      return index_js_9.dataLength;
    } });
    Object.defineProperty(exports, "dataSlice", { enumerable: true, get: function() {
      return index_js_9.dataSlice;
    } });
    Object.defineProperty(exports, "getBytes", { enumerable: true, get: function() {
      return index_js_9.getBytes;
    } });
    Object.defineProperty(exports, "getBytesCopy", { enumerable: true, get: function() {
      return index_js_9.getBytesCopy;
    } });
    Object.defineProperty(exports, "hexlify", { enumerable: true, get: function() {
      return index_js_9.hexlify;
    } });
    Object.defineProperty(exports, "isHexString", { enumerable: true, get: function() {
      return index_js_9.isHexString;
    } });
    Object.defineProperty(exports, "isBytesLike", { enumerable: true, get: function() {
      return index_js_9.isBytesLike;
    } });
    Object.defineProperty(exports, "stripZerosLeft", { enumerable: true, get: function() {
      return index_js_9.stripZerosLeft;
    } });
    Object.defineProperty(exports, "zeroPadBytes", { enumerable: true, get: function() {
      return index_js_9.zeroPadBytes;
    } });
    Object.defineProperty(exports, "zeroPadValue", { enumerable: true, get: function() {
      return index_js_9.zeroPadValue;
    } });
    Object.defineProperty(exports, "defineProperties", { enumerable: true, get: function() {
      return index_js_9.defineProperties;
    } });
    Object.defineProperty(exports, "resolveProperties", { enumerable: true, get: function() {
      return index_js_9.resolveProperties;
    } });
    Object.defineProperty(exports, "assert", { enumerable: true, get: function() {
      return index_js_9.assert;
    } });
    Object.defineProperty(exports, "assertArgument", { enumerable: true, get: function() {
      return index_js_9.assertArgument;
    } });
    Object.defineProperty(exports, "assertArgumentCount", { enumerable: true, get: function() {
      return index_js_9.assertArgumentCount;
    } });
    Object.defineProperty(exports, "assertNormalize", { enumerable: true, get: function() {
      return index_js_9.assertNormalize;
    } });
    Object.defineProperty(exports, "assertPrivate", { enumerable: true, get: function() {
      return index_js_9.assertPrivate;
    } });
    Object.defineProperty(exports, "makeError", { enumerable: true, get: function() {
      return index_js_9.makeError;
    } });
    Object.defineProperty(exports, "isCallException", { enumerable: true, get: function() {
      return index_js_9.isCallException;
    } });
    Object.defineProperty(exports, "isError", { enumerable: true, get: function() {
      return index_js_9.isError;
    } });
    Object.defineProperty(exports, "EventPayload", { enumerable: true, get: function() {
      return index_js_9.EventPayload;
    } });
    Object.defineProperty(exports, "FetchRequest", { enumerable: true, get: function() {
      return index_js_9.FetchRequest;
    } });
    Object.defineProperty(exports, "FetchResponse", { enumerable: true, get: function() {
      return index_js_9.FetchResponse;
    } });
    Object.defineProperty(exports, "FetchCancelSignal", { enumerable: true, get: function() {
      return index_js_9.FetchCancelSignal;
    } });
    Object.defineProperty(exports, "FixedNumber", { enumerable: true, get: function() {
      return index_js_9.FixedNumber;
    } });
    Object.defineProperty(exports, "getBigInt", { enumerable: true, get: function() {
      return index_js_9.getBigInt;
    } });
    Object.defineProperty(exports, "getNumber", { enumerable: true, get: function() {
      return index_js_9.getNumber;
    } });
    Object.defineProperty(exports, "getUint", { enumerable: true, get: function() {
      return index_js_9.getUint;
    } });
    Object.defineProperty(exports, "toBeArray", { enumerable: true, get: function() {
      return index_js_9.toBeArray;
    } });
    Object.defineProperty(exports, "toBigInt", { enumerable: true, get: function() {
      return index_js_9.toBigInt;
    } });
    Object.defineProperty(exports, "toBeHex", { enumerable: true, get: function() {
      return index_js_9.toBeHex;
    } });
    Object.defineProperty(exports, "toNumber", { enumerable: true, get: function() {
      return index_js_9.toNumber;
    } });
    Object.defineProperty(exports, "toQuantity", { enumerable: true, get: function() {
      return index_js_9.toQuantity;
    } });
    Object.defineProperty(exports, "fromTwos", { enumerable: true, get: function() {
      return index_js_9.fromTwos;
    } });
    Object.defineProperty(exports, "toTwos", { enumerable: true, get: function() {
      return index_js_9.toTwos;
    } });
    Object.defineProperty(exports, "mask", { enumerable: true, get: function() {
      return index_js_9.mask;
    } });
    Object.defineProperty(exports, "formatEther", { enumerable: true, get: function() {
      return index_js_9.formatEther;
    } });
    Object.defineProperty(exports, "parseEther", { enumerable: true, get: function() {
      return index_js_9.parseEther;
    } });
    Object.defineProperty(exports, "formatUnits", { enumerable: true, get: function() {
      return index_js_9.formatUnits;
    } });
    Object.defineProperty(exports, "parseUnits", { enumerable: true, get: function() {
      return index_js_9.parseUnits;
    } });
    Object.defineProperty(exports, "toUtf8Bytes", { enumerable: true, get: function() {
      return index_js_9.toUtf8Bytes;
    } });
    Object.defineProperty(exports, "toUtf8CodePoints", { enumerable: true, get: function() {
      return index_js_9.toUtf8CodePoints;
    } });
    Object.defineProperty(exports, "toUtf8String", { enumerable: true, get: function() {
      return index_js_9.toUtf8String;
    } });
    Object.defineProperty(exports, "Utf8ErrorFuncs", { enumerable: true, get: function() {
      return index_js_9.Utf8ErrorFuncs;
    } });
    Object.defineProperty(exports, "decodeRlp", { enumerable: true, get: function() {
      return index_js_9.decodeRlp;
    } });
    Object.defineProperty(exports, "encodeRlp", { enumerable: true, get: function() {
      return index_js_9.encodeRlp;
    } });
    Object.defineProperty(exports, "uuidV4", { enumerable: true, get: function() {
      return index_js_9.uuidV4;
    } });
    var index_js_10 = require_wallet2();
    Object.defineProperty(exports, "Mnemonic", { enumerable: true, get: function() {
      return index_js_10.Mnemonic;
    } });
    Object.defineProperty(exports, "BaseWallet", { enumerable: true, get: function() {
      return index_js_10.BaseWallet;
    } });
    Object.defineProperty(exports, "HDNodeWallet", { enumerable: true, get: function() {
      return index_js_10.HDNodeWallet;
    } });
    Object.defineProperty(exports, "HDNodeVoidWallet", { enumerable: true, get: function() {
      return index_js_10.HDNodeVoidWallet;
    } });
    Object.defineProperty(exports, "Wallet", { enumerable: true, get: function() {
      return index_js_10.Wallet;
    } });
    Object.defineProperty(exports, "defaultPath", { enumerable: true, get: function() {
      return index_js_10.defaultPath;
    } });
    Object.defineProperty(exports, "getAccountPath", { enumerable: true, get: function() {
      return index_js_10.getAccountPath;
    } });
    Object.defineProperty(exports, "getIndexedAccountPath", { enumerable: true, get: function() {
      return index_js_10.getIndexedAccountPath;
    } });
    Object.defineProperty(exports, "isCrowdsaleJson", { enumerable: true, get: function() {
      return index_js_10.isCrowdsaleJson;
    } });
    Object.defineProperty(exports, "isKeystoreJson", { enumerable: true, get: function() {
      return index_js_10.isKeystoreJson;
    } });
    Object.defineProperty(exports, "decryptCrowdsaleJson", { enumerable: true, get: function() {
      return index_js_10.decryptCrowdsaleJson;
    } });
    Object.defineProperty(exports, "decryptKeystoreJsonSync", { enumerable: true, get: function() {
      return index_js_10.decryptKeystoreJsonSync;
    } });
    Object.defineProperty(exports, "decryptKeystoreJson", { enumerable: true, get: function() {
      return index_js_10.decryptKeystoreJson;
    } });
    Object.defineProperty(exports, "encryptKeystoreJson", { enumerable: true, get: function() {
      return index_js_10.encryptKeystoreJson;
    } });
    Object.defineProperty(exports, "encryptKeystoreJsonSync", { enumerable: true, get: function() {
      return index_js_10.encryptKeystoreJsonSync;
    } });
    var index_js_11 = require_wordlists();
    Object.defineProperty(exports, "Wordlist", { enumerable: true, get: function() {
      return index_js_11.Wordlist;
    } });
    Object.defineProperty(exports, "LangEn", { enumerable: true, get: function() {
      return index_js_11.LangEn;
    } });
    Object.defineProperty(exports, "WordlistOwl", { enumerable: true, get: function() {
      return index_js_11.WordlistOwl;
    } });
    Object.defineProperty(exports, "WordlistOwlA", { enumerable: true, get: function() {
      return index_js_11.WordlistOwlA;
    } });
    Object.defineProperty(exports, "wordlists", { enumerable: true, get: function() {
      return index_js_11.wordlists;
    } });
  }
});

// node_modules/ethers/lib.commonjs/index.js
var require_lib2 = __commonJS({
  "node_modules/ethers/lib.commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ethers = void 0;
    var tslib_1 = (init_tslib_es62(), __toCommonJS(tslib_es6_exports));
    var ethers = tslib_1.__importStar(require_ethers());
    exports.ethers = ethers;
    tslib_1.__exportStar(require_ethers(), exports);
  }
});

// node_modules/siwe/dist/ethersCompat.js
var require_ethersCompat = __commonJS({
  "node_modules/siwe/dist/ethersCompat.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.getAddress = exports.hashMessage = exports.verifyMessage = void 0;
    var ethers_1 = require_lib2();
    var ethersVerifyMessage = null;
    var ethersHashMessage = null;
    var ethersGetAddress = null;
    try {
      ethersVerifyMessage = ethers_1.ethers.utils.verifyMessage;
      ethersHashMessage = ethers_1.ethers.utils.hashMessage;
      ethersGetAddress = ethers_1.ethers.utils.getAddress;
    } catch (_a2) {
      ethersVerifyMessage = ethers_1.ethers.verifyMessage;
      ethersHashMessage = ethers_1.ethers.hashMessage;
      ethersGetAddress = ethers_1.ethers.getAddress;
    }
    exports.verifyMessage = ethersVerifyMessage;
    exports.hashMessage = ethersHashMessage;
    exports.getAddress = ethersGetAddress;
  }
});

// node_modules/siwe/dist/types.js
var require_types = __commonJS({
  "node_modules/siwe/dist/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SiweErrorType = exports.SiweError = exports.VerifyOptsKeys = exports.VerifyParamsKeys = void 0;
    exports.VerifyParamsKeys = [
      "signature",
      "scheme",
      "domain",
      "nonce",
      "time"
    ];
    exports.VerifyOptsKeys = [
      "provider",
      "suppressExceptions",
      "verificationFallback"
    ];
    var SiweError = class {
      constructor(type6, expected, received) {
        this.type = type6;
        this.expected = expected;
        this.received = received;
      }
    };
    exports.SiweError = SiweError;
    var SiweErrorType;
    (function(SiweErrorType2) {
      SiweErrorType2["EXPIRED_MESSAGE"] = "Expired message.";
      SiweErrorType2["INVALID_DOMAIN"] = "Invalid domain.";
      SiweErrorType2["SCHEME_MISMATCH"] = "Scheme does not match provided scheme for verification.";
      SiweErrorType2["DOMAIN_MISMATCH"] = "Domain does not match provided domain for verification.";
      SiweErrorType2["NONCE_MISMATCH"] = "Nonce does not match provided nonce for verification.";
      SiweErrorType2["INVALID_ADDRESS"] = "Invalid address.";
      SiweErrorType2["INVALID_URI"] = "URI does not conform to RFC 3986.";
      SiweErrorType2["INVALID_NONCE"] = "Nonce size smaller then 8 characters or is not alphanumeric.";
      SiweErrorType2["NOT_YET_VALID_MESSAGE"] = "Message is not valid yet.";
      SiweErrorType2["INVALID_SIGNATURE"] = "Signature does not match address of the message.";
      SiweErrorType2["INVALID_TIME_FORMAT"] = "Invalid time format.";
      SiweErrorType2["INVALID_MESSAGE_VERSION"] = "Invalid message version.";
      SiweErrorType2["UNABLE_TO_PARSE"] = "Unable to parse the message.";
    })(SiweErrorType = exports.SiweErrorType || (exports.SiweErrorType = {}));
  }
});

// node_modules/@stablelib/random/lib/source/browser.js
var require_browser2 = __commonJS({
  "node_modules/@stablelib/random/lib/source/browser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.BrowserRandomSource = void 0;
    var QUOTA = 65536;
    var BrowserRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        const browserCrypto = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (browserCrypto && browserCrypto.getRandomValues !== void 0) {
          this._crypto = browserCrypto;
          this.isAvailable = true;
          this.isInstantiated = true;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Browser random byte generator is not available.");
        }
        const out = new Uint8Array(length2);
        for (let i2 = 0; i2 < out.length; i2 += QUOTA) {
          this._crypto.getRandomValues(out.subarray(i2, i2 + Math.min(out.length - i2, QUOTA)));
        }
        return out;
      }
    };
    exports.BrowserRandomSource = BrowserRandomSource;
  }
});

// node_modules/@stablelib/wipe/lib/wipe.js
var require_wipe = __commonJS({
  "node_modules/@stablelib/wipe/lib/wipe.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function wipe(array) {
      for (var i2 = 0; i2 < array.length; i2++) {
        array[i2] = 0;
      }
      return array;
    }
    exports.wipe = wipe;
  }
});

// browser-external:crypto
var require_crypto3 = __commonJS({
  "browser-external:crypto"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_2, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "crypto" has been externalized for browser compatibility. Cannot access "crypto.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/@stablelib/random/lib/source/node.js
var require_node = __commonJS({
  "node_modules/@stablelib/random/lib/source/node.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NodeRandomSource = void 0;
    var wipe_1 = require_wipe();
    var NodeRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.isInstantiated = false;
        if (typeof __require !== "undefined") {
          const nodeCrypto = require_crypto3();
          if (nodeCrypto && nodeCrypto.randomBytes) {
            this._crypto = nodeCrypto;
            this.isAvailable = true;
            this.isInstantiated = true;
          }
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable || !this._crypto) {
          throw new Error("Node.js random byte generator is not available.");
        }
        let buffer3 = this._crypto.randomBytes(length2);
        if (buffer3.length !== length2) {
          throw new Error("NodeRandomSource: got fewer bytes than requested");
        }
        const out = new Uint8Array(length2);
        for (let i2 = 0; i2 < out.length; i2++) {
          out[i2] = buffer3[i2];
        }
        (0, wipe_1.wipe)(buffer3);
        return out;
      }
    };
    exports.NodeRandomSource = NodeRandomSource;
  }
});

// node_modules/@stablelib/random/lib/source/system.js
var require_system = __commonJS({
  "node_modules/@stablelib/random/lib/source/system.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SystemRandomSource = void 0;
    var browser_1 = require_browser2();
    var node_1 = require_node();
    var SystemRandomSource = class {
      constructor() {
        this.isAvailable = false;
        this.name = "";
        this._source = new browser_1.BrowserRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Browser";
          return;
        }
        this._source = new node_1.NodeRandomSource();
        if (this._source.isAvailable) {
          this.isAvailable = true;
          this.name = "Node";
          return;
        }
      }
      randomBytes(length2) {
        if (!this.isAvailable) {
          throw new Error("System random byte generator is not available.");
        }
        return this._source.randomBytes(length2);
      }
    };
    exports.SystemRandomSource = SystemRandomSource;
  }
});

// node_modules/@stablelib/int/lib/int.js
var require_int = __commonJS({
  "node_modules/@stablelib/int/lib/int.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    function imulShim(a3, b4) {
      var ah = a3 >>> 16 & 65535, al2 = a3 & 65535;
      var bh = b4 >>> 16 & 65535, bl2 = b4 & 65535;
      return al2 * bl2 + (ah * bl2 + al2 * bh << 16 >>> 0) | 0;
    }
    exports.mul = Math.imul || imulShim;
    function add4(a3, b4) {
      return a3 + b4 | 0;
    }
    exports.add = add4;
    function sub(a3, b4) {
      return a3 - b4 | 0;
    }
    exports.sub = sub;
    function rotl2(x2, n2) {
      return x2 << n2 | x2 >>> 32 - n2;
    }
    exports.rotl = rotl2;
    function rotr4(x2, n2) {
      return x2 << 32 - n2 | x2 >>> n2;
    }
    exports.rotr = rotr4;
    function isIntegerShim(n2) {
      return typeof n2 === "number" && isFinite(n2) && Math.floor(n2) === n2;
    }
    exports.isInteger = Number.isInteger || isIntegerShim;
    exports.MAX_SAFE_INTEGER = 9007199254740991;
    exports.isSafeInteger = function(n2) {
      return exports.isInteger(n2) && (n2 >= -exports.MAX_SAFE_INTEGER && n2 <= exports.MAX_SAFE_INTEGER);
    };
  }
});

// node_modules/@stablelib/binary/lib/binary.js
var require_binary = __commonJS({
  "node_modules/@stablelib/binary/lib/binary.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    var int_1 = require_int();
    function readInt16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) << 16 >> 16;
    }
    exports.readInt16BE = readInt16BE;
    function readUint16BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 0] << 8 | array[offset + 1]) >>> 0;
    }
    exports.readUint16BE = readUint16BE;
    function readInt16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) << 16 >> 16;
    }
    exports.readInt16LE = readInt16LE;
    function readUint16LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint16LE = readUint16LE;
    function writeUint16BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 8;
      out[offset + 1] = value >>> 0;
      return out;
    }
    exports.writeUint16BE = writeUint16BE;
    exports.writeInt16BE = writeUint16BE;
    function writeUint16LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(2);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      return out;
    }
    exports.writeUint16LE = writeUint16LE;
    exports.writeInt16LE = writeUint16LE;
    function readInt32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3];
    }
    exports.readInt32BE = readInt32BE;
    function readUint32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset] << 24 | array[offset + 1] << 16 | array[offset + 2] << 8 | array[offset + 3]) >>> 0;
    }
    exports.readUint32BE = readUint32BE;
    function readInt32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset];
    }
    exports.readInt32LE = readInt32LE;
    function readUint32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      return (array[offset + 3] << 24 | array[offset + 2] << 16 | array[offset + 1] << 8 | array[offset]) >>> 0;
    }
    exports.readUint32LE = readUint32LE;
    function writeUint32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 24;
      out[offset + 1] = value >>> 16;
      out[offset + 2] = value >>> 8;
      out[offset + 3] = value >>> 0;
      return out;
    }
    exports.writeUint32BE = writeUint32BE;
    exports.writeInt32BE = writeUint32BE;
    function writeUint32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      out[offset + 0] = value >>> 0;
      out[offset + 1] = value >>> 8;
      out[offset + 2] = value >>> 16;
      out[offset + 3] = value >>> 24;
      return out;
    }
    exports.writeUint32LE = writeUint32LE;
    exports.writeInt32LE = writeUint32LE;
    function readInt64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readInt32BE(array, offset);
      var lo2 = readInt32BE(array, offset + 4);
      return hi * 4294967296 + lo2 - (lo2 >> 31) * 4294967296;
    }
    exports.readInt64BE = readInt64BE;
    function readUint64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var hi = readUint32BE(array, offset);
      var lo2 = readUint32BE(array, offset + 4);
      return hi * 4294967296 + lo2;
    }
    exports.readUint64BE = readUint64BE;
    function readInt64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo2 = readInt32LE(array, offset);
      var hi = readInt32LE(array, offset + 4);
      return hi * 4294967296 + lo2 - (lo2 >> 31) * 4294967296;
    }
    exports.readInt64LE = readInt64LE;
    function readUint64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var lo2 = readUint32LE(array, offset);
      var hi = readUint32LE(array, offset + 4);
      return hi * 4294967296 + lo2;
    }
    exports.readUint64LE = readUint64LE;
    function writeUint64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32BE(value / 4294967296 >>> 0, out, offset);
      writeUint32BE(value >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64BE = writeUint64BE;
    exports.writeInt64BE = writeUint64BE;
    function writeUint64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      writeUint32LE(value >>> 0, out, offset);
      writeUint32LE(value / 4294967296 >>> 0, out, offset + 4);
      return out;
    }
    exports.writeUint64LE = writeUint64LE;
    exports.writeInt64LE = writeUint64LE;
    function readUintBE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintBE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintBE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintBE = readUintBE;
    function readUintLE(bitLength, array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("readUintLE supports only bitLengths divisible by 8");
      }
      if (bitLength / 8 > array.length - offset) {
        throw new Error("readUintLE: array is too short for the given bitLength");
      }
      var result = 0;
      var mul = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        result += array[i2] * mul;
        mul *= 256;
      }
      return result;
    }
    exports.readUintLE = readUintLE;
    function writeUintBE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintBE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintBE value must be an integer");
      }
      var div = 1;
      for (var i2 = bitLength / 8 + offset - 1; i2 >= offset; i2--) {
        out[i2] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintBE = writeUintBE;
    function writeUintLE(bitLength, value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(bitLength / 8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      if (bitLength % 8 !== 0) {
        throw new Error("writeUintLE supports only bitLengths divisible by 8");
      }
      if (!int_1.isSafeInteger(value)) {
        throw new Error("writeUintLE value must be an integer");
      }
      var div = 1;
      for (var i2 = offset; i2 < offset + bitLength / 8; i2++) {
        out[i2] = value / div & 255;
        div *= 256;
      }
      return out;
    }
    exports.writeUintLE = writeUintLE;
    function readFloat32BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset);
    }
    exports.readFloat32BE = readFloat32BE;
    function readFloat32LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat32(offset, true);
    }
    exports.readFloat32LE = readFloat32LE;
    function readFloat64BE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset);
    }
    exports.readFloat64BE = readFloat64BE;
    function readFloat64LE(array, offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(array.buffer, array.byteOffset, array.byteLength);
      return view.getFloat64(offset, true);
    }
    exports.readFloat64LE = readFloat64LE;
    function writeFloat32BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value);
      return out;
    }
    exports.writeFloat32BE = writeFloat32BE;
    function writeFloat32LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(4);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat32(offset, value, true);
      return out;
    }
    exports.writeFloat32LE = writeFloat32LE;
    function writeFloat64BE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value);
      return out;
    }
    exports.writeFloat64BE = writeFloat64BE;
    function writeFloat64LE(value, out, offset) {
      if (out === void 0) {
        out = new Uint8Array(8);
      }
      if (offset === void 0) {
        offset = 0;
      }
      var view = new DataView(out.buffer, out.byteOffset, out.byteLength);
      view.setFloat64(offset, value, true);
      return out;
    }
    exports.writeFloat64LE = writeFloat64LE;
  }
});

// node_modules/@stablelib/random/lib/random.js
var require_random2 = __commonJS({
  "node_modules/@stablelib/random/lib/random.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.randomStringForEntropy = exports.randomString = exports.randomUint32 = exports.randomBytes = exports.defaultRandomSource = void 0;
    var system_1 = require_system();
    var binary_1 = require_binary();
    var wipe_1 = require_wipe();
    exports.defaultRandomSource = new system_1.SystemRandomSource();
    function randomBytes3(length2, prng = exports.defaultRandomSource) {
      return prng.randomBytes(length2);
    }
    exports.randomBytes = randomBytes3;
    function randomUint32(prng = exports.defaultRandomSource) {
      const buf = randomBytes3(4, prng);
      const result = (0, binary_1.readUint32LE)(buf);
      (0, wipe_1.wipe)(buf);
      return result;
    }
    exports.randomUint32 = randomUint32;
    var ALPHANUMERIC = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz";
    function randomString(length2, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      if (charset.length < 2) {
        throw new Error("randomString charset is too short");
      }
      if (charset.length > 256) {
        throw new Error("randomString charset is too long");
      }
      let out = "";
      const charsLen = charset.length;
      const maxByte = 256 - 256 % charsLen;
      while (length2 > 0) {
        const buf = randomBytes3(Math.ceil(length2 * 256 / maxByte), prng);
        for (let i2 = 0; i2 < buf.length && length2 > 0; i2++) {
          const randomByte = buf[i2];
          if (randomByte < maxByte) {
            out += charset.charAt(randomByte % charsLen);
            length2--;
          }
        }
        (0, wipe_1.wipe)(buf);
      }
      return out;
    }
    exports.randomString = randomString;
    function randomStringForEntropy(bits, charset = ALPHANUMERIC, prng = exports.defaultRandomSource) {
      const length2 = Math.ceil(bits / (Math.log(charset.length) / Math.LN2));
      return randomString(length2, charset, prng);
    }
    exports.randomStringForEntropy = randomStringForEntropy;
  }
});

// node_modules/siwe/dist/utils.js
var require_utils9 = __commonJS({
  "node_modules/siwe/dist/utils.js"(exports) {
    "use strict";
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step2(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step2(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step2(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step2((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.checkInvalidKeys = exports.isValidISO8601Date = exports.generateNonce = exports.checkContractWalletSignature = void 0;
    var random_1 = require_random2();
    var ethers_1 = require_lib2();
    var ethersCompat_1 = require_ethersCompat();
    var EIP1271_ABI = [
      "function isValidSignature(bytes32 _message, bytes _signature) public view returns (bytes4)"
    ];
    var EIP1271_MAGICVALUE = "0x1626ba7e";
    var ISO8601 = /^(?<date>[0-9]{4}-(0[1-9]|1[012])-(0[1-9]|[12][0-9]|3[01]))[Tt]([01][0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9]|60)(.[0-9]+)?(([Zz])|([+|-]([01][0-9]|2[0-3]):[0-5][0-9]))$/;
    var checkContractWalletSignature = (message, signature, provider) => __awaiter2(void 0, void 0, void 0, function* () {
      if (!provider) {
        return false;
      }
      const walletContract = new ethers_1.Contract(message.address, EIP1271_ABI, provider);
      const hashedMessage = (0, ethersCompat_1.hashMessage)(message.prepareMessage());
      const res = yield walletContract.isValidSignature(hashedMessage, signature);
      return res === EIP1271_MAGICVALUE;
    });
    exports.checkContractWalletSignature = checkContractWalletSignature;
    var generateNonce2 = () => {
      const nonce = (0, random_1.randomStringForEntropy)(96);
      if (!nonce || nonce.length < 8) {
        throw new Error("Error during nonce creation.");
      }
      return nonce;
    };
    exports.generateNonce = generateNonce2;
    var isValidISO8601Date = (inputDate) => {
      const inputMatch = ISO8601.exec(inputDate);
      if (!inputDate) {
        return false;
      }
      const inputDateParsed = new Date(inputMatch.groups.date).toISOString();
      const parsedInputMatch = ISO8601.exec(inputDateParsed);
      return inputMatch.groups.date === parsedInputMatch.groups.date;
    };
    exports.isValidISO8601Date = isValidISO8601Date;
    var checkInvalidKeys = (obj, keys) => {
      const invalidKeys = [];
      Object.keys(obj).forEach((key) => {
        if (!keys.includes(key)) {
          invalidKeys.push(key);
        }
      });
      return invalidKeys;
    };
    exports.checkInvalidKeys = checkInvalidKeys;
  }
});

// node_modules/siwe/dist/client.js
var require_client = __commonJS({
  "node_modules/siwe/dist/client.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __setModuleDefault2 = exports && exports.__setModuleDefault || (Object.create ? function(o2, v2) {
      Object.defineProperty(o2, "default", { enumerable: true, value: v2 });
    } : function(o2, v2) {
      o2["default"] = v2;
    });
    var __importStar2 = exports && exports.__importStar || function(mod2) {
      if (mod2 && mod2.__esModule) return mod2;
      var result = {};
      if (mod2 != null) {
        for (var k4 in mod2) if (k4 !== "default" && Object.prototype.hasOwnProperty.call(mod2, k4)) __createBinding2(result, mod2, k4);
      }
      __setModuleDefault2(result, mod2);
      return result;
    };
    var __awaiter2 = exports && exports.__awaiter || function(thisArg, _arguments, P, generator) {
      function adopt(value) {
        return value instanceof P ? value : new P(function(resolve) {
          resolve(value);
        });
      }
      return new (P || (P = Promise))(function(resolve, reject) {
        function fulfilled(value) {
          try {
            step2(generator.next(value));
          } catch (e2) {
            reject(e2);
          }
        }
        function rejected(value) {
          try {
            step2(generator["throw"](value));
          } catch (e2) {
            reject(e2);
          }
        }
        function step2(result) {
          result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
        }
        step2((generator = generator.apply(thisArg, _arguments || [])).next());
      });
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SiweMessage = void 0;
    var siwe_parser_1 = require_parsers();
    var uri = __importStar2(require_valid_url());
    var ethersCompat_1 = require_ethersCompat();
    var types_1 = require_types();
    var utils_1 = require_utils9();
    var SiweMessage = class {
      /**
       * Creates a parsed Sign-In with Ethereum Message (EIP-4361) object from a
       * string or an object. If a string is used an ABNF parser is called to
       * validate the parameter, otherwise the fields are attributed.
       * @param param {string | SiweMessage} Sign message as a string or an object.
       */
      constructor(param) {
        if (typeof param === "string") {
          const parsedMessage = new siwe_parser_1.ParsedMessage(param);
          this.scheme = parsedMessage.scheme;
          this.domain = parsedMessage.domain;
          this.address = parsedMessage.address;
          this.statement = parsedMessage.statement;
          this.uri = parsedMessage.uri;
          this.version = parsedMessage.version;
          this.nonce = parsedMessage.nonce;
          this.issuedAt = parsedMessage.issuedAt;
          this.expirationTime = parsedMessage.expirationTime;
          this.notBefore = parsedMessage.notBefore;
          this.requestId = parsedMessage.requestId;
          this.chainId = parsedMessage.chainId;
          this.resources = parsedMessage.resources;
        } else {
          this.scheme = param === null || param === void 0 ? void 0 : param.scheme;
          this.domain = param.domain;
          this.address = param.address;
          this.statement = param === null || param === void 0 ? void 0 : param.statement;
          this.uri = param.uri;
          this.version = param.version;
          this.chainId = param.chainId;
          this.nonce = param.nonce;
          this.issuedAt = param === null || param === void 0 ? void 0 : param.issuedAt;
          this.expirationTime = param === null || param === void 0 ? void 0 : param.expirationTime;
          this.notBefore = param === null || param === void 0 ? void 0 : param.notBefore;
          this.requestId = param === null || param === void 0 ? void 0 : param.requestId;
          this.resources = param === null || param === void 0 ? void 0 : param.resources;
          if (typeof this.chainId === "string") {
            this.chainId = (0, siwe_parser_1.parseIntegerNumber)(this.chainId);
          }
        }
        this.nonce = this.nonce || (0, utils_1.generateNonce)();
        this.validateMessage();
      }
      /**
       * This function can be used to retrieve an EIP-4361 formated message for
       * signature, although you can call it directly it's advised to use
       * [prepareMessage()] instead which will resolve to the correct method based
       * on the [type] attribute of this object, in case of other formats being
       * implemented.
       * @returns {string} EIP-4361 formated message, ready for EIP-191 signing.
       */
      toMessage() {
        this.validateMessage();
        const headerPrefx = this.scheme ? `${this.scheme}://${this.domain}` : this.domain;
        const header = `${headerPrefx} wants you to sign in with your Ethereum account:`;
        const uriField = `URI: ${this.uri}`;
        let prefix = [header, this.address].join("\n");
        const versionField = `Version: ${this.version}`;
        if (!this.nonce) {
          this.nonce = (0, utils_1.generateNonce)();
        }
        const chainField = `Chain ID: ` + this.chainId || "1";
        const nonceField = `Nonce: ${this.nonce}`;
        const suffixArray = [uriField, versionField, chainField, nonceField];
        this.issuedAt = this.issuedAt || (/* @__PURE__ */ new Date()).toISOString();
        suffixArray.push(`Issued At: ${this.issuedAt}`);
        if (this.expirationTime) {
          const expiryField = `Expiration Time: ${this.expirationTime}`;
          suffixArray.push(expiryField);
        }
        if (this.notBefore) {
          suffixArray.push(`Not Before: ${this.notBefore}`);
        }
        if (this.requestId) {
          suffixArray.push(`Request ID: ${this.requestId}`);
        }
        if (this.resources) {
          suffixArray.push([`Resources:`, ...this.resources.map((x2) => `- ${x2}`)].join("\n"));
        }
        const suffix = suffixArray.join("\n");
        prefix = [prefix, this.statement].join("\n\n");
        if (this.statement) {
          prefix += "\n";
        }
        return [prefix, suffix].join("\n");
      }
      /**
       * This method parses all the fields in the object and creates a messaging for signing
       * message according with the type defined.
       * @returns {string} Returns a message ready to be signed according with the
       * type defined in the object.
       */
      prepareMessage() {
        let message;
        switch (this.version) {
          case "1": {
            message = this.toMessage();
            break;
          }
          default: {
            message = this.toMessage();
            break;
          }
        }
        return message;
      }
      /**
       * @deprecated
       * Verifies the integrity of the object by matching its signature.
       * @param signature Signature to match the address in the message.
       * @param provider Ethers provider to be used for EIP-1271 validation
       */
      validate(signature, provider) {
        return __awaiter2(this, void 0, void 0, function* () {
          console.warn("validate() has been deprecated, please update your code to use verify(). validate() may be removed in future versions.");
          return this.verify({ signature }, { provider, suppressExceptions: false }).then(({ data }) => data).catch(({ error }) => {
            throw error;
          });
        });
      }
      /**
       * Verifies the integrity of the object by matching its signature.
       * @param params Parameters to verify the integrity of the message, signature is required.
       * @returns {Promise<SiweMessage>} This object if valid.
       */
      verify(params, opts = { suppressExceptions: false }) {
        return __awaiter2(this, void 0, void 0, function* () {
          return new Promise((resolve, reject) => {
            var _a2, _b, _c2;
            const fail = (result) => {
              if (opts.suppressExceptions) {
                return resolve(result);
              } else {
                return reject(result);
              }
            };
            const invalidParams = (0, utils_1.checkInvalidKeys)(params, types_1.VerifyParamsKeys);
            if (invalidParams.length > 0) {
              fail({
                success: false,
                data: this,
                error: new Error(`${invalidParams.join(", ")} is/are not valid key(s) for VerifyParams.`)
              });
            }
            const invalidOpts = (0, utils_1.checkInvalidKeys)(opts, types_1.VerifyOptsKeys);
            if (invalidParams.length > 0) {
              fail({
                success: false,
                data: this,
                error: new Error(`${invalidOpts.join(", ")} is/are not valid key(s) for VerifyOpts.`)
              });
            }
            const { signature, scheme, domain, nonce, time: time2 } = params;
            if (scheme && scheme !== this.scheme) {
              fail({
                success: false,
                data: this,
                error: new types_1.SiweError(types_1.SiweErrorType.SCHEME_MISMATCH, scheme, this.scheme)
              });
            }
            if (domain && domain !== this.domain) {
              fail({
                success: false,
                data: this,
                error: new types_1.SiweError(types_1.SiweErrorType.DOMAIN_MISMATCH, domain, this.domain)
              });
            }
            if (nonce && nonce !== this.nonce) {
              fail({
                success: false,
                data: this,
                error: new types_1.SiweError(types_1.SiweErrorType.NONCE_MISMATCH, nonce, this.nonce)
              });
            }
            const checkTime = new Date(time2 || /* @__PURE__ */ new Date());
            if (this.expirationTime) {
              const expirationDate = new Date(this.expirationTime);
              if (checkTime.getTime() >= expirationDate.getTime()) {
                fail({
                  success: false,
                  data: this,
                  error: new types_1.SiweError(types_1.SiweErrorType.EXPIRED_MESSAGE, `${checkTime.toISOString()} < ${expirationDate.toISOString()}`, `${checkTime.toISOString()} >= ${expirationDate.toISOString()}`)
                });
              }
            }
            if (this.notBefore) {
              const notBefore = new Date(this.notBefore);
              if (checkTime.getTime() < notBefore.getTime()) {
                fail({
                  success: false,
                  data: this,
                  error: new types_1.SiweError(types_1.SiweErrorType.NOT_YET_VALID_MESSAGE, `${checkTime.toISOString()} >= ${notBefore.toISOString()}`, `${checkTime.toISOString()} < ${notBefore.toISOString()}`)
                });
              }
            }
            let EIP4361Message;
            try {
              EIP4361Message = this.prepareMessage();
            } catch (e2) {
              fail({
                success: false,
                data: this,
                error: e2
              });
            }
            let addr;
            try {
              addr = (0, ethersCompat_1.verifyMessage)(EIP4361Message, signature);
            } catch (e2) {
              console.error(e2);
            }
            if (addr === this.address) {
              return resolve({
                success: true,
                data: this
              });
            } else {
              const EIP1271Promise = (0, utils_1.checkContractWalletSignature)(this, signature, opts.provider).then((isValid) => {
                if (!isValid) {
                  return {
                    success: false,
                    data: this,
                    error: new types_1.SiweError(types_1.SiweErrorType.INVALID_SIGNATURE, addr, `Resolved address to be ${this.address}`)
                  };
                }
                return {
                  success: true,
                  data: this
                };
              }).catch((error) => {
                return {
                  success: false,
                  data: this,
                  error
                };
              });
              Promise.all([
                EIP1271Promise,
                (_c2 = (_b = (_a2 = opts === null || opts === void 0 ? void 0 : opts.verificationFallback) === null || _a2 === void 0 ? void 0 : _a2.call(opts, params, opts, this, EIP1271Promise)) === null || _b === void 0 ? void 0 : _b.then((res) => res)) === null || _c2 === void 0 ? void 0 : _c2.catch((res) => res)
              ]).then(([EIP1271Response, fallbackResponse]) => {
                if (fallbackResponse) {
                  if (fallbackResponse.success) {
                    return resolve(fallbackResponse);
                  } else {
                    fail(fallbackResponse);
                  }
                } else {
                  if (EIP1271Response.success) {
                    return resolve(EIP1271Response);
                  } else {
                    fail(EIP1271Response);
                  }
                }
              });
            }
          });
        });
      }
      /**
       * Validates the values of this object fields.
       * @throws Throws an {ErrorType} if a field is invalid.
       */
      validateMessage(...args) {
        var _a2;
        if (args.length > 0) {
          throw new types_1.SiweError(types_1.SiweErrorType.UNABLE_TO_PARSE, `Unexpected argument in the validateMessage function.`);
        }
        if (!this.domain || this.domain.length === 0 || !/[^#?]*/.test(this.domain)) {
          throw new types_1.SiweError(types_1.SiweErrorType.INVALID_DOMAIN, `${this.domain} to be a valid domain.`);
        }
        if (!(0, siwe_parser_1.isEIP55Address)(this.address)) {
          throw new types_1.SiweError(types_1.SiweErrorType.INVALID_ADDRESS, (0, ethersCompat_1.getAddress)(this.address), this.address);
        }
        if (!uri.isUri(this.uri)) {
          throw new types_1.SiweError(types_1.SiweErrorType.INVALID_URI, `${this.uri} to be a valid uri.`);
        }
        if (this.version !== "1") {
          throw new types_1.SiweError(types_1.SiweErrorType.INVALID_MESSAGE_VERSION, "1", this.version);
        }
        const nonce = (_a2 = this === null || this === void 0 ? void 0 : this.nonce) === null || _a2 === void 0 ? void 0 : _a2.match(/[a-zA-Z0-9]{8,}/);
        if (!nonce || this.nonce.length < 8 || nonce[0] !== this.nonce) {
          throw new types_1.SiweError(types_1.SiweErrorType.INVALID_NONCE, `Length > 8 (${nonce.length}). Alphanumeric.`, this.nonce);
        }
        if (this.issuedAt) {
          if (!(0, utils_1.isValidISO8601Date)(this.issuedAt)) {
            throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);
          }
        }
        if (this.expirationTime) {
          if (!(0, utils_1.isValidISO8601Date)(this.expirationTime)) {
            throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);
          }
        }
        if (this.notBefore) {
          if (!(0, utils_1.isValidISO8601Date)(this.notBefore)) {
            throw new Error(types_1.SiweErrorType.INVALID_TIME_FORMAT);
          }
        }
      }
    };
    exports.SiweMessage = SiweMessage;
  }
});

// node_modules/siwe/dist/siwe.js
var require_siwe = __commonJS({
  "node_modules/siwe/dist/siwe.js"(exports) {
    "use strict";
    var __createBinding2 = exports && exports.__createBinding || (Object.create ? function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      var desc = Object.getOwnPropertyDescriptor(m3, k4);
      if (!desc || ("get" in desc ? !m3.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m3[k4];
        } };
      }
      Object.defineProperty(o2, k22, desc);
    } : function(o2, m3, k4, k22) {
      if (k22 === void 0) k22 = k4;
      o2[k22] = m3[k4];
    });
    var __exportStar2 = exports && exports.__exportStar || function(m3, exports2) {
      for (var p2 in m3) if (p2 !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p2)) __createBinding2(exports2, m3, p2);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    __exportStar2(require_client(), exports);
    __exportStar2(require_types(), exports);
    __exportStar2(require_utils9(), exports);
  }
});

// node_modules/@bedrock_org/passport/dist/index.es.js
var f2 = __toESM(require_react());
var import_react72 = __toESM(require_react());
var ri = __toESM(require_react_dom());
var import_react_dom2 = __toESM(require_react_dom());

// node_modules/wagmi/dist/esm/context.js
var import_react2 = __toESM(require_react(), 1);

// node_modules/@wagmi/core/dist/esm/utils/getAction.js
function getAction(client, actionFn, name) {
  const action_implicit = client[actionFn.name];
  if (typeof action_implicit === "function")
    return action_implicit;
  const action_explicit = client[name];
  if (typeof action_explicit === "function")
    return action_explicit;
  return (params) => actionFn(client, params);
}

// node_modules/@wagmi/core/dist/esm/version.js
var version = "2.17.0";

// node_modules/@wagmi/core/dist/esm/utils/getVersion.js
var getVersion = () => `@wagmi/core@${version}`;

// node_modules/@wagmi/core/dist/esm/errors/base.js
var __classPrivateFieldGet = function(receiver, state, kind, f3) {
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _BaseError_instances;
var _BaseError_walk;
var BaseError3 = class _BaseError extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return getVersion();
  }
  constructor(shortMessage, options = {}) {
    var _a2;
    super();
    _BaseError_instances.add(this);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiCoreError"
    });
    const details = options.cause instanceof _BaseError ? options.cause.details : ((_a2 = options.cause) == null ? void 0 : _a2.message) ? options.cause.message : options.details;
    const docsPath = options.cause instanceof _BaseError ? options.cause.docsPath || options.docsPath : options.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...options.metaMessages ? [...options.metaMessages, ""] : [],
      ...docsPath ? [
        `Docs: ${this.docsBaseUrl}${docsPath}.html${options.docsSlug ? `#${options.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (options.cause)
      this.cause = options.cause;
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = options.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn2) {
    return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk).call(this, this, fn2);
  }
};
_BaseError_instances = /* @__PURE__ */ new WeakSet(), _BaseError_walk = function _BaseError_walk2(err, fn2) {
  if (fn2 == null ? void 0 : fn2(err))
    return err;
  if (err.cause)
    return __classPrivateFieldGet(this, _BaseError_instances, "m", _BaseError_walk2).call(this, err.cause, fn2);
  return err;
};

// node_modules/@wagmi/core/dist/esm/errors/config.js
var ChainNotConfiguredError = class extends BaseError3 {
  constructor() {
    super("Chain not configured.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotConfiguredError"
    });
  }
};
var ConnectorAlreadyConnectedError = class extends BaseError3 {
  constructor() {
    super("Connector already connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAlreadyConnectedError"
    });
  }
};
var ConnectorNotConnectedError = class extends BaseError3 {
  constructor() {
    super("Connector not connected.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorNotConnectedError"
    });
  }
};
var ConnectorAccountNotFoundError = class extends BaseError3 {
  constructor({ address, connector }) {
    super(`Account "${address}" not found for connector "${connector.name}".`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorAccountNotFoundError"
    });
  }
};
var ConnectorChainMismatchError = class extends BaseError3 {
  constructor({ connectionChainId, connectorChainId }) {
    super(`The current chain of the connector (id: ${connectorChainId}) does not match the connection's chain (id: ${connectionChainId}).`, {
      metaMessages: [
        `Current Chain ID:  ${connectorChainId}`,
        `Expected Chain ID: ${connectionChainId}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorChainMismatchError"
    });
  }
};
var ConnectorUnavailableReconnectingError = class extends BaseError3 {
  constructor({ connector }) {
    super(`Connector "${connector.name}" unavailable while reconnecting.`, {
      details: [
        "During the reconnection step, the only connector methods guaranteed to be available are: `id`, `name`, `type`, `uid`.",
        "All other methods are not guaranteed to be available until reconnection completes and connectors are fully restored.",
        "This error commonly occurs for connectors that asynchronously inject after reconnection has already started."
      ].join(" ")
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ConnectorUnavailableReconnectingError"
    });
  }
};

// node_modules/@wagmi/core/dist/esm/actions/connect.js
async function connect(config, parameters) {
  var _a2;
  let connector;
  if (typeof parameters.connector === "function") {
    connector = config._internal.connectors.setup(parameters.connector);
  } else
    connector = parameters.connector;
  if (connector.uid === config.state.current)
    throw new ConnectorAlreadyConnectedError();
  try {
    config.setState((x2) => ({ ...x2, status: "connecting" }));
    connector.emitter.emit("message", { type: "connecting" });
    const { connector: _2, ...rest } = parameters;
    const data = await connector.connect(rest);
    const accounts = data.accounts;
    connector.emitter.off("connect", config._internal.events.connect);
    connector.emitter.on("change", config._internal.events.change);
    connector.emitter.on("disconnect", config._internal.events.disconnect);
    await ((_a2 = config.storage) == null ? void 0 : _a2.setItem("recentConnectorId", connector.id));
    config.setState((x2) => ({
      ...x2,
      connections: new Map(x2.connections).set(connector.uid, {
        accounts,
        chainId: data.chainId,
        connector
      }),
      current: connector.uid,
      status: "connected"
    }));
    return { accounts, chainId: data.chainId };
  } catch (error) {
    config.setState((x2) => ({
      ...x2,
      // Keep existing connector connected in case of error
      status: x2.current ? "connected" : "disconnected"
    }));
    throw error;
  }
}

// node_modules/@wagmi/core/dist/esm/actions/getConnectorClient.js
async function getConnectorClient(config, parameters = {}) {
  let connection;
  if (parameters.connector) {
    const { connector: connector2 } = parameters;
    if (config.state.status === "reconnecting" && !connector2.getAccounts && !connector2.getChainId)
      throw new ConnectorUnavailableReconnectingError({ connector: connector2 });
    const [accounts, chainId2] = await Promise.all([
      connector2.getAccounts().catch((e2) => {
        if (parameters.account === null)
          return [];
        throw e2;
      }),
      connector2.getChainId()
    ]);
    connection = {
      accounts,
      chainId: chainId2,
      connector: connector2
    };
  } else
    connection = config.state.connections.get(config.state.current);
  if (!connection)
    throw new ConnectorNotConnectedError();
  const chainId = parameters.chainId ?? connection.chainId;
  const connectorChainId = await connection.connector.getChainId();
  if (connectorChainId !== connection.chainId)
    throw new ConnectorChainMismatchError({
      connectionChainId: connection.chainId,
      connectorChainId
    });
  const connector = connection.connector;
  if (connector.getClient)
    return connector.getClient({ chainId });
  const account = parseAccount(parameters.account ?? connection.accounts[0]);
  if (account)
    account.address = getAddress(account.address);
  if (parameters.account && !connection.accounts.some((x2) => x2.toLowerCase() === account.address.toLowerCase()))
    throw new ConnectorAccountNotFoundError({
      address: account.address,
      connector
    });
  const chain2 = config.chains.find((chain3) => chain3.id === chainId);
  const provider = await connection.connector.getProvider({ chainId });
  return createClient({
    account,
    chain: chain2,
    name: "Connector Client",
    transport: (opts) => custom(provider)({ ...opts, retryCount: 0 })
  });
}

// node_modules/@wagmi/core/dist/esm/actions/disconnect.js
async function disconnect(config, parameters = {}) {
  var _a2, _b;
  let connector;
  if (parameters.connector)
    connector = parameters.connector;
  else {
    const { connections: connections2, current } = config.state;
    const connection = connections2.get(current);
    connector = connection == null ? void 0 : connection.connector;
  }
  const connections = config.state.connections;
  if (connector) {
    await connector.disconnect();
    connector.emitter.off("change", config._internal.events.change);
    connector.emitter.off("disconnect", config._internal.events.disconnect);
    connector.emitter.on("connect", config._internal.events.connect);
    connections.delete(connector.uid);
  }
  config.setState((x2) => {
    if (connections.size === 0)
      return {
        ...x2,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      };
    const nextConnection = connections.values().next().value;
    return {
      ...x2,
      connections: new Map(connections),
      current: nextConnection.connector.uid
    };
  });
  {
    const current = config.state.current;
    if (!current)
      return;
    const connector2 = (_a2 = config.state.connections.get(current)) == null ? void 0 : _a2.connector;
    if (!connector2)
      return;
    await ((_b = config.storage) == null ? void 0 : _b.setItem("recentConnectorId", connector2.id));
  }
}

// node_modules/@wagmi/core/dist/esm/utils/getUnit.js
function getUnit(unit) {
  if (typeof unit === "number")
    return unit;
  if (unit === "wei")
    return 0;
  return Math.abs(weiUnits[unit]);
}

// node_modules/@wagmi/core/dist/esm/actions/getAccount.js
function getAccount(config) {
  const uid3 = config.state.current;
  const connection = config.state.connections.get(uid3);
  const addresses = connection == null ? void 0 : connection.accounts;
  const address = addresses == null ? void 0 : addresses[0];
  const chain2 = config.chains.find((chain3) => chain3.id === (connection == null ? void 0 : connection.chainId));
  const status = config.state.status;
  switch (status) {
    case "connected":
      return {
        address,
        addresses,
        chain: chain2,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "reconnecting":
      return {
        address,
        addresses,
        chain: chain2,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: !!address,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status
      };
    case "connecting":
      return {
        address,
        addresses,
        chain: chain2,
        chainId: connection == null ? void 0 : connection.chainId,
        connector: connection == null ? void 0 : connection.connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status
      };
  }
}

// node_modules/@wagmi/core/dist/esm/actions/multicall.js
async function multicall2(config, parameters) {
  const { allowFailure = true, chainId, contracts: contracts2, ...rest } = parameters;
  const client = config.getClient({ chainId });
  const action = getAction(client, multicall, "multicall");
  return action({
    allowFailure,
    contracts: contracts2,
    ...rest
  });
}

// node_modules/@wagmi/core/dist/esm/actions/readContract.js
function readContract2(config, parameters) {
  const { chainId, ...rest } = parameters;
  const client = config.getClient({ chainId });
  const action = getAction(client, readContract, "readContract");
  return action(rest);
}

// node_modules/@wagmi/core/dist/esm/actions/readContracts.js
async function readContracts(config, parameters) {
  var _a2;
  const { allowFailure = true, blockNumber, blockTag, ...rest } = parameters;
  const contracts2 = parameters.contracts;
  try {
    const contractsByChainId = {};
    for (const [index5, contract] of contracts2.entries()) {
      const chainId = contract.chainId ?? config.state.chainId;
      if (!contractsByChainId[chainId])
        contractsByChainId[chainId] = [];
      (_a2 = contractsByChainId[chainId]) == null ? void 0 : _a2.push({ contract, index: index5 });
    }
    const promises = () => Object.entries(contractsByChainId).map(([chainId, contracts3]) => multicall2(config, {
      ...rest,
      allowFailure,
      blockNumber,
      blockTag,
      chainId: Number.parseInt(chainId),
      contracts: contracts3.map(({ contract }) => contract)
    }));
    const multicallResults = (await Promise.all(promises())).flat();
    const resultIndexes = Object.values(contractsByChainId).flatMap((contracts3) => contracts3.map(({ index: index5 }) => index5));
    return multicallResults.reduce((results2, result, index5) => {
      if (results2)
        results2[resultIndexes[index5]] = result;
      return results2;
    }, []);
  } catch (error) {
    if (error instanceof ContractFunctionExecutionError)
      throw error;
    const promises = () => contracts2.map((contract) => readContract2(config, { ...contract, blockNumber, blockTag }));
    if (allowFailure)
      return (await Promise.allSettled(promises())).map((result) => {
        if (result.status === "fulfilled")
          return { result: result.value, status: "success" };
        return { error: result.reason, result: void 0, status: "failure" };
      });
    return await Promise.all(promises());
  }
}

// node_modules/@wagmi/core/dist/esm/actions/getBalance.js
async function getBalance2(config, parameters) {
  const { address, blockNumber, blockTag, chainId, token: tokenAddress, unit = "ether" } = parameters;
  if (tokenAddress) {
    try {
      return await getTokenBalance(config, {
        balanceAddress: address,
        chainId,
        symbolType: "string",
        tokenAddress
      });
    } catch (error) {
      if (error.name === "ContractFunctionExecutionError") {
        const balance = await getTokenBalance(config, {
          balanceAddress: address,
          chainId,
          symbolType: "bytes32",
          tokenAddress
        });
        const symbol = hexToString(trim(balance.symbol, { dir: "right" }));
        return { ...balance, symbol };
      }
      throw error;
    }
  }
  const client = config.getClient({ chainId });
  const action = getAction(client, getBalance, "getBalance");
  const value = await action(blockNumber ? { address, blockNumber } : { address, blockTag });
  const chain2 = config.chains.find((x2) => x2.id === chainId) ?? client.chain;
  return {
    decimals: chain2.nativeCurrency.decimals,
    formatted: formatUnits(value, getUnit(unit)),
    symbol: chain2.nativeCurrency.symbol,
    value
  };
}
async function getTokenBalance(config, parameters) {
  const { balanceAddress, chainId, symbolType, tokenAddress, unit } = parameters;
  const contract = {
    abi: [
      {
        type: "function",
        name: "balanceOf",
        stateMutability: "view",
        inputs: [{ type: "address" }],
        outputs: [{ type: "uint256" }]
      },
      {
        type: "function",
        name: "decimals",
        stateMutability: "view",
        inputs: [],
        outputs: [{ type: "uint8" }]
      },
      {
        type: "function",
        name: "symbol",
        stateMutability: "view",
        inputs: [],
        outputs: [{ type: symbolType }]
      }
    ],
    address: tokenAddress
  };
  const [value, decimals, symbol] = await readContracts(config, {
    allowFailure: false,
    contracts: [
      {
        ...contract,
        functionName: "balanceOf",
        args: [balanceAddress],
        chainId
      },
      { ...contract, functionName: "decimals", chainId },
      { ...contract, functionName: "symbol", chainId }
    ]
  });
  const formatted = formatUnits(value ?? "0", getUnit(unit ?? decimals));
  return { decimals, formatted, symbol, value };
}

// node_modules/@wagmi/core/dist/esm/actions/getBlockNumber.js
function getBlockNumber2(config, parameters = {}) {
  const { chainId, ...rest } = parameters;
  const client = config.getClient({ chainId });
  const action = getAction(client, getBlockNumber, "getBlockNumber");
  return action(rest);
}

// node_modules/@wagmi/core/dist/esm/actions/getChainId.js
function getChainId2(config) {
  return config.state.chainId;
}

// node_modules/@wagmi/core/dist/esm/utils/deepEqual.js
function deepEqual(a3, b4) {
  if (a3 === b4)
    return true;
  if (a3 && b4 && typeof a3 === "object" && typeof b4 === "object") {
    if (a3.constructor !== b4.constructor)
      return false;
    let length2;
    let i2;
    if (Array.isArray(a3) && Array.isArray(b4)) {
      length2 = a3.length;
      if (length2 !== b4.length)
        return false;
      for (i2 = length2; i2-- !== 0; )
        if (!deepEqual(a3[i2], b4[i2]))
          return false;
      return true;
    }
    if (a3.valueOf !== Object.prototype.valueOf)
      return a3.valueOf() === b4.valueOf();
    if (a3.toString !== Object.prototype.toString)
      return a3.toString() === b4.toString();
    const keys = Object.keys(a3);
    length2 = keys.length;
    if (length2 !== Object.keys(b4).length)
      return false;
    for (i2 = length2; i2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(b4, keys[i2]))
        return false;
    for (i2 = length2; i2-- !== 0; ) {
      const key = keys[i2];
      if (key && !deepEqual(a3[key], b4[key]))
        return false;
    }
    return true;
  }
  return a3 !== a3 && b4 !== b4;
}

// node_modules/@wagmi/core/dist/esm/actions/getChains.js
var previousChains = [];
function getChains(config) {
  const chains = config.chains;
  if (deepEqual(previousChains, chains))
    return previousChains;
  previousChains = chains;
  return chains;
}

// node_modules/@wagmi/core/dist/esm/actions/getConnections.js
var previousConnections = [];
function getConnections(config) {
  const connections = [...config.state.connections.values()];
  if (config.state.status === "reconnecting")
    return previousConnections;
  if (deepEqual(previousConnections, connections))
    return previousConnections;
  previousConnections = connections;
  return connections;
}

// node_modules/@wagmi/core/dist/esm/actions/getConnectors.js
var previousConnectors = [];
function getConnectors(config) {
  const connectors = config.connectors;
  if (deepEqual(previousConnectors, connectors))
    return previousConnectors;
  previousConnectors = connectors;
  return connectors;
}

// node_modules/@wagmi/core/dist/esm/actions/getEnsAddress.js
function getEnsAddress2(config, parameters) {
  const { chainId, ...rest } = parameters;
  const client = config.getClient({ chainId });
  const action = getAction(client, getEnsAddress, "getEnsAddress");
  return action(rest);
}

// node_modules/@wagmi/core/dist/esm/actions/getEnsAvatar.js
function getEnsAvatar2(config, parameters) {
  const { chainId, ...rest } = parameters;
  const client = config.getClient({ chainId });
  const action = getAction(client, getEnsAvatar, "getEnsAvatar");
  return action(rest);
}

// node_modules/@wagmi/core/dist/esm/actions/getEnsName.js
function getEnsName2(config, parameters) {
  const { chainId, ...rest } = parameters;
  const client = config.getClient({ chainId });
  const action = getAction(client, getEnsName, "getEnsName");
  return action(rest);
}

// node_modules/@wagmi/core/dist/esm/actions/reconnect.js
var isReconnecting = false;
async function reconnect(config, parameters = {}) {
  var _a2, _b;
  if (isReconnecting)
    return [];
  isReconnecting = true;
  config.setState((x2) => ({
    ...x2,
    status: x2.current ? "reconnecting" : "connecting"
  }));
  const connectors = [];
  if ((_a2 = parameters.connectors) == null ? void 0 : _a2.length) {
    for (const connector_ of parameters.connectors) {
      let connector;
      if (typeof connector_ === "function")
        connector = config._internal.connectors.setup(connector_);
      else
        connector = connector_;
      connectors.push(connector);
    }
  } else
    connectors.push(...config.connectors);
  let recentConnectorId;
  try {
    recentConnectorId = await ((_b = config.storage) == null ? void 0 : _b.getItem("recentConnectorId"));
  } catch {
  }
  const scores = {};
  for (const [, connection] of config.state.connections) {
    scores[connection.connector.id] = 1;
  }
  if (recentConnectorId)
    scores[recentConnectorId] = 0;
  const sorted = Object.keys(scores).length > 0 ? (
    // .toSorted()
    [...connectors].sort((a3, b4) => (scores[a3.id] ?? 10) - (scores[b4.id] ?? 10))
  ) : connectors;
  let connected = false;
  const connections = [];
  const providers = [];
  for (const connector of sorted) {
    const provider = await connector.getProvider().catch(() => void 0);
    if (!provider)
      continue;
    if (providers.some((x2) => x2 === provider))
      continue;
    const isAuthorized = await connector.isAuthorized();
    if (!isAuthorized)
      continue;
    const data = await connector.connect({ isReconnecting: true }).catch(() => null);
    if (!data)
      continue;
    connector.emitter.off("connect", config._internal.events.connect);
    connector.emitter.on("change", config._internal.events.change);
    connector.emitter.on("disconnect", config._internal.events.disconnect);
    config.setState((x2) => {
      const connections2 = new Map(connected ? x2.connections : /* @__PURE__ */ new Map()).set(connector.uid, { accounts: data.accounts, chainId: data.chainId, connector });
      return {
        ...x2,
        current: connected ? x2.current : connector.uid,
        connections: connections2
      };
    });
    connections.push({
      accounts: data.accounts,
      chainId: data.chainId,
      connector
    });
    providers.push(provider);
    connected = true;
  }
  if (config.state.status === "reconnecting" || config.state.status === "connecting") {
    if (!connected)
      config.setState((x2) => ({
        ...x2,
        connections: /* @__PURE__ */ new Map(),
        current: null,
        status: "disconnected"
      }));
    else
      config.setState((x2) => ({ ...x2, status: "connected" }));
  }
  isReconnecting = false;
  return connections;
}

// node_modules/@wagmi/core/dist/esm/actions/signMessage.js
async function signMessage2(config, parameters) {
  const { account, connector, ...rest } = parameters;
  let client;
  if (typeof account === "object" && account.type === "local")
    client = config.getClient();
  else
    client = await getConnectorClient(config, { account, connector });
  const action = getAction(client, signMessage, "signMessage");
  return action({
    ...rest,
    ...account ? { account } : {}
  });
}

// node_modules/@wagmi/core/dist/esm/errors/connector.js
var ProviderNotFoundError = class extends BaseError3 {
  constructor() {
    super("Provider not found.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderNotFoundError"
    });
  }
};
var SwitchChainNotSupportedError = class extends BaseError3 {
  constructor({ connector }) {
    super(`"${connector.name}" does not support programmatic chain switching.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "SwitchChainNotSupportedError"
    });
  }
};

// node_modules/@wagmi/core/dist/esm/actions/switchChain.js
async function switchChain2(config, parameters) {
  var _a2;
  const { addEthereumChainParameter, chainId } = parameters;
  const connection = config.state.connections.get(((_a2 = parameters.connector) == null ? void 0 : _a2.uid) ?? config.state.current);
  if (connection) {
    const connector = connection.connector;
    if (!connector.switchChain)
      throw new SwitchChainNotSupportedError({ connector });
    const chain3 = await connector.switchChain({
      addEthereumChainParameter,
      chainId
    });
    return chain3;
  }
  const chain2 = config.chains.find((x2) => x2.id === chainId);
  if (!chain2)
    throw new ChainNotConfiguredError();
  config.setState((x2) => ({ ...x2, chainId }));
  return chain2;
}

// node_modules/@wagmi/core/dist/esm/actions/watchAccount.js
function watchAccount(config, parameters) {
  const { onChange } = parameters;
  return config.subscribe(() => getAccount(config), onChange, {
    equalityFn(a3, b4) {
      const { connector: aConnector, ...aRest } = a3;
      const { connector: bConnector, ...bRest } = b4;
      return deepEqual(aRest, bRest) && // check connector separately
      (aConnector == null ? void 0 : aConnector.id) === (bConnector == null ? void 0 : bConnector.id) && (aConnector == null ? void 0 : aConnector.uid) === (bConnector == null ? void 0 : bConnector.uid);
    }
  });
}

// node_modules/@wagmi/core/dist/esm/actions/watchBlockNumber.js
function watchBlockNumber2(config, parameters) {
  const { syncConnectedChain = config._internal.syncConnectedChain, ...rest } = parameters;
  let unwatch;
  const listener = (chainId) => {
    if (unwatch)
      unwatch();
    const client = config.getClient({ chainId });
    const action = getAction(client, watchBlockNumber, "watchBlockNumber");
    unwatch = action(rest);
    return unwatch;
  };
  const unlisten = listener(parameters.chainId);
  let unsubscribe;
  if (syncConnectedChain && !parameters.chainId)
    unsubscribe = config.subscribe(({ chainId }) => chainId, async (chainId) => listener(chainId));
  return () => {
    unlisten == null ? void 0 : unlisten();
    unsubscribe == null ? void 0 : unsubscribe();
  };
}

// node_modules/@wagmi/core/dist/esm/actions/watchChainId.js
function watchChainId(config, parameters) {
  const { onChange } = parameters;
  return config.subscribe((state) => state.chainId, onChange);
}

// node_modules/@wagmi/core/dist/esm/actions/watchConnections.js
function watchConnections(config, parameters) {
  const { onChange } = parameters;
  return config.subscribe(() => getConnections(config), onChange, {
    equalityFn: deepEqual
  });
}

// node_modules/@wagmi/core/dist/esm/actions/watchConnectors.js
function watchConnectors(config, parameters) {
  const { onChange } = parameters;
  return config._internal.connectors.subscribe((connectors, prevConnectors) => {
    onChange(Object.values(connectors), prevConnectors);
  });
}

// node_modules/@wagmi/core/dist/esm/connectors/createConnector.js
function createConnector(createConnectorFn) {
  return createConnectorFn;
}

// node_modules/@wagmi/core/dist/esm/connectors/injected.js
injected.type = "injected";
function injected(parameters = {}) {
  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string")
      return {
        ...targetMap[target] ?? {
          id: target,
          name: `${target[0].toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0].toUpperCase()}${target.slice(1)}`
        }
      };
    return {
      id: "injected",
      name: "Injected",
      provider(window2) {
        return window2 == null ? void 0 : window2.ethereum;
      }
    };
  }
  let accountsChanged;
  let chainChanged;
  let connect3;
  let disconnect3;
  return createConnector((config) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return getTarget().id;
    },
    get name() {
      return getTarget().name;
    },
    /** @deprecated */
    get supportsSimulation() {
      return true;
    },
    type: injected.type,
    async setup() {
      const provider = await this.getProvider();
      if ((provider == null ? void 0 : provider.on) && parameters.target) {
        if (!connect3) {
          connect3 = this.onConnect.bind(this);
          provider.on("connect", connect3);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      var _a2, _b, _c2, _d, _e2, _f;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      let accounts = [];
      if (isReconnecting2)
        accounts = await this.getAccounts().catch(() => []);
      else if (shimDisconnect) {
        try {
          const permissions = await provider.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
          accounts = (_d = (_c2 = (_b = (_a2 = permissions[0]) == null ? void 0 : _a2.caveats) == null ? void 0 : _b[0]) == null ? void 0 : _c2.value) == null ? void 0 : _d.map((x2) => getAddress(x2));
          if (accounts.length > 0) {
            const sortedAccounts = await this.getAccounts();
            accounts = sortedAccounts;
          }
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error);
          if (error.code === ResourceUnavailableRpcError.code)
            throw error;
        }
      }
      try {
        if (!(accounts == null ? void 0 : accounts.length) && !isReconnecting2) {
          const requestedAccounts = await provider.request({
            method: "eth_requestAccounts"
          });
          accounts = requestedAccounts.map((x2) => getAddress(x2));
        }
        if (connect3) {
          provider.removeListener("connect", connect3);
          connect3 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect3) {
          disconnect3 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect3);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain2 = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain2 == null ? void 0 : chain2.id) ?? currentChainId;
        }
        if (shimDisconnect)
          await ((_e2 = config.storage) == null ? void 0 : _e2.removeItem(`${this.id}.disconnected`));
        if (!parameters.target)
          await ((_f = config.storage) == null ? void 0 : _f.setItem("injected.connected", true));
        return { accounts, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a2, _b;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
      if (!connect3) {
        connect3 = this.onConnect.bind(this);
        provider.on("connect", connect3);
      }
      try {
        await withTimeout(() => (
          // TODO: Remove explicit type for viem@3
          provider.request({
            // `'wallet_revokePermissions'` added in `viem@2.10.3`
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }]
          })
        ), { timeout: 100 });
      } catch {
      }
      if (shimDisconnect) {
        await ((_a2 = config.storage) == null ? void 0 : _a2.setItem(`${this.id}.disconnected`, true));
      }
      if (!parameters.target)
        await ((_b = config.storage) == null ? void 0 : _b.removeItem("injected.connected"));
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const accounts = await provider.request({ method: "eth_accounts" });
      return accounts.map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return Number(hexChainId);
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      let provider;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider = target.provider(window);
      else if (typeof target.provider === "string")
        provider = findProvider(window, target.provider);
      else
        provider = target.provider;
      if (provider && !provider.removeListener) {
        if ("off" in provider && typeof provider.off === "function")
          provider.removeListener = provider.off;
        else
          provider.removeListener = () => {
          };
      }
      return provider;
    },
    async isAuthorized() {
      var _a2, _b;
      try {
        const isDisconnected = shimDisconnect && // If shim exists in storage, connector is disconnected
        await ((_a2 = config.storage) == null ? void 0 : _a2.getItem(`${this.id}.disconnected`));
        if (isDisconnected)
          return false;
        if (!parameters.target) {
          const connected = await ((_b = config.storage) == null ? void 0 : _b.getItem("injected.connected"));
          if (!connected)
            return false;
        }
        const provider = await this.getProvider();
        if (!provider) {
          if (unstable_shimAsyncInject !== void 0 && unstable_shimAsyncInject !== false) {
            const handleEthereum = async () => {
              if (typeof window !== "undefined")
                window.removeEventListener("ethereum#initialized", handleEthereum);
              const provider2 = await this.getProvider();
              return !!provider2;
            };
            const timeout = typeof unstable_shimAsyncInject === "number" ? unstable_shimAsyncInject : 1e3;
            const res = await Promise.race([
              ...typeof window !== "undefined" ? [
                new Promise((resolve) => window.addEventListener("ethereum#initialized", () => resolve(handleEthereum()), { once: true }))
              ] : [],
              new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout))
            ]);
            if (res)
              return true;
          }
          throw new ProviderNotFoundError();
        }
        const accounts = await withRetry(() => this.getAccounts());
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b, _c2, _d;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain2 = config.chains.find((x2) => x2.id === chainId);
      if (!chain2)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const promise = new Promise((resolve) => {
        const listener = (data) => {
          if ("chainId" in data && data.chainId === chainId) {
            config.emitter.off("change", listener);
            resolve();
          }
        };
        config.emitter.on("change", listener);
      });
      try {
        await Promise.all([
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config.emitter.emit("change", { chainId });
          }),
          promise
        ]);
        return chain2;
      } catch (err) {
        const error = err;
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((_b = (_a2 = error == null ? void 0 : error.data) == null ? void 0 : _a2.originalError) == null ? void 0 : _b.code) === 4902) {
          try {
            const { default: blockExplorer, ...blockExplorers } = chain2.blockExplorers ?? {};
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else if (blockExplorer)
              blockExplorerUrls = [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x2) => x2.url)
              ];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d = chain2.rpcUrls.default) == null ? void 0 : _d.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain2.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain2.nativeCurrency,
              rpcUrls
            };
            await Promise.all([
              provider.request({
                method: "wallet_addEthereumChain",
                params: [addEthereumChain]
              }).then(async () => {
                const currentChainId = await this.getChainId();
                if (currentChainId === chainId)
                  config.emitter.emit("change", { chainId });
                else
                  throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
              }),
              promise
            ]);
            return chain2;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    },
    async onAccountsChanged(accounts) {
      var _a2;
      if (accounts.length === 0)
        this.onDisconnect();
      else if (config.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
        if (shimDisconnect)
          await ((_a2 = config.storage) == null ? void 0 : _a2.removeItem(`${this.id}.disconnected`));
      } else
        config.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain2) {
      const chainId = Number(chain2);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts();
      if (accounts.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config.emitter.emit("connect", { accounts, chainId });
      const provider = await this.getProvider();
      if (provider) {
        if (connect3) {
          provider.removeListener("connect", connect3);
          connect3 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect3) {
          disconnect3 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect3);
        }
      }
    },
    async onDisconnect(error) {
      const provider = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider && !!(await this.getAccounts()).length)
          return;
      }
      config.emitter.emit("disconnect");
      if (provider) {
        if (chainChanged) {
          provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect3) {
          provider.removeListener("disconnect", disconnect3);
          disconnect3 = void 0;
        }
        if (!connect3) {
          connect3 = this.onConnect.bind(this);
          provider.on("connect", connect3);
        }
      }
    }
  }));
}
var targetMap = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(window2) {
      if (window2 == null ? void 0 : window2.coinbaseWalletExtension)
        return window2.coinbaseWalletExtension;
      return findProvider(window2, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(window2) {
      return findProvider(window2, (provider) => {
        if (!provider.isMetaMask)
          return false;
        if (provider.isBraveWallet && !provider._events && !provider._state)
          return false;
        const flags = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPhantom",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion"
        ];
        for (const flag of flags)
          if (provider[flag])
            return false;
        return true;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(window2) {
      var _a2, _b;
      if ((_a2 = window2 == null ? void 0 : window2.phantom) == null ? void 0 : _a2.ethereum)
        return (_b = window2.phantom) == null ? void 0 : _b.ethereum;
      return findProvider(window2, "isPhantom");
    }
  }
};
function findProvider(window2, select) {
  function isProvider(provider) {
    if (typeof select === "function")
      return select(provider);
    if (typeof select === "string")
      return provider[select];
    return true;
  }
  const ethereum = window2.ethereum;
  if (ethereum == null ? void 0 : ethereum.providers)
    return ethereum.providers.find((provider) => isProvider(provider));
  if (ethereum && isProvider(ethereum))
    return ethereum;
  return void 0;
}

// node_modules/@wagmi/core/dist/esm/connectors/mock.js
mock.type = "mock";
function mock(parameters) {
  const transactionCache = /* @__PURE__ */ new Map();
  const features = parameters.features ?? { defaultConnected: false };
  let connected = features.defaultConnected;
  let connectedChainId;
  return createConnector((config) => ({
    id: "mock",
    name: "Mock Connector",
    type: mock.type,
    async setup() {
      connectedChainId = config.chains[0].id;
    },
    async connect({ chainId } = {}) {
      if (features.connectError) {
        if (typeof features.connectError === "boolean")
          throw new UserRejectedRequestError(new Error("Failed to connect."));
        throw features.connectError;
      }
      const provider = await this.getProvider();
      const accounts = await provider.request({
        method: "eth_requestAccounts"
      });
      let currentChainId = await this.getChainId();
      if (chainId && currentChainId !== chainId) {
        const chain2 = await this.switchChain({ chainId });
        currentChainId = chain2.id;
      }
      connected = true;
      return {
        accounts: accounts.map((x2) => getAddress(x2)),
        chainId: currentChainId
      };
    },
    async disconnect() {
      connected = false;
    },
    async getAccounts() {
      if (!connected)
        throw new ConnectorNotConnectedError();
      const provider = await this.getProvider();
      const accounts = await provider.request({ method: "eth_accounts" });
      return accounts.map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return fromHex(hexChainId, "number");
    },
    async isAuthorized() {
      if (!features.reconnect)
        return false;
      if (!connected)
        return false;
      const accounts = await this.getAccounts();
      return !!accounts.length;
    },
    async switchChain({ chainId }) {
      const provider = await this.getProvider();
      const chain2 = config.chains.find((x2) => x2.id === chainId);
      if (!chain2)
        throw new SwitchChainError(new ChainNotConfiguredError());
      await provider.request({
        method: "wallet_switchEthereumChain",
        params: [{ chainId: numberToHex(chainId) }]
      });
      return chain2;
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain2) {
      const chainId = Number(chain2);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config.emitter.emit("disconnect");
      connected = false;
    },
    async getProvider({ chainId } = {}) {
      const chain2 = config.chains.find((x2) => x2.id === chainId) ?? config.chains[0];
      const url = chain2.rpcUrls.default.http[0];
      const request = async ({ method, params }) => {
        if (method === "eth_chainId")
          return numberToHex(connectedChainId);
        if (method === "eth_requestAccounts")
          return parameters.accounts;
        if (method === "eth_signTypedData_v4") {
          if (features.signTypedDataError) {
            if (typeof features.signTypedDataError === "boolean")
              throw new UserRejectedRequestError(new Error("Failed to sign typed data."));
            throw features.signTypedDataError;
          }
        }
        if (method === "wallet_switchEthereumChain") {
          if (features.switchChainError) {
            if (typeof features.switchChainError === "boolean")
              throw new UserRejectedRequestError(new Error("Failed to switch chain."));
            throw features.switchChainError;
          }
          connectedChainId = fromHex(params[0].chainId, "number");
          this.onChainChanged(connectedChainId.toString());
          return;
        }
        if (method === "wallet_watchAsset") {
          if (features.watchAssetError) {
            if (typeof features.watchAssetError === "boolean")
              throw new UserRejectedRequestError(new Error("Failed to switch chain."));
            throw features.watchAssetError;
          }
          return connected;
        }
        if (method === "wallet_getCapabilities")
          return {
            "0x2105": {
              paymasterService: {
                supported: params[0] === "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
              },
              sessionKeys: {
                supported: true
              }
            },
            "0x14A34": {
              paymasterService: {
                supported: params[0] === "0xf39Fd6e51aad88F6F4ce6aB8827279cffFb92266"
              }
            }
          };
        if (method === "wallet_sendCalls") {
          const hashes = [];
          const calls = params[0].calls;
          for (const call3 of calls) {
            const { result: result2, error: error2 } = await rpc.http(url, {
              body: {
                method: "eth_sendTransaction",
                params: [call3]
              }
            });
            if (error2)
              throw new RpcRequestError({
                body: { method, params },
                error: error2,
                url
              });
            hashes.push(result2);
          }
          const id3 = keccak256(stringToHex(JSON.stringify(calls)));
          transactionCache.set(id3, hashes);
          return { id: id3 };
        }
        if (method === "wallet_getCallsStatus") {
          const hashes = transactionCache.get(params[0]);
          if (!hashes)
            return {
              atomic: false,
              chainId: "0x1",
              id: params[0],
              status: 100,
              receipts: [],
              version: "2.0.0"
            };
          const receipts = await Promise.all(hashes.map(async (hash8) => {
            const { result: result2, error: error2 } = await rpc.http(url, {
              body: {
                method: "eth_getTransactionReceipt",
                params: [hash8],
                id: 0
              }
            });
            if (error2)
              throw new RpcRequestError({
                body: { method, params },
                error: error2,
                url
              });
            if (!result2)
              return null;
            return {
              blockHash: result2.blockHash,
              blockNumber: result2.blockNumber,
              gasUsed: result2.gasUsed,
              logs: result2.logs,
              status: result2.status,
              transactionHash: result2.transactionHash
            };
          }));
          const receipts_ = receipts.filter((x2) => x2 !== null);
          if (receipts_.length === 0)
            return {
              atomic: false,
              chainId: "0x1",
              id: params[0],
              status: 100,
              receipts: [],
              version: "2.0.0"
            };
          return {
            atomic: false,
            chainId: "0x1",
            id: params[0],
            status: 200,
            receipts: receipts_,
            version: "2.0.0"
          };
        }
        if (method === "wallet_showCallsStatus")
          return;
        if (method === "personal_sign") {
          if (features.signMessageError) {
            if (typeof features.signMessageError === "boolean")
              throw new UserRejectedRequestError(new Error("Failed to sign message."));
            throw features.signMessageError;
          }
          method = "eth_sign";
          params = [params[1], params[0]];
        }
        const body = { method, params };
        const { error, result } = await rpc.http(url, { body });
        if (error)
          throw new RpcRequestError({ body, error, url });
        return result;
      };
      return custom({ request })({ retryCount: 0 });
    }
  }));
}

// node_modules/mipd/dist/esm/utils.js
function requestProviders(listener) {
  if (typeof window === "undefined")
    return;
  const handler = (event) => listener(event.detail);
  window.addEventListener("eip6963:announceProvider", handler);
  window.dispatchEvent(new CustomEvent("eip6963:requestProvider"));
  return () => window.removeEventListener("eip6963:announceProvider", handler);
}

// node_modules/mipd/dist/esm/store.js
function createStore() {
  const listeners2 = /* @__PURE__ */ new Set();
  let providerDetails = [];
  const request = () => requestProviders((providerDetail) => {
    if (providerDetails.some(({ info }) => info.uuid === providerDetail.info.uuid))
      return;
    providerDetails = [...providerDetails, providerDetail];
    listeners2.forEach((listener) => listener(providerDetails, { added: [providerDetail] }));
  });
  let unwatch = request();
  return {
    _listeners() {
      return listeners2;
    },
    clear() {
      listeners2.forEach((listener) => listener([], { removed: [...providerDetails] }));
      providerDetails = [];
    },
    destroy() {
      this.clear();
      listeners2.clear();
      unwatch == null ? void 0 : unwatch();
    },
    findProvider({ rdns }) {
      return providerDetails.find((providerDetail) => providerDetail.info.rdns === rdns);
    },
    getProviders() {
      return providerDetails;
    },
    reset() {
      this.clear();
      unwatch == null ? void 0 : unwatch();
      unwatch = request();
    },
    subscribe(listener, { emitImmediately } = {}) {
      listeners2.add(listener);
      if (emitImmediately)
        listener(providerDetails, { added: providerDetails });
      return () => listeners2.delete(listener);
    }
  };
}

// node_modules/@wagmi/core/node_modules/zustand/esm/middleware.mjs
var subscribeWithSelectorImpl = (fn2) => (set, get, api) => {
  const origSubscribe = api.subscribe;
  api.subscribe = (selector, optListener, options) => {
    let listener = selector;
    if (optListener) {
      const equalityFn = (options == null ? void 0 : options.equalityFn) || Object.is;
      let currentSlice = selector(api.getState());
      listener = (state) => {
        const nextSlice = selector(state);
        if (!equalityFn(currentSlice, nextSlice)) {
          const previousSlice = currentSlice;
          optListener(currentSlice = nextSlice, previousSlice);
        }
      };
      if (options == null ? void 0 : options.fireImmediately) {
        optListener(currentSlice, currentSlice);
      }
    }
    return origSubscribe(listener);
  };
  const initialState = fn2(set, get, api);
  return initialState;
};
var subscribeWithSelector = subscribeWithSelectorImpl;
function createJSONStorage(getStorage, options) {
  let storage;
  try {
    storage = getStorage();
  } catch (e2) {
    return;
  }
  const persistStorage = {
    getItem: (name) => {
      var _a2;
      const parse3 = (str2) => {
        if (str2 === null) {
          return null;
        }
        return JSON.parse(str2, options == null ? void 0 : options.reviver);
      };
      const str = (_a2 = storage.getItem(name)) != null ? _a2 : null;
      if (str instanceof Promise) {
        return str.then(parse3);
      }
      return parse3(str);
    },
    setItem: (name, newValue) => storage.setItem(
      name,
      JSON.stringify(newValue, options == null ? void 0 : options.replacer)
    ),
    removeItem: (name) => storage.removeItem(name)
  };
  return persistStorage;
}
var toThenable = (fn2) => (input) => {
  try {
    const result = fn2(input);
    if (result instanceof Promise) {
      return result;
    }
    return {
      then(onFulfilled) {
        return toThenable(onFulfilled)(result);
      },
      catch(_onRejected) {
        return this;
      }
    };
  } catch (e2) {
    return {
      then(_onFulfilled) {
        return this;
      },
      catch(onRejected) {
        return toThenable(onRejected)(e2);
      }
    };
  }
};
var persistImpl = (config, baseOptions) => (set, get, api) => {
  let options = {
    storage: createJSONStorage(() => localStorage),
    partialize: (state) => state,
    version: 0,
    merge: (persistedState, currentState) => ({
      ...currentState,
      ...persistedState
    }),
    ...baseOptions
  };
  let hasHydrated = false;
  const hydrationListeners = /* @__PURE__ */ new Set();
  const finishHydrationListeners = /* @__PURE__ */ new Set();
  let storage = options.storage;
  if (!storage) {
    return config(
      (...args) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${options.name}', the given storage is currently unavailable.`
        );
        set(...args);
      },
      get,
      api
    );
  }
  const setItem = () => {
    const state = options.partialize({ ...get() });
    return storage.setItem(options.name, {
      state,
      version: options.version
    });
  };
  const savedSetState = api.setState;
  api.setState = (state, replace) => {
    savedSetState(state, replace);
    void setItem();
  };
  const configResult = config(
    (...args) => {
      set(...args);
      void setItem();
    },
    get,
    api
  );
  api.getInitialState = () => configResult;
  let stateFromStorage;
  const hydrate2 = () => {
    var _a2, _b;
    if (!storage) return;
    hasHydrated = false;
    hydrationListeners.forEach((cb2) => {
      var _a22;
      return cb2((_a22 = get()) != null ? _a22 : configResult);
    });
    const postRehydrationCallback = ((_b = options.onRehydrateStorage) == null ? void 0 : _b.call(options, (_a2 = get()) != null ? _a2 : configResult)) || void 0;
    return toThenable(storage.getItem.bind(storage))(options.name).then((deserializedStorageValue) => {
      if (deserializedStorageValue) {
        if (typeof deserializedStorageValue.version === "number" && deserializedStorageValue.version !== options.version) {
          if (options.migrate) {
            return [
              true,
              options.migrate(
                deserializedStorageValue.state,
                deserializedStorageValue.version
              )
            ];
          }
          console.error(
            `State loaded from storage couldn't be migrated since no migrate function was provided`
          );
        } else {
          return [false, deserializedStorageValue.state];
        }
      }
      return [false, void 0];
    }).then((migrationResult) => {
      var _a22;
      const [migrated, migratedState] = migrationResult;
      stateFromStorage = options.merge(
        migratedState,
        (_a22 = get()) != null ? _a22 : configResult
      );
      set(stateFromStorage, true);
      if (migrated) {
        return setItem();
      }
    }).then(() => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(stateFromStorage, void 0);
      stateFromStorage = get();
      hasHydrated = true;
      finishHydrationListeners.forEach((cb2) => cb2(stateFromStorage));
    }).catch((e2) => {
      postRehydrationCallback == null ? void 0 : postRehydrationCallback(void 0, e2);
    });
  };
  api.persist = {
    setOptions: (newOptions) => {
      options = {
        ...options,
        ...newOptions
      };
      if (newOptions.storage) {
        storage = newOptions.storage;
      }
    },
    clearStorage: () => {
      storage == null ? void 0 : storage.removeItem(options.name);
    },
    getOptions: () => options,
    rehydrate: () => hydrate2(),
    hasHydrated: () => hasHydrated,
    onHydrate: (cb2) => {
      hydrationListeners.add(cb2);
      return () => {
        hydrationListeners.delete(cb2);
      };
    },
    onFinishHydration: (cb2) => {
      finishHydrationListeners.add(cb2);
      return () => {
        finishHydrationListeners.delete(cb2);
      };
    }
  };
  if (!options.skipHydration) {
    hydrate2();
  }
  return stateFromStorage || configResult;
};
var persist = persistImpl;

// node_modules/@wagmi/core/node_modules/zustand/esm/vanilla.mjs
var createStoreImpl = (createState2) => {
  let state;
  const listeners2 = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners2.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe2 = (listener) => {
    listeners2.add(listener);
    return () => listeners2.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe: subscribe2 };
  const initialState = state = createState2(setState, getState, api);
  return api;
};
var createStore2 = (createState2) => createState2 ? createStoreImpl(createState2) : createStoreImpl;

// node_modules/@wagmi/core/node_modules/eventemitter3/index.mjs
var import_index = __toESM(require_eventemitter3(), 1);

// node_modules/@wagmi/core/dist/esm/createEmitter.js
var Emitter = class {
  constructor(uid3) {
    Object.defineProperty(this, "uid", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: uid3
    });
    Object.defineProperty(this, "_emitter", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: new import_index.default()
    });
  }
  on(eventName, fn2) {
    this._emitter.on(eventName, fn2);
  }
  once(eventName, fn2) {
    this._emitter.once(eventName, fn2);
  }
  off(eventName, fn2) {
    this._emitter.off(eventName, fn2);
  }
  emit(eventName, ...params) {
    const data = params[0];
    this._emitter.emit(eventName, { uid: this.uid, ...data });
  }
  listenerCount(eventName) {
    return this._emitter.listenerCount(eventName);
  }
};
function createEmitter(uid3) {
  return new Emitter(uid3);
}

// node_modules/@wagmi/core/dist/esm/utils/deserialize.js
function deserialize(value, reviver) {
  return JSON.parse(value, (key, value_) => {
    let value2 = value_;
    if ((value2 == null ? void 0 : value2.__type) === "bigint")
      value2 = BigInt(value2.value);
    if ((value2 == null ? void 0 : value2.__type) === "Map")
      value2 = new Map(value2.value);
    return (reviver == null ? void 0 : reviver(key, value2)) ?? value2;
  });
}

// node_modules/@wagmi/core/dist/esm/utils/serialize.js
function getReferenceKey(keys, cutoff) {
  return keys.slice(0, cutoff).join(".") || ".";
}
function getCutoff(array, value) {
  const { length: length2 } = array;
  for (let index5 = 0; index5 < length2; ++index5) {
    if (array[index5] === value) {
      return index5 + 1;
    }
  }
  return 0;
}
function createReplacer(replacer, circularReplacer) {
  const hasReplacer = typeof replacer === "function";
  const hasCircularReplacer = typeof circularReplacer === "function";
  const cache = [];
  const keys = [];
  return function replace(key, value) {
    if (typeof value === "object") {
      if (cache.length) {
        const thisCutoff = getCutoff(cache, this);
        if (thisCutoff === 0) {
          cache[cache.length] = this;
        } else {
          cache.splice(thisCutoff);
          keys.splice(thisCutoff);
        }
        keys[keys.length] = key;
        const valueCutoff = getCutoff(cache, value);
        if (valueCutoff !== 0) {
          return hasCircularReplacer ? circularReplacer.call(this, key, value, getReferenceKey(keys, valueCutoff)) : `[ref=${getReferenceKey(keys, valueCutoff)}]`;
        }
      } else {
        cache[0] = value;
        keys[0] = key;
      }
    }
    return hasReplacer ? replacer.call(this, key, value) : value;
  };
}
function serialize(value, replacer, indent, circularReplacer) {
  return JSON.stringify(value, createReplacer((key, value_) => {
    let value2 = value_;
    if (typeof value2 === "bigint")
      value2 = { __type: "bigint", value: value_.toString() };
    if (value2 instanceof Map)
      value2 = { __type: "Map", value: Array.from(value_.entries()) };
    return (replacer == null ? void 0 : replacer(key, value2)) ?? value2;
  }, circularReplacer), indent ?? void 0);
}

// node_modules/@wagmi/core/dist/esm/createStorage.js
function createStorage(parameters) {
  const { deserialize: deserialize7 = deserialize, key: prefix = "wagmi", serialize: serialize8 = serialize, storage = noopStorage } = parameters;
  function unwrap(value) {
    if (value instanceof Promise)
      return value.then((x2) => x2).catch(() => null);
    return value;
  }
  return {
    ...storage,
    key: prefix,
    async getItem(key, defaultValue) {
      const value = storage.getItem(`${prefix}.${key}`);
      const unwrapped = await unwrap(value);
      if (unwrapped)
        return deserialize7(unwrapped) ?? null;
      return defaultValue ?? null;
    },
    async setItem(key, value) {
      const storageKey = `${prefix}.${key}`;
      if (value === null)
        await unwrap(storage.removeItem(storageKey));
      else
        await unwrap(storage.setItem(storageKey, serialize8(value)));
    },
    async removeItem(key) {
      await unwrap(storage.removeItem(`${prefix}.${key}`));
    }
  };
}
var noopStorage = {
  getItem: () => null,
  setItem: () => {
  },
  removeItem: () => {
  }
};
function getDefaultStorage() {
  const storage = (() => {
    if (typeof window !== "undefined" && window.localStorage)
      return window.localStorage;
    return noopStorage;
  })();
  return {
    getItem(key) {
      return storage.getItem(key);
    },
    removeItem(key) {
      storage.removeItem(key);
    },
    setItem(key, value) {
      try {
        storage.setItem(key, value);
      } catch {
      }
    }
  };
}

// node_modules/@wagmi/core/dist/esm/utils/uid.js
var size3 = 256;
var index = size3;
var buffer;
function uid(length2 = 11) {
  if (!buffer || index + length2 > size3 * 2) {
    buffer = "";
    index = 0;
    for (let i2 = 0; i2 < size3; i2++) {
      buffer += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer.substring(index, index++ + length2);
}

// node_modules/@wagmi/core/dist/esm/createConfig.js
function createConfig(parameters) {
  const { multiInjectedProviderDiscovery = true, storage = createStorage({
    storage: getDefaultStorage()
  }), syncConnectedChain = true, ssr = false, ...rest } = parameters;
  const mipd = typeof window !== "undefined" && multiInjectedProviderDiscovery ? createStore() : void 0;
  const chains = createStore2(() => rest.chains);
  const connectors = createStore2(() => {
    const collection = [];
    const rdnsSet = /* @__PURE__ */ new Set();
    for (const connectorFns of rest.connectors ?? []) {
      const connector = setup(connectorFns);
      collection.push(connector);
      if (!ssr && connector.rdns) {
        const rdnsValues = typeof connector.rdns === "string" ? [connector.rdns] : connector.rdns;
        for (const rdns of rdnsValues) {
          rdnsSet.add(rdns);
        }
      }
    }
    if (!ssr && mipd) {
      const providers = mipd.getProviders();
      for (const provider of providers) {
        if (rdnsSet.has(provider.info.rdns))
          continue;
        collection.push(setup(providerDetailToConnector(provider)));
      }
    }
    return collection;
  });
  function setup(connectorFn) {
    var _a2;
    const emitter = createEmitter(uid());
    const connector = {
      ...connectorFn({
        emitter,
        chains: chains.getState(),
        storage,
        transports: rest.transports
      }),
      emitter,
      uid: emitter.uid
    };
    emitter.on("connect", connect3);
    (_a2 = connector.setup) == null ? void 0 : _a2.call(connector);
    return connector;
  }
  function providerDetailToConnector(providerDetail) {
    const { info } = providerDetail;
    const provider = providerDetail.provider;
    return injected({ target: { ...info, id: info.rdns, provider } });
  }
  const clients = /* @__PURE__ */ new Map();
  function getClient2(config = {}) {
    const chainId = config.chainId ?? store.getState().chainId;
    const chain2 = chains.getState().find((x2) => x2.id === chainId);
    if (config.chainId && !chain2)
      throw new ChainNotConfiguredError();
    {
      const client2 = clients.get(store.getState().chainId);
      if (client2 && !chain2)
        return client2;
      if (!chain2)
        throw new ChainNotConfiguredError();
    }
    {
      const client2 = clients.get(chainId);
      if (client2)
        return client2;
    }
    let client;
    if (rest.client)
      client = rest.client({ chain: chain2 });
    else {
      const chainId2 = chain2.id;
      const chainIds = chains.getState().map((x2) => x2.id);
      const properties = {};
      const entries = Object.entries(rest);
      for (const [key, value] of entries) {
        if (key === "chains" || key === "client" || key === "connectors" || key === "transports")
          continue;
        if (typeof value === "object") {
          if (chainId2 in value)
            properties[key] = value[chainId2];
          else {
            const hasChainSpecificValue = chainIds.some((x2) => x2 in value);
            if (hasChainSpecificValue)
              continue;
            properties[key] = value;
          }
        } else
          properties[key] = value;
      }
      client = createClient({
        ...properties,
        chain: chain2,
        batch: properties.batch ?? { multicall: true },
        transport: (parameters2) => rest.transports[chainId2]({ ...parameters2, connectors })
      });
    }
    clients.set(chainId, client);
    return client;
  }
  function getInitialState() {
    return {
      chainId: chains.getState()[0].id,
      connections: /* @__PURE__ */ new Map(),
      current: null,
      status: "disconnected"
    };
  }
  let currentVersion;
  const prefix = "0.0.0-canary-";
  if (version.startsWith(prefix))
    currentVersion = Number.parseInt(version.replace(prefix, ""));
  else
    currentVersion = Number.parseInt(version.split(".")[0] ?? "0");
  const store = createStore2(subscribeWithSelector(
    // only use persist middleware if storage exists
    storage ? persist(getInitialState, {
      migrate(persistedState, version7) {
        if (version7 === currentVersion)
          return persistedState;
        const initialState = getInitialState();
        const chainId = validatePersistedChainId(persistedState, initialState.chainId);
        return { ...initialState, chainId };
      },
      name: "store",
      partialize(state) {
        return {
          connections: {
            __type: "Map",
            value: Array.from(state.connections.entries()).map(([key, connection]) => {
              const { id: id3, name, type: type6, uid: uid3 } = connection.connector;
              const connector = { id: id3, name, type: type6, uid: uid3 };
              return [key, { ...connection, connector }];
            })
          },
          chainId: state.chainId,
          current: state.current
        };
      },
      merge(persistedState, currentState) {
        if (typeof persistedState === "object" && persistedState && "status" in persistedState)
          delete persistedState.status;
        const chainId = validatePersistedChainId(persistedState, currentState.chainId);
        return {
          ...currentState,
          ...persistedState,
          chainId
        };
      },
      skipHydration: ssr,
      storage,
      version: currentVersion
    }) : getInitialState
  ));
  store.setState(getInitialState());
  function validatePersistedChainId(persistedState, defaultChainId) {
    return persistedState && typeof persistedState === "object" && "chainId" in persistedState && typeof persistedState.chainId === "number" && chains.getState().some((x2) => x2.id === persistedState.chainId) ? persistedState.chainId : defaultChainId;
  }
  if (syncConnectedChain)
    store.subscribe(({ connections, current }) => {
      var _a2;
      return current ? (_a2 = connections.get(current)) == null ? void 0 : _a2.chainId : void 0;
    }, (chainId) => {
      const isChainConfigured = chains.getState().some((x2) => x2.id === chainId);
      if (!isChainConfigured)
        return;
      return store.setState((x2) => ({
        ...x2,
        chainId: chainId ?? x2.chainId
      }));
    });
  mipd == null ? void 0 : mipd.subscribe((providerDetails) => {
    const connectorIdSet = /* @__PURE__ */ new Set();
    const connectorRdnsSet = /* @__PURE__ */ new Set();
    for (const connector of connectors.getState()) {
      connectorIdSet.add(connector.id);
      if (connector.rdns) {
        const rdnsValues = typeof connector.rdns === "string" ? [connector.rdns] : connector.rdns;
        for (const rdns of rdnsValues) {
          connectorRdnsSet.add(rdns);
        }
      }
    }
    const newConnectors = [];
    for (const providerDetail of providerDetails) {
      if (connectorRdnsSet.has(providerDetail.info.rdns))
        continue;
      const connector = setup(providerDetailToConnector(providerDetail));
      if (connectorIdSet.has(connector.id))
        continue;
      newConnectors.push(connector);
    }
    if (storage && !store.persist.hasHydrated())
      return;
    connectors.setState((x2) => [...x2, ...newConnectors], true);
  });
  function change(data) {
    store.setState((x2) => {
      const connection = x2.connections.get(data.uid);
      if (!connection)
        return x2;
      return {
        ...x2,
        connections: new Map(x2.connections).set(data.uid, {
          accounts: data.accounts ?? connection.accounts,
          chainId: data.chainId ?? connection.chainId,
          connector: connection.connector
        })
      };
    });
  }
  function connect3(data) {
    if (store.getState().status === "connecting" || store.getState().status === "reconnecting")
      return;
    store.setState((x2) => {
      const connector = connectors.getState().find((x3) => x3.uid === data.uid);
      if (!connector)
        return x2;
      if (connector.emitter.listenerCount("connect"))
        connector.emitter.off("connect", change);
      if (!connector.emitter.listenerCount("change"))
        connector.emitter.on("change", change);
      if (!connector.emitter.listenerCount("disconnect"))
        connector.emitter.on("disconnect", disconnect3);
      return {
        ...x2,
        connections: new Map(x2.connections).set(data.uid, {
          accounts: data.accounts,
          chainId: data.chainId,
          connector
        }),
        current: data.uid,
        status: "connected"
      };
    });
  }
  function disconnect3(data) {
    store.setState((x2) => {
      const connection = x2.connections.get(data.uid);
      if (connection) {
        const connector = connection.connector;
        if (connector.emitter.listenerCount("change"))
          connection.connector.emitter.off("change", change);
        if (connector.emitter.listenerCount("disconnect"))
          connection.connector.emitter.off("disconnect", disconnect3);
        if (!connector.emitter.listenerCount("connect"))
          connection.connector.emitter.on("connect", connect3);
      }
      x2.connections.delete(data.uid);
      if (x2.connections.size === 0)
        return {
          ...x2,
          connections: /* @__PURE__ */ new Map(),
          current: null,
          status: "disconnected"
        };
      const nextConnection = x2.connections.values().next().value;
      return {
        ...x2,
        connections: new Map(x2.connections),
        current: nextConnection.connector.uid
      };
    });
  }
  return {
    get chains() {
      return chains.getState();
    },
    get connectors() {
      return connectors.getState();
    },
    storage,
    getClient: getClient2,
    get state() {
      return store.getState();
    },
    setState(value) {
      let newState;
      if (typeof value === "function")
        newState = value(store.getState());
      else
        newState = value;
      const initialState = getInitialState();
      if (typeof newState !== "object")
        newState = initialState;
      const isCorrupt = Object.keys(initialState).some((x2) => !(x2 in newState));
      if (isCorrupt)
        newState = initialState;
      store.setState(newState, true);
    },
    subscribe(selector, listener, options) {
      return store.subscribe(selector, listener, options ? {
        ...options,
        fireImmediately: options.emitImmediately
        // Workaround cast since Zustand does not support `'exactOptionalPropertyTypes'`
      } : void 0);
    },
    _internal: {
      mipd,
      store,
      ssr: Boolean(ssr),
      syncConnectedChain,
      transports: rest.transports,
      chains: {
        setState(value) {
          const nextChains = typeof value === "function" ? value(chains.getState()) : value;
          if (nextChains.length === 0)
            return;
          return chains.setState(nextChains, true);
        },
        subscribe(listener) {
          return chains.subscribe(listener);
        }
      },
      connectors: {
        providerDetailToConnector,
        setup,
        setState(value) {
          return connectors.setState(typeof value === "function" ? value(connectors.getState()) : value, true);
        },
        subscribe(listener) {
          return connectors.subscribe(listener);
        }
      },
      events: { change, connect: connect3, disconnect: disconnect3 }
    }
  };
}

// node_modules/@wagmi/core/dist/esm/hydrate.js
function hydrate(config, parameters) {
  const { initialState, reconnectOnMount } = parameters;
  if (initialState && !config._internal.store.persist.hasHydrated())
    config.setState({
      ...initialState,
      chainId: config.chains.some((x2) => x2.id === initialState.chainId) ? initialState.chainId : config.chains[0].id,
      connections: reconnectOnMount ? initialState.connections : /* @__PURE__ */ new Map(),
      status: reconnectOnMount ? "reconnecting" : "disconnected"
    });
  return {
    async onMount() {
      if (config._internal.ssr) {
        await config._internal.store.persist.rehydrate();
        if (config._internal.mipd) {
          config._internal.connectors.setState((connectors) => {
            var _a2;
            const rdnsSet = /* @__PURE__ */ new Set();
            for (const connector of connectors ?? []) {
              if (connector.rdns) {
                const rdnsValues = Array.isArray(connector.rdns) ? connector.rdns : [connector.rdns];
                for (const rdns of rdnsValues) {
                  rdnsSet.add(rdns);
                }
              }
            }
            const mipdConnectors = [];
            const providers = ((_a2 = config._internal.mipd) == null ? void 0 : _a2.getProviders()) ?? [];
            for (const provider of providers) {
              if (rdnsSet.has(provider.info.rdns))
                continue;
              const connectorFn = config._internal.connectors.providerDetailToConnector(provider);
              const connector = config._internal.connectors.setup(connectorFn);
              mipdConnectors.push(connector);
            }
            return [...connectors, ...mipdConnectors];
          });
        }
      }
      if (reconnectOnMount)
        reconnect(config);
      else if (config.storage)
        config.setState((x2) => ({
          ...x2,
          connections: /* @__PURE__ */ new Map()
        }));
    }
  };
}

// node_modules/@wagmi/core/dist/esm/utils/extractRpcUrls.js
function extractRpcUrls(parameters) {
  var _a2, _b, _c2;
  const { chain: chain2 } = parameters;
  const fallbackUrl = chain2.rpcUrls.default.http[0];
  if (!parameters.transports)
    return [fallbackUrl];
  const transport = (_b = (_a2 = parameters.transports) == null ? void 0 : _a2[chain2.id]) == null ? void 0 : _b.call(_a2, { chain: chain2 });
  const transports = ((_c2 = transport == null ? void 0 : transport.value) == null ? void 0 : _c2.transports) || [transport];
  return transports.map(({ value }) => (value == null ? void 0 : value.url) || fallbackUrl);
}

// node_modules/wagmi/dist/esm/hydrate.js
var import_react = __toESM(require_react(), 1);
function Hydrate(parameters) {
  const { children, config, initialState, reconnectOnMount = true } = parameters;
  const { onMount } = hydrate(config, {
    initialState,
    reconnectOnMount
  });
  if (!config._internal.ssr)
    onMount();
  const active = (0, import_react.useRef)(true);
  (0, import_react.useEffect)(() => {
    if (!active.current)
      return;
    if (!config._internal.ssr)
      return;
    onMount();
    return () => {
      active.current = false;
    };
  }, []);
  return children;
}

// node_modules/wagmi/dist/esm/context.js
var WagmiContext = (0, import_react2.createContext)(void 0);
function WagmiProvider(parameters) {
  const { children, config } = parameters;
  const props = { value: config };
  return (0, import_react2.createElement)(Hydrate, parameters, (0, import_react2.createElement)(WagmiContext.Provider, props, children));
}

// node_modules/wagmi/dist/esm/version.js
var version2 = "2.15.0";

// node_modules/wagmi/dist/esm/utils/getVersion.js
var getVersion2 = () => `wagmi@${version2}`;

// node_modules/wagmi/dist/esm/errors/base.js
var BaseError4 = class extends BaseError3 {
  constructor() {
    super(...arguments);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiError"
    });
  }
  get docsBaseUrl() {
    return "https://wagmi.sh/react";
  }
  get version() {
    return getVersion2();
  }
};

// node_modules/wagmi/dist/esm/errors/context.js
var WagmiProviderNotFoundError = class extends BaseError4 {
  constructor() {
    super("`useConfig` must be used within `WagmiProvider`.", {
      docsPath: "/api/WagmiProvider"
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiProviderNotFoundError"
    });
  }
};

// node_modules/wagmi/dist/esm/hooks/useConfig.js
var import_react3 = __toESM(require_react(), 1);
function useConfig(parameters = {}) {
  const config = parameters.config ?? (0, import_react3.useContext)(WagmiContext);
  if (!config)
    throw new WagmiProviderNotFoundError();
  return config;
}

// node_modules/@wagmi/core/dist/esm/actions/watchChains.js
function watchChains(config, parameters) {
  const { onChange } = parameters;
  return config._internal.chains.subscribe((chains, prevChains) => {
    onChange(chains, prevChains);
  });
}

// node_modules/wagmi/dist/esm/hooks/useSyncExternalStoreWithTracked.js
var import_react4 = __toESM(require_react(), 1);
var import_with_selector = __toESM(require_with_selector(), 1);
var isPlainObject = (obj) => typeof obj === "object" && !Array.isArray(obj);
function useSyncExternalStoreWithTracked(subscribe2, getSnapshot, getServerSnapshot = getSnapshot, isEqual3 = deepEqual) {
  const trackedKeys = (0, import_react4.useRef)([]);
  const result = (0, import_with_selector.useSyncExternalStoreWithSelector)(subscribe2, getSnapshot, getServerSnapshot, (x2) => x2, (a3, b4) => {
    if (isPlainObject(a3) && isPlainObject(b4) && trackedKeys.current.length) {
      for (const key of trackedKeys.current) {
        const equal = isEqual3(a3[key], b4[key]);
        if (!equal)
          return false;
      }
      return true;
    }
    return isEqual3(a3, b4);
  });
  return (0, import_react4.useMemo)(() => {
    if (isPlainObject(result)) {
      const trackedResult = { ...result };
      let properties = {};
      for (const [key, value] of Object.entries(trackedResult)) {
        properties = {
          ...properties,
          [key]: {
            configurable: false,
            enumerable: true,
            get: () => {
              if (!trackedKeys.current.includes(key)) {
                trackedKeys.current.push(key);
              }
              return value;
            }
          }
        };
      }
      Object.defineProperties(trackedResult, properties);
      return trackedResult;
    }
    return result;
  }, [result]);
}

// node_modules/wagmi/dist/esm/hooks/useAccount.js
function useAccount(parameters = {}) {
  const config = useConfig(parameters);
  return useSyncExternalStoreWithTracked((onChange) => watchAccount(config, { onChange }), () => getAccount(config));
}

// node_modules/wagmi/dist/esm/hooks/useAccountEffect.js
var import_react5 = __toESM(require_react(), 1);
function useAccountEffect(parameters = {}) {
  const { onConnect, onDisconnect } = parameters;
  const config = useConfig(parameters);
  (0, import_react5.useEffect)(() => {
    return watchAccount(config, {
      onChange(data, prevData) {
        if ((prevData.status === "reconnecting" || prevData.status === "connecting" && prevData.address === void 0) && data.status === "connected") {
          const { address, addresses, chain: chain2, chainId, connector } = data;
          const isReconnected = prevData.status === "reconnecting" || // if `previousAccount.status` is `undefined`, the connector connected immediately.
          prevData.status === void 0;
          onConnect == null ? void 0 : onConnect({
            address,
            addresses,
            chain: chain2,
            chainId,
            connector,
            isReconnected
          });
        } else if (prevData.status === "connected" && data.status === "disconnected")
          onDisconnect == null ? void 0 : onDisconnect();
      }
    });
  }, [config, onConnect, onDisconnect]);
}

// node_modules/@wagmi/core/dist/esm/query/utils.js
function hashFn(queryKey) {
  return JSON.stringify(queryKey, (_2, value) => {
    if (isPlainObject2(value))
      return Object.keys(value).sort().reduce((result, key) => {
        result[key] = value[key];
        return result;
      }, {});
    if (typeof value === "bigint")
      return value.toString();
    return value;
  });
}
function isPlainObject2(value) {
  if (!hasObjectPrototype(value)) {
    return false;
  }
  const ctor = value.constructor;
  if (typeof ctor === "undefined")
    return true;
  const prot = ctor.prototype;
  if (!hasObjectPrototype(prot))
    return false;
  if (!prot.hasOwnProperty("isPrototypeOf"))
    return false;
  return true;
}
function hasObjectPrototype(o2) {
  return Object.prototype.toString.call(o2) === "[object Object]";
}
function filterQueryOptions(options) {
  const {
    // import('@tanstack/query-core').QueryOptions
    _defaulted,
    behavior,
    gcTime,
    initialData,
    initialDataUpdatedAt,
    maxPages,
    meta,
    networkMode,
    queryFn,
    queryHash,
    queryKey,
    queryKeyHashFn,
    retry,
    retryDelay,
    structuralSharing: structuralSharing2,
    // import('@tanstack/query-core').InfiniteQueryObserverOptions
    getPreviousPageParam,
    getNextPageParam,
    initialPageParam,
    // import('@tanstack/react-query').UseQueryOptions
    _optimisticResults,
    enabled,
    notifyOnChangeProps,
    placeholderData,
    refetchInterval,
    refetchIntervalInBackground,
    refetchOnMount,
    refetchOnReconnect,
    refetchOnWindowFocus,
    retryOnMount,
    select,
    staleTime,
    suspense,
    throwOnError,
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // wagmi
    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    config,
    connector,
    query,
    ...rest
  } = options;
  return rest;
}

// node_modules/@wagmi/core/dist/esm/query/connect.js
function connectMutationOptions(config) {
  return {
    mutationFn(variables) {
      return connect(config, variables);
    },
    mutationKey: ["connect"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/disconnect.js
function disconnectMutationOptions(config) {
  return {
    mutationFn(variables) {
      return disconnect(config, variables);
    },
    mutationKey: ["disconnect"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/getBalance.js
function getBalanceQueryOptions(config, options = {}) {
  return {
    async queryFn({ queryKey }) {
      const { address, scopeKey: _2, ...parameters } = queryKey[1];
      if (!address)
        throw new Error("address is required");
      const balance = await getBalance2(config, {
        ...parameters,
        address
      });
      return balance ?? null;
    },
    queryKey: getBalanceQueryKey(options)
  };
}
function getBalanceQueryKey(options = {}) {
  return ["balance", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getBlockNumber.js
function getBlockNumberQueryOptions(config, options = {}) {
  return {
    gcTime: 0,
    async queryFn({ queryKey }) {
      const { scopeKey: _2, ...parameters } = queryKey[1];
      const blockNumber = await getBlockNumber2(config, parameters);
      return blockNumber ?? null;
    },
    queryKey: getBlockNumberQueryKey(options)
  };
}
function getBlockNumberQueryKey(options = {}) {
  return ["blockNumber", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getEnsAddress.js
function getEnsAddressQueryOptions(config, options = {}) {
  return {
    async queryFn({ queryKey }) {
      const { name, scopeKey: _2, ...parameters } = queryKey[1];
      if (!name)
        throw new Error("name is required");
      return getEnsAddress2(config, { ...parameters, name });
    },
    queryKey: getEnsAddressQueryKey(options)
  };
}
function getEnsAddressQueryKey(options = {}) {
  return ["ensAddress", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getEnsAvatar.js
function getEnsAvatarQueryOptions(config, options = {}) {
  return {
    async queryFn({ queryKey }) {
      const { name, scopeKey: _2, ...parameters } = queryKey[1];
      if (!name)
        throw new Error("name is required");
      return getEnsAvatar2(config, { ...parameters, name });
    },
    queryKey: getEnsAvatarQueryKey(options)
  };
}
function getEnsAvatarQueryKey(options = {}) {
  return ["ensAvatar", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/getEnsName.js
function getEnsNameQueryOptions(config, options = {}) {
  return {
    async queryFn({ queryKey }) {
      const { address, scopeKey: _2, ...parameters } = queryKey[1];
      if (!address)
        throw new Error("address is required");
      return getEnsName2(config, { ...parameters, address });
    },
    queryKey: getEnsNameQueryKey(options)
  };
}
function getEnsNameQueryKey(options = {}) {
  return ["ensName", filterQueryOptions(options)];
}

// node_modules/@wagmi/core/dist/esm/query/signMessage.js
function signMessageMutationOptions(config) {
  return {
    mutationFn(variables) {
      return signMessage2(config, variables);
    },
    mutationKey: ["signMessage"]
  };
}

// node_modules/@wagmi/core/dist/esm/query/switchChain.js
function switchChainMutationOptions(config) {
  return {
    mutationFn(variables) {
      return switchChain2(config, variables);
    },
    mutationKey: ["switchChain"]
  };
}

// node_modules/wagmi/dist/esm/utils/query.js
function useQuery2(parameters) {
  const result = useQuery({
    ...parameters,
    queryKeyHashFn: hashFn
    // for bigint support
  });
  result.queryKey = parameters.queryKey;
  return result;
}

// node_modules/wagmi/dist/esm/hooks/useChainId.js
var import_react6 = __toESM(require_react(), 1);
function useChainId(parameters = {}) {
  const config = useConfig(parameters);
  return (0, import_react6.useSyncExternalStore)((onChange) => watchChainId(config, { onChange }), () => getChainId2(config), () => getChainId2(config));
}

// node_modules/wagmi/dist/esm/hooks/useBalance.js
function useBalance(parameters = {}) {
  const { address, query = {} } = parameters;
  const config = useConfig(parameters);
  const chainId = useChainId({ config });
  const options = getBalanceQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId
  });
  const enabled = Boolean(address && (query.enabled ?? true));
  return useQuery2({ ...query, ...options, enabled });
}

// node_modules/wagmi/dist/esm/hooks/useWatchBlocks.js
var import_react7 = __toESM(require_react(), 1);

// node_modules/wagmi/dist/esm/hooks/useWatchBlockNumber.js
var import_react8 = __toESM(require_react(), 1);
function useWatchBlockNumber(parameters = {}) {
  const { enabled = true, onBlockNumber, config: _2, ...rest } = parameters;
  const config = useConfig(parameters);
  const configChainId = useChainId({ config });
  const chainId = parameters.chainId ?? configChainId;
  (0, import_react8.useEffect)(() => {
    if (!enabled)
      return;
    if (!onBlockNumber)
      return;
    return watchBlockNumber2(config, {
      ...rest,
      chainId,
      onBlockNumber
    });
  }, [
    chainId,
    config,
    enabled,
    onBlockNumber,
    ///
    rest.onError,
    rest.emitMissed,
    rest.emitOnBegin,
    rest.poll,
    rest.pollingInterval,
    rest.syncConnectedChain
  ]);
}

// node_modules/wagmi/dist/esm/hooks/useBlockNumber.js
function useBlockNumber(parameters = {}) {
  const { query = {}, watch } = parameters;
  const config = useConfig(parameters);
  const queryClient = useQueryClient();
  const configChainId = useChainId({ config });
  const chainId = parameters.chainId ?? configChainId;
  const options = getBlockNumberQueryOptions(config, {
    ...parameters,
    chainId
  });
  useWatchBlockNumber({
    ...{
      config: parameters.config,
      chainId: parameters.chainId,
      ...typeof watch === "object" ? watch : {}
    },
    enabled: Boolean((query.enabled ?? true) && (typeof watch === "object" ? watch.enabled : watch)),
    onBlockNumber(blockNumber) {
      queryClient.setQueryData(options.queryKey, blockNumber);
    }
  });
  return useQuery2({ ...query, ...options });
}

// node_modules/wagmi/dist/esm/hooks/useChains.js
var import_react9 = __toESM(require_react(), 1);
function useChains(parameters = {}) {
  const config = useConfig(parameters);
  return (0, import_react9.useSyncExternalStore)((onChange) => watchChains(config, { onChange }), () => getChains(config), () => getChains(config));
}

// node_modules/wagmi/dist/esm/hooks/useClient.js
var import_with_selector2 = __toESM(require_with_selector(), 1);

// node_modules/wagmi/dist/esm/hooks/useConnect.js
var import_react11 = __toESM(require_react(), 1);

// node_modules/wagmi/dist/esm/hooks/useConnectors.js
var import_react10 = __toESM(require_react(), 1);
function useConnectors(parameters = {}) {
  const config = useConfig(parameters);
  return (0, import_react10.useSyncExternalStore)((onChange) => watchConnectors(config, { onChange }), () => getConnectors(config), () => getConnectors(config));
}

// node_modules/wagmi/dist/esm/hooks/useConnect.js
function useConnect(parameters = {}) {
  const { mutation } = parameters;
  const config = useConfig(parameters);
  const mutationOptions = connectMutationOptions(config);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  (0, import_react11.useEffect)(() => {
    return config.subscribe(({ status }) => status, (status, previousStatus) => {
      if (previousStatus === "connected" && status === "disconnected")
        result.reset();
    });
  }, [config, result.reset]);
  return {
    ...result,
    connect: mutate,
    connectAsync: mutateAsync,
    connectors: useConnectors({ config })
  };
}

// node_modules/wagmi/dist/esm/hooks/useConnections.js
var import_react12 = __toESM(require_react(), 1);
function useConnections(parameters = {}) {
  const config = useConfig(parameters);
  return (0, import_react12.useSyncExternalStore)((onChange) => watchConnections(config, { onChange }), () => getConnections(config), () => getConnections(config));
}

// node_modules/wagmi/dist/esm/hooks/useConnectorClient.js
var import_react13 = __toESM(require_react(), 1);

// node_modules/wagmi/dist/esm/hooks/useDisconnect.js
function useDisconnect(parameters = {}) {
  const { mutation } = parameters;
  const config = useConfig(parameters);
  const mutationOptions = disconnectMutationOptions(config);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    connectors: useConnections({ config }).map((connection) => connection.connector),
    disconnect: mutate,
    disconnectAsync: mutateAsync
  };
}

// node_modules/wagmi/dist/esm/hooks/useEnsAddress.js
function useEnsAddress(parameters = {}) {
  const { name, query = {} } = parameters;
  const config = useConfig(parameters);
  const chainId = useChainId({ config });
  const options = getEnsAddressQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId
  });
  const enabled = Boolean(name && (query.enabled ?? true));
  return useQuery2({ ...query, ...options, enabled });
}

// node_modules/wagmi/dist/esm/hooks/useEnsAvatar.js
function useEnsAvatar(parameters = {}) {
  const { name, query = {} } = parameters;
  const config = useConfig(parameters);
  const chainId = useChainId({ config });
  const options = getEnsAvatarQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId
  });
  const enabled = Boolean(name && (query.enabled ?? true));
  return useQuery2({ ...query, ...options, enabled });
}

// node_modules/wagmi/dist/esm/hooks/useEnsName.js
function useEnsName(parameters = {}) {
  const { address, query = {} } = parameters;
  const config = useConfig(parameters);
  const chainId = useChainId({ config });
  const options = getEnsNameQueryOptions(config, {
    ...parameters,
    chainId: parameters.chainId ?? chainId
  });
  const enabled = Boolean(address && (query.enabled ?? true));
  return useQuery2({ ...query, ...options, enabled });
}

// node_modules/wagmi/dist/esm/hooks/usePublicClient.js
var import_with_selector3 = __toESM(require_with_selector(), 1);

// node_modules/wagmi/dist/esm/hooks/useReadContracts.js
var import_react14 = __toESM(require_react(), 1);

// node_modules/wagmi/dist/esm/hooks/useSignMessage.js
function useSignMessage(parameters = {}) {
  const { mutation } = parameters;
  const config = useConfig(parameters);
  const mutationOptions = signMessageMutationOptions(config);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    signMessage: mutate,
    signMessageAsync: mutateAsync
  };
}

// node_modules/wagmi/dist/esm/hooks/useSwitchChain.js
function useSwitchChain(parameters = {}) {
  const { mutation } = parameters;
  const config = useConfig(parameters);
  const mutationOptions = switchChainMutationOptions(config);
  const { mutate, mutateAsync, ...result } = useMutation({
    ...mutation,
    ...mutationOptions
  });
  return {
    ...result,
    chains: useChains({ config }),
    switchChain: mutate,
    switchChainAsync: mutateAsync
  };
}

// node_modules/wagmi/dist/esm/hooks/useWalletClient.js
var import_react15 = __toESM(require_react(), 1);

// node_modules/wagmi/dist/esm/hooks/useWatchContractEvent.js
var import_react16 = __toESM(require_react(), 1);

// node_modules/wagmi/dist/esm/hooks/useWatchPendingTransactions.js
var import_react17 = __toESM(require_react(), 1);

// node_modules/viem/_esm/chains/definitions/abey.js
var abey = defineChain({
  id: 179,
  name: "ABEY Mainnet",
  nativeCurrency: { name: "ABEY", symbol: "ABEY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.abeychain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Abey Scan",
      url: "https://abeyscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/zksync/constants/number.js
var gasPerPubdataDefault = 50000n;
var maxBytecodeSize = maxUint16 * 32n;

// node_modules/viem/_esm/zksync/formatters.js
var formatters = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        var _a3;
        if (typeof transaction === "string")
          return transaction;
        const formatted = (_a3 = formatters.transaction) == null ? void 0 : _a3.format(transaction);
        if (formatted.typeHex === "0x71")
          formatted.type = "eip712";
        else if (formatted.typeHex === "0xff")
          formatted.type = "priority";
        return formatted;
      });
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTimestamp: args.l1BatchTimestamp ? hexToBigInt(args.l1BatchTimestamp) : null,
        transactions
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x71")
        transaction.type = "eip712";
      else if (args.type === "0xff")
        transaction.type = "priority";
      return {
        ...transaction,
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null
      };
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1BatchNumber: args.l1BatchNumber ? hexToBigInt(args.l1BatchNumber) : null,
        l1BatchTxIndex: args.l1BatchTxIndex ? hexToBigInt(args.l1BatchTxIndex) : null,
        logs: args.logs.map((log) => {
          return {
            ...formatLog(log),
            l1BatchNumber: log.l1BatchNumber ? hexToBigInt(log.l1BatchNumber) : null,
            transactionLogIndex: hexToNumber(log.transactionLogIndex),
            logType: log.logType
          };
        }),
        l2ToL1Logs: args.l2ToL1Logs.map((l2ToL1Log) => {
          return {
            blockNumber: hexToBigInt(l2ToL1Log.blockHash),
            blockHash: l2ToL1Log.blockHash,
            l1BatchNumber: l2ToL1Log.l1BatchNumber ? hexToBigInt(l2ToL1Log.l1BatchNumber) : null,
            transactionIndex: hexToBigInt(l2ToL1Log.transactionIndex),
            shardId: hexToBigInt(l2ToL1Log.shardId),
            isService: l2ToL1Log.isService,
            sender: l2ToL1Log.sender,
            key: l2ToL1Log.key,
            value: l2ToL1Log.value,
            transactionHash: l2ToL1Log.transactionHash,
            logIndex: hexToBigInt(l2ToL1Log.logIndex)
          };
        })
      };
    }
  }),
  transactionRequest: defineTransactionRequest({
    exclude: [
      "customSignature",
      "factoryDeps",
      "gasPerPubdata",
      "paymaster",
      "paymasterInput"
    ],
    format(args) {
      if (args.gasPerPubdata || args.paymaster && args.paymasterInput || args.factoryDeps || args.customSignature)
        return {
          eip712Meta: {
            ...args.gasPerPubdata ? { gasPerPubdata: toHex(args.gasPerPubdata) } : { gasPerPubdata: toHex(gasPerPubdataDefault) },
            ...args.paymaster && args.paymasterInput ? {
              paymasterParams: {
                paymaster: args.paymaster,
                paymasterInput: Array.from(hexToBytes(args.paymasterInput))
              }
            } : {},
            ...args.factoryDeps ? {
              factoryDeps: args.factoryDeps.map((dep) => Array.from(hexToBytes(dep)))
            } : {},
            ...args.customSignature ? {
              customSignature: Array.from(hexToBytes(args.customSignature))
            } : {}
          },
          type: "0x71"
        };
      return {};
    }
  })
};

// node_modules/viem/_esm/zksync/errors/transaction.js
var InvalidEip712TransactionError = class extends BaseError {
  constructor() {
    super([
      "Transaction is not an EIP712 transaction.",
      "",
      "Transaction must:",
      '  - include `type: "eip712"`',
      "  - include one of the following: `customSignature`, `paymaster`, `paymasterInput`, `gasPerPubdata`, `factoryDeps`"
    ].join("\n"), { name: "InvalidEip712TransactionError" });
  }
};

// node_modules/viem/_esm/zksync/utils/isEip712Transaction.js
function isEIP712Transaction(transaction) {
  if (transaction.type === "eip712")
    return true;
  if ("customSignature" in transaction && transaction.customSignature || "paymaster" in transaction && transaction.paymaster || "paymasterInput" in transaction && transaction.paymasterInput || "gasPerPubdata" in transaction && typeof transaction.gasPerPubdata === "bigint" || "factoryDeps" in transaction && transaction.factoryDeps)
    return true;
  return false;
}

// node_modules/viem/_esm/zksync/utils/assertEip712Transaction.js
function assertEip712Transaction(transaction) {
  const { chainId, to: to4, from: from26, paymaster, paymasterInput } = transaction;
  if (!isEIP712Transaction(transaction))
    throw new InvalidEip712TransactionError();
  if (!chainId || chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to4 && !isAddress(to4))
    throw new InvalidAddressError({ address: to4 });
  if (from26 && !isAddress(from26))
    throw new InvalidAddressError({ address: from26 });
  if (paymaster && !isAddress(paymaster))
    throw new InvalidAddressError({ address: paymaster });
  if (paymaster && !paymasterInput) {
    throw new BaseError("`paymasterInput` must be provided when `paymaster` is defined");
  }
  if (!paymaster && paymasterInput) {
    throw new BaseError("`paymaster` must be provided when `paymasterInput` is defined");
  }
}

// node_modules/viem/_esm/zksync/serializers.js
function serializeTransaction2(transaction, signature) {
  if (isEIP712Transaction(transaction))
    return serializeTransactionEIP712(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers = {
  transaction: serializeTransaction2
};
function serializeTransactionEIP712(transaction) {
  const { chainId, gas, nonce, to: to4, from: from26, value, maxFeePerGas, maxPriorityFeePerGas, customSignature, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  assertEip712Transaction(transaction);
  const serializedTransaction = [
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to4 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    toHex(chainId),
    toHex(""),
    toHex(""),
    toHex(chainId),
    from26 ?? "0x",
    gasPerPubdata ? toHex(gasPerPubdata) : toHex(gasPerPubdataDefault),
    factoryDeps ?? [],
    customSignature ?? "0x",
    // EIP712 signature
    paymaster && paymasterInput ? [paymaster, paymasterInput] : []
  ];
  return concatHex([
    "0x71",
    toRlp(serializedTransaction)
  ]);
}

// node_modules/viem/_esm/zksync/errors/bytecode.js
var BytecodeLengthExceedsMaxSizeError = class extends BaseError {
  constructor({ givenLength, maxBytecodeSize: maxBytecodeSize2 }) {
    super(`Bytecode cannot be longer than ${maxBytecodeSize2} bytes. Given length: ${givenLength}`, { name: "BytecodeLengthExceedsMaxSizeError" });
  }
};
var BytecodeLengthInWordsMustBeOddError = class extends BaseError {
  constructor({ givenLengthInWords }) {
    super(`Bytecode length in 32-byte words must be odd. Given length in words: ${givenLengthInWords}`, { name: "BytecodeLengthInWordsMustBeOddError" });
  }
};
var BytecodeLengthMustBeDivisibleBy32Error = class extends BaseError {
  constructor({ givenLength }) {
    super(`The bytecode length in bytes must be divisible by 32. Given length: ${givenLength}`, { name: "BytecodeLengthMustBeDivisibleBy32Error" });
  }
};

// node_modules/viem/_esm/zksync/utils/hashBytecode.js
function hashBytecode(bytecode) {
  const bytecodeBytes = toBytes(bytecode);
  if (bytecodeBytes.length % 32 !== 0)
    throw new BytecodeLengthMustBeDivisibleBy32Error({
      givenLength: bytecodeBytes.length
    });
  if (bytecodeBytes.length > maxBytecodeSize)
    throw new BytecodeLengthExceedsMaxSizeError({
      givenLength: bytecodeBytes.length,
      maxBytecodeSize
    });
  const hashStr = sha2562(bytecodeBytes);
  const hash8 = toBytes(hashStr);
  const bytecodeLengthInWords = bytecodeBytes.length / 32;
  if (bytecodeLengthInWords % 2 === 0) {
    throw new BytecodeLengthInWordsMustBeOddError({
      givenLengthInWords: bytecodeLengthInWords
    });
  }
  const bytecodeLength = toBytes(bytecodeLengthInWords);
  const bytecodeLengthPadded = pad(bytecodeLength, { size: 2 });
  const codeHashVersion = new Uint8Array([1, 0]);
  hash8.set(codeHashVersion, 0);
  hash8.set(bytecodeLengthPadded, 2);
  return hash8;
}

// node_modules/viem/_esm/zksync/utils/getEip712Domain.js
var getEip712Domain2 = (transaction) => {
  assertEip712Transaction(transaction);
  const message = transactionToMessage(transaction);
  return {
    domain: {
      name: "zkSync",
      version: "2",
      chainId: transaction.chainId
    },
    types: {
      Transaction: [
        { name: "txType", type: "uint256" },
        { name: "from", type: "uint256" },
        { name: "to", type: "uint256" },
        { name: "gasLimit", type: "uint256" },
        { name: "gasPerPubdataByteLimit", type: "uint256" },
        { name: "maxFeePerGas", type: "uint256" },
        { name: "maxPriorityFeePerGas", type: "uint256" },
        { name: "paymaster", type: "uint256" },
        { name: "nonce", type: "uint256" },
        { name: "value", type: "uint256" },
        { name: "data", type: "bytes" },
        { name: "factoryDeps", type: "bytes32[]" },
        { name: "paymasterInput", type: "bytes" }
      ]
    },
    primaryType: "Transaction",
    message
  };
};
function transactionToMessage(transaction) {
  const { gas, nonce, to: to4, from: from26, value, maxFeePerGas, maxPriorityFeePerGas, factoryDeps, paymaster, paymasterInput, gasPerPubdata, data } = transaction;
  return {
    txType: 113n,
    from: BigInt(from26),
    to: to4 ? BigInt(to4) : 0n,
    gasLimit: gas ?? 0n,
    gasPerPubdataByteLimit: gasPerPubdata ?? gasPerPubdataDefault,
    maxFeePerGas: maxFeePerGas ?? 0n,
    maxPriorityFeePerGas: maxPriorityFeePerGas ?? 0n,
    paymaster: paymaster ? BigInt(paymaster) : 0n,
    nonce: nonce ? BigInt(nonce) : 0n,
    value: value ?? 0n,
    data: data ? data : "0x0",
    factoryDeps: (factoryDeps == null ? void 0 : factoryDeps.map((dep) => toHex(hashBytecode(dep)))) ?? [],
    paymasterInput: paymasterInput ? paymasterInput : "0x"
  };
}

// node_modules/viem/_esm/zksync/chainConfig.js
var chainConfig = {
  formatters,
  serializers,
  custom: {
    getEip712Domain: getEip712Domain2
  }
};

// node_modules/viem/_esm/chains/definitions/abstract.js
var abstract = defineChain({
  ...chainConfig,
  id: 2741,
  name: "Abstract",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnet.abs.xyz"],
      webSocket: ["wss://api.mainnet.abs.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.mainnet.abs.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xAa4De41dba0Ca5dCBb288b7cC6b708F3aaC759E7",
      blockCreated: 5288
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 5263
    }
  }
});

// node_modules/viem/_esm/chains/definitions/abstractTestnet.js
var abstractTestnet = defineChain({
  ...chainConfig,
  id: 11124,
  name: "Abstract Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.abs.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.abscan.org"
    },
    native: {
      name: "Abstract Explorer",
      url: "https://explorer.testnet.abs.xyz"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 358349
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 431682
    }
  }
});

// node_modules/viem/_esm/chains/definitions/acala.js
var acala = defineChain({
  id: 787,
  name: "Acala",
  network: "acala",
  nativeCurrency: {
    name: "Acala",
    symbol: "ACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-acala.aca-api.network"],
      webSocket: ["wss://eth-rpc-acala.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acala Blockscout",
      url: "https://blockscout.acala.network",
      apiUrl: "https://blockscout.acala.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/acria.js
var acria = defineChain({
  id: 47,
  name: "Acria IntelliChain",
  nativeCurrency: {
    decimals: 18,
    name: "ACRIA",
    symbol: "ACRIA"
  },
  rpcUrls: {
    default: {
      http: ["https://aic.acria.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "Acria Explorer",
      url: "https://explorer.acria.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/adf.js
var adf = defineChain({
  id: 1215,
  name: "ADF Chain",
  nativeCurrency: { name: "ADDFILL", symbol: "ADF", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.adftechnology.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ADF Mainnet Explorer",
      url: "https://explorer.adftechnology.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/aioz.js
var aioz = defineChain({
  id: 168,
  name: "AIOZ Network",
  nativeCurrency: {
    decimals: 18,
    name: "AIOZ",
    symbol: "AIOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://eth-dataseed.aioz.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "AIOZ Explorer",
      url: "https://explorer.aioz.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/alephZero.js
var alephZero = defineChain({
  id: 41455,
  name: "Aleph Zero",
  nativeCurrency: { name: "Aleph Zero", symbol: "AZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Explorer",
      url: "https://evm-explorer.alephzero.org",
      apiUrl: "https://evm-explorer.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4603377
    }
  }
});

// node_modules/viem/_esm/chains/definitions/alephZeroTestnet.js
var alephZeroTestnet = defineChain({
  id: 2039,
  name: "Aleph Zero Testnet",
  nativeCurrency: { name: "TZERO", symbol: "TZERO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.alephzero-testnet.gelato.digital"],
      webSocket: ["wss://ws.alephzero-testnet.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "Aleph Zero EVM Testnet explorer",
      url: "https://evm-explorer-testnet.alephzero.org",
      apiUrl: "https://evm-explorer-testnet.alephzero.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2861745
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/alienX.js
var alienx = defineChain({
  id: 10241024,
  name: "AlienX Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://explorer.alienxchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/alienXHalTestnet.js
var alienxHalTestnet = defineChain({
  id: 10241025,
  name: "ALIENX Hal Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://hal-rpc.alienxchain.io/http"] }
  },
  blockExplorers: {
    default: {
      name: "AlienX Explorer",
      url: "https://hal-explorer.alienxchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/op-stack/contracts.js
var contracts = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};

// node_modules/viem/_esm/op-stack/formatters.js
var formatters2 = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        if (formatted.typeHex === "0x7e") {
          formatted.isSystemTx = transaction.isSystemTx;
          formatted.mint = transaction.mint ? hexToBigInt(transaction.mint) : void 0;
          formatted.sourceHash = transaction.sourceHash;
          formatted.type = "deposit";
        }
        return formatted;
      });
      return {
        transactions,
        stateRoot: args.stateRoot
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      const transaction = {};
      if (args.type === "0x7e") {
        transaction.isSystemTx = args.isSystemTx;
        transaction.mint = args.mint ? hexToBigInt(args.mint) : void 0;
        transaction.sourceHash = args.sourceHash;
        transaction.type = "deposit";
      }
      return transaction;
    }
  }),
  transactionReceipt: defineTransactionReceipt({
    format(args) {
      return {
        l1GasPrice: args.l1GasPrice ? hexToBigInt(args.l1GasPrice) : null,
        l1GasUsed: args.l1GasUsed ? hexToBigInt(args.l1GasUsed) : null,
        l1Fee: args.l1Fee ? hexToBigInt(args.l1Fee) : null,
        l1FeeScalar: args.l1FeeScalar ? Number(args.l1FeeScalar) : null
      };
    }
  })
};

// node_modules/viem/_esm/op-stack/serializers.js
function serializeTransaction3(transaction, signature) {
  if (isDeposit(transaction))
    return serializeTransactionDeposit(transaction);
  return serializeTransaction(transaction, signature);
}
var serializers2 = {
  transaction: serializeTransaction3
};
function serializeTransactionDeposit(transaction) {
  assertTransactionDeposit(transaction);
  const { sourceHash, data, from: from26, gas, isSystemTx, mint: mint2, to: to4, value } = transaction;
  const serializedTransaction = [
    sourceHash,
    from26,
    to4 ?? "0x",
    mint2 ? toHex(mint2) : "0x",
    value ? toHex(value) : "0x",
    gas ? toHex(gas) : "0x",
    isSystemTx ? "0x1" : "0x",
    data ?? "0x"
  ];
  return concatHex([
    "0x7e",
    toRlp(serializedTransaction)
  ]);
}
function isDeposit(transaction) {
  if (transaction.type === "deposit")
    return true;
  if (typeof transaction.sourceHash !== "undefined")
    return true;
  return false;
}
function assertTransactionDeposit(transaction) {
  const { from: from26, to: to4 } = transaction;
  if (from26 && !isAddress(from26))
    throw new InvalidAddressError({ address: from26 });
  if (to4 && !isAddress(to4))
    throw new InvalidAddressError({ address: to4 });
}

// node_modules/viem/_esm/op-stack/chainConfig.js
var chainConfig2 = {
  contracts,
  formatters: formatters2,
  serializers: serializers2
};

// node_modules/viem/_esm/chains/definitions/ancient8.js
var sourceId = 1;
var ancient8 = defineChain({
  ...chainConfig2,
  id: 888888888,
  name: "Ancient8",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 explorer",
      url: "https://scan.ancient8.gg",
      apiUrl: "https://scan.ancient8.gg/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId]: {
        address: "0xB09DC08428C8b4EFB4ff9C0827386CDF34277996"
      }
    },
    portal: {
      [sourceId]: {
        address: "0x639F2AECE398Aa76b07e59eF6abe2cFe32bacb68",
        blockCreated: 19070571
      }
    },
    l1StandardBridge: {
      [sourceId]: {
        address: "0xd5e3eDf5b68135D559D572E26bF863FBC1950033",
        blockCreated: 19070571
      }
    }
  },
  sourceId
});

// node_modules/viem/_esm/chains/definitions/ancient8Sepolia.js
var sourceId2 = 11155111;
var ancient8Sepolia = defineChain({
  ...chainConfig2,
  id: 28122024,
  name: "Ancient8 Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcv2-testnet.ancient8.gg"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ancient8 Celestia Testnet explorer",
      url: "https://scanv2-testnet.ancient8.gg",
      apiUrl: "https://scanv2-testnet.ancient8.gg/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId2]: {
        address: "0x942fD5017c0F60575930D8574Eaca13BEcD6e1bB"
      }
    },
    portal: {
      [sourceId2]: {
        address: "0xfa1d9E26A6aCD7b22115D27572c1221B9803c960",
        blockCreated: 4972908
      }
    },
    l1StandardBridge: {
      [sourceId2]: {
        address: "0xF6Bc0146d3c74D48306e79Ae134A260E418C9335",
        blockCreated: 4972908
      }
    }
  },
  sourceId: sourceId2
});

// node_modules/viem/_esm/chains/definitions/anvil.js
var anvil = defineChain({
  id: 31337,
  name: "Anvil",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/apeChain.js
var sourceId3 = 42161;
var apeChain = defineChain({
  id: 33139,
  name: "Ape Chain",
  nativeCurrency: {
    name: "ApeCoin",
    symbol: "APE",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.apechain.com/http"],
      webSocket: ["wss://rpc.apechain.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Apescan",
      url: "https://apescan.io",
      apiUrl: "https://api.apescan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 20889
    }
  },
  sourceId: sourceId3
});

// node_modules/viem/_esm/chains/definitions/apexTestnet.js
var apexTestnet = defineChain({
  id: 3993,
  name: "APEX Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.apexlayer.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-testnet.apexlayer.xyz",
      apiUrl: "https://exp-testnet.apexlayer.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf7642be33a6b18D16a995657adb5a68CD0438aE2",
      blockCreated: 283775
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arbitrum.js
var arbitrum = defineChain({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumGoerli.js
var arbitrumGoerli = defineChain({
  id: 421613,
  name: "Arbitrum Goerli",
  nativeCurrency: {
    name: "Arbitrum Goerli Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://goerli-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://goerli.arbiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 88114
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arbitrumNova.js
var arbitrumNova = defineChain({
  id: 42170,
  name: "Arbitrum Nova",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://nova.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://nova.arbiscan.io",
      apiUrl: "https://api-nova.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1746963
    }
  }
});

// node_modules/viem/_esm/chains/definitions/arbitrumSepolia.js
var arbitrumSepolia = defineChain({
  id: 421614,
  name: "Arbitrum Sepolia",
  nativeCurrency: {
    name: "Arbitrum Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rollup.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://sepolia.arbiscan.io",
      apiUrl: "https://api-sepolia.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 81930
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/areonNetwork.js
var areonNetwork = defineChain({
  id: 463,
  name: "Areon Network",
  nativeCurrency: { decimals: 18, name: "AREA", symbol: "AREA" },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.areon.network"],
      webSocket: ["wss://mainnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 353286
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/areonNetworkTestnet.js
var areonNetworkTestnet = defineChain({
  id: 462,
  name: "Areon Network Testnet",
  nativeCurrency: { decimals: 18, name: "TAREA", symbol: "TAREA" },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.areon.network"],
      webSocket: ["wss://testnet-ws.areon.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Areonscan",
      url: "https://areonscan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/artelaTestnet.js
var artelaTestnet = defineChain({
  id: 11822,
  name: "Artela Testnet",
  nativeCurrency: { name: "ART", symbol: "ART", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://betanet-rpc1.artela.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Artela",
      url: "https://betanet-scan.artela.network",
      apiUrl: "https://betanet-scan.artela.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd07c8635f76e8745Ee7092fbb6e8fbc5FeF09DD7",
      blockCreated: 7001871
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/arthera.js
var arthera = defineChain({
  id: 10242,
  name: "Arthera",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer.arthera.net",
      apiUrl: "https://explorer.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4502791
    }
  }
});

// node_modules/viem/_esm/chains/definitions/artheraTestnet.js
var artheraTestnet = defineChain({
  id: 10243,
  name: "Arthera Testnet",
  nativeCurrency: { name: "Arthera", symbol: "AA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-test.arthera.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arthera EVM Explorer",
      url: "https://explorer-test.arthera.net",
      apiUrl: "https://explorer-test.arthera.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 22051
    }
  }
});

// node_modules/viem/_esm/chains/definitions/assetChain.js
var assetChain = defineChain({
  id: 42420,
  name: "AssetChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Explorer",
      url: "https://scan.assetchain.org",
      apiUrl: "https://scan.assetchain.org/api"
    }
  },
  testnet: false,
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/assetChainTestnet.js
var assetChainTestnet = defineChain({
  id: 42421,
  name: "AssetChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Real World Asset",
    symbol: "RWA"
  },
  rpcUrls: {
    default: { http: ["https://enugu-rpc.assetchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Asset Chain Testnet Explorer",
      url: "https://scan-testnet.assetchain.org",
      apiUrl: "https://scan-testnet.assetchain.org/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0x989F832D35988cb5e3eB001Fa2Fe789469EC31Ea",
      blockCreated: 17177
    }
  }
});

// node_modules/viem/_esm/chains/definitions/astar.js
var astar = defineChain({
  id: 592,
  name: "Astar",
  network: "astar-mainnet",
  nativeCurrency: {
    name: "Astar",
    symbol: "ASTR",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://astar.api.onfinality.io/public"] }
  },
  blockExplorers: {
    default: {
      name: "Astar Subscan",
      url: "https://astar.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 761794
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/astarZkEVM.js
var astarZkEVM = defineChain({
  id: 3776,
  name: "Astar zkEVM",
  network: "AstarZkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-zkevm.astar.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Astar zkEVM Explorer",
      url: "https://astar-zkevm.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 93528
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/astarZkyoto.js
var astarZkyoto = defineChain({
  id: 6038361,
  name: "Astar zkEVM Testnet zKyoto",
  network: "zKyoto",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.startale.com/zkyoto"]
    }
  },
  blockExplorers: {
    default: {
      name: "zKyoto Explorer",
      url: "https://zkyoto.explorer.startale.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 196153
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/atletaOlympia.js
var atletaOlympia = defineChain({
  id: 2340,
  name: "Atleta Olympia",
  nativeCurrency: { decimals: 18, name: "Atla", symbol: "ATLA" },
  rpcUrls: {
    default: {
      http: [
        "https://testnet-rpc.atleta.network:9944",
        "https://testnet-rpc.atleta.network"
      ],
      ws: ["wss://testnet-rpc.atleta.network:9944"]
    }
  },
  blockExplorers: {
    default: {
      name: "Atleta Olympia Explorer",
      url: "https://blockscout.atleta.network",
      apiUrl: "https://blockscout.atleta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x1472ec6392180fb84F345d2455bCC75B26577115",
      blockCreated: 1076473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/aurora.js
var aurora = defineChain({
  id: 1313161554,
  name: "Aurora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://aurorascan.dev",
      apiUrl: "https://aurorascan.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 62907816
    }
  }
});

// node_modules/viem/_esm/chains/definitions/auroraTestnet.js
var auroraTestnet = defineChain({
  id: 1313161555,
  name: "Aurora Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://testnet.aurora.dev"] }
  },
  blockExplorers: {
    default: {
      name: "Aurorascan",
      url: "https://testnet.aurorascan.dev",
      apiUrl: "https://testnet.aurorascan.dev/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/auroria.js
var auroria = defineChain({
  id: 205205,
  name: "Auroria Testnet",
  network: "auroria",
  nativeCurrency: {
    name: "Auroria Stratis",
    symbol: "tSTRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://auroria.rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Auroria Testnet Explorer",
      url: "https://auroria.explorer.stratisevm.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/avalanche.js
var avalanche = defineChain({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});

// node_modules/viem/_esm/chains/definitions/avalancheFuji.js
var avalancheFuji = defineChain({
  id: 43113,
  name: "Avalanche Fuji",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche Fuji",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax-test.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://testnet.snowtrace.io",
      apiUrl: "https://api-testnet.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7096959
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/b3.js
var sourceId4 = 8453;
var b3 = defineChain({
  id: 8333,
  name: "B3",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  sourceId: sourceId4
});

// node_modules/viem/_esm/chains/definitions/b3Sepolia.js
var sourceId5 = 168587773;
var b3Sepolia = defineChain({
  id: 1993,
  name: "B3 Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.b3.fun/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.b3.fun"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  },
  testnet: true,
  sourceId: sourceId5
});

// node_modules/viem/_esm/chains/definitions/bahamut.js
var bahamut = defineChain({
  id: 5165,
  network: "bahamut",
  name: "Bahamut",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc1.bahamut.io",
        "https://bahamut-rpc.publicnode.com",
        "https://rpc2.bahamut.io"
      ],
      webSocket: [
        "wss://ws1.sahara.bahamutchain.com",
        "wss://bahamut-rpc.publicnode.com",
        "wss://ws2.sahara.bahamutchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://www.ftnscan.com",
      apiUrl: "https://www.ftnscan.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/base.js
var sourceId6 = 1;
var base = defineChain({
  ...chainConfig2,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId6]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [sourceId6]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [sourceId6]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [sourceId6]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: sourceId6
});

// node_modules/viem/_esm/chains/definitions/basecampTestnet.js
var basecampTestnet = defineChain({
  id: 123420001114,
  name: "Basecamp Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Camp",
    symbol: "CAMP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.basecamp.t.raas.gelato.cloud"] }
  },
  blockExplorers: {
    default: {
      name: "basecamp",
      url: "https://basecamp.cloud.blockscout.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/baseGoerli.js
var sourceId7 = 5;
var baseGoerli = defineChain({
  ...chainConfig2,
  id: 84531,
  name: "Base Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://goerli.base.org"] }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://goerli.basescan.org",
      apiUrl: "https://goerli.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId7]: {
        address: "0x2A35891ff30313CcFa6CE88dcf3858bb075A2298"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1376988
    },
    portal: {
      [sourceId7]: {
        address: "0xe93c8cD0D409341205A592f8c4Ac1A5fe5585cfA"
      }
    },
    l1StandardBridge: {
      [sourceId7]: {
        address: "0xfA6D8Ee5BE770F84FC001D098C4bD604Fe01284a"
      }
    }
  },
  testnet: true,
  sourceId: sourceId7
});

// node_modules/viem/_esm/chains/definitions/baseSepolia.js
var sourceId8 = 11155111;
var baseSepolia = defineChain({
  ...chainConfig2,
  id: 84532,
  network: "base-sepolia",
  name: "Base Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://sepolia.basescan.org",
      apiUrl: "https://api-sepolia.basescan.org/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId8]: {
        address: "0xd6E6dBf4F7EA0ac412fD8b65ED297e64BB7a06E1"
      }
    },
    l2OutputOracle: {
      [sourceId8]: {
        address: "0x84457ca9D0163FbC4bbfe4Dfbb20ba46e48DF254"
      }
    },
    portal: {
      [sourceId8]: {
        address: "0x49f53e41452c74589e85ca1677426ba426459e85",
        blockCreated: 4446677
      }
    },
    l1StandardBridge: {
      [sourceId8]: {
        address: "0xfd0Bf71F60660E2f608ed56e1659C450eB113120",
        blockCreated: 4446677
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1059647
    }
  },
  testnet: true,
  sourceId: sourceId8
});

// node_modules/viem/_esm/chains/definitions/beam.js
var beam = defineChain({
  id: 4337,
  name: "Beam",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc"],
      webSocket: ["wss://build.onbeam.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x4956f15efdc3dc16645e90cc356eafa65ffc65ec",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/beamTestnet.js
var beamTestnet = defineChain({
  id: 13337,
  name: "Beam Testnet",
  network: "beam",
  nativeCurrency: {
    decimals: 18,
    name: "Beam",
    symbol: "BEAM"
  },
  rpcUrls: {
    default: {
      http: ["https://build.onbeam.com/rpc/testnet"],
      webSocket: ["wss://build.onbeam.com/ws/testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beam Explorer",
      url: "https://subnets-test.avax.network/beam"
    }
  },
  contracts: {
    multicall3: {
      address: "0x9bf49b704ee2a095b95c1f2d4eb9010510c41c9e",
      blockCreated: 3
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bearNetworkChainMainnet.js
var bearNetworkChainMainnet = defineChain({
  id: 641230,
  name: "Bear Network Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BearNetworkChain",
    symbol: "BRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-mainnet.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkScan",
      url: "https://brnkscan.bearnetwork.net",
      apiUrl: "https://brnkscan.bearnetwork.net/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bearNetworkChainTestnet.js
var bearNetworkChainTestnet = defineChain({
  id: 751230,
  name: "Bear Network Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBRNKC",
    symbol: "tBRNKC"
  },
  rpcUrls: {
    default: { http: ["https://brnkc-test.bearnetwork.net"] }
  },
  blockExplorers: {
    default: {
      name: "BrnkTestScan",
      url: "https://brnktest-scan.bearnetwork.net",
      apiUrl: "https://brnktest-scan.bearnetwork.net/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachain.js
var berachain = defineChain({
  id: 80094,
  name: "Berachain",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ensRegistry: {
      address: "0x5b22280886a2f5e09a49bea7e320eab0e5320e28",
      blockCreated: 877007
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 877008
    }
  },
  rpcUrls: {
    default: { http: ["https://rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://berascan.com"
    }
  },
  ensTlds: [".bera"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/berachainBepolia.js
var berachainBepolia = defineChain({
  id: 80069,
  name: "Berachain Bepolia",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  rpcUrls: {
    default: { http: ["https://bepolia.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berascan",
      url: "https://bepolia.beratrail.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachainTestnet.js
var berachainTestnet = defineChain({
  id: 80085,
  name: "Berachain Artio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  rpcUrls: {
    default: { http: ["https://artio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain",
      url: "https://artio.beratrail.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 866924
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/berachainTestnetbArtio.js
var berachainTestnetbArtio = defineChain({
  id: 80084,
  name: "Berachain bArtio",
  nativeCurrency: {
    decimals: 18,
    name: "BERA Token",
    symbol: "BERA"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 109269
    },
    ensRegistry: {
      address: "0xB0eef18971290b333450586D33dcA6cE122651D2",
      blockCreated: 7736794
    },
    ensUniversalResolver: {
      address: "0x41692Ef1EA0C79E6b73077E4A67572D2BDbD7057",
      blockCreated: 7736795
    }
  },
  ensTlds: [".bera"],
  rpcUrls: {
    default: { http: ["https://bartio.rpc.berachain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Berachain bArtio Beratrail",
      url: "https://bartio.beratrail.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bevmMainnet.js
var bevmMainnet = defineChain({
  id: 11501,
  name: "BEVM Mainnet",
  nativeCurrency: { name: "Bitcoin", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet-1.bevm.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bevmscan",
      url: "https://scan-mainnet.bevm.io",
      apiUrl: "https://scan-mainnet-api.bevm.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bifrost.js
var bifrost = defineChain({
  id: 3068,
  name: "Bifrost Mainnet",
  nativeCurrency: { name: "BFC", symbol: "BFC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://public-01.mainnet.bifrostnetwork.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bifrost Blockscout",
      url: "https://explorer.mainnet.bifrostnetwork.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitgert.js
var bitgert = defineChain({
  id: 32520,
  name: "Bitgert Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Brise",
    symbol: "Brise"
  },
  rpcUrls: {
    default: { http: ["https://rpc-bitgert.icecreamswap.com"] }
  },
  blockExplorers: {
    default: {
      name: "Bitgert Scan",
      url: "https://brisescan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2118034
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitkub.js
var bitkub = defineChain({
  id: 96,
  name: "Bitkub",
  nativeCurrency: { name: "Bitkub", symbol: "KUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Mainnet Explorer",
      url: "https://www.bkcscan.com",
      apiUrl: "https://www.bkcscan.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitkubTestnet.js
var bitkubTestnet = defineChain({
  id: 25925,
  name: "Bitkub Testnet",
  network: "Bitkub Testnet",
  nativeCurrency: { name: "Bitkub Test", symbol: "tKUB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.bitkubchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitkub Chain Testnet Explorer",
      url: "https://testnet.bkcscan.com",
      apiUrl: "https://testnet.bkcscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bitlayer.js
var bitlayer = defineChain({
  id: 200901,
  name: "Bitlayer Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org"],
      webSocket: ["wss://ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer mainnet scan",
      url: "https://www.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 2421963
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitlayerTestnet.js
var bitlayerTestnet = defineChain({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: ["wss://testnet-ws.bitlayer.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "bitlayer testnet scan",
      url: "https://testnet.btrscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5B256fE9e993902eCe49D138a5b1162cBb529474",
      blockCreated: 4135671
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bitrock.js
var bitrock = defineChain({
  id: 7171,
  name: "Bitrock Mainnet",
  nativeCurrency: { name: "BROCK", symbol: "BROCK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://brockrpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitrock Explorer",
      url: "https://explorer.bit-rock.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bitTorrent.js
var bitTorrent = defineChain({
  id: 199,
  name: "BitTorrent",
  network: "bittorrent-chain-mainnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://bttcscan.com",
      apiUrl: "https://api.bttcscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 31078552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bitTorrentTestnet.js
var bitTorrentTestnet = defineChain({
  id: 1028,
  name: "BitTorrent Chain Testnet",
  network: "bittorrent-chain-testnet",
  nativeCurrency: { name: "BitTorrent", symbol: "BTT", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testrpc.bittorrentchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Bttcscan",
      url: "https://testnet.bttcscan.com",
      apiUrl: "https://testnet.bttcscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/birdlayer.js
var birdlayer = defineChain({
  id: 53456,
  name: "BirdLayer",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.birdlayer.xyz", "https://rpc1.birdlayer.xyz"],
      webSocket: ["wss://rpc.birdlayer.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "BirdLayer Explorer",
      url: "https://scan.birdlayer.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/blast.js
var sourceId9 = 1;
var blast = defineChain({
  ...chainConfig2,
  id: 81457,
  name: "Blast",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blast.io"] }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://blastscan.io",
      apiUrl: "https://api.blastscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 212929
    }
  },
  sourceId: sourceId9
});

// node_modules/viem/_esm/chains/definitions/blastSepolia.js
var sourceId10 = 11155111;
var blastSepolia = defineChain({
  id: 168587773,
  name: "Blast Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.blast.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blastscan",
      url: "https://sepolia.blastscan.io",
      apiUrl: "https://api-sepolia.blastscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 756690
    }
  },
  testnet: true,
  sourceId: sourceId10
});

// node_modules/viem/_esm/chains/definitions/bob.js
var sourceId11 = 1;
var bob = defineChain({
  ...chainConfig2,
  id: 60808,
  name: "BOB",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gobob.xyz"],
      webSocket: ["wss://rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Explorer",
      url: "https://explorer.gobob.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 23131
    },
    l2OutputOracle: {
      [sourceId11]: {
        address: "0xdDa53E23f8a32640b04D7256e651C1db98dB11C1",
        blockCreated: 4462615
      }
    },
    portal: {
      [sourceId11]: {
        address: "0x8AdeE124447435fE03e3CD24dF3f4cAE32E65a3E",
        blockCreated: 4462615
      }
    }
  },
  sourceId: sourceId11
});

// node_modules/viem/_esm/chains/definitions/boba.js
var boba = defineChain({
  id: 288,
  name: "Boba Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://bobascan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 446859
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bobaSepolia.js
var bobaSepolia = defineChain({
  id: 28882,
  name: "Boba Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://sepolia.boba.network"] }
  },
  blockExplorers: {
    default: {
      name: "BOBAScan",
      url: "https://testnet.bobascan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bobSepolia.js
var sourceId12 = 11155111;
var bobSepolia = defineChain({
  ...chainConfig2,
  id: 808813,
  name: "BOB Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://bob-sepolia.rpc.gobob.xyz"],
      webSocket: ["wss://bob-sepolia.rpc.gobob.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "BOB Sepolia Explorer",
      url: "https://bob-sepolia.explorer.gobob.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 35677
    },
    l2OutputOracle: {
      [sourceId12]: {
        address: "0x14D0069452b4AE2b250B395b8adAb771E4267d2f",
        blockCreated: 4462615
      }
    },
    portal: {
      [sourceId12]: {
        address: "0x867B1Aa872b9C8cB5E9F7755feDC45BB24Ad0ae4",
        blockCreated: 4462615
      }
    }
  },
  testnet: true,
  sourceId: sourceId12
});

// node_modules/viem/_esm/chains/definitions/boolBetaMainnet.js
var boolBetaMainnet = defineChain({
  id: 11100,
  name: "Bool Beta Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BOL",
    symbol: "BOL"
  },
  rpcUrls: {
    default: { http: ["https://beta-rpc-node-http.bool.network"] }
  },
  blockExplorers: {
    default: {
      name: "BoolScan",
      url: "https://beta-mainnet.boolscan.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/botanixTestnet.js
var botanixTestnet = defineChain({
  id: 3636,
  name: "Botanix Testnet",
  nativeCurrency: { name: "Botanix", symbol: "BTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node.botanixlabs.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Botanix Testnet Explorer",
      url: "https://testnet.botanixscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bounceBit.js
var bounceBit = defineChain({
  id: 6001,
  name: "BounceBit Mainnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-mainnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://bbscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bounceBitTestnet.js
var bounceBitTestnet = defineChain({
  id: 6e3,
  name: "BounceBit Testnet",
  nativeCurrency: { name: "BounceBit", symbol: "BB", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://fullnode-testnet.bouncebitapi.com"] }
  },
  blockExplorers: {
    default: {
      name: "BB Scan",
      url: "https://testnet.bbscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bronos.js
var bronos = defineChain({
  id: 1039,
  name: "Bronos",
  nativeCurrency: {
    decimals: 18,
    name: "BRO",
    symbol: "BRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://broscan.bronos.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bronosTestnet.js
var bronosTestnet = defineChain({
  id: 1038,
  name: "Bronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bronos Coin",
    symbol: "tBRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-testnet.bronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "BronoScan",
      url: "https://tbroscan.bronos.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bsc.js
var bsc = defineChain({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bscGreenfield.js
var bscGreenfield = defineChain({
  id: 1017,
  name: "BNB Greenfield Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://greenfield-chain.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "BNB Greenfield Mainnet Scan",
      url: "https://greenfieldscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/bscTestnet.js
var bscTestnet = defineChain({
  id: 97,
  name: "Binance Smart Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://data-seed-prebsc-1-s1.bnbchain.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://testnet.bscscan.com",
      apiUrl: "https://api-testnet.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 17422483
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bsquared.js
var bsquared = defineChain({
  id: 223,
  name: "B2",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.bsquared.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bsquaredTestnet.js
var bsquaredTestnet = defineChain({
  id: 1123,
  name: "B2 Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bsquared.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-explorer.bsquared.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/btr.js
var btr = defineChain({
  id: 200901,
  name: "Bitlayer",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.bitlayer.org", "https://rpc.bitlayer-rpc.com"],
      webSocket: ["wss://ws.bitlayer.org", "wss://ws.bitlayer-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://www.btrscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/btrTestnet.js
var btrTestnet = defineChain({
  id: 200810,
  name: "Bitlayer Testnet",
  nativeCurrency: {
    name: "Bitcoin",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.bitlayer.org"],
      webSocket: [
        "wss://testnet-ws.bitlayer.org",
        "wss://testnet-ws.bitlayer-rpc.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Bitlayer(BTR) Scan",
      url: "https://testnet.btrscan.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/bxn.js
var bxn = defineChain({
  id: 4999,
  name: "BlackFort Exchange Network",
  nativeCurrency: { name: "BlackFort Token", symbol: "BXN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.blackfort.network",
      apiUrl: "https://explorer.blackfort.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/bxnTestnet.js
var bxnTestnet = defineChain({
  id: 4777,
  name: "BlackFort Exchange Network Testnet",
  nativeCurrency: {
    name: "BlackFort Testnet Token",
    symbol: "TBXN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.blackfort.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.blackfort.network",
      apiUrl: "https://testnet-explorer.blackfort.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cannon.js
var cannon = defineChain({
  id: 13370,
  name: "Cannon",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/canto.js
var canto = defineChain({
  id: 7700,
  name: "Canto",
  nativeCurrency: {
    decimals: 18,
    name: "Canto",
    symbol: "CANTO"
  },
  rpcUrls: {
    default: { http: ["https://canto.gravitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Tuber.Build (Blockscout)",
      url: "https://tuber.build"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2905789
    }
  }
});

// node_modules/viem/_esm/celo/fees.js
var fees = {
  /*
     * Estimates the fees per gas for a transaction.
  
     * If the transaction is to be paid in a token (feeCurrency is present) then the fees
     * are estimated in the value of the token. Otherwise falls back to the default
     * estimation by returning null.
     *
     * @param params fee estimation function parameters
     */
  estimateFeesPerGas: async (params) => {
    var _a2;
    if (!((_a2 = params.request) == null ? void 0 : _a2.feeCurrency))
      return null;
    const [gasPrice, maxPriorityFeePerGas] = await Promise.all([
      estimateFeePerGasInFeeCurrency(params.client, params.request.feeCurrency),
      estimateMaxPriorityFeePerGasInFeeCurrency(params.client, params.request.feeCurrency)
    ]);
    const maxFeePerGas = params.multiply(gasPrice - maxPriorityFeePerGas) + maxPriorityFeePerGas;
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  }
};
async function estimateFeePerGasInFeeCurrency(client, feeCurrency) {
  const fee = await client.request({
    method: "eth_gasPrice",
    params: [feeCurrency]
  });
  return BigInt(fee);
}
async function estimateMaxPriorityFeePerGasInFeeCurrency(client, feeCurrency) {
  const feesPerGas = await client.request({
    method: "eth_maxPriorityFeePerGas",
    params: [feeCurrency]
  });
  return BigInt(feesPerGas);
}

// node_modules/viem/_esm/celo/utils.js
function isEmpty(value) {
  return value === 0 || value === 0n || value === void 0 || value === null || value === "0" || value === "" || typeof value === "string" && (trim(value).toLowerCase() === "0x" || trim(value).toLowerCase() === "0x00");
}
function isPresent(value) {
  return !isEmpty(value);
}
function isEIP1559(transaction) {
  return typeof transaction.maxFeePerGas !== "undefined" && typeof transaction.maxPriorityFeePerGas !== "undefined";
}
function isCIP64(transaction) {
  if (transaction.type === "cip64") {
    return true;
  }
  return isEIP1559(transaction) && isPresent(transaction.feeCurrency);
}

// node_modules/viem/_esm/celo/formatters.js
var formatters3 = {
  block: defineBlock({
    format(args) {
      var _a2;
      const transactions = (_a2 = args.transactions) == null ? void 0 : _a2.map((transaction) => {
        if (typeof transaction === "string")
          return transaction;
        const formatted = formatTransaction(transaction);
        return {
          ...formatted,
          ...transaction.gatewayFee ? {
            gatewayFee: hexToBigInt(transaction.gatewayFee),
            gatewayFeeRecipient: transaction.gatewayFeeRecipient
          } : {},
          feeCurrency: transaction.feeCurrency
        };
      });
      return {
        transactions,
        ...args.randomness ? { randomness: args.randomness } : {}
      };
    }
  }),
  transaction: defineTransaction({
    format(args) {
      if (args.type === "0x7e")
        return {
          isSystemTx: args.isSystemTx,
          mint: args.mint ? hexToBigInt(args.mint) : void 0,
          sourceHash: args.sourceHash,
          type: "deposit"
        };
      const transaction = { feeCurrency: args.feeCurrency };
      if (args.type === "0x7b")
        transaction.type = "cip64";
      else {
        if (args.type === "0x7c")
          transaction.type = "cip42";
        transaction.gatewayFee = args.gatewayFee ? hexToBigInt(args.gatewayFee) : null;
        transaction.gatewayFeeRecipient = args.gatewayFeeRecipient;
      }
      return transaction;
    }
  }),
  transactionRequest: defineTransactionRequest({
    format(args) {
      const request = {};
      if (args.feeCurrency)
        request.feeCurrency = args.feeCurrency;
      if (isCIP64(args))
        request.type = "0x7b";
      return request;
    }
  })
};

// node_modules/viem/_esm/celo/serializers.js
function serializeTransaction4(transaction, signature) {
  if (isCIP64(transaction))
    return serializeTransactionCIP64(transaction, signature);
  return serializeTransaction3(transaction, signature);
}
var serializers3 = {
  transaction: serializeTransaction4
};
function serializeTransactionCIP64(transaction, signature) {
  assertTransactionCIP64(transaction);
  const { chainId, gas, nonce, to: to4, value, maxFeePerGas, maxPriorityFeePerGas, accessList, feeCurrency, data } = transaction;
  const serializedTransaction = [
    toHex(chainId),
    nonce ? toHex(nonce) : "0x",
    maxPriorityFeePerGas ? toHex(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? toHex(maxFeePerGas) : "0x",
    gas ? toHex(gas) : "0x",
    to4 ?? "0x",
    value ? toHex(value) : "0x",
    data ?? "0x",
    serializeAccessList(accessList),
    feeCurrency,
    ...toYParitySignatureArray(transaction, signature)
  ];
  return concatHex([
    "0x7b",
    toRlp(serializedTransaction)
  ]);
}
var MAX_MAX_FEE_PER_GAS = maxUint256;
function assertTransactionCIP64(transaction) {
  const { chainId, maxPriorityFeePerGas, gasPrice, maxFeePerGas, to: to4, feeCurrency } = transaction;
  if (chainId <= 0)
    throw new InvalidChainIdError({ chainId });
  if (to4 && !isAddress(to4))
    throw new InvalidAddressError({ address: to4 });
  if (gasPrice)
    throw new BaseError("`gasPrice` is not a valid CIP-64 Transaction attribute.");
  if (isPresent(maxFeePerGas) && maxFeePerGas > MAX_MAX_FEE_PER_GAS)
    throw new FeeCapTooHighError({ maxFeePerGas });
  if (isPresent(maxPriorityFeePerGas) && isPresent(maxFeePerGas) && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError({ maxFeePerGas, maxPriorityFeePerGas });
  if (isPresent(feeCurrency) && !isAddress(feeCurrency)) {
    throw new BaseError("`feeCurrency` MUST be a token address for CIP-64 transactions.");
  }
  if (isEmpty(feeCurrency)) {
    throw new BaseError("`feeCurrency` must be provided for CIP-64 transactions.");
  }
}

// node_modules/viem/_esm/celo/chainConfig.js
var chainConfig3 = {
  contracts,
  formatters: formatters3,
  serializers: serializers3,
  fees
};

// node_modules/viem/_esm/chains/definitions/celo.js
var celo = defineChain({
  ...chainConfig3,
  id: 42220,
  name: "Celo",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "CELO"
  },
  rpcUrls: {
    default: { http: ["https://forno.celo.org"] }
  },
  blockExplorers: {
    default: {
      name: "Celo Explorer",
      url: "https://celoscan.io",
      apiUrl: "https://api.celoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13112599
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/celoAlfajores.js
var sourceId13 = 17e3;
var celoAlfajores = defineChain({
  ...chainConfig3,
  id: 44787,
  name: "Alfajores",
  nativeCurrency: {
    decimals: 18,
    name: "CELO",
    symbol: "A-CELO"
  },
  rpcUrls: {
    default: {
      http: ["https://alfajores-forno.celo-testnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Celo Alfajores Explorer",
      url: "https://celo-alfajores.blockscout.com",
      apiUrl: "https://celo-alfajores.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig3.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 14569001
    },
    portal: {
      [sourceId13]: {
        address: "0x82527353927d8D069b3B452904c942dA149BA381",
        blockCreated: 2411324
      }
    },
    disputeGameFactory: {
      [sourceId13]: {
        address: "0xE28AAdcd9883746c0e5068F58f9ea06027b214cb",
        blockCreated: 2411324
      }
    },
    l2OutputOracle: {
      [sourceId13]: {
        address: "0x4a2635e9e4f6e45817b1D402ac4904c1d1752438",
        blockCreated: 2411324
      }
    },
    l1StandardBridge: {
      [sourceId13]: {
        address: "0xD1B0E0581973c9eB7f886967A606b9441A897037",
        blockCreated: 2411324
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/chang.js
var chang = defineChain({
  id: 5858,
  name: "Chang Chain Foundation Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "CTH",
    symbol: "CTH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.cthscan.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chang Chain explorer",
      url: "https://cthscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/chiliz.js
var chiliz = defineChain({
  id: 88888,
  name: "Chiliz Chain",
  network: "chiliz-chain",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: ["https://chiliz-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "https://scan.chiliz.com",
      apiUrl: "https://scan.chiliz.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/chips.js
var chips = defineChain({
  id: 2882,
  name: "Chips Network",
  network: "CHIPS",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: [
        "https://node.chips.ooo/wasp/api/v1/chains/iota1pp3d3mnap3ufmgqnjsnw344sqmf5svjh26y2khnmc89sv6788y3r207a8fn/evm"
      ]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/citreaTestnet.js
var citreaTestnet = defineChain({
  id: 5115,
  name: "Citrea Testnet",
  nativeCurrency: { name: "cBTC", symbol: "cBTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.citrea.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Citrea Explorer",
      url: "https://explorer.testnet.citrea.xyz",
      apiUrl: "https://explorer.testnet.citrea.xyz/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/classic.js
var classic = defineChain({
  id: 61,
  name: "Ethereum Classic",
  nativeCurrency: {
    decimals: 18,
    name: "ETC",
    symbol: "ETC"
  },
  rpcUrls: {
    default: { http: ["https://etc.rivet.link"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.com/etc/mainnet"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/coinbit.js
var coinbit = defineChain({
  id: 112,
  name: "Coinbit Mainnet",
  nativeCurrency: { name: "GIDR", symbol: "GIDR", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://coinbit-rpc-mainnet.chain.sbcrypto.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Coinbit Explorer",
      url: "https://coinbit-explorer.chain.sbcrypto.app"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/coinex.js
var coinex = defineChain({
  id: 52,
  name: "CoinEx Mainnet",
  nativeCurrency: { name: "cet", symbol: "cet", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.coinex.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "CoinEx Explorer",
      url: "https://www.coinex.net"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/confluxESpace.js
var confluxESpace = defineChain({
  id: 1030,
  name: "Conflux eSpace",
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm.confluxrpc.com"],
      webSocket: ["wss://evm.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evm.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 68602935
    }
  }
});

// node_modules/viem/_esm/chains/definitions/confluxESpaceTestnet.js
var confluxESpaceTestnet = defineChain({
  id: 71,
  name: "Conflux eSpace Testnet",
  network: "cfx-espace-testnet",
  testnet: true,
  nativeCurrency: { name: "Conflux", symbol: "CFX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmtestnet.confluxrpc.com"],
      webSocket: ["wss://evmtestnet.confluxrpc.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "ConfluxScan",
      url: "https://evmtestnet.confluxscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xEFf0078910f638cd81996cc117bccD3eDf2B072F",
      blockCreated: 117499050
    }
  }
});

// node_modules/viem/_esm/chains/definitions/coreDao.js
var coreDao = defineChain({
  id: 1116,
  name: "Core Dao",
  nativeCurrency: {
    decimals: 18,
    name: "Core",
    symbol: "CORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.coredao.org"] }
  },
  blockExplorers: {
    default: {
      name: "CoreDao",
      url: "https://scan.coredao.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 11907934
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/coreTestnet1.js
var coreTestnet1 = defineChain({
  id: 1115,
  name: "Core Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tCore",
    symbol: "TCORE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet",
      url: "https://scan.test.btcs.network",
      apiUrl: "https://api.test.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xCcddF20A1932537123C2E48Bd8e00b108B8f7569",
      blockCreated: 29350509
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/coreTestnet2.js
var coreTestnet2 = defineChain({
  id: 1114,
  name: "Core Testnet2",
  nativeCurrency: {
    decimals: 18,
    name: "tCore2",
    symbol: "TCORE2"
  },
  rpcUrls: {
    default: { http: ["https://rpc.test2.btcs.network"] }
  },
  blockExplorers: {
    default: {
      name: "Core Testnet2",
      url: "https://scan.test2.btcs.network",
      apiUrl: "https://api.test2.btcs.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x3CB285ff3Cd5C7C7e570b1E7DE3De17A0f985e56",
      blockCreated: 3838600
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/corn.js
var sourceId14 = 1;
var corn = defineChain({
  id: 21e6,
  name: "Corn",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Explorer",
      url: "https://cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/21000000/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3228
    }
  },
  sourceId: sourceId14
});

// node_modules/viem/_esm/chains/definitions/cornTestnet.js
var sourceId15 = 11155111;
var cornTestnet = defineChain({
  id: 21000001,
  name: "Corn Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcorn",
    symbol: "BTCN"
  },
  rpcUrls: {
    default: { http: ["https://21000001.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Corn Testnet Explorer",
      url: "https://testnet.cornscan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/21000001/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4886
    }
  },
  testnet: true,
  sourceId: sourceId15
});

// node_modules/viem/_esm/chains/definitions/crab.js
var crab = defineChain({
  id: 44,
  name: "Crab Network",
  nativeCurrency: {
    decimals: 18,
    name: "Crab Network Native Token",
    symbol: "CRAB"
  },
  rpcUrls: {
    default: {
      http: ["https://crab-rpc.darwinia.network"],
      webSocket: ["wss://crab-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://crab-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3032593
    }
  }
});

// node_modules/viem/_esm/chains/definitions/creatorTestnet.js
var creatorTestnet = defineChain({
  id: 66665,
  name: "Creator",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.creatorchain.io"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.creatorchain.io" }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Mainnet.js
var creditCoin3Mainnet = defineChain({
  id: 102030,
  name: "Creditcoin3 Mainnet",
  nativeCurrency: { name: "Creditcoin3 Mainnet", symbol: "CTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet3.creditcoin.network"],
      webSocket: ["wss://mainnet3.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin.blockscout.com",
      apiUrl: "https://creditcoin.blockscout.com/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/creditCoin3Testnet.js
var creditCoin3Testnet = defineChain({
  id: 102031,
  name: "Creditcoin3 Testnet",
  nativeCurrency: { name: "Creditcoin3 Testnet", symbol: "TCTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cc3-testnet.creditcoin.network"],
      webSocket: ["wss://rpc.cc3-testnet.creditcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://creditcoin-testnet.blockscout.com",
      apiUrl: "https://creditcoin-testnet.blockscout.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cronos.js
var cronos = defineChain({
  id: 25,
  name: "Cronos Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos",
    symbol: "CRO"
  },
  rpcUrls: {
    default: { http: ["https://evm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://explorer.cronos.org",
      apiUrl: "https://explorer-api.cronos.org/mainnet/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1963112
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cronosTestnet.js
var cronosTestnet = defineChain({
  id: 338,
  name: "Cronos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CRO",
    symbol: "tCRO"
  },
  rpcUrls: {
    default: { http: ["https://evm-t3.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos Explorer",
      url: "https://cronos.org/explorer/testnet3"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 10191251
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cronoszkEVM.js
var cronoszkEVM = defineChain({
  id: 388,
  name: "Cronos zkEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM CRO",
    symbol: "zkCRO"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM (Mainnet) Chain Explorer",
      url: "https://explorer.zkevm.cronos.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x06f4487d7c4a5983d2660db965cc6d2565e4cfaa",
      blockCreated: 72
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cronoszkEVMTestnet.js
var cronoszkEVMTestnet = defineChain({
  id: 282,
  name: "Cronos zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Cronos zkEVM Test Coin",
    symbol: "zkTCRO"
  },
  rpcUrls: {
    default: { http: ["https://testnet.zkevm.cronos.org"] }
  },
  blockExplorers: {
    default: {
      name: "Cronos zkEVM Testnet Explorer",
      url: "https://explorer.zkevm.cronos.org/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/crossbell.js
var crossbell = defineChain({
  id: 3737,
  name: "Crossbell",
  nativeCurrency: {
    decimals: 18,
    name: "CSB",
    symbol: "CSB"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.crossbell.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "CrossScan",
      url: "https://scan.crossbell.io",
      apiUrl: "https://scan.crossbell.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 38246031
    }
  }
});

// node_modules/viem/_esm/chains/definitions/curtis.js
var curtis = defineChain({
  id: 33111,
  name: "Curtis",
  nativeCurrency: { name: "ApeCoin", symbol: "APE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.curtis.apechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Curtis Explorer",
      url: "https://explorer.curtis.apechain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/cyber.js
var cyber = defineChain({
  id: 7560,
  name: "Cyber",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://cyberscan.co",
      apiUrl: "https://cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/cyberTestnet.js
var cyberTestnet = defineChain({
  id: 111557560,
  name: "Cyber Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://cyber-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet.cyberscan.co",
      apiUrl: "https://testnet.cyberscan.co/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xffc391F0018269d4758AEA1a144772E8FB99545E",
      blockCreated: 304545
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dailyNetwork.js
var dailyNetwork = defineChain({
  id: 824,
  name: "Daily Network Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mainnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Mainnet Explorer",
      url: "https://explorer.mainnet.dailycrypto.net"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dailyNetworkTestnet.js
var dailyNetworkTestnet = defineChain({
  id: 825,
  name: "Daily Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Daily",
    symbol: "DLY"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.dailycrypto.net"] }
  },
  blockExplorers: {
    default: {
      name: "Daily Testnet Explorer",
      url: "https://explorer.testnet.dailycrypto.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/darwinia.js
var darwinia = defineChain({
  id: 46,
  name: "Darwinia Network",
  nativeCurrency: {
    decimals: 18,
    name: "RING",
    symbol: "RING"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.darwinia.network"],
      webSocket: ["wss://rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Explorer", url: "https://explorer.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69420
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dbkchain.js
var dbkchain = defineChain({
  id: 20240603,
  name: "DBK chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.dbkchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "DBK Chain Explorer",
      url: "https://scan.dbkchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dchain.js
var dchain = defineChain({
  ...chainConfig2,
  id: 2716446429837e3,
  name: "Dchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dchain-2716446429837000-1.jsonrpc.sagarpc.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchain-2716446429837000-1.sagaexplorer.io",
      apiUrl: "https://api-dchain-2716446429837000-1.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  }
});

// node_modules/viem/_esm/chains/definitions/dchainTestnet.js
var dchainTestnet = defineChain({
  ...chainConfig2,
  id: 2713017997578e3,
  name: "Dchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://dchaintestnet-2713017997578000-1.jsonrpc.testnet.sagarpc.io"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Dchain Explorer",
      url: "https://dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io",
      apiUrl: "https://api-dchaintestnet-2713017997578000-1.testnet.sagaexplorer.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  }
});

// node_modules/viem/_esm/chains/definitions/defichainEvm.js
var defichainEvm = defineChain({
  id: 1130,
  network: "defichain-evm",
  name: "DeFiChain EVM Mainnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.mainnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 137852
    }
  }
});

// node_modules/viem/_esm/chains/definitions/defichainEvmTestnet.js
var defichainEvmTestnet = defineChain({
  id: 1131,
  network: "defichain-evm-testnet",
  name: "DeFiChain EVM Testnet",
  nativeCurrency: {
    name: "DeFiChain",
    symbol: "DFI",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth.testnet.ocean.jellyfishsdk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DeFiScan",
      url: "https://meta.defiscan.live/?network=TestNet"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 156462
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/degen.js
var degen = defineChain({
  id: 666666666,
  name: "Degen",
  nativeCurrency: {
    decimals: 18,
    name: "Degen",
    symbol: "DEGEN"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.degen.tips"],
      webSocket: ["wss://rpc.degen.tips"]
    }
  },
  blockExplorers: {
    default: {
      name: "Degen Chain Explorer",
      url: "https://explorer.degen.tips",
      apiUrl: "https://explorer.degen.tips/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dfk.js
var dfk = defineChain({
  id: 53935,
  name: "DFK Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Jewel",
    symbol: "JEWEL"
  },
  rpcUrls: {
    default: {
      http: ["https://subnets.avax.network/defi-kingdoms/dfk-chain/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "DFKSubnetScan",
      url: "https://subnets.avax.network/defi-kingdoms"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14790551
    }
  }
});

// node_modules/viem/_esm/chains/definitions/diode.js
var diode = defineChain({
  id: 15,
  name: "Diode Prenet",
  nativeCurrency: {
    decimals: 18,
    name: "DIODE",
    symbol: "DIODE"
  },
  rpcUrls: {
    default: {
      http: ["https://prenet.diode.io:8443"],
      webSocket: ["wss://prenet.diode.io:8443/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Diode Explorer",
      url: "https://diode.io/prenet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/disChain.js
var disChain = defineChain({
  id: 513100,
  name: "DisChain",
  nativeCurrency: {
    decimals: 18,
    name: "DIS",
    symbol: "DIS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dischain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "DisChain Explorer",
      url: "https://www.oklink.com/dis"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dodochainTestnet.js
var dodochainTestnet = defineChain({
  id: 53457,
  name: "DODOchain Testnet",
  nativeCurrency: { decimals: 18, name: "DODO", symbol: "DODO" },
  rpcUrls: {
    default: {
      http: ["https://dodochain-testnet.alt.technology"],
      webSocket: ["wss://dodochain-testnet.alt.technology/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "DODOchain Testnet (Sepolia) Explorer",
      url: "https://testnet-scan.dodochain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dogechain.js
var dogechain = defineChain({
  id: 2e3,
  name: "Dogechain",
  nativeCurrency: {
    decimals: 18,
    name: "Wrapped Dogecoin",
    symbol: "WDOGE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.dogechain.dog"] }
  },
  blockExplorers: {
    default: {
      name: "DogeChainExplorer",
      url: "https://explorer.dogechain.dog",
      apiUrl: "https://explorer.dogechain.dog/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x68a8609a60a008EFA633dfdec592c03B030cC508",
      blockCreated: 25384031
    }
  }
});

// node_modules/viem/_esm/chains/definitions/donatuz.js
var donatuz = defineChain({
  id: 42026,
  name: "Donatuz",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.donatuz.com"] }
  },
  blockExplorers: {
    default: {
      name: "Donatuz Explorer",
      url: "https://explorer.donatuz.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dosChain.js
var dosChain = defineChain({
  id: 7979,
  name: "DOS Chain",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://main.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Explorer",
      url: "https://doscan.io",
      apiUrl: "https://api.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 161908
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dosChainTestnet.js
var dosChainTestnet = defineChain({
  id: 3939,
  name: "DOS Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "DOS Chain Testnet",
    symbol: "DOS"
  },
  rpcUrls: {
    default: { http: ["https://test.doschain.com"] }
  },
  blockExplorers: {
    default: {
      name: "DOS Chain Testnet Explorer",
      url: "https://test.doscan.io",
      apiUrl: "https://api-test.doscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 69623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dreyerxMainnet.js
var dreyerxMainnet = defineChain({
  id: 23451,
  name: "DreyerX Mainnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Scan",
      url: "https://scan.dreyerx.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/dreyerxTestnet.js
var dreyerxTestnet = defineChain({
  id: 23452,
  name: "DreyerX Testnet",
  nativeCurrency: {
    name: "DreyerX",
    symbol: "DRX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["http://testnet-rpc.dreyerx.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "DreyerX Testnet Scan",
      url: "https://testnet-scan.dreyerx.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/dustboyIoT.js
var dustboyIoT = defineChain({
  id: 555888,
  name: "DustBoy IoT",
  nativeCurrency: { name: "Ether", symbol: "DST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dustboy-rpc.jibl2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://dustboy.jibl2.com",
      apiUrl: "https://dustboy.jibl2.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xFFD34aa2C62B2D52E00A361e466C229788f4eD6a",
      blockCreated: 526569
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/dymension.js
var dymension = defineChain({
  id: 1100,
  name: "Dymension",
  nativeCurrency: {
    name: "DYM",
    symbol: "DYM",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://dymension-evm-rpc.publicnode.com"],
      webSocket: ["wss://dymension-evm-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Dym FYI",
      url: "https://dym.fyi"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/edexaTestnet.js
var edexaTestnet = defineChain({
  id: 1995,
  name: "edeXa Testnet",
  nativeCurrency: { name: "edeXa", symbol: "tEDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Testnet Explorer",
      url: "https://explorer.testnet.edexa.network",
      apiUrl: "https://explorer.testnet.edexa.network/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/edexa.js
var edexa = defineChain({
  id: 5424,
  name: "edeXa",
  nativeCurrency: { name: "edeXa", symbol: "EDX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.edexa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "edeXa Explorer",
      url: "https://explorer.edexa.network",
      apiUrl: "https://explorer.edexa.network/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgeless.js
var edgeless = defineChain({
  id: 2026,
  name: "Edgeless Network",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edgeless.network/http"],
      webSocket: ["wss://rpc.edgeless.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Explorer",
      url: "https://explorer.edgeless.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgelessTestnet.js
var edgelessTestnet = defineChain({
  id: 202,
  name: "Edgeless Testnet",
  nativeCurrency: {
    name: "Edgeless Wrapped ETH",
    symbol: "EwETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://edgeless-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://edgeless-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Edgeless Testnet Explorer",
      url: "https://testnet.explorer.edgeless.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgeware.js
var edgeware = defineChain({
  id: 2021,
  name: "Edgeware EdgeEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Edgeware",
    symbol: "EDG"
  },
  rpcUrls: {
    default: { http: ["https://edgeware-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://edgscan.live",
      apiUrl: "https://edgscan.live/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18117872
    }
  }
});

// node_modules/viem/_esm/chains/definitions/edgewareTestnet.js
var edgewareTestnet = defineChain({
  id: 2022,
  name: "Beresheet BereEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Testnet EDG",
    symbol: "tEDG"
  },
  rpcUrls: {
    default: { http: ["https://beresheet-evm.jelliedowl.net"] }
  },
  blockExplorers: {
    default: {
      name: "Edgscan by Bharathcoorg",
      url: "https://testnet.edgscan.live",
      apiUrl: "https://testnet.edgscan.live/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/eduChain.js
var eduChain = defineChain({
  id: 41923,
  name: "EDU Chain",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.edu-chain.raas.gelato.cloud"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Explorer",
      url: "https://educhain.blockscout.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eduChainTestnet.js
var eduChainTestnet = defineChain({
  id: 656476,
  name: "EDU Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EDU",
    symbol: "EDU"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.open-campus-codex.gelato.digital/"],
      webSocket: ["wss://ws.open-campus-codex.gelato.digital"]
    }
  },
  blockExplorers: {
    default: {
      name: "EDU Chain Testnet Explorer",
      url: "https://opencampus-codex.blockscout.com",
      apiUrl: "https://opencampus-codex.blockscout.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15514133
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ekta.js
var ekta = defineChain({
  id: 1994,
  name: "Ekta",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://main.ekta.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ektascan",
      url: "https://ektascan.io",
      apiUrl: "https://ektascan.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ektaTestnet.js
var ektaTestnet = defineChain({
  id: 1004,
  name: "Ekta Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EKTA",
    symbol: "EKTA"
  },
  rpcUrls: {
    default: { http: ["https://test.ekta.io:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Test Ektascan",
      url: "https://test.ektascan.io",
      apiUrl: "https://test.ektascan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/elastos.js
var elastos = defineChain({
  id: 20,
  name: "Elastos Smart Chain",
  nativeCurrency: { name: "ELA", symbol: "ELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api2.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc.elastos.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/elastosTestnet.js
var elastosTestnet = defineChain({
  id: 21,
  name: "Elastos Smart Chain Testnet",
  nativeCurrency: { name: "tELA", symbol: "tELA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api-testnet.elastos.io/eth"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elastos Explorer",
      url: "https://esc-testnet.elastos.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/electroneum.js
var electroneum = defineChain({
  id: 52014,
  name: "Electroneum Mainnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.electroneum.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/electroneumTestnet.js
var electroneumTestnet = defineChain({
  id: 5201420,
  name: "Electroneum Testnet",
  nativeCurrency: {
    name: "ETN",
    symbol: "ETN",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.electroneum.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Electroneum Block Explorer",
      url: "https://blockexplorer.thesecurityteam.rocks"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/elysiumTestnet.js
var elysiumTestnet = defineChain({
  ...chainConfig2,
  id: 1338,
  name: "Elysium Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LAVA",
    symbol: "LAVA"
  },
  rpcUrls: {
    default: {
      http: ["https://elysium-test-rpc.vulcanforged.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Elysium testnet explorer",
      url: "https://elysium-explorer.vulcanforged.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/energy.js
var energy = defineChain({
  id: 246,
  name: "Energy Mainnet",
  nativeCurrency: { name: "EWT", symbol: "EWT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.energyweb.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "EnergyWeb Explorer",
      url: "https://explorer.energyweb.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/enuls.js
var enuls = defineChain({
  id: 119,
  name: "ENULS Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "NULS",
    symbol: "NULS"
  },
  rpcUrls: {
    default: { http: ["https://evmapi2.nuls.io"] }
  },
  blockExplorers: {
    default: {
      name: "ENULS Explorer",
      url: "https://evmscan.nuls.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/eon.js
var eon = defineChain({
  id: 7332,
  name: "Horizen EON",
  nativeCurrency: {
    decimals: 18,
    name: "ZEN",
    symbol: "ZEN"
  },
  rpcUrls: {
    default: { http: ["https://eon-rpc.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "EON Explorer",
      url: "https://eon-explorer.horizenlabs.io"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/eos.js
var eos = defineChain({
  id: 17777,
  name: "EOS EVM",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Explorer",
      url: "https://explorer.evm.eosnetwork.com",
      apiUrl: "https://explorer.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7943933
    }
  }
});

// node_modules/viem/_esm/chains/definitions/eosTestnet.js
var eosTestnet = defineChain({
  id: 15557,
  name: "EOS EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "EOS",
    symbol: "EOS"
  },
  rpcUrls: {
    default: { http: ["https://api.testnet.evm.eosnetwork.com"] }
  },
  blockExplorers: {
    default: {
      name: "EOS EVM Testnet Explorer",
      url: "https://explorer.testnet.evm.eosnetwork.com",
      apiUrl: "https://explorer.testnet.evm.eosnetwork.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9067940
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/etherlink.js
var etherlink = defineChain({
  id: 42793,
  name: "Etherlink",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.mainnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink",
      url: "https://explorer.etherlink.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 33899
    }
  }
});

// node_modules/viem/_esm/chains/definitions/etherlinkTestnet.js
var etherlinkTestnet = defineChain({
  id: 128123,
  name: "Etherlink Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Tez",
    symbol: "XTZ"
  },
  rpcUrls: {
    default: { http: ["https://node.ghostnet.etherlink.com"] }
  },
  blockExplorers: {
    default: {
      name: "Etherlink Testnet",
      url: "https://testnet.explorer.etherlink.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ethernity.js
var ethernity = defineChain({
  id: 183,
  name: "Ethernity",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.ethernitychain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ethernity Explorer",
      url: "https://ernscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/etp.js
var etp = defineChain({
  id: 20256789,
  name: "ETP Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETP Chain Native Token",
    symbol: "ETP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.etpscan.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "ETP Scan",
      url: "https://etpscan.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/evmos.js
var evmos = defineChain({
  id: 9001,
  name: "Evmos",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.org:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Block Explorer",
      url: "https://escan.live"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/evmosTestnet.js
var evmosTestnet = defineChain({
  id: 9e3,
  name: "Evmos Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Evmos",
    symbol: "EVMOS"
  },
  rpcUrls: {
    default: { http: ["https://eth.bd.evmos.dev:8545"] }
  },
  blockExplorers: {
    default: {
      name: "Evmos Testnet Block Explorer",
      url: "https://evm.evmos.dev/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/excelonMainnet.js
var excelonMainnet = defineChain({
  id: 22052002,
  name: "Excelon Mainnet",
  network: "XLON",
  nativeCurrency: {
    decimals: 18,
    name: "Excelon",
    symbol: "xlon"
  },
  rpcUrls: {
    default: {
      http: ["https://edgewallet1.xlon.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Excelon explorer",
      url: "https://explorer.excelon.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/expanse.js
var expanse = defineChain({
  id: 2,
  name: "Expanse Network",
  nativeCurrency: {
    decimals: 18,
    name: "EXP",
    symbol: "EXP"
  },
  rpcUrls: {
    default: { http: ["https://node.expanse.tech"] }
  },
  blockExplorers: {
    default: {
      name: "Expanse Explorer",
      url: "https://explorer.expanse.tech"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/exSat.js
var exsat = defineChain({
  id: 7200,
  name: "exSat Network",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan.exsat.network",
      apiUrl: "https://scan.exsat.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/exSatTestnet.js
var exsatTestnet = defineChain({
  id: 839999,
  name: "exSat Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "BTC",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://evm-tst3.exsat.network"] }
  },
  blockExplorers: {
    default: {
      name: "exSat Explorer",
      url: "https://scan-testnet.exsat.network",
      apiUrl: "https://scan-testnet.exsat.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantom.js
var fantom = defineChain({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://250.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fantomSonicTestnet.js
var fantomSonicTestnet = defineChain({
  id: 64240,
  name: "Fantom Sonic Open Testnet",
  network: "fantom-sonic-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpcapi.sonic.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "Fantom Sonic Open Testnet Explorer",
      url: "https://public-sonic.fantom.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fantomTestnet.js
var fantomTestnet = defineChain({
  id: 4002,
  name: "Fantom Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.fantom.network"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://testnet.ftmscan.com",
      apiUrl: "https://testnet.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8328688
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fibo.js
var fibo = defineChain({
  id: 12306,
  name: "Fibo Chain",
  nativeCurrency: {
    decimals: 18,
    name: "fibo",
    symbol: "FIBO"
  },
  rpcUrls: {
    default: { http: ["https://network.hzroc.art"] }
  },
  blockExplorers: {
    default: {
      name: "FiboScan",
      url: "https://scan.fibochain.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/filecoin.js
var filecoin = defineChain({
  id: 314,
  name: "Filecoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "filecoin",
    symbol: "FIL"
  },
  rpcUrls: {
    default: { http: ["https://api.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://filfox.info/en"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3328594
    }
  }
});

// node_modules/viem/_esm/chains/definitions/filecoinCalibration.js
var filecoinCalibration = defineChain({
  id: 314159,
  name: "Filecoin Calibration",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.calibration.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filscan",
      url: "https://calibration.filscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/filecoinHyperspace.js
var filecoinHyperspace = defineChain({
  id: 3141,
  name: "Filecoin Hyperspace",
  nativeCurrency: {
    decimals: 18,
    name: "testnet filecoin",
    symbol: "tFIL"
  },
  rpcUrls: {
    default: { http: ["https://api.hyperspace.node.glif.io/rpc/v1"] }
  },
  blockExplorers: {
    default: {
      name: "Filfox",
      url: "https://hyperspace.filfox.info/en"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/5ireChain.js
var fireChain = defineChain({
  id: 995,
  name: "5ireChain",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Mainnet Explorer",
      url: "https://5irescan.io/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/flare.js
var flare = defineChain({
  id: 14,
  name: "Flare Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flare",
    symbol: "FLR"
  },
  rpcUrls: {
    default: { http: ["https://flare-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Flare Explorer",
      url: "https://flare-explorer.flare.network",
      apiUrl: "https://flare-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3002461
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flareTestnet.js
var flareTestnet = defineChain({
  id: 114,
  name: "Flare Testnet Coston2",
  nativeCurrency: {
    decimals: 18,
    name: "Coston2 Flare",
    symbol: "C2FLR"
  },
  rpcUrls: {
    default: { http: ["https://coston2-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston2 Explorer",
      url: "https://coston2-explorer.flare.network",
      apiUrl: "https://coston2-explorer.flare.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/flowMainnet.js
var flowMainnet = defineChain({
  id: 747,
  name: "Flow EVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mainnet Explorer",
      url: "https://evm.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flowPreviewnet.js
var flowPreviewnet = defineChain({
  id: 646,
  name: "Flow EVM Previewnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Previewnet Explorer",
      url: "https://previewnet.flowdiver.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6205
    }
  }
});

// node_modules/viem/_esm/chains/definitions/flowTestnet.js
var flowTestnet = defineChain({
  id: 545,
  name: "Flow EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Flow",
    symbol: "FLOW"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.evm.nodes.onflow.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Flow Diver",
      url: "https://evm-testnet.flowscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 137518
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluence.js
var fluence = defineChain({
  id: 9999999,
  name: "Fluence",
  nativeCurrency: { name: "FLT", symbol: "FLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.fluence.dev"],
      webSocket: ["wss://ws.mainnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.mainnet.fluence.dev",
      apiUrl: "https://blockscout.mainnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 207583
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fluenceStage.js
var fluenceStage = defineChain({
  id: 123420000220,
  name: "Fluence Stage",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.stage.fluence.dev"],
      webSocket: ["wss://ws.stage.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.stage.fluence.dev",
      apiUrl: "https://blockscout.stage.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83227
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluenceTestnet.js
var fluenceTestnet = defineChain({
  id: 52164803,
  name: "Fluence Testnet",
  nativeCurrency: { name: "tFLT", symbol: "tFLT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.fluence.dev"],
      webSocket: ["wss://ws.testnet.fluence.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.testnet.fluence.dev",
      apiUrl: "https://blockscout.testnet.fluence.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96424
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/fluentTestnet.js
var fluentTestnet = defineChain({
  id: 20993,
  name: "Fluent Testnet",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.dev.gblend.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Fluent Explorer",
      url: "https://blockscout.dev.gblend.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/forma.js
var forma = defineChain({
  id: 984122,
  name: "Forma",
  network: "forma",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.forma.art"],
      webSocket: ["wss://ws.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forma Explorer",
      url: "https://explorer.forma.art"
    }
  },
  contracts: {
    multicall3: {
      address: "0xd53C6FFB123F7349A32980F87faeD8FfDc9ef079",
      blockCreated: 252705
    }
  }
});

// node_modules/viem/_esm/chains/definitions/form.js
var sourceId16 = 1;
var form = defineChain({
  id: 478,
  name: "Form Network",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.form.network/http"],
      webSocket: ["wss://rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Explorer",
      url: "https://explorer.form.network"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    addressManager: {
      [sourceId16]: {
        address: "0x15c249E46A2F924C2dB3A1560CF86729bAD1f07B"
      }
    },
    l1CrossDomainMessenger: {
      [sourceId16]: {
        address: "0xF333158DCCad1dF6C3F0a3aEe8BC31fA94d9eD5c"
      }
    },
    l2OutputOracle: {
      [sourceId16]: {
        address: "0x4ccAAF69F41c5810cA875183648B577CaCf1F67E"
      }
    },
    portal: {
      [sourceId16]: {
        address: "0x4E259Ee5F4136408908160dD32295A5031Fa426F"
      }
    },
    l1StandardBridge: {
      [sourceId16]: {
        address: "0xdc20aA63D3DE59574E065957190D8f24e0F7B8Ba"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: sourceId16
});

// node_modules/viem/_esm/chains/definitions/memecoreFormicariumTestnet.js
var formicarium = defineChain({
  id: 43521,
  name: "Formicarium",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.formicarium.memecore.net"],
      webSocket: ["wss://ws.formicarium.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.memecorescan.io"
    },
    okx: {
      name: "MemeCore Testnet Explorer",
      url: "https://web3.okx.com/explorer/formicarium-testnet"
    },
    memecore: {
      name: "MemeCore Testnet Explorer",
      url: "https://formicarium.blockscout.memecore.com",
      apiUrl: "https://formicarium.blockscout.memecore.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/formTestnet.js
var sourceId17 = 11155111;
var formTestnet = defineChain({
  id: 132902,
  name: "Form Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ethereum",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.form.network/http"],
      webSocket: ["wss://sepolia-rpc.form.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Form Testnet Explorer",
      url: "https://sepolia-explorer.form.network"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    addressManager: {
      [sourceId17]: {
        address: "0xd5C38fa934f7fd7477D4800F4f38a1c5BFdF1373"
      }
    },
    l1CrossDomainMessenger: {
      [sourceId17]: {
        address: "0x37A68565c4BE9700b3E3Ec60cC4416cAC3052FAa"
      }
    },
    l2OutputOracle: {
      [sourceId17]: {
        address: "0x9eA2239E65a59EC9C7F1ED4C116dD58Da71Fc1e2"
      }
    },
    portal: {
      [sourceId17]: {
        address: "0x60377e3cE15dF4CCA24c4beF076b60314240b032"
      }
    },
    l1StandardBridge: {
      [sourceId17]: {
        address: "0xD4531f633942b2725896F47cD2aFd260b44Ab1F7"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true,
  sourceId: sourceId17
});

// node_modules/viem/_esm/chains/definitions/forta.js
var forta = defineChain({
  id: 80931,
  name: "Forta Chain",
  nativeCurrency: {
    symbol: "FORT",
    name: "FORT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-forta-chain-8gj1qndmfc.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Forta Explorer",
      url: "https://explorer.forta.org"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/foundry.js
var foundry = defineChain({
  id: 31337,
  name: "Foundry",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:8545"],
      webSocket: ["ws://127.0.0.1:8545"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fraxtal.js
var sourceId18 = 1;
var fraxtal = defineChain({
  ...chainConfig2,
  id: 252,
  name: "Fraxtal",
  nativeCurrency: { name: "Frax Ether", symbol: "frxETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan",
      url: "https://fraxscan.com",
      apiUrl: "https://api.fraxscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId18]: {
        address: "0x66CC916Ed5C6C2FA97014f7D1cD141528Ae171e4"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId18]: {
        address: "0x36cb65c1967A0Fb0EEE11569C51C2f2aA1Ca6f6D",
        blockCreated: 19135323
      }
    },
    l1StandardBridge: {
      [sourceId18]: {
        address: "0x34C0bD5877A5Ee7099D0f5688D65F4bB9158BDE2",
        blockCreated: 19135323
      }
    }
  },
  sourceId: sourceId18
});

// node_modules/viem/_esm/chains/definitions/fraxtalTestnet.js
var sourceId19 = 17e3;
var fraxtalTestnet = defineChain({
  ...chainConfig2,
  id: 2522,
  name: "Fraxtal Testnet",
  nativeCurrency: { name: "Frax Ether", symbol: "frxETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.frax.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "fraxscan testnet",
      url: "https://holesky.fraxscan.com",
      apiUrl: "https://api-holesky.fraxscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId19]: {
        address: "0x715EA64DA13F4d0831ece4Ad3E8c1aa013167F32"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId19]: {
        address: "0xB9c64BfA498d5b9a8398Ed6f46eb76d90dE5505d",
        blockCreated: 318416
      }
    },
    l1StandardBridge: {
      [sourceId19]: {
        address: "0x0BaafC217162f64930909aD9f2B27125121d6332",
        blockCreated: 318416
      }
    }
  },
  sourceId: sourceId19
});

// node_modules/viem/_esm/chains/definitions/funkiMainnet.js
var sourceId20 = 1;
var funkiMainnet = defineChain({
  ...chainConfig2,
  id: 33979,
  name: "Funki",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.funkichain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Mainnet Explorer",
      url: "https://funkiscan.io"
    }
  },
  contracts: {
    ...chainConfig2.contracts
  },
  sourceId: sourceId20
});

// node_modules/viem/_esm/chains/definitions/funkiSepolia.js
var sourceId21 = 11155111;
var funkiSepolia = defineChain({
  ...chainConfig2,
  id: 3397901,
  network: "funkiSepolia",
  name: "Funki Sepolia Sandbox",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://funki-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Funki Sepolia Sandbox Explorer",
      url: "https://sepolia-sandbox.funkichain.com/"
    }
  },
  testnet: true,
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    }
  },
  sourceId: sourceId21
});

// node_modules/viem/_esm/chains/definitions/fuse.js
var fuse = defineChain({
  id: 122,
  name: "Fuse",
  nativeCurrency: { name: "Fuse", symbol: "FUSE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fuse.io"] }
  },
  blockExplorers: {
    default: {
      name: "Fuse Explorer",
      url: "https://explorer.fuse.io",
      apiUrl: "https://explorer.fuse.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 16146628
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fuseSparknet.js
var fuseSparknet = defineChain({
  id: 123,
  name: "Fuse Sparknet",
  nativeCurrency: { name: "Spark", symbol: "SPARK", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.fusespark.io"] }
  },
  blockExplorers: {
    default: {
      name: "Sparkent Explorer",
      url: "https://explorer.fusespark.io",
      apiUrl: "https://explorer.fusespark.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/fusion.js
var fusion = defineChain({
  id: 32659,
  name: "Fusion Mainnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.fusionnetwork.io"],
      webSocket: ["wss://mainnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10441605
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/fusionTestnet.js
var fusionTestnet = defineChain({
  id: 46688,
  name: "Fusion Testnet",
  nativeCurrency: { name: "Fusion", symbol: "FSN", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.fusionnetwork.io"],
      webSocket: ["wss://testnet.fusionnetwork.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "FSNscan",
      url: "https://testnet.fsnscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10428309
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/garnet.js
var sourceId22 = 17e3;
var garnet = defineChain({
  ...chainConfig2,
  name: "Garnet Testnet",
  testnet: true,
  id: 17069,
  sourceId: sourceId22,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.garnetchain.com"],
      webSocket: ["wss://rpc.garnetchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.garnetchain.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId22]: {
        address: "0x57ee40586fbE286AfC75E67cb69511A6D9aF5909",
        blockCreated: 1274684
      }
    },
    l2OutputOracle: {
      [sourceId22]: {
        address: "0xCb8E7AC561b8EF04F2a15865e9fbc0766FEF569B",
        blockCreated: 1274684
      }
    },
    l1StandardBridge: {
      [sourceId22]: {
        address: "0x09bcDd311FE398F80a78BE37E489f5D440DB95DE",
        blockCreated: 1274684
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/geist.js
var geist = defineChain({
  id: 63157,
  name: "Geist Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Aavegotchi GHST Token",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-mainnet.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://geist-mainnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 660735
    }
  }
});

// node_modules/viem/_esm/chains/definitions/genesys.js
var genesys = defineChain({
  id: 16507,
  name: "Genesys Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "GSYS",
    symbol: "GSYS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.genesys.network"] }
  },
  blockExplorers: {
    default: {
      name: "Genesys Explorer",
      url: "https://gchainexplorer.genesys.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/glideL1Protocol.js
var glideL1Protocol = defineChain({
  id: 251,
  name: "Glide L1 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l1-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l1-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/glideL2Protocol.js
var glideL2Protocol = defineChain({
  id: 253,
  name: "Glide L2 Protocol XP",
  nativeCurrency: { name: "GLXP", symbol: "GLXP", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-api.glideprotocol.xyz/l2-rpc"],
      webSocket: ["wss://rpc-api.glideprotocol.xyz/l2-rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Glide Protocol Explore",
      url: "https://blockchain-explorer.glideprotocol.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/gnosis.js
var gnosis = defineChain({
  id: 100,
  name: "Gnosis",
  nativeCurrency: {
    decimals: 18,
    name: "xDAI",
    symbol: "XDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.gnosischain.com"],
      webSocket: ["wss://rpc.gnosischain.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gnosisscan",
      url: "https://gnosisscan.io",
      apiUrl: "https://api.gnosisscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 21022491
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gnosisChiado.js
var gnosisChiado = defineChain({
  id: 10200,
  name: "Gnosis Chiado",
  nativeCurrency: {
    decimals: 18,
    name: "Gnosis",
    symbol: "xDAI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.chiadochain.net"],
      webSocket: ["wss://rpc.chiadochain.net/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.chiadochain.net",
      apiUrl: "https://blockscout.chiadochain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4967313
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/goat.js
var goat = defineChain({
  id: 2345,
  name: "GOAT",
  nativeCurrency: {
    decimals: 18,
    name: "Bitcoin",
    symbol: "BTC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.goat.network"] }
  },
  blockExplorers: {
    default: {
      name: "Goat Explorer",
      url: "https://explorer.goat.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gobi.js
var gobi = defineChain({
  id: 1663,
  name: "Horizen Gobi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Test ZEN",
    symbol: "tZEN"
  },
  rpcUrls: {
    default: { http: ["https://gobi-testnet.horizenlabs.io/ethv1"] }
  },
  blockExplorers: {
    default: {
      name: "Gobi Explorer",
      url: "https://gobi-explorer.horizen.io"
    }
  },
  contracts: {},
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/goChain.js
var goChain = defineChain({
  id: 60,
  name: "GoChain",
  nativeCurrency: {
    decimals: 18,
    name: "GO",
    symbol: "GO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.gochain.io"] }
  },
  blockExplorers: {
    default: {
      name: "GoChain Explorer",
      url: "https://explorer.gochain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/godwoken.js
var godwoken = defineChain({
  id: 71402,
  name: "Godwoken Mainnet",
  nativeCurrency: { decimals: 18, name: "pCKB", symbol: "pCKB" },
  rpcUrls: {
    default: {
      http: ["https://v1.mainnet.godwoken.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "GW Scan",
      url: "https://v1.gwscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 15034
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/goerli.js
var goerli = defineChain({
  id: 5,
  name: "Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://5.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.etherscan.io",
      apiUrl: "https://api-goerli.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xfc4AC75C46C914aF5892d6d3eFFcebD7917293F1",
      blockCreated: 10339206
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6507670
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/gravity.js
var gravity = defineChain({
  id: 1625,
  name: "Gravity Alpha Mainnet",
  nativeCurrency: { name: "G", symbol: "G", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.gravity.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Gravity Explorer",
      url: "https://explorer.gravity.xyz",
      apiUrl: "https://explorer.gravity.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xf8ac4BEB2F75d2cFFb588c63251347fdD629B92c",
      blockCreated: 16851
    }
  }
});

// node_modules/viem/_esm/chains/definitions/gunz.js
var gunz = defineChain({
  id: 43419,
  name: "Gunz Mainnet",
  nativeCurrency: { name: "GUN", symbol: "GUN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.gunzchain.io/ext/bc/2M47TxWHGnhNtq6pM5zPXdATBtuqubxn5EPFgFmEawCQr9WFML/rpc"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Gunz Explorer",
      url: "https://gunzscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 70502
    }
  }
});

// node_modules/viem/_esm/chains/definitions/guruNetwork.js
var guruNetwork = defineChain({
  id: 260,
  name: "Guru Network Mainnet",
  nativeCurrency: {
    name: "GURU Token",
    symbol: "GURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-main.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/260"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://scan.gurunetwork.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 271691
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/guruTestnet.js
var guruTestnet = defineChain({
  id: 261,
  name: "Guru Network Testnet",
  nativeCurrency: {
    name: "tGURU Token",
    symbol: "tGURU",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-test.gurunetwork.ai",
        "https://rpc.gurunetwork.ai/archive/261"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Guruscan",
      url: "https://sepolia.gurunetwork.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ham.js
var ham = defineChain({
  id: 5112,
  name: "Ham",
  nativeCurrency: {
    decimals: 18,
    name: "Ham",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.ham.fun"],
      webSocket: ["wss://rpc.ham.fun"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ham Chain Explorer",
      url: "https://explorer.ham.fun",
      apiUrl: "https://explorer.ham.fun/api/v2"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/happychainTestnet.js
var happychainTestnet = defineChain({
  id: 216,
  name: "Happychain Testnet",
  nativeCurrency: {
    symbol: "HAPPY",
    name: "HAPPY",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.happy.tech/http"],
      webSocket: ["wss://rpc.testnet.happy.tech/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Happy Chain Testnet Explorer",
      url: "https://explorer.testnet.happy.tech"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/haqqMainnet.js
var haqqMainnet = defineChain({
  id: 11235,
  name: "HAQQ Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.haqq.network",
      apiUrl: "https://explorer.haqq.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/haqqTestedge2.js
var haqqTestedge2 = defineChain({
  id: 54211,
  name: "HAQQ Testedge 2",
  nativeCurrency: {
    decimals: 18,
    name: "Islamic Coin",
    symbol: "ISLMT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.eth.testedge2.haqq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "HAQQ Explorer",
      url: "https://explorer.testedge2.haqq.network",
      apiUrl: "https://explorer.testedge2.haqq.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hardhat.js
var hardhat = defineChain({
  id: 31337,
  name: "Hardhat",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/harmonyOne.js
var harmonyOne = defineChain({
  id: 16666e5,
  name: "Harmony One",
  nativeCurrency: {
    name: "Harmony",
    symbol: "ONE",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://1666600000.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "Harmony Explorer",
      url: "https://explorer.harmony.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 24185753
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hashKeyChain.js
var hashkey = defineChain({
  id: 177,
  name: "HashKey Chain",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hsk.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkey.blockscout.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hashkeyChainTestnet.js
var hashkeyTestnet = defineChain({
  id: 133,
  name: "HashKey Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HashKey EcoPoints",
    symbol: "HSK"
  },
  rpcUrls: {
    default: {
      http: ["https://hashkeychain-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "HashKey Chain Explorer",
      url: "https://hashkeychain-testnet-explorer.alt.technology"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/haustTestnet.js
var haustTestnet = defineChain({
  id: 1523903251,
  name: "Haust Network Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "HAUST",
    symbol: "HAUST"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.haust.app"]
    }
  },
  blockExplorers: {
    default: {
      name: "Haust Network Testnet Explorer",
      url: "https://explorer-testnet.haust.app"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hedera.js
var hedera = defineChain({
  id: 295,
  name: "Hedera Mainnet",
  network: "hedera-mainnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/mainnet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hederaPreviewnet.js
var hederaPreviewnet = defineChain({
  id: 297,
  name: "Hedera Previewnet",
  network: "hedera-previewnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://previewnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/previewnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hederaTestnet.js
var hederaTestnet = defineChain({
  id: 296,
  name: "Hedera Testnet",
  network: "hedera-testnet",
  nativeCurrency: {
    symbol: "HBAR",
    name: "HBAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.hashio.io/api"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hashscan",
      url: "https://hashscan.io/testnet"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hela.js
var hela = defineChain({
  id: 8668,
  name: "Hela Mainnet",
  nativeCurrency: {
    name: "HLUSD",
    symbol: "HLUSD",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.helachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hela explorer",
      url: "https://mainnet-blockexplorer.helachain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hemi.js
var hemi = defineChain({
  id: 43111,
  name: "Hemi",
  network: "Hemi",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.hemi.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hemiSepolia.js
var hemiSepolia = defineChain({
  id: 743111,
  name: "Hemi Sepolia",
  network: "Hemi Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.hemi.network/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Hemi Sepolia explorer",
      url: "https://testnet.explorer.hemi.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/holesky.js
var holesky = defineChain({
  id: 17e3,
  name: "Holesky",
  nativeCurrency: { name: "Holesky Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ethereum-holesky-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://holesky.etherscan.io",
      apiUrl: "https://api-holesky.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 77
    },
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
      blockCreated: 801613
    },
    ensUniversalResolver: {
      address: "0xa6AC935D4971E3CD133b950aE053bECD16fE7f3b",
      blockCreated: 973484
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hoodi.js
var hoodi = defineChain({
  id: 560048,
  name: "Hoodi",
  nativeCurrency: { name: "Hoodi Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hoodi.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://hoodi.etherscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2589
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/hpb.js
var hpb = defineChain({
  id: 269,
  name: "High Performance Blockchain",
  nativeCurrency: { name: "HPB", symbol: "HPB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://hpbnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "hpbScan",
      url: "https://hscan.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/huddle01Mainnet.js
var sourceId23 = 42161;
var huddle01Mainnet = defineChain({
  id: 12323,
  name: "Huddle01 dRTC Chain",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle01.calderachain.xyz/http"],
      webSocket: ["wss://huddle01.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle01.calderaexplorer.xyz",
      apiUrl: "https://huddle01.calderaexplorer.xyz/api"
    }
  },
  sourceId: sourceId23
});

// node_modules/viem/_esm/chains/definitions/huddle01Testnet.js
var sourceId24 = 421614;
var huddle01Testnet = defineChain({
  id: 2524852,
  name: "Huddle01 dRTC Chain Testnet",
  nativeCurrency: {
    name: "Ethereum",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://huddle-testnet.rpc.caldera.xyz/http"],
      webSocket: ["wss://huddle-testnet.rpc.caldera.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Huddle01 Caldera Explorer",
      url: "https://huddle-testnet.explorer.caldera.xyz",
      apiUrl: "https://huddle-testnet.explorer.caldera.xyz/api"
    }
  },
  sourceId: sourceId24
});

// node_modules/viem/_esm/chains/definitions/humanode.js
var humanode = defineChain({
  id: 5234,
  name: "Humanode",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.mainnet.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.mainnet.stages.humanode.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://humanode.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4413097
    }
  }
});

// node_modules/viem/_esm/chains/definitions/humanodeTestnet5.js
var humanodeTestnet5 = defineChain({
  id: 14853,
  name: "Humanode Testnet 5",
  nativeCurrency: { name: "HMND", symbol: "HMND", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://explorer-rpc-http.testnet5.stages.humanode.io"],
      webSocket: ["wss://explorer-rpc-ws.testnet5.stages.humanode.io"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/hychain.js
var hychain = defineChain({
  id: 2911,
  name: "HYCHAIN",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://explorer.hychain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/hychainTestnet.js
var hychainTestnet = defineChain({
  id: 29112,
  name: "HYCHAIN Testnet",
  nativeCurrency: { name: "HYTOPIA", symbol: "TOPIA", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.hychain.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "HYCHAIN Explorer",
      url: "https://testnet-rpc.hychain.com/http"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/idchain.js
var idchain = defineChain({
  id: 74,
  name: "IDChain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "EIDI",
    symbol: "EIDI"
  },
  rpcUrls: {
    default: {
      http: ["https://idchain.one/rpc"],
      webSocket: ["wss://idchain.one/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "IDChain Explorer",
      url: "https://explorer.idchain.one"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/immutableZkEvm.js
var immutableZkEvm = defineChain({
  id: 13371,
  name: "Immutable zkEVM",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Explorer",
      url: "https://explorer.immutable.com",
      apiUrl: "https://explorer.immutable.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x236bdA4589e44e6850f5aC6a74BfCa398a86c6c0",
      blockCreated: 4335972
    }
  }
});

// node_modules/viem/_esm/chains/definitions/immutableZkEvmTestnet.js
var immutableZkEvmTestnet = defineChain({
  id: 13473,
  name: "Immutable zkEVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Immutable Coin",
    symbol: "IMX"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.immutable.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Immutable Testnet Explorer",
      url: "https://explorer.testnet.immutable.com/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2CC787Ed364600B0222361C4188308Fa8E68bA60",
      blockCreated: 5977391
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/inEVM.js
var inEVM = defineChain({
  id: 2525,
  name: "inEVM Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Injective",
    symbol: "INJ"
  },
  rpcUrls: {
    default: { http: ["https://mainnet.rpc.inevm.com/http"] }
  },
  blockExplorers: {
    default: {
      name: "inEVM Explorer",
      url: "https://inevm.calderaexplorer.xyz",
      apiUrl: "https://inevm.calderaexplorer.xyz/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 118606
    }
  }
});

// node_modules/viem/_esm/chains/definitions/initVerse.js
var initVerse = defineChain({
  id: 7233,
  name: "InitVerse Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseScan",
      url: "https://www.iniscan.com",
      apiUrl: "https://explorer-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83466BE48A067115FFF91f7b892Ed1726d032e47",
      blockCreated: 2318
    }
  }
});

// node_modules/viem/_esm/chains/definitions/initVerseGenesis.js
var initVerseGenesis = defineChain({
  id: 7234,
  name: "InitVerse Genesis Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "InitVerse",
    symbol: "INI"
  },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.inichain.com"] }
  },
  blockExplorers: {
    default: {
      name: "InitVerseGenesisScan",
      url: "https://genesis-testnet.iniscan.com",
      apiUrl: "https://explorer-testnet-api.inichain.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0cF32CBDd6c437331EA4f85ed2d881A5379B5a6F",
      blockCreated: 16361
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ink.js
var sourceId25 = 1;
var ink = defineChain({
  ...chainConfig2,
  id: 57073,
  name: "Ink",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-gel.inkonchain.com",
        "https://rpc-qnd.inkonchain.com"
      ],
      webSocket: [
        "wss://rpc-gel.inkonchain.com",
        "wss://rpc-qnd.inkonchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.inkonchain.com",
      apiUrl: "https://explorer.inkonchain.com/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId25]: {
        address: "0x10d7b35078d3baabb96dd45a9143b94be65b12cd"
      }
    },
    portal: {
      [sourceId25]: {
        address: "0x5d66c1782664115999c47c9fa5cd031f495d3e4f"
      }
    },
    l1StandardBridge: {
      [sourceId25]: {
        address: "0x88ff1e5b602916615391f55854588efcbb7663f0"
      }
    }
  },
  testnet: false,
  sourceId: sourceId25
});

// node_modules/viem/_esm/chains/definitions/inkSepolia.js
var sourceId26 = 11155111;
var inkSepolia = defineChain({
  ...chainConfig2,
  id: 763373,
  name: "Ink Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-gel-sepolia.inkonchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer-sepolia.inkonchain.com/",
      apiUrl: "https://explorer-sepolia.inkonchain.com/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId26]: {
        address: "0x860e626c700af381133d9f4af31412a2d1db3d5d"
      }
    },
    portal: {
      [sourceId26]: {
        address: "0x5c1d29c6c9c8b0800692acc95d700bcb4966a1d7"
      }
    },
    l1StandardBridge: {
      [sourceId26]: {
        address: "0x33f60714bbd74d62b66d79213c348614de51901c"
      }
    }
  },
  testnet: true,
  sourceId: sourceId26
});

// node_modules/viem/_esm/chains/definitions/iota.js
var iota = defineChain({
  id: 8822,
  name: "IOTA EVM",
  network: "iotaevm",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.iota.org",
      apiUrl: "https://explorer.evm.iota.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25022
    }
  }
});

// node_modules/viem/_esm/chains/definitions/iotaTestnet.js
var iotaTestnet = defineChain({
  id: 1075,
  name: "IOTA EVM Testnet",
  network: "iotaevm-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IOTA",
    symbol: "IOTA"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.iotaledger.net"],
      webSocket: ["wss://ws.json-rpc.evm.testnet.iotaledger.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.evm.testnet.iotaledger.net",
      apiUrl: "https://explorer.evm.testnet.iotaledger.net/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/iotex.js
var iotex = defineChain({
  id: 4689,
  name: "IoTeX",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.mainnet.iotex.io"],
      webSocket: ["wss://babel-api.mainnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 22163670
    }
  }
});

// node_modules/viem/_esm/chains/definitions/iotexTestnet.js
var iotexTestnet = defineChain({
  id: 4690,
  name: "IoTeX Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IoTeX",
    symbol: "IOTX"
  },
  rpcUrls: {
    default: {
      http: ["https://babel-api.testnet.iotex.io"],
      webSocket: ["wss://babel-api.testnet.iotex.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "IoTeXScan",
      url: "https://testnet.iotexscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xb5cecD6894c6f473Ec726A176f1512399A2e355d",
      blockCreated: 24347592
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/iSunCoin.js
var iSunCoin = defineChain({
  id: 8017,
  name: "iSunCoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ISC",
    symbol: "ISC"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.isuncoin.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "iSunCoin Explorer",
      url: "https://baifa.io/app/chains/8017"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/jbc.js
var jbc = defineChain({
  id: 8899,
  name: "JIBCHAIN L1",
  network: "jbc",
  nativeCurrency: { name: "JBC", symbol: "JBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-l1.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp-l1.jibchain.net",
      apiUrl: "https://exp-l1.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc0C8C486D1466C57Efe13C2bf000d4c56F47CBdC",
      blockCreated: 2299048
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/jbcTestnet.js
var jbcTestnet = defineChain({
  id: 88991,
  name: "Jibchain Testnet",
  nativeCurrency: { name: "tJBC", symbol: "tJBC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.jibchain.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.testnet.jibchain.net",
      apiUrl: "https://exp.testnet.jibchain.net/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xa1a858ad9041B4741e620355a3F96B3c78e70ecE",
      blockCreated: 32848
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/juneo.js
var juneo = defineChain({
  id: 45003,
  name: "Juneo JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/2",
      apiUrl: "https://juneoscan.io/chain/2/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoBCH1Chain.js
var juneoBCH1Chain = defineChain({
  id: 45013,
  name: "Juneo BCH1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo BCH1-Chain",
    symbol: "BCH1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/BCH1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/12",
      apiUrl: "https://juneoscan.io/chain/12/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoDAI1Chain.js
var juneoDAI1Chain = defineChain({
  id: 45004,
  name: "Juneo DAI1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DAI1-Chain",
    symbol: "DAI1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DAI1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/5",
      apiUrl: "https://juneoscan.io/chain/5/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoDOGE1Chain.js
var juneoDOGE1Chain = defineChain({
  id: 45010,
  name: "Juneo DOGE1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo DOGE1-Chain",
    symbol: "DOGE1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/DOGE1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/10",
      apiUrl: "https://juneoscan.io/chain/10/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoEUR1Chain.js
var juneoEUR1Chain = defineChain({
  id: 45011,
  name: "Juneo EUR1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo EUR1-Chain",
    symbol: "EUR1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/EUR1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/6",
      apiUrl: "https://juneoscan.io/chain/6/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoGLD1Chain.js
var juneoGLD1Chain = defineChain({
  id: 45008,
  name: "Juneo GLD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo GLD1-Chain",
    symbol: "GLD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/GLD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/8",
      apiUrl: "https://juneoscan.io/chain/8/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoLINK1Chain.js
var juneoLINK1Chain = defineChain({
  id: 45014,
  name: "Juneo LINK1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LINK1-Chain",
    symbol: "LINK1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LINK1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/13",
      apiUrl: "https://juneoscan.io/chain/13/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoLTC1Chain.js
var juneoLTC1Chain = defineChain({
  id: 45009,
  name: "Juneo LTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo LTC1-Chain",
    symbol: "LTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/LTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/11",
      apiUrl: "https://juneoscan.io/chain/11/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneomBTC1Chain.js
var juneomBTC1Chain = defineChain({
  id: 45007,
  name: "Juneo mBTC1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo mBTC1-Chain",
    symbol: "mBTC1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/mBTC1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/9",
      apiUrl: "https://juneoscan.io/chain/9/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoSGD1Chain.js
var juneoSGD1Chain = defineChain({
  id: 45012,
  name: "Juneo SGD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo SGD1-Chain",
    symbol: "SGD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/SGD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/7",
      apiUrl: "https://juneoscan.io/chain/7/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoSocotraTestnet.js
var juneoSocotraTestnet = defineChain({
  id: 101003,
  name: "Socotra JUNE-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Socotra JUNE-Chain",
    symbol: "JUNE"
  },
  rpcUrls: {
    default: { http: ["https://rpc.socotra-testnet.network/ext/bc/JUNE/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://socotra.juneoscan.io/chain/2",
      apiUrl: "https://socotra.juneoscan.io/chain/2/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/juneoUSD1Chain.js
var juneoUSD1Chain = defineChain({
  id: 45006,
  name: "Juneo USD1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USD1-Chain",
    symbol: "USD1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USD1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/4",
      apiUrl: "https://juneoscan.io/chain/4/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/juneoUSDT1Chain.js
var juneoUSDT1Chain = defineChain({
  id: 45005,
  name: "Juneo USDT1-Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Juneo USDT1-Chain",
    symbol: "USDT1"
  },
  rpcUrls: {
    default: { http: ["https://rpc.juneo-mainnet.network/ext/bc/USDT1/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Juneo Scan",
      url: "https://juneoscan.io/chain/3",
      apiUrl: "https://juneoscan.io/chain/3/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/karura.js
var karura = defineChain({
  id: 686,
  name: "Karura",
  network: "karura",
  nativeCurrency: {
    name: "Karura",
    symbol: "KAR",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-karura.aca-api.network"],
      webSocket: ["wss://eth-rpc-karura.aca-api.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Karura Blockscout",
      url: "https://blockscout.karura.network",
      apiUrl: "https://blockscout.karura.network/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kakarotSepolia.js
var kakarotSepolia = defineChain({
  id: 1802203764,
  name: "Kakarot Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kakarotStarknetSepolia.js
var kakarotStarknetSepolia = defineChain({
  id: 920637907288165,
  name: "Kakarot Starknet Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.kakarot.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kakarot Scan",
      url: "https://sepolia.kakarotscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kardiaChain.js
var kardiaChain = defineChain({
  id: 24,
  name: "KardiaChain Mainnet",
  nativeCurrency: { name: "KAI", symbol: "KAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.kardiachain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "KardiaChain Explorer",
      url: "https://explorer.kardiachain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kava.js
var kava = defineChain({
  id: 2222,
  name: "Kava EVM",
  network: "kava-mainnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Explorer",
      url: "https://kavascan.com",
      apiUrl: "https://kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3661165
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kavaTestnet.js
var kavaTestnet = defineChain({
  id: 2221,
  name: "Kava EVM Testnet",
  network: "kava-testnet",
  nativeCurrency: {
    name: "Kava",
    symbol: "KAVA",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://evm.testnet.kava.io"] }
  },
  blockExplorers: {
    default: {
      name: "Kava EVM Testnet Explorer",
      url: "https://testnet.kavascan.com/",
      apiUrl: "https://testnet.kavascan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xDf1D724A7166261eEB015418fe8c7679BBEa7fd6",
      blockCreated: 7242179
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kcc.js
var kcc = defineChain({
  id: 321,
  name: "KCC Mainnet",
  network: "KCC Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "KCS",
    symbol: "KCS"
  },
  rpcUrls: {
    default: {
      http: ["https://kcc-rpc.com"]
    }
  },
  blockExplorers: {
    default: { name: "KCC Explorer", url: "https://explorer.kcc.io" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11760430
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kinto.js
var kinto = defineChain({
  id: 7887,
  name: "Kinto Mainnet",
  network: "Kinto Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.kinto.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Kinto Explorer",
      url: "https://explorer.kinto.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/klaytn.js
var klaytn = defineChain({
  id: 8217,
  name: "Klaytn",
  nativeCurrency: {
    decimals: 18,
    name: "Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-cypress.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://scope.klaytn.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
});

// node_modules/viem/_esm/chains/definitions/kaia.js
var kaia = defineChain({
  id: 8217,
  name: "Kaia",
  nativeCurrency: {
    decimals: 18,
    name: "Kaia",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kaiascan.io",
      apiUrl: "https://api-cypress.klaytnscope.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 96002415
    }
  }
});

// node_modules/viem/_esm/chains/definitions/kairos.js
var kairos = defineChain({
  id: 1001,
  name: "Kairos Testnet",
  network: "kairos",
  nativeCurrency: {
    decimals: 18,
    name: "Kairos KAIA",
    symbol: "KAIA"
  },
  rpcUrls: {
    default: { http: ["https://public-en-kairos.node.kaia.io"] }
  },
  blockExplorers: {
    default: {
      name: "KaiaScan",
      url: "https://kairos.kaiascan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/klaytnBaobab.js
var klaytnBaobab = defineChain({
  id: 1001,
  name: "Klaytn Baobab Testnet",
  network: "klaytn-baobab",
  nativeCurrency: {
    decimals: 18,
    name: "Baobab Klaytn",
    symbol: "KLAY"
  },
  rpcUrls: {
    default: { http: ["https://public-en-baobab.klaytn.net"] }
  },
  blockExplorers: {
    default: {
      name: "KlaytnScope",
      url: "https://baobab.klaytnscope.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 123390593
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/koi.js
var koi = defineChain({
  id: 701,
  name: "Koi Network",
  nativeCurrency: {
    decimals: 18,
    name: "Koi Network Native Token",
    symbol: "KRING"
  },
  rpcUrls: {
    default: {
      http: ["https://koi-rpc.darwinia.network"],
      webSocket: ["wss://koi-rpc.darwinia.network"]
    }
  },
  blockExplorers: {
    default: { name: "Blockscout", url: "https://koi-scan.darwinia.network" }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 180001
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/kroma.js
var kroma = defineChain({
  id: 255,
  name: "Kroma",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Explorer",
      url: "https://blockscout.kroma.network",
      apiUrl: "https://blockscout.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 16054868
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/kromaSepolia.js
var kromaSepolia = defineChain({
  id: 2358,
  name: "Kroma Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.sepolia.kroma.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Kroma Sepolia Explorer",
      url: "https://blockscout.sepolia.kroma.network",
      apiUrl: "https://blockscout.sepolia.kroma.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 8900914
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/l3x.js
var l3x = defineChain({
  id: 12324,
  name: "L3X Protocol",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.l3x.com"],
      webSocket: ["wss://rpc-mainnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Mainnet Explorer",
      url: "https://explorer.l3x.com",
      apiUrl: "https://explorer.l3x.com/api/v2"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/l3xTestnet.js
var l3xTestnet = defineChain({
  id: 12325,
  name: "L3X Protocol Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.l3x.com"],
      webSocket: ["wss://rpc-testnet.l3x.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "L3X Testnet Explorer",
      url: "https://explorer-testnet.l3x.com",
      apiUrl: "https://explorer-testnet.l3x.com/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lavita.js
var lavita = defineChain({
  id: 360890,
  name: "LAVITA Mainnet",
  nativeCurrency: { name: "vTFUEL", symbol: "vTFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://tsub360890-eth-rpc.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "LAVITA Explorer",
      url: "https://tsub360890-explorer.thetatoken.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lens.js
var lens = defineChain({
  id: 232,
  name: "Lens",
  nativeCurrency: { name: "GHO", symbol: "GHO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lens.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://explorer.lens.xyz",
      apiUrl: "https://explorer.lens.xyz/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/lensTestnet.js
var lensTestnet = defineChain({
  id: 37111,
  name: "Lens Testnet",
  nativeCurrency: { name: "GRASS", symbol: "GRASS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lens.dev"],
      webSocket: ["wss://rpc.testnet.lens.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lens Block Explorer",
      url: "https://block-explorer.testnet.lens.dev",
      apiUrl: "https://block-explorer-api.staging.lens.dev/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lestnet.js
var lestnet = defineChain({
  id: 21363,
  name: "Lestnet",
  nativeCurrency: { name: "Lestnet Ether", symbol: "LETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://service.lestnet.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lestnet Explorer",
      url: "https://explore.lestnet.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lightlinkPegasus.js
var lightlinkPegasus = defineChain({
  id: 1891,
  name: "LightLink Pegasus Testnet",
  network: "lightlink-pegasus",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.pegasus.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Pegasus Explorer",
      url: "https://pegasus.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 127188532
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lightlinkPhoenix.js
var lightlinkPhoenix = defineChain({
  id: 1890,
  name: "LightLink Phoenix Mainnet",
  network: "lightlink-phoenix",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://replicator.phoenix.lightlink.io/rpc/v1"]
    }
  },
  blockExplorers: {
    default: {
      name: "LightLink Phoenix Explorer",
      url: "https://phoenix.lightlink.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 125499184
    }
  },
  testnet: false
});

// node_modules/viem/_esm/linea/actions/estimateGas.js
async function estimateGas3(client, args) {
  var _a2, _b, _c2;
  const { account: account_ = client.account } = args;
  if (!account_)
    throw new AccountNotFoundError();
  const account = parseAccount(account_);
  try {
    const { accessList, blockNumber, blockTag, data, gas, gasPrice, maxFeePerGas, maxPriorityFeePerGas, nonce, to: to4, value, ...rest } = args;
    const blockNumberHex = blockNumber ? numberToHex(blockNumber) : void 0;
    const block = blockNumberHex || blockTag;
    assertRequest(args);
    const chainFormat = (_c2 = (_b = (_a2 = client.chain) == null ? void 0 : _a2.formatters) == null ? void 0 : _b.transactionRequest) == null ? void 0 : _c2.format;
    const format6 = chainFormat || formatTransactionRequest;
    const request = format6({
      // Pick out extra data that might exist on the chain's transaction request type.
      ...extract(rest, { format: chainFormat }),
      from: account == null ? void 0 : account.address,
      accessList,
      data,
      gas,
      gasPrice,
      maxFeePerGas,
      maxPriorityFeePerGas,
      nonce,
      to: to4,
      value
    });
    const { baseFeePerGas, gasLimit, priorityFeePerGas } = await client.request({
      method: "linea_estimateGas",
      params: block ? [request, block] : [request]
    });
    return {
      baseFeePerGas: BigInt(baseFeePerGas),
      gasLimit: BigInt(gasLimit),
      priorityFeePerGas: BigInt(priorityFeePerGas)
    };
  } catch (err) {
    throw getCallError(err, {
      ...args,
      account,
      chain: client.chain
    });
  }
}

// node_modules/viem/_esm/linea/chainConfig.js
var chainConfig4 = {
  fees: {
    estimateFeesPerGas: estimateFeesPerGas3,
    async maxPriorityFeePerGas({ block, client, request }) {
      const response = await estimateFeesPerGas3({
        block,
        client,
        multiply: (x2) => x2,
        request,
        type: "eip1559"
      });
      if (!(response == null ? void 0 : response.maxPriorityFeePerGas))
        return null;
      return response.maxPriorityFeePerGas;
    }
  }
};
async function estimateFeesPerGas3({ client, multiply, request, type: type6 }) {
  try {
    const response = await estimateGas3(client, {
      ...request,
      account: request == null ? void 0 : request.account
    });
    const { priorityFeePerGas: maxPriorityFeePerGas } = response;
    const baseFeePerGas = multiply(BigInt(response.baseFeePerGas));
    const maxFeePerGas = baseFeePerGas + maxPriorityFeePerGas;
    if (type6 === "legacy")
      return { gasPrice: maxFeePerGas };
    return {
      maxFeePerGas,
      maxPriorityFeePerGas
    };
  } catch {
    return null;
  }
}

// node_modules/viem/_esm/chains/definitions/linea.js
var linea = defineChain({
  ...chainConfig4,
  id: 59144,
  name: "Linea Mainnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.linea.build"],
      webSocket: ["wss://rpc.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://lineascan.build",
      apiUrl: "https://api.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 42
    },
    ensRegistry: {
      address: "0x50130b669B28C339991d8676FA73CF122a121267",
      blockCreated: 6682888
    },
    ensUniversalResolver: {
      address: "0x3aA974fb3f8C1E02796048BDCdeD79e9D53a6965",
      blockCreated: 6683e3
    }
  },
  ensTlds: [".linea.eth"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lineaGoerli.js
var lineaGoerli = defineChain({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://api-goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lineaSepolia.js
var lineaSepolia = defineChain({
  ...chainConfig4,
  id: 59141,
  name: "Linea Sepolia Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.linea.build"],
      webSocket: ["wss://rpc.sepolia.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.lineascan.build",
      apiUrl: "https://api-sepolia.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 227427
    },
    ensRegistry: {
      address: "0x5B2636F0f2137B4aE722C01dd5122D7d3e9541f7",
      blockCreated: 2395094
    },
    ensUniversalResolver: {
      address: "0x72560a31B3DAEE82B984a7F51c6b3b1bb7CC9F50",
      blockCreated: 2395255
    }
  },
  ensTlds: [".linea.eth"],
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lineaTestnet.js
var lineaTestnet = defineChain({
  id: 59140,
  name: "Linea Goerli Testnet",
  nativeCurrency: { name: "Linea Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.goerli.linea.build"],
      webSocket: ["wss://rpc.goerli.linea.build"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli.lineascan.build",
      apiUrl: "https://goerli.lineascan.build/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 498623
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lisk.js
var sourceId27 = 1;
var lisk = defineChain({
  ...chainConfig2,
  id: 1135,
  name: "Lisk",
  network: "lisk",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://blockscout.lisk.com",
      apiUrl: "https://blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xA9d71E1dd7ca26F26e656E66d6AA81ed7f745bf0"
    },
    l2OutputOracle: {
      [sourceId27]: {
        address: "0x113cB99283AF242Da0A0C54347667edF531Aa7d6"
      }
    },
    portal: {
      [sourceId27]: {
        address: "0x26dB93F8b8b4f7016240af62F7730979d353f9A7"
      }
    },
    l1StandardBridge: {
      [sourceId27]: {
        address: "0x2658723Bf70c7667De6B25F99fcce13A16D25d08"
      }
    }
  },
  sourceId: sourceId27
});

// node_modules/viem/_esm/chains/definitions/liskSepolia.js
var sourceId28 = 11155111;
var liskSepolia = defineChain({
  ...chainConfig2,
  id: 4202,
  network: "lisk-sepolia",
  name: "Lisk Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia-api.lisk.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia-blockscout.lisk.com",
      apiUrl: "https://sepolia-blockscout.lisk.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId28]: {
        address: "0xA0E35F56C318DE1bD5D9ca6A94Fe7e37C5663348"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId28]: {
        address: "0xe3d90F21490686Ec7eF37BE788E02dfC12787264"
      }
    },
    l1StandardBridge: {
      [sourceId28]: {
        address: "0x1Fb30e446eA791cd1f011675E5F3f5311b70faF5"
      }
    }
  },
  testnet: true,
  sourceId: sourceId28
});

// node_modules/viem/_esm/chains/definitions/localhost.js
var localhost = defineChain({
  id: 1337,
  name: "Localhost",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["http://127.0.0.1:8545"] }
  }
});

// node_modules/viem/_esm/chains/definitions/loop.js
var loop = defineChain({
  id: 15551,
  name: "LoopNetwork Mainnet",
  nativeCurrency: {
    name: "LOOP",
    symbol: "LOOP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://api.mainnetloop.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "LoopNetwork Blockchain Explorer",
      url: "https://explorer.mainnetloop.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lukso.js
var lukso = defineChain({
  id: 42,
  network: "lukso",
  name: "LUKSO",
  nativeCurrency: {
    name: "LUKSO",
    symbol: "LYX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.lukso.network"],
      webSocket: ["wss://ws-rpc.mainnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Mainnet Explorer",
      url: "https://explorer.execution.mainnet.lukso.network",
      apiUrl: "https://api.explorer.execution.mainnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 468183
    }
  }
});

// node_modules/viem/_esm/chains/definitions/luksoTestnet.js
var luksoTestnet = defineChain({
  id: 4201,
  name: "LUKSO Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "LUKSO Testnet",
    symbol: "LYXt"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.lukso.network"],
      webSocket: ["wss://ws-rpc.testnet.lukso.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "LUKSO Testnet Explorer",
      url: "https://explorer.execution.testnet.lukso.network",
      apiUrl: "https://api.explorer.execution.testnet.lukso.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 605348
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lumiaMainnet.js
var lumiaMainnet = defineChain({
  id: 994873017,
  name: "Lumia Mainnet",
  network: "LumiaMainnet",
  nativeCurrency: { name: "Lumia", symbol: "LUMIA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Explorer",
      url: "https://explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3975939
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lumiaTestnet.js
var lumiaTestnet = defineChain({
  id: 1952959480,
  name: "Lumia Testnet",
  network: "LumiaTestnet",
  nativeCurrency: {
    name: "Lumia",
    symbol: "LUMIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumia.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumia Testnet Explorer",
      url: "https://testnet-explorer.lumia.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2235063
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lumoz.js
var lumoz = defineChain({
  id: 96370,
  name: "Lumoz",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.lumoz.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumoz Scan",
      url: "https://scan.lumoz.info"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/lumozTestnet.js
var lumozTestnet = defineChain({
  id: 105363,
  name: "Lumoz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Lumoz Testnet Token",
    symbol: "MOZ"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.lumoz.org"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/lycan.js
var lycan = defineChain({
  id: 721,
  name: "Lycan",
  nativeCurrency: {
    decimals: 18,
    name: "Lycan",
    symbol: "LYC"
  },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.lycanchain.com",
        "https://us-east.lycanchain.com",
        "https://us-west.lycanchain.com",
        "https://eu-north.lycanchain.com",
        "https://eu-west.lycanchain.com",
        "https://asia-southeast.lycanchain.com"
      ],
      webSocket: [
        "wss://rpc.lycanchain.com",
        "wss://us-east.lycanchain.com",
        "wss://us-west.lycanchain.com",
        "wss://eu-north.lycanchain.com",
        "wss://eu-west.lycanchain.com",
        "wss://asia-southeast.lycanchain.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Lycan Explorer",
      url: "https://explorer.lycanchain.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/lyra.js
var lyra = defineChain({
  id: 957,
  name: "Lyra Chain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.lyra.finance"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lyra Explorer",
      url: "https://explorer.lyra.finance",
      apiUrl: "https://explorer.lyra.finance/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1935198
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mainnet.js
var mainnet = defineChain({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mandala.js
var mandala = defineChain({
  id: 595,
  name: "Mandala TC9",
  network: "mandala",
  nativeCurrency: {
    name: "Mandala",
    symbol: "mACA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-tc9.aca-staging.network"],
      webSocket: ["wss://eth-rpc-tc9.aca-staging.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mandala Blockscout",
      url: "https://blockscout.mandala.aca-staging.network",
      apiUrl: "https://blockscout.mandala.aca-staging.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/manta.js
var manta = defineChain({
  id: 169,
  name: "Manta Pacific Mainnet",
  network: "manta",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://pacific-rpc.manta.network/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Explorer",
      url: "https://pacific-explorer.manta.network",
      apiUrl: "https://pacific-explorer.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 332890
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantaSepoliaTestnet.js
var mantaSepoliaTestnet = defineChain({
  id: 3441006,
  name: "Manta Pacific Sepolia Testnet",
  network: "manta-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://pacific-rpc.sepolia-testnet.manta.network/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Manta Sepolia Testnet Explorer",
      url: "https://pacific-explorer.sepolia-testnet.manta.network",
      apiUrl: "https://pacific-explorer.sepolia-testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca54918f7B525C8df894668846506767412b53E3",
      blockCreated: 479584
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantaTestnet.js
var mantaTestnet = defineChain({
  id: 3441005,
  name: "Manta Pacific Testnet",
  network: "manta-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://manta-testnet.calderachain.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Manta Testnet Explorer",
      url: "https://pacific-explorer.testnet.manta.network",
      apiUrl: "https://pacific-explorer.testnet.manta.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x211B1643b95Fe76f11eD8880EE810ABD9A4cf56C",
      blockCreated: 419915
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantle.js
var mantle = defineChain({
  id: 5e3,
  name: "Mantle",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Explorer",
      url: "https://mantlescan.xyz/",
      apiUrl: "https://api.mantlescan.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 304717
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mantleSepoliaTestnet.js
var mantleSepoliaTestnet = defineChain({
  id: 5003,
  name: "Mantle Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.sepolia.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.sepolia.mantle.xyz/",
      apiUrl: "https://explorer.sepolia.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4584012
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mantleTestnet.js
var mantleTestnet = defineChain({
  id: 5001,
  name: "Mantle Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MNT",
    symbol: "MNT"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.mantle.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Mantle Testnet Explorer",
      url: "https://explorer.testnet.mantle.xyz",
      apiUrl: "https://explorer.testnet.mantle.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 561333
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mapProtocol.js
var mapProtocol = defineChain({
  id: 22776,
  name: "MAP Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "MAPO",
    symbol: "MAPO"
  },
  rpcUrls: {
    default: { http: ["https://rpc.maplabs.io"] }
  },
  blockExplorers: {
    default: {
      name: "MAPO Scan",
      url: "https://maposcan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/matchain.js
var matchain = defineChain({
  id: 698,
  name: "Matchain",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://matchscan.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/matchainTestnet.js
var matchainTestnet = defineChain({
  id: 699,
  name: "Matchain Testnet",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.matchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Matchain Scan",
      url: "https://testnet.matchscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mchVerse.js
var mchVerse = defineChain({
  id: 29548,
  name: "MCH Verse",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.oasys.mycryptoheroes.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MCH Verse Explorer",
      url: "https://explorer.oasys.mycryptoheroes.net",
      apiUrl: "https://explorer.oasys.mycryptoheroes.net/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/megaethTestnet.js
var megaethTestnet = defineChain({
  id: 6342,
  name: "MegaETH Testnet",
  nativeCurrency: {
    name: "MegaETH Testnet Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://carrot.megaeth.com/rpc"],
      webSocket: ["wss://carrot.megaeth.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "MegaETH Testnet Explorer",
      url: "https://www.megaexplorer.xyz/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mekong.js
var mekong = defineChain({
  id: 7078815900,
  name: "Mekong Pectra Devnet",
  nativeCurrency: { name: "eth", symbol: "eth", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mekong.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Block Explorer",
      url: "https://explorer.mekong.ethpandaops.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/meld.js
var meld = defineChain({
  id: 333000333,
  name: "Meld",
  nativeCurrency: {
    decimals: 18,
    name: "Meld",
    symbol: "MELD"
  },
  rpcUrls: {
    default: { http: ["https://rpc-1.meld.com"] }
  },
  blockExplorers: {
    default: { name: "MELDscan", url: "https://meldscan.io" }
  },
  contracts: {
    multicall3: {
      address: "0x769ee5a8e82c15c1b6e358f62ac8eb6e3abe8dc5",
      blockCreated: 360069
    }
  }
});

// node_modules/viem/_esm/chains/definitions/memecore.js
var memecore = defineChain({
  id: 4352,
  name: "MemeCore",
  nativeCurrency: {
    decimals: 18,
    name: "M",
    symbol: "M"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.memecore.net"],
      webSocket: ["wss://ws.memecore.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "MemeCore Explorer",
      url: "https://memecorescan.io",
      apiUrl: "https://api.memecorescan.io/api"
    },
    okx: {
      name: "MemeCore Explorer",
      url: "https://web3.okx.com/explorer/memecore"
    },
    memecore: {
      name: "MemeCore Explorer",
      url: "https://blockscout.memecore.com",
      apiUrl: "https://blockscout.memecore.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/merlin.js
var merlin = defineChain({
  id: 4200,
  name: "Merlin",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://scan.merlinchain.io",
      apiUrl: "https://scan.merlinchain.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/merlinErigonTestnet.js
var merlinErigonTestnet = defineChain({
  id: 4203,
  name: "Merlin Erigon Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://testnet-erigon-rpc.merlinchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet-erigon-scan.merlinchain.io",
      apiUrl: "https://testnet-erigon-scan.merlinchain.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/metachain.js
var metachain = defineChain({
  id: 571,
  name: "MetaChain Mainnet",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.metatime.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://explorer.metatime.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metachainIstanbul.js
var metachainIstanbul = defineChain({
  id: 1453,
  name: "MetaChain Istanbul",
  nativeCurrency: { name: "Metatime Coin", symbol: "MTC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://istanbul-rpc.metachain.dev"]
    }
  },
  blockExplorers: {
    default: {
      name: "MetaExplorer",
      url: "https://istanbul-explorer.metachain.dev"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0000000000000000000000000000000000003001",
      blockCreated: 0
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/metadium.js
var metadium = defineChain({
  id: 11,
  name: "Metadium Network",
  nativeCurrency: {
    decimals: 18,
    name: "META",
    symbol: "META"
  },
  rpcUrls: {
    default: { http: ["https://api.metadium.com/prod"] }
  },
  blockExplorers: {
    default: {
      name: "Metadium Explorer",
      url: "https://explorer.metadium.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/metalL2.js
var sourceId29 = 1;
var metalL2 = defineChain({
  ...chainConfig2,
  id: 1750,
  name: "Metal L2",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.metall2.com"],
      webSocket: ["wss://rpc.metall2.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.metall2.com",
      apiUrl: "https://explorer.metall2.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId29]: {
        address: "0x3B1F7aDa0Fcc26B13515af752Dd07fB1CAc11426"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    },
    portal: {
      [sourceId29]: {
        address: "0x3F37aBdE2C6b5B2ed6F8045787Df1ED1E3753956"
      }
    },
    l1StandardBridge: {
      [sourceId29]: {
        address: "0x6d0f65D59b55B0FEC5d2d15365154DcADC140BF3"
      }
    }
  },
  sourceId: sourceId29
});

// node_modules/viem/_esm/chains/definitions/meter.js
var meter = defineChain({
  id: 82,
  name: "Meter",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpc.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterScan",
      url: "https://scan.meter.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/meterTestnet.js
var meterTestnet = defineChain({
  id: 83,
  name: "Meter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MTR",
    symbol: "MTR"
  },
  rpcUrls: {
    default: { http: ["https://rpctest.meter.io"] }
  },
  blockExplorers: {
    default: {
      name: "MeterTestnetScan",
      url: "https://scan-warringstakes.meter.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metis.js
var metis = defineChain({
  id: 1088,
  name: "Metis",
  nativeCurrency: {
    decimals: 18,
    name: "Metis",
    symbol: "METIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://metis.rpc.hypersync.xyz",
        "https://metis-pokt.nodies.app",
        "https://api.blockeden.xyz/metis/67nCBdZQSH9z3YqDDjdm",
        "https://metis-andromeda.rpc.thirdweb.com",
        "https://metis-andromeda.gateway.tenderly.co",
        "https://metis.api.onfinality.io/public",
        "https://andromeda.metis.io/?owner=1088",
        "https://metis-mainnet.public.blastapi.io"
      ],
      webSocket: ["wss://metis-rpc.publicnode.com", "wss://metis.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Explorer",
      url: "https://explorer.metis.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/1088/etherscan/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2338552
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metisSepolia.js
var metisSepolia = defineChain({
  id: 59902,
  name: "Metis Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Test Metis",
    symbol: "tMETIS"
  },
  rpcUrls: {
    default: {
      http: [
        "https://sepolia.metisdevops.link",
        "https://metis-sepolia-rpc.publicnode.com",
        "https://metis-sepolia.gateway.tenderly.co"
      ],
      webSocket: ["wss://metis-sepolia-rpc.publicnode.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Metis Sepolia Explorer",
      url: "https://sepolia-explorer.metisdevops.link",
      apiUrl: "https://sepolia-explorer.metisdevops.link/api-docs"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 224185
    }
  }
});

// node_modules/viem/_esm/chains/definitions/metisGoerli.js
var metisGoerli = defineChain({
  id: 599,
  name: "Metis Goerli",
  nativeCurrency: {
    decimals: 18,
    name: "Metis Goerli",
    symbol: "METIS"
  },
  rpcUrls: {
    default: { http: ["https://goerli.gateway.metisdevops.link"] }
  },
  blockExplorers: {
    default: {
      name: "Metis Goerli Explorer",
      url: "https://goerli.explorer.metisdevops.link",
      apiUrl: "https://goerli.explorer.metisdevops.link/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1006207
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mev.js
var mev = defineChain({
  id: 7518,
  name: "MEVerse Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversemainnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://www.meversescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 86881340
    }
  }
});

// node_modules/viem/_esm/chains/definitions/mevTestnet.js
var mevTestnet = defineChain({
  id: 4759,
  name: "MEVerse Chain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MEVerse",
    symbol: "MEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.meversetestnet.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.meversescan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 64371115
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mint.js
var mint = defineChain({
  id: 185,
  name: "Mint Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain explorer",
      url: "https://explorer.mintchain.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/mintSepoliaTestnet.js
var mintSepoliaTestnet = defineChain({
  id: 1686,
  name: "Mint Sepolia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.mintchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mintchain Testnet explorer",
      url: "https://testnet-explorer.mintchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mitosisTestnet.js
var mitosisTestnet = defineChain({
  id: 124832,
  name: "Mitosis Testnet",
  nativeCurrency: { name: "MITO", symbol: "MITO", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.mitosis.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Mitosis testnet explorer",
      url: "https://testnet.mitosiscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/mode.js
var sourceId30 = 1;
var mode = defineChain({
  ...chainConfig2,
  id: 34443,
  name: "Mode Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Modescan",
      url: "https://modescan.io"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 2465882
    },
    l2OutputOracle: {
      [sourceId30]: {
        address: "0x4317ba146D4933D889518a3e5E11Fe7a53199b04"
      }
    },
    portal: {
      [sourceId30]: {
        address: "0x8B34b14c7c7123459Cf3076b8Cb929BE097d0C07"
      }
    },
    l1StandardBridge: {
      [sourceId30]: {
        address: "0x735aDBbE72226BD52e818E7181953f42E3b0FF21"
      }
    }
  },
  sourceId: sourceId30
});

// node_modules/viem/_esm/chains/definitions/modeTestnet.js
var sourceId31 = 11155111;
var modeTestnet = defineChain({
  ...chainConfig2,
  id: 919,
  name: "Mode Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.mode.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepolia.explorer.mode.network",
      apiUrl: "https://sepolia.explorer.mode.network/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId31]: {
        address: "0x2634BD65ba27AB63811c74A63118ACb312701Bfa",
        blockCreated: 3778393
      }
    },
    portal: {
      [sourceId31]: {
        address: "0x320e1580effF37E008F1C92700d1eBa47c1B23fD",
        blockCreated: 3778395
      }
    },
    l1StandardBridge: {
      [sourceId31]: {
        address: "0xbC5C679879B2965296756CD959C3C739769995E2",
        blockCreated: 3778392
      }
    },
    multicall3: {
      address: "0xBAba8373113Fb7a68f195deF18732e01aF8eDfCF",
      blockCreated: 3019007
    }
  },
  testnet: true,
  sourceId: sourceId31
});

// node_modules/viem/_esm/chains/definitions/monadTestnet.js
var monadTestnet = defineChain({
  id: 10143,
  name: "Monad Testnet",
  nativeCurrency: {
    name: "Testnet MON Token",
    symbol: "MON",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.monad.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Monad Testnet explorer",
      url: "https://testnet.monadexplorer.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 251449
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/moonbaseAlpha.js
var moonbaseAlpha = defineChain({
  id: 1287,
  name: "Moonbase Alpha",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.api.moonbase.moonbeam.network"],
      webSocket: ["wss://wss.api.moonbase.moonbeam.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonbase.moonscan.io",
      apiUrl: "https://moonbase.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1850686
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/moonbeam.js
var moonbeam = defineChain({
  id: 1284,
  name: "Moonbeam",
  nativeCurrency: {
    decimals: 18,
    name: "GLMR",
    symbol: "GLMR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonbeam.public.blastapi.io"],
      webSocket: ["wss://moonbeam.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonscan.io",
      apiUrl: "https://api-moonbeam.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 609002
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/moonbeamDev.js
var moonbeamDev = defineChain({
  id: 1281,
  name: "Moonbeam Development Node",
  nativeCurrency: {
    decimals: 18,
    name: "DEV",
    symbol: "DEV"
  },
  rpcUrls: {
    default: {
      http: ["http://127.0.0.1:9944"],
      webSocket: ["wss://127.0.0.1:9944"]
    }
  }
});

// node_modules/viem/_esm/chains/definitions/moonriver.js
var moonriver = defineChain({
  id: 1285,
  name: "Moonriver",
  nativeCurrency: {
    decimals: 18,
    name: "MOVR",
    symbol: "MOVR"
  },
  rpcUrls: {
    default: {
      http: ["https://moonriver.public.blastapi.io"],
      webSocket: ["wss://moonriver.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Moonscan",
      url: "https://moonriver.moonscan.io",
      apiUrl: "https://api-moonriver.moonscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1597904
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/morph.js
var morph = defineChain({
  id: 2818,
  name: "Morph",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.morphl2.io"],
      webSocket: ["wss://rpc.morphl2.io:8443"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Explorer",
      url: "https://explorer.morphl2.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/morphHolesky.js
var morphHolesky = defineChain({
  id: 2810,
  name: "Morph Holesky",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-quicknode-holesky.morphl2.io"],
      webSocket: ["wss://rpc-quicknode-holesky.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Holesky Explorer",
      url: "https://explorer-holesky.morphl2.io",
      apiUrl: "https://explorer-api-holesky.morphl2.io/api?"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/morphSepolia.js
var morphSepolia = defineChain({
  id: 2710,
  name: "Morph Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.morphl2.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Morph Testnet Explorer",
      url: "https://explorer-testnet.morphl2.io",
      apiUrl: "https://explorer-api-testnet.morphl2.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/nahmii.js
var nahmii = defineChain({
  id: 5551,
  name: "Nahmii 2 Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://l2.nahmii.io"] }
  },
  blockExplorers: {
    default: {
      name: "Nahmii 2 Explorer",
      url: "https://explorer.n2.nahmii.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nautilus.js
var nautilus = defineChain({
  id: 22222,
  name: "Nautilus Mainnet",
  nativeCurrency: { name: "ZBC", symbol: "ZBC", decimals: 9 },
  rpcUrls: {
    default: {
      http: ["https://api.nautilus.nautchain.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "NautScan",
      url: "https://nautscan.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/near.js
var near = defineChain({
  id: 397,
  name: "NEAR Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.mainnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer.near.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nearTestnet.js
var nearTestnet = defineChain({
  id: 398,
  name: "NEAR Protocol Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "NEAR",
    symbol: "NEAR"
  },
  rpcUrls: {
    default: { http: ["https://eth-rpc.testnet.near.org"] }
  },
  blockExplorers: {
    default: {
      name: "NEAR Explorer",
      url: "https://eth-explorer-testnet.near.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/neonDevnet.js
var neonDevnet = defineChain({
  id: 245022926,
  name: "Neon EVM DevNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://devnet.neonevm.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://devnet.neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 205206112
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/neonMainnet.js
var neonMainnet = defineChain({
  id: 245022934,
  network: "neonMainnet",
  name: "Neon EVM MainNet",
  nativeCurrency: { name: "NEON", symbol: "NEON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://neon-proxy-mainnet.solana.p2p.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Neonscan",
      url: "https://neonscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 206545524
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/neoxMainnet.js
var neoxMainnet = defineChain({
  id: 47763,
  name: "Neo X Mainnet",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet-1.rpc.banelabs.org",
        "https://mainnet-2.rpc.banelabs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Neo X - Explorer",
      url: "https://xexplorer.neo.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/neoxT4.js
var neoxT4 = defineChain({
  id: 12227332,
  name: "Neo X Testnet T4",
  nativeCurrency: { name: "Gas", symbol: "GAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.banelabs.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "neox-scan",
      url: "https://xt4scan.ngd.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/newton.js
var newton = defineChain({
  id: 1012,
  name: "Newton",
  nativeCurrency: {
    name: "Newton",
    symbol: "NEW",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://global.rpc.mainnet.newtonproject.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "NewFi explorer",
      url: "https://explorer.newtonproject.org/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/nexi.js
var nexi = defineChain({
  id: 4242,
  name: "Nexi",
  nativeCurrency: { name: "Nexi", symbol: "NEXI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.chain.nexi.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "NexiScan",
      url: "https://www.nexiscan.com",
      apiUrl: "https://www.nexiscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0277A46Cc69A57eE3A6C8c158bA874832F718B8E",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nexilix.js
var nexilix = defineChain({
  id: 240,
  name: "Nexilix Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Nexilix",
    symbol: "NEXILIX"
  },
  rpcUrls: {
    default: { http: ["https://rpcurl.pos.nexilix.com"] }
  },
  blockExplorers: {
    default: {
      name: "NexilixScan",
      url: "https://scan.nexilix.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x58381c8e2BF9d0C2C4259cA14BdA9Afe02831244",
      blockCreated: 74448
    }
  }
});

// node_modules/viem/_esm/chains/definitions/nibiru.js
var nibiru = defineChain({
  id: 6900,
  name: "Nibiru",
  nativeCurrency: {
    decimals: 18,
    name: "NIBI",
    symbol: "NIBI"
  },
  rpcUrls: {
    default: { http: ["https://evm-rpc.nibiru.fi"] }
  },
  blockExplorers: {
    default: {
      name: "NibiScan",
      url: "https://nibiscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 19587573
    }
  }
});

// node_modules/viem/_esm/chains/definitions/oasisTestnet.js
var oasisTestnet = defineChain({
  id: 4090,
  network: "oasis-testnet",
  name: "Oasis Testnet",
  nativeCurrency: { name: "Fasttoken", symbol: "FTN", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc1.oasis.bahamutchain.com"] }
  },
  blockExplorers: {
    default: {
      name: "Ftnscan",
      url: "https://oasis.ftnscan.com",
      apiUrl: "https://oasis.ftnscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/oasys.js
var oasys = defineChain({
  id: 248,
  name: "Oasys",
  nativeCurrency: { name: "Oasys", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.oasys.games"]
    }
  },
  blockExplorers: {
    default: {
      name: "OasysScan",
      url: "https://scan.oasys.games",
      apiUrl: "https://scan.oasys.games/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/odysseyTestnet.js
var odysseyTestnet = defineChain({
  id: 911867,
  name: "Odyssey Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://odyssey.ithaca.xyz"] }
  },
  blockExplorers: {
    default: {
      name: "Odyssey Explorer",
      url: "https://odyssey-explorer.ithaca.xyz",
      apiUrl: "https://odyssey-explorer.ithaca.xyz/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/okc.js
var okc = defineChain({
  id: 66,
  name: "OKC",
  nativeCurrency: {
    decimals: 18,
    name: "OKT",
    symbol: "OKT"
  },
  rpcUrls: {
    default: { http: ["https://exchainrpc.okex.org"] }
  },
  blockExplorers: {
    default: {
      name: "oklink",
      url: "https://www.oklink.com/okc"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 10364792
    }
  }
});

// node_modules/viem/_esm/chains/definitions/omax.js
var omax = defineChain({
  id: 311,
  name: "Omax Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OMAX",
    symbol: "OMAX"
  },
  rpcUrls: {
    default: { http: ["https://mainapi.omaxray.com"] }
  },
  blockExplorers: {
    default: {
      name: "Omax Explorer",
      url: "https://omaxscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/oneWorld.js
var oneWorld = defineChain({
  id: 309075,
  name: "One World Chain Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OWCT",
    symbol: "OWCT"
  },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.oneworldchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "One World Explorer",
      url: "https://mainnet.oneworldchain.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/oortmainnetDev.js
var oortMainnetDev = defineChain({
  id: 9700,
  name: "OORT MainnetDev",
  nativeCurrency: {
    decimals: 18,
    name: "OORT",
    symbol: "OORT"
  },
  rpcUrls: {
    default: { http: ["https://dev-rpc.oortech.com"] }
  },
  blockExplorers: {
    default: {
      name: "OORT MainnetDev Explorer",
      url: "https://dev-scan.oortech.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/opBNB.js
var sourceId32 = 56;
var opBNB = defineChain({
  id: 204,
  name: "opBNB",
  nativeCurrency: {
    name: "BNB",
    symbol: "BNB",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://opbnb-mainnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opBNB (BSCScan)",
      url: "https://opbnb.bscscan.com",
      apiUrl: "https://api-opbnb.bscscan.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 512881
    },
    l2OutputOracle: {
      [sourceId32]: {
        address: "0x153CAB79f4767E2ff862C94aa49573294B13D169"
      }
    },
    portal: {
      [sourceId32]: {
        address: "0x1876EA7702C0ad0C6A2ae6036DE7733edfBca519"
      }
    },
    l1StandardBridge: {
      [sourceId32]: {
        address: "0xF05F0e4362859c3331Cb9395CBC201E3Fa6757Ea"
      }
    }
  },
  sourceId: sourceId32
});

// node_modules/viem/_esm/chains/definitions/opBNBTestnet.js
var sourceId33 = 97;
var opBNBTestnet = defineChain({
  id: 5611,
  name: "opBNB Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "tBNB",
    symbol: "tBNB"
  },
  rpcUrls: {
    default: { http: ["https://opbnb-testnet-rpc.bnbchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "opbnbscan",
      url: "https://testnet.opbnbscan.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3705108
    },
    l2OutputOracle: {
      [sourceId33]: {
        address: "0xFf2394Bb843012562f4349C6632a0EcB92fC8810"
      }
    },
    portal: {
      [sourceId33]: {
        address: "0x4386C8ABf2009aC0c263462Da568DD9d46e52a31"
      }
    },
    l1StandardBridge: {
      [sourceId33]: {
        address: "0x677311Fd2cCc511Bbc0f581E8d9a07B033D5E840"
      }
    }
  },
  testnet: true,
  sourceId: sourceId33
});

// node_modules/viem/_esm/chains/definitions/optimism.js
var sourceId34 = 1;
var optimism = defineChain({
  ...chainConfig2,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId34]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [sourceId34]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [sourceId34]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [sourceId34]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: sourceId34
});

// node_modules/viem/_esm/chains/definitions/optimismGoerli.js
var sourceId35 = 5;
var optimismGoerli = defineChain({
  ...chainConfig2,
  id: 420,
  name: "Optimism Goerli",
  nativeCurrency: { name: "Goerli Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://goerli.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://goerli-optimism.etherscan.io",
      apiUrl: "https://goerli-optimism.etherscan.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId35]: {
        address: "0xE6Dfba0953616Bacab0c9A8ecb3a9BBa77FC15c0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 49461
    },
    portal: {
      [sourceId35]: {
        address: "0x5b47E1A08Ea6d985D6649300584e6722Ec4B1383"
      }
    },
    l1StandardBridge: {
      [sourceId35]: {
        address: "0x636Af16bf2f682dD3109e60102b8E1A089FedAa8"
      }
    }
  },
  testnet: true,
  sourceId: sourceId35
});

// node_modules/viem/_esm/chains/definitions/optimismSepolia.js
var sourceId36 = 11155111;
var optimismSepolia = defineChain({
  ...chainConfig2,
  id: 11155420,
  name: "OP Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://optimism-sepolia.blockscout.com",
      apiUrl: "https://optimism-sepolia.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId36]: {
        address: "0x05F9613aDB30026FFd634f38e5C4dFd30a197Fa1"
      }
    },
    l2OutputOracle: {
      [sourceId36]: {
        address: "0x90E9c4f8a994a250F6aEfd61CAFb4F2e895D458F"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1620204
    },
    portal: {
      [sourceId36]: {
        address: "0x16Fc5058F25648194471939df75CF27A2fdC48BC"
      }
    },
    l1StandardBridge: {
      [sourceId36]: {
        address: "0xFBb0621E0B23b5478B630BD55a5f21f67730B0F1"
      }
    }
  },
  testnet: true,
  sourceId: sourceId36
});

// node_modules/viem/_esm/chains/definitions/optopia.js
var optopia = defineChain({
  id: 62050,
  name: "Optopia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-mainnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan.optopia.ai"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/optopiaTestnet.js
var optopiaTestnet = defineChain({
  id: 62049,
  name: "Optopia Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-testnet.optopia.ai"] }
  },
  blockExplorers: {
    default: {
      name: "Optopia Explorer",
      url: "https://scan-testnet.optopia.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/orderly.js
var orderly = defineChain({
  id: 291,
  name: "Orderly",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.orderly.network"] }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorer.orderly.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/orderlySepolia.js
var orderlySepolia = defineChain({
  id: 4460,
  name: "Orderly Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://l2-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Orderly Explorer",
      url: "https://explorerl2new-orderly-l2-4460-sepolia-8tc3sd7dvy.t.conduit.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/otimDevnet.js
var otimDevnet = defineChain({
  id: 41144114,
  name: "Otim Devnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["http://devnet.otim.xyz"]
    }
  },
  contracts: {
    batchInvoker: {
      address: "0x5FbDB2315678afecb367f032d93F642f64180aa3"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/palm.js
var palm = defineChain({
  id: 11297108109,
  name: "Palm",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  }
});

// node_modules/viem/_esm/chains/definitions/palmTestnet.js
var palmTestnet = defineChain({
  id: 11297108099,
  name: "Palm Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PALM",
    symbol: "PALM"
  },
  rpcUrls: {
    default: {
      http: ["https://palm-mainnet.public.blastapi.io"],
      webSocket: ["wss://palm-mainnet.public.blastapi.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Chainlens",
      url: "https://palm.chainlens.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15429248
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/peaq.js
var peaq = defineChain({
  id: 3338,
  name: "Peaq",
  nativeCurrency: {
    decimals: 18,
    name: "peaq",
    symbol: "PEAQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://peaq-rpc.publicnode.com",
        "https://peaq.api.onfinality.io/public",
        "https://peaq-rpc.dwellir.com",
        "https://evm.peaq.network"
      ],
      webSocket: [
        "wss://peaq-rpc.publicnode.com",
        "wss://peaq.api.onfinality.io/public",
        "wss://peaq-rpc.dwellir.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Subscan",
      url: "https://peaq.subscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3566354
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pgn.js
var sourceId37 = 1;
var pgn = defineChain({
  id: 424,
  network: "pgn",
  name: "PGN",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Explorer",
      url: "https://explorer.publicgoods.network",
      apiUrl: "https://explorer.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [sourceId37]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3380209
    },
    portal: {
      [sourceId37]: {
        address: "0xb26Fd985c5959bBB382BAFdD0b879E149e48116c"
      }
    },
    l1StandardBridge: {
      [sourceId37]: {
        address: "0xD0204B9527C1bA7bD765Fa5CCD9355d38338272b"
      }
    }
  },
  formatters: formatters2,
  sourceId: sourceId37
});

// node_modules/viem/_esm/chains/definitions/pgnTestnet.js
var sourceId38 = 11155111;
var pgnTestnet = defineChain({
  id: 58008,
  network: "pgn-testnet",
  name: "PGN ",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.publicgoods.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "PGN Testnet Explorer",
      url: "https://explorer.sepolia.publicgoods.network",
      apiUrl: "https://explorer.sepolia.publicgoods.network/api"
    }
  },
  contracts: {
    l2OutputOracle: {
      [sourceId38]: {
        address: "0xD5bAc3152ffC25318F848B3DD5dA6C85171BaEEe"
      }
    },
    portal: {
      [sourceId38]: {
        address: "0xF04BdD5353Bb0EFF6CA60CfcC78594278eBfE179"
      }
    },
    l1StandardBridge: {
      [sourceId38]: {
        address: "0xFaE6abCAF30D23e233AC7faF747F2fC3a5a6Bfa3"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3754925
    }
  },
  formatters: formatters2,
  sourceId: sourceId38,
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/phoenix.js
var phoenix = defineChain({
  id: 13381,
  name: "Phoenix Blockchain",
  nativeCurrency: { name: "Phoenix", symbol: "PHX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.phoenixplorer.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Phoenixplorer",
      url: "https://phoenixplorer.com",
      apiUrl: "https://phoenixplorer.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x498cF757a575cFF2c2Ed9f532f56Efa797f86442",
      blockCreated: 5620192
    }
  }
});

// node_modules/viem/_esm/chains/definitions/planq.js
var planq = defineChain({
  id: 7070,
  name: "Planq Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "PLQ",
    symbol: "PLQ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://planq-rpc.nodies.app",
        "https://evm-rpc.planq.network",
        "https://jsonrpc.planq.nodestake.top"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Planq Explorer",
      url: "https://evm.planq.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 8470015
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/playfiAlbireo.js
var playfiAlbireo = defineChain({
  ...chainConfig,
  id: 1612127,
  name: "PlayFi Albireo Testnet",
  network: "albireo",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://albireo-rpc.playfi.ai"],
      webSocket: ["wss://albireo-rpc-ws.playfi.ai/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "PlayFi Albireo Explorer",
      url: "https://albireo-explorer.playfi.ai"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/plinga.js
var plinga = defineChain({
  id: 242,
  name: "Plinga",
  nativeCurrency: { name: "Plinga", symbol: "PLINGA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpcurl.mainnet.plgchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Plgscan",
      url: "https://www.plgscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0989576160f2e7092908BB9479631b901060b6e4",
      blockCreated: 204489
    }
  }
});

// node_modules/viem/_esm/chains/definitions/plume.js
var sourceId39 = 1;
var plume = defineChain({
  id: 98865,
  name: "Plume (Legacy)",
  nativeCurrency: {
    name: "Plume Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.plumenetwork.xyz"],
      webSocket: ["wss://rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.plumenetwork.xyz",
      apiUrl: "https://explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 48577
    }
  },
  sourceId: sourceId39
});

// node_modules/viem/_esm/chains/definitions/plumeDevnet.js
var sourceId40 = 11155111;
var plumeDevnet = defineChain({
  id: 98864,
  name: "Plume Devnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://test-rpc.plumenetwork.xyz"],
      webSocket: ["wss://test-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://test-explorer.plumenetwork.xyz",
      apiUrl: "https://test-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 481948
    }
  },
  testnet: true,
  sourceId: sourceId40
});

// node_modules/viem/_esm/chains/definitions/plumeMainnet.js
var sourceId41 = 1;
var plumeMainnet = defineChain({
  id: 98866,
  name: "Plume",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://phoenix-rpc.plumenetwork.xyz"],
      webSocket: ["wss://phoenix-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://phoenix-explorer.plumenetwork.xyz",
      apiUrl: "https://phoenix-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39679
    }
  },
  sourceId: sourceId41
});

// node_modules/viem/_esm/chains/definitions/plumeSepolia.js
var sourceId42 = 11155111;
var plumeSepolia = defineChain({
  id: 98867,
  name: "Plume Testnet",
  nativeCurrency: {
    name: "Plume",
    symbol: "PLUME",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plumenetwork.xyz"],
      webSocket: ["wss://testnet-rpc.plumenetwork.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plumenetwork.xyz",
      apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 199712
    }
  },
  testnet: true,
  sourceId: sourceId42
});

// node_modules/viem/_esm/chains/definitions/plumeTestnet.js
var sourceId43 = 11155111;
var plumeTestnet = defineChain({
  id: 161221135,
  name: "Plume Testnet (Legacy)",
  nativeCurrency: {
    name: "Plume Sepolia Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.plumenetwork.xyz/http"],
      webSocket: ["wss://testnet-rpc.plumenetwork.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer.plumenetwork.xyz",
      apiUrl: "https://testnet-explorer.plumenetwork.xyz/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6022332
    }
  },
  testnet: true,
  sourceId: sourceId43
});

// node_modules/viem/_esm/chains/definitions/polterTestnet.js
var polterTestnet = defineChain({
  id: 631571,
  name: "Polter Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Polter GHST",
    symbol: "GHST"
  },
  rpcUrls: {
    default: {
      http: ["https://geist-polter.g.alchemy.com/public"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://polter-testnet.explorer.alchemy.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11245
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygon.js
var polygon = defineChain({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonAmoy.js
var polygonAmoy = defineChain({
  id: 80002,
  name: "Polygon Amoy",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-amoy.polygon.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://amoy.polygonscan.com",
      apiUrl: "https://api-amoy.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 3127388
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonMumbai.js
var polygonMumbai = defineChain({
  id: 80001,
  name: "Polygon Mumbai",
  nativeCurrency: { name: "MATIC", symbol: "MATIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://80001.rpc.thirdweb.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://mumbai.polygonscan.com",
      apiUrl: "https://api-testnet.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvm.js
var polygonZkEvm = defineChain({
  id: 1101,
  name: "Polygon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://zkevm.polygonscan.com",
      apiUrl: "https://api-zkevm.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 57746
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvmCardona.js
var polygonZkEvmCardona = defineChain({
  id: 2442,
  name: "Polygon zkEVM Cardona",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.cardona.zkevm-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://cardona-zkevm.polygonscan.com",
      apiUrl: "https://cardona-zkevm.polygonscan.com/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 114091
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polygonZkEvmTestnet.js
var polygonZkEvmTestnet = defineChain({
  id: 1442,
  name: "Polygon zkEVM Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.public.zkevm-test.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://testnet-zkevm.polygonscan.com",
      apiUrl: "https://testnet-zkevm.polygonscan.com/api"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 525686
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polynomial.js
var polynomial = defineChain({
  id: 8008,
  name: "Polynomial",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://polynomialscan.io"
    }
  },
  testnet: false,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/polynomialSepolia.js
var polynomialSepolia = defineChain({
  id: 80008,
  name: "Polynomia Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sepolia.polynomial.fi"]
    }
  },
  blockExplorers: {
    default: {
      name: "Polynomial Scan",
      url: "https://sepolia.polynomialscan.io"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/premiumBlock.js
var premiumBlockTestnet = defineChain({
  id: 23023,
  name: "PremiumBlock Testnet",
  nativeCurrency: { name: "Premium Block", symbol: "PBLK", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.premiumblock.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "PremiumBlocks Explorer",
      url: "https://scan.premiumblock.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/pulsechain.js
var pulsechain = defineChain({
  id: 369,
  name: "PulseChain",
  nativeCurrency: { name: "Pulse", symbol: "PLS", decimals: 18 },
  testnet: false,
  rpcUrls: {
    default: {
      http: ["https://rpc.pulsechain.com"],
      webSocket: ["wss://ws.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.pulsechain.com",
      apiUrl: "https://api.scan.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pulsechainV4.js
var pulsechainV4 = defineChain({
  id: 943,
  name: "PulseChain V4",
  testnet: true,
  nativeCurrency: { name: "V4 Pulse", symbol: "v4PLS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.v4.testnet.pulsechain.com"],
      webSocket: ["wss://ws.v4.testnet.pulsechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PulseScan",
      url: "https://scan.v4.testnet.pulsechain.com",
      apiUrl: "https://scan.v4.testnet.pulsechain.com/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});

// node_modules/viem/_esm/chains/definitions/pumpfiTestnet.js
var pumpfiTestnet = defineChain({
  id: 490092,
  name: "Pumpfi Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "PMPT",
    symbol: "PMPT"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc1testnet.pumpfi.me"]
    }
  },
  blockExplorers: {
    default: {
      name: "Pumpfi Testnet Scan",
      url: "https://testnetscan.pumpfi.me"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/pyrope.js
var sourceId44 = 11155111;
var pyrope = defineChain({
  ...chainConfig2,
  name: "Pyrope Testnet",
  testnet: true,
  id: 695569,
  sourceId: sourceId44,
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.pyropechain.com"],
      webSocket: ["wss://rpc.pyropechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://pyrope.blockscout.com"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l1StandardBridge: {
      [sourceId44]: {
        address: "0xC24932c31D9621aE9e792576152B7ef010cFC2F8"
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ql1.js
var ql1 = defineChain({
  id: 766,
  name: "QL1",
  nativeCurrency: {
    decimals: 18,
    name: "QOM",
    symbol: "QOM"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.qom.one"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ql1 Explorer",
      url: "https://scan.qom.one"
    }
  },
  contracts: {
    multicall3: {
      address: "0x7A52370716ea730585884F5BDB0f6E60C39b8C64"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/qMainnet.js
var qMainnet = defineChain({
  id: 35441,
  name: "Q Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.q.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Mainnet Explorer",
      url: "https://explorer.q.org",
      apiUrl: "https://explorer.q.org/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/qTestnet.js
var qTestnet = defineChain({
  id: 35443,
  name: "Q Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Q",
    symbol: "Q"
  },
  rpcUrls: {
    default: { http: ["https://rpc.qtestnet.org"] }
  },
  blockExplorers: {
    default: {
      name: "Q Testnet Explorer",
      url: "https://explorer.qtestnet.org",
      apiUrl: "https://explorer.qtestnet.org/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/real.js
var real = defineChain({
  id: 111188,
  name: "re.al",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.realforreal.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "re.al Explorer",
      url: "https://explorer.re.al",
      apiUrl: "https://explorer.re.al/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 695
    }
  }
});

// node_modules/viem/_esm/chains/definitions/redbellyMainnet.js
var redbellyMainnet = defineChain({
  id: 151,
  name: "Redbelly Network Mainnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.mainnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/mainnet/evm/151/etherscan/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/redbellyTestnet.js
var redbellyTestnet = defineChain({
  id: 153,
  name: "Redbelly Network Testnet",
  nativeCurrency: {
    name: "Redbelly Native Coin",
    symbol: "RBNT",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://governors.testnet.redbelly.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Routescan",
      url: "https://redbelly.testnet.routescan.io",
      apiUrl: "https://api.routescan.io/v2/network/testnet/evm/153_2/etherscan/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/redstone.js
var sourceId45 = 1;
var redstone = defineChain({
  ...chainConfig2,
  name: "Redstone",
  id: 690,
  sourceId: sourceId45,
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.redstonechain.com"],
      webSocket: ["wss://rpc.redstonechain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.redstone.xyz"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId45]: {
        address: "0xC7bCb0e8839a28A1cFadd1CF716de9016CdA51ae",
        blockCreated: 19578329
      }
    },
    l2OutputOracle: {
      [sourceId45]: {
        address: "0xa426A052f657AEEefc298b3B5c35a470e4739d69",
        blockCreated: 19578337
      }
    },
    l1StandardBridge: {
      [sourceId45]: {
        address: "0xc473ca7E02af24c129c2eEf51F2aDf0411c1Df69",
        blockCreated: 19578331
      }
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rei.js
var rei = defineChain({
  id: 47805,
  name: "REI Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "REI",
    symbol: "REI"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rei.network"],
      webSocket: ["wss://rpc.rei.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "REI Scan",
      url: "https://scan.rei.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/reyaNetwork.js
var reyaNetwork = defineChain({
  id: 1729,
  name: "Reya Network",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rpc.reya.network"],
      webSocket: ["wss://ws.reya.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reya Network Explorer",
      url: "https://explorer.reya.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/reddioSepolia.js
var reddioSepolia = defineChain({
  id: 50341,
  name: "Reddio Sepolia",
  nativeCurrency: { name: "Reddio", symbol: "RED", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://reddio-dev.reddio.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Reddioscan",
      url: "https://reddio-devnet.l2scan.co",
      apiUrl: "https://reddio-devnet.l2scan.co/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rivalz.js
var rivalz = defineChain({
  id: 753,
  name: "Rivalz",
  nativeCurrency: { decimals: 18, name: "Ether", symbol: "ETH" },
  rpcUrls: {
    default: {
      http: ["https://rivalz.calderachain.xyz/http"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rivalz Caldera Explorer",
      url: "https://rivalz.calderaexplorer.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/rollux.js
var rollux = defineChain({
  id: 570,
  name: "Rollux Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.rollux.com"],
      webSocket: ["wss://rpc.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxExplorer",
      url: "https://explorer.rollux.com",
      apiUrl: "https://explorer.rollux.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 119222
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rolluxTestnet.js
var rolluxTestnet = defineChain({
  id: 57e3,
  name: "Rollux Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc-tanenbaum.rollux.com/"],
      webSocket: ["wss://rpc-tanenbaum.rollux.com/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "RolluxTestnetExplorer",
      url: "https://rollux.tanenbaum.io",
      apiUrl: "https://rollux.tanenbaum.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1813675
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ronin.js
var ronin = defineChain({
  id: 2020,
  name: "Ronin",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ronin Explorer",
      url: "https://app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 26023535
    }
  }
});

// node_modules/viem/_esm/chains/definitions/root.js
var root = defineChain({
  id: 7668,
  name: "The Root Network",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://root.rootnet.live/archive"],
      webSocket: ["wss://root.rootnet.live/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 9218338
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rootPorcini.js
var rootPorcini = defineChain({
  id: 7672,
  name: "The Root Network - Porcini",
  nativeCurrency: {
    decimals: 18,
    name: "XRP",
    symbol: "XRP"
  },
  rpcUrls: {
    default: {
      http: ["https://porcini.rootnet.app/archive"],
      webSocket: ["wss://porcini.rootnet.app/archive/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Rootscan",
      url: "https://porcini.rootscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xc9C2E2429AeC354916c476B30d729deDdC94988d",
      blockCreated: 10555692
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rootstock.js
var rootstock = defineChain({
  id: 30,
  name: "Rootstock Mainnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "RBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.rsk.co"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 4249540
    }
  }
});

// node_modules/viem/_esm/chains/definitions/rootstockTestnet.js
var rootstockTestnet = defineChain({
  id: 31,
  name: "Rootstock Testnet",
  network: "rootstock",
  nativeCurrency: {
    decimals: 18,
    name: "Rootstock Bitcoin",
    symbol: "tRBTC"
  },
  rpcUrls: {
    default: { http: ["https://public-node.testnet.rsk.co"] }
  },
  blockExplorers: {
    default: {
      name: "RSK Explorer",
      url: "https://explorer.testnet.rootstock.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2771150
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/rss3.js
var sourceId46 = 1;
var rss3 = defineChain({
  ...chainConfig2,
  id: 12553,
  name: "RSS3 VSL Mainnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Mainnet Scan",
      url: "https://scan.rss3.io",
      apiUrl: "https://scan.rss3.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId46]: {
        address: "0xE6f24d2C32B3109B18ed33cF08eFb490b1e09C10"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14193
    },
    portal: {
      [sourceId46]: {
        address: "0x6A12432491bbbE8d3babf75F759766774C778Db4",
        blockCreated: 19387057
      }
    },
    l1StandardBridge: {
      [sourceId46]: {
        address: "0x4cbab69108Aa72151EDa5A3c164eA86845f18438"
      }
    }
  },
  sourceId: sourceId46
});

// node_modules/viem/_esm/chains/definitions/rss3Sepolia.js
var sourceId47 = 11155111;
var rss3Sepolia = defineChain({
  ...chainConfig2,
  id: 2331,
  name: "RSS3 VSL Sepolia Testnet",
  nativeCurrency: { name: "RSS3", symbol: "RSS3", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.rss3.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "RSS3 VSL Sepolia Testnet Scan",
      url: "https://scan.testnet.rss3.io",
      apiUrl: "https://scan.testnet.rss3.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId47]: {
        address: "0xDb5c46C3Eaa6Ed6aE8b2379785DF7dd029C0dC81"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 55697
    },
    portal: {
      [sourceId47]: {
        address: "0xcBD77E8E1E7F06B25baDe67142cdE82652Da7b57",
        blockCreated: 5345035
      }
    },
    l1StandardBridge: {
      [sourceId47]: {
        address: "0xdDD29bb63B0839FB1cE0eE439Ff027738595D07B"
      }
    }
  },
  testnet: true,
  sourceId: sourceId47
});

// node_modules/viem/_esm/chains/definitions/saakuru.js
var saakuru = defineChain({
  id: 7225878,
  name: "Saakuru Mainnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.saakuru.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saakuru Explorer",
      url: "https://explorer.saakuru.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/saga.js
var saga = defineChain({
  id: 5464,
  name: "Saga",
  network: "saga",
  nativeCurrency: {
    decimals: 18,
    name: "gas",
    symbol: "GAS"
  },
  rpcUrls: {
    default: { http: ["https://sagaevm.jsonrpc.sagarpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Saga Explorer",
      url: "https://sagaevm.sagaexplorer.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864DDc9B50B9A0dF676d826c9B9EDe9F8913a160",
      blockCreated: 467530
    }
  }
});

// node_modules/viem/_esm/chains/definitions/saigon.js
var saigon = defineChain({
  id: 2021,
  name: "Saigon Testnet",
  nativeCurrency: { name: "RON", symbol: "RON", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://saigon-testnet.roninchain.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Saigon Explorer",
      url: "https://saigon-app.roninchain.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 18736871
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sanko.js
var sanko = defineChain({
  id: 1996,
  name: "Sanko",
  nativeCurrency: { name: "DMT", symbol: "DMT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.sanko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sanko Explorer",
      url: "https://explorer.sanko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 37
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sapphire.js
var sapphire = defineChain({
  id: 23294,
  name: "Oasis Sapphire",
  network: "sapphire",
  nativeCurrency: { name: "Sapphire Rose", symbol: "ROSE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sapphire.oasis.io"],
      webSocket: ["wss://sapphire.oasis.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/mainnet/sapphire"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 734531
    }
  }
});

// node_modules/viem/_esm/chains/definitions/sapphireTestnet.js
var sapphireTestnet = defineChain({
  id: 23295,
  name: "Oasis Sapphire Testnet",
  network: "sapphire-testnet",
  nativeCurrency: { name: "Sapphire Test Rose", symbol: "TEST", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.sapphire.oasis.dev"],
      webSocket: ["wss://testnet.sapphire.oasis.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Oasis Explorer",
      url: "https://explorer.oasis.io/testnet/sapphire"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/satoshivm.js
var satoshiVM = defineChain({
  id: 3109,
  name: "SatoshiVM Alpha Mainnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://alpha-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://svmscan.io",
      apiUrl: "https://svmscan.io/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/satoshivmTestnet.js
var satoshiVMTestnet = defineChain({
  id: 3110,
  name: "SatoshiVM Testnet",
  nativeCurrency: {
    name: "BTC",
    symbol: "BTC",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://test-rpc-node-http.svmscan.io"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://testnet.svmscan.io",
      apiUrl: "https://testnet.svmscan.io/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/scroll.js
var scroll = defineChain({
  id: 534352,
  name: "Scroll",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.scroll.io"],
      webSocket: ["wss://wss-rpc.scroll.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://scrollscan.com",
      apiUrl: "https://api.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/scrollSepolia.js
var scrollSepolia = defineChain({
  id: 534351,
  name: "Scroll Sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia-rpc.scroll.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Scrollscan",
      url: "https://sepolia.scrollscan.com",
      apiUrl: "https://api-sepolia.scrollscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 9473
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sei.js
var sei = defineChain({
  id: 1329,
  name: "Sei Network",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc.sei-apis.com/"],
      webSocket: ["wss://evm-ws.sei-apis.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com",
      apiUrl: "https://seitrace.com/pacific-1/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/seiDevnet.js
var seiDevnet = defineChain({
  id: 713715,
  name: "Sei Devnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-arctic-1.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/seismicDevnet.js
var seismicDevnet = defineChain({
  id: 5124,
  name: "Seismic Devnet",
  nativeCurrency: { name: "Seismic Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://node-2.seismicdev.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seismic Devnet Explorer",
      url: "https://explorer-2.seismicdev.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/seiTestnet.js
var seiTestnet = defineChain({
  id: 1328,
  name: "Sei Testnet",
  nativeCurrency: { name: "Sei", symbol: "SEI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evm-rpc-testnet.sei-apis.com"],
      webSocket: ["wss://evm-ws-testnet.sei-apis.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Seitrace",
      url: "https://seitrace.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sepolia.js
var sepolia = defineChain({
  id: 11155111,
  name: "Sepolia",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.drpc.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia.etherscan.io",
      apiUrl: "https://api-sepolia.etherscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 751532
    },
    ensRegistry: { address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e" },
    ensUniversalResolver: {
      address: "0xc8Af999e38273D658BE1b921b88A9Ddf005769cC",
      blockCreated: 5317080
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shape.js
var sourceId48 = 1;
var shape = defineChain({
  ...chainConfig2,
  id: 360,
  name: "Shape",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "shapescan",
      url: "https://shapescan.xyz",
      apiUrl: "https://shapescan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId48]: {
        address: "0x6Ef8c69CfE4635d866e3E02732068022c06e724D",
        blockCreated: 20369940
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    },
    portal: {
      [sourceId48]: {
        address: "0xEB06fFa16011B5628BaB98E29776361c83741dd3",
        blockCreated: 20369933
      }
    },
    l1StandardBridge: {
      [sourceId48]: {
        address: "0x62Edd5f4930Ea92dCa3fB81689bDD9b9d076b57B",
        blockCreated: 20369935
      }
    }
  },
  sourceId: sourceId48
});

// node_modules/viem/_esm/chains/definitions/shapeSepolia.js
var sourceId49 = 11155111;
var shapeSepolia = defineChain({
  ...chainConfig2,
  id: 11011,
  name: "Shape Sepolia Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.shape.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer-sepolia.shape.network/",
      apiUrl: "https://explorer-sepolia.shape.network/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1
    }
  },
  testnet: true,
  sourceId: sourceId49
});

// node_modules/viem/_esm/chains/definitions/shardeum.js
var shardeum = defineChain({
  id: 8118,
  name: "Shardeum",
  nativeCurrency: { name: "Shardeum", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer.shardeum.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/shardeumSphinx.js
var shardeumSphinx = defineChain({
  id: 8082,
  name: "Shardeum Sphinx",
  nativeCurrency: { name: "SHARDEUM", symbol: "SHM", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sphinx.shardeum.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shardeum Explorer",
      url: "https://explorer-sphinx.shardeum.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shibarium.js
var shibarium = defineChain({
  id: 109,
  name: "Shibarium",
  network: "shibarium",
  nativeCurrency: { name: "Bone", symbol: "BONE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.shibrpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://shibariumscan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x864Bf681ADD6052395188A89101A1B37d3B4C961",
      blockCreated: 265900
    }
  }
});

// node_modules/viem/_esm/chains/definitions/shibariumTestnet.js
var shibariumTestnet = defineChain({
  id: 157,
  name: "Puppynet Shibarium",
  nativeCurrency: {
    decimals: 18,
    name: "Bone",
    symbol: "BONE"
  },
  rpcUrls: {
    default: { http: ["https://puppynet.shibrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://puppyscan.shib.io",
      apiUrl: "https://puppyscan.shib.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xA4029b74FBA366c926eDFA7Dd10B21C621170a4c",
      blockCreated: 3035769
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/shiden.js
var shiden = defineChain({
  id: 336,
  name: "Shiden",
  nativeCurrency: {
    decimals: 18,
    name: "SDN",
    symbol: "SDN"
  },
  rpcUrls: {
    default: {
      http: ["https://shiden.public.blastapi.io"],
      webSocket: ["wss://shiden-rpc.dwellir.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shiden Scan",
      url: "https://shiden.subscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/shimmer.js
var shimmer = defineChain({
  id: 148,
  name: "Shimmer",
  network: "shimmer",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.shimmer.network",
      apiUrl: "https://explorer.evm.shimmer.network/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/shimmerTestnet.js
var shimmerTestnet = defineChain({
  id: 1073,
  name: "Shimmer Testnet",
  network: "shimmer-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Shimmer",
    symbol: "SMR"
  },
  rpcUrls: {
    default: {
      http: ["https://json-rpc.evm.testnet.shimmer.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Shimmer Network Explorer",
      url: "https://explorer.evm.testnet.shimmer.network",
      apiUrl: "https://explorer.evm.testnet.shimmer.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sidra.js
var sidraChain = defineChain({
  id: 97453,
  name: "Sidra Chain",
  nativeCurrency: {
    decimals: 18,
    name: "Sidra Digital Asset",
    symbol: "SDA"
  },
  rpcUrls: {
    default: {
      http: ["https://node.sidrachain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sidra Chain Explorer",
      url: "https://ledger.sidrachain.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/silicon.js
var silicon = defineChain({
  id: 2355,
  name: "Silicon zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc.silicon.network",
        "https://silicon-mainnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconScope",
      url: "https://scope.silicon.network"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/siliconSepolia.js
var siliconSepolia = defineChain({
  id: 1722641160,
  name: "Silicon Sepolia zkEVM",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://rpc-sepolia.silicon.network",
        "https://silicon-testnet.nodeinfra.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SiliconSepoliaScope",
      url: "https://scope-sepolia.silicon.network"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sixProtocol.js
var sixProtocol = defineChain({
  id: 98,
  name: "Six Protocol",
  nativeCurrency: {
    decimals: 18,
    name: "SIX",
    symbol: "SIX"
  },
  rpcUrls: {
    default: {
      http: ["https://sixnet-rpc-evm.sixprotocol.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Six Protocol Scan",
      url: "https://sixscan.io/sixnet"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/skale/brawl.js
var skaleBlockBrawlers = defineChain({
  id: 391845894,
  name: "SKALE | Block Brawlers",
  nativeCurrency: { name: "BRAWL", symbol: "BRAWL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/frayed-decent-antares"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/frayed-decent-antares"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://frayed-decent-antares.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/calypso.js
var skaleCalypso = defineChain({
  id: 1564830818,
  name: "SKALE Calypso Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/honorable-steel-rasalhague"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/honorable-steel-rasalhague"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://honorable-steel-rasalhague.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3107626
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/calypsoTestnet.js
var skaleCalypsoTestnet = defineChain({
  id: 974399131,
  name: "SKALE Calypso Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/giant-half-dual-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/giant-half-dual-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://giant-half-dual-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 103220
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/cryptoBlades.js
var skaleCryptoBlades = defineChain({
  id: 1026062157,
  name: "SKALE | CryptoBlades",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/affectionate-immediate-pollux"],
      webSocket: [
        "wss://mainnet.skalenodes.com/v1/ws/affectionate-immediate-pollux"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://affectionate-immediate-pollux.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/cryptoColosseum.js
var skaleCryptoColosseum = defineChain({
  id: 1032942172,
  name: "SKALE | Crypto Colosseum",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/haunting-devoted-deneb"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/haunting-devoted-deneb"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://haunting-devoted-deneb.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/europa.js
var skaleEuropa = defineChain({
  id: 2046399126,
  name: "SKALE Europa Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/elated-tan-skat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/elated-tan-skat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://elated-tan-skat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 3113495
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/europaTestnet.js
var skaleEuropaTestnet = defineChain({
  id: 1444673419,
  name: "SKALE Europa Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/juicy-low-small-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/juicy-low-small-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://juicy-low-small-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 110858
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/exorde.js
var skaleExorde = defineChain({
  id: 2139927552,
  name: "Exorde Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/light-vast-diphda"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/light-vast-diphda"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://light-vast-diphda.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/humanProtocol.js
var skaleHumanProtocol = defineChain({
  id: 1273227453,
  name: "SKALE | Human Protocol",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/wan-red-ain"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/wan-red-ain"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://wan-red-ain.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/nebula.js
var skaleNebula = defineChain({
  id: 1482601649,
  name: "SKALE Nebula Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/green-giddy-denebola"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/green-giddy-denebola"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://green-giddy-denebola.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2372986
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/nebulaTestnet.js
var skaleNebulaTestnet = defineChain({
  id: 37084624,
  name: "SKALE Nebula Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/lanky-ill-funny-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/lanky-ill-funny-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://lanky-ill-funny-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 105141
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/skale/razor.js
var skaleRazor = defineChain({
  id: 278611351,
  name: "SKALE | Razor Network",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/turbulent-unique-scheat"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/turbulent-unique-scheat"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://turbulent-unique-scheat.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {}
});

// node_modules/viem/_esm/chains/definitions/skale/titan.js
var skaleTitan = defineChain({
  id: 1350216234,
  name: "SKALE Titan Hub",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.skalenodes.com/v1/parallel-stormy-spica"],
      webSocket: ["wss://mainnet.skalenodes.com/v1/ws/parallel-stormy-spica"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://parallel-stormy-spica.explorer.mainnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2076458
    }
  }
});

// node_modules/viem/_esm/chains/definitions/skale/titanTestnet.js
var skaleTitanTestnet = defineChain({
  id: 1020352220,
  name: "SKALE Titan Testnet",
  nativeCurrency: { name: "sFUEL", symbol: "sFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.skalenodes.com/v1/aware-fake-trim-testnet"],
      webSocket: ["wss://testnet.skalenodes.com/v1/ws/aware-fake-trim-testnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "SKALE Explorer",
      url: "https://aware-fake-trim-testnet.explorer.testnet.skalenodes.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 104072
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sketchpad.js
var sketchpad = defineChain({
  id: 984123,
  name: "Forma Sketchpad",
  network: "sketchpad",
  nativeCurrency: {
    symbol: "TIA",
    name: "TIA",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sketchpad-1.forma.art"],
      webSocket: ["wss://ws.sketchpad-1.forma.art"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sketchpad Explorer",
      url: "https://explorer.sketchpad-1.forma.art"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/snax.js
var sourceId50 = 1;
var snax = defineChain({
  ...chainConfig2,
  id: 2192,
  network: "snaxchain-mainnet",
  name: "SnaxChain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://explorer.snaxchain.io",
      apiUrl: "https://explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId50]: {
        address: "0x472562Fcf26D6b2793f8E0b0fB660ba0E5e08A46"
      }
    },
    l2OutputOracle: {
      [sourceId50]: {
        address: "0x2172e492Fc807F5d5645D0E3543f139ECF539294"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId50]: {
        address: "0x79f446D024d74D0Bb6E699C131c703463c5D65E9"
      }
    },
    l1StandardBridge: {
      [sourceId50]: {
        address: "0x6534Bdb6b5c060d3e6aa833433333135eFE8E0aA"
      }
    }
  },
  sourceId: sourceId50
});

// node_modules/viem/_esm/chains/definitions/snaxTestnet.js
var sourceId51 = 11155111;
var snaxTestnet = defineChain({
  ...chainConfig2,
  id: 13001,
  network: "snaxchain-testnet",
  name: "SnaxChain Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet.snaxchain.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Snax Explorer",
      url: "https://testnet-explorer.snaxchain.io",
      apiUrl: "https://testnet-explorer.snaxchain.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId51]: {
        address: "0x206a75d89d45F146C54020F132FF93bEDD09f55E"
      }
    },
    l2OutputOracle: {
      [sourceId51]: {
        address: "0x60e3A368a4cdCEf85ffB964e372726F56A46221e"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11"
    },
    portal: {
      [sourceId51]: {
        address: "0xb5afdd0E8dDF081Ef90e8A3e0c7b5798e66E954E"
      }
    },
    l1StandardBridge: {
      [sourceId51]: {
        address: "0xbd37E1a59D4C00C9A46F75018dffd84061bC5f74"
      }
    }
  },
  testnet: true,
  sourceId: sourceId51
});

// node_modules/viem/_esm/chains/definitions/somniaTestnet.js
var somniaTestnet = defineChain({
  id: 50312,
  name: "Somnia Testnet",
  nativeCurrency: { name: "STT", symbol: "STT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dream-rpc.somnia.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Somnia Testnet Explorer",
      url: "https://somnia-testnet.socialscan.io",
      apiUrl: "https://shannon-explorer.somnia.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/soneium.js
var sourceId52 = 1;
var soneium = defineChain({
  ...chainConfig2,
  id: 1868,
  name: "Soneium Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium.blockscout.com",
      apiUrl: "https://soneium.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId52]: {
        address: "0x512a3d2c7a43bd9261d2b8e8c9c70d4bd4d503c0"
      }
    },
    l2OutputOracle: {
      [sourceId52]: {
        address: "0x0000000000000000000000000000000000000000"
      }
    },
    portal: {
      [sourceId52]: {
        address: "0x88e529a6ccd302c948689cd5156c83d4614fae92",
        blockCreated: 7061266
      }
    },
    l1StandardBridge: {
      [sourceId52]: {
        address: "0xeb9bf100225c214efc3e7c651ebbadcf85177607",
        blockCreated: 7061266
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  sourceId: sourceId52
});

// node_modules/viem/_esm/chains/definitions/soneiumMinato.js
var sourceId53 = 11155111;
var soneiumMinato = defineChain({
  ...chainConfig2,
  id: 1946,
  name: "Soneium Minato Testnet",
  nativeCurrency: { name: "Sepolia Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.minato.soneium.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://soneium-minato.blockscout.com",
      apiUrl: "https://soneium-minato.blockscout.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId53]: {
        address: "0xB3Ad2c38E6e0640d7ce6aA952AB3A60E81bf7a01"
      }
    },
    l2OutputOracle: {
      [sourceId53]: {
        address: "0x710e5286C746eC38beeB7538d0146f60D27be343"
      }
    },
    portal: {
      [sourceId53]: {
        address: "0x65ea1489741A5D72fFdD8e6485B216bBdcC15Af3",
        blockCreated: 6466136
      }
    },
    l1StandardBridge: {
      [sourceId53]: {
        address: "0x5f5a404A5edabcDD80DB05E8e54A78c9EBF000C2",
        blockCreated: 6466136
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  },
  testnet: true,
  sourceId: sourceId53
});

// node_modules/viem/_esm/chains/definitions/sonic.js
var sonic = defineChain({
  id: 146,
  name: "Sonic",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Explorer",
      url: "https://sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 60
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sonicTestnet.js
var sonicTestnet = defineChain({
  id: 64165,
  name: "Sonic Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Testnet Explorer",
      url: "https://testnet.soniclabs.com/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sonicBlazeTestnet.js
var sonicBlazeTestnet = defineChain({
  id: 57054,
  name: "Sonic Blaze Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sonic",
    symbol: "S"
  },
  rpcUrls: {
    default: { http: ["https://rpc.blaze.soniclabs.com"] }
  },
  blockExplorers: {
    default: {
      name: "Sonic Blaze Testnet Explorer",
      url: "https://testnet.sonicscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1100
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/songbird.js
var songbird = defineChain({
  id: 19,
  name: "Songbird Canary-Network",
  nativeCurrency: {
    decimals: 18,
    name: "Songbird",
    symbol: "SGB"
  },
  rpcUrls: {
    default: { http: ["https://songbird-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Songbird Explorer",
      url: "https://songbird-explorer.flare.network",
      apiUrl: "https://songbird-explorer.flare.network/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 13382504
    }
  }
});

// node_modules/viem/_esm/chains/definitions/songbirdTestnet.js
var songbirdTestnet = defineChain({
  id: 16,
  name: "Songbird Testnet Coston",
  nativeCurrency: {
    decimals: 18,
    name: "Coston Flare",
    symbol: "CFLR"
  },
  rpcUrls: {
    default: { http: ["https://coston-api.flare.network/ext/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "Coston Explorer",
      url: "https://coston-explorer.flare.network",
      apiUrl: "https://coston-explorer.flare.network/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/sophon.js
var sophon = defineChain({
  ...chainConfig,
  id: 50104,
  name: "Sophon",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.sophon.xyz"],
      webSocket: ["wss://rpc.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x5f4867441d2416cA88B1b3fd38f21811680CD2C8",
      blockCreated: 116
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/sophonTestnet.js
var sophonTestnet = defineChain({
  ...chainConfig,
  id: 531050104,
  name: "Sophon Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Sophon",
    symbol: "SOPH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.sophon.xyz"],
      webSocket: ["wss://rpc.testnet.sophon.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Sophon Block Explorer",
      url: "https://explorer.testnet.sophon.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0x83c04d112adedA2C6D9037bb6ecb42E7f0b108Af",
      blockCreated: 15642
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/spicy.js
var spicy = defineChain({
  id: 88882,
  name: "Chiliz Spicy Testnet",
  network: "chiliz-spicy-Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "CHZ",
    symbol: "CHZ"
  },
  rpcUrls: {
    default: {
      http: [
        "https://spicy-rpc.chiliz.com",
        "https://chiliz-spicy-rpc.publicnode.com"
      ],
      webSocket: [
        "wss://spicy-rpc-ws.chiliz.com",
        "wss://chiliz-spicy-rpc.publicnode.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Chiliz Explorer",
      url: "http://spicy-explorer.chiliz.com",
      apiUrl: "http://spicy-explorer.chiliz.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/statusNetworkSepolia.js
var statusSepolia = defineChain({
  ...chainConfig4,
  id: 1660990954,
  name: "Status Network Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://public.sepolia.rpc.status.network"],
      webSocket: ["wss://public.sepolia.rpc.status.network/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://sepoliascan.status.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1578364
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/step.js
var step = defineChain({
  id: 1234,
  name: "Step Network",
  nativeCurrency: { name: "FITFI", symbol: "FITFI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.step.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Step Scan",
      url: "https://stepscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/story.js
var story = defineChain({
  id: 1514,
  name: "Story",
  nativeCurrency: {
    decimals: 18,
    name: "IP Token",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 340998
    },
    ensRegistry: {
      address: "0x5dc881dda4e4a8d312be3544ad13118d1a04cb17",
      blockCreated: 648924
    },
    ensUniversalResolver: {
      address: "0xddfb18888a9466688235887dec2a10c4f5effee9",
      blockCreated: 649114
    }
  },
  rpcUrls: {
    default: { http: ["https://mainnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story explorer",
      url: "https://storyscan.xyz",
      apiUrl: "https://storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/storyAeneid.js
var storyAeneid = defineChain({
  id: 1315,
  name: "Story Aeneid",
  network: "story-aeneid",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 1792
    },
    ensRegistry: {
      address: "0x5dC881dDA4e4a8d312be3544AD13118D1a04Cb17",
      blockCreated: 1322033
    },
    ensUniversalResolver: {
      address: "0x6D3B3F99177FB2A5de7F9E928a9BD807bF7b5BAD",
      blockCreated: 1322097
    }
  },
  rpcUrls: {
    default: { http: ["https://aeneid.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Aeneid Explorer",
      url: "https://aeneid.storyscan.xyz",
      apiUrl: "https://aeneid.storyscan.xyz/api/v2"
    }
  },
  ensTlds: [".ip"],
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/storyOdyssey.js
var storyOdyssey = defineChain({
  id: 1516,
  name: "Story Odyssey",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://rpc.odyssey.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Odyssey Explorer",
      url: "https://odyssey.storyscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/storyTestnet.js
var storyTestnet = defineChain({
  id: 1513,
  name: "Story Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "IP",
    symbol: "IP"
  },
  rpcUrls: {
    default: { http: ["https://testnet.storyrpc.io"] }
  },
  blockExplorers: {
    default: {
      name: "Story Testnet Explorer",
      url: "https://testnet.storyscan.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/stratis.js
var stratis = defineChain({
  id: 105105,
  name: "Stratis Mainnet",
  network: "stratis",
  nativeCurrency: {
    name: "Stratis",
    symbol: "STRAX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.stratisevm.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Stratis Explorer",
      url: "https://explorer.stratisevm.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/superlumio.js
var superlumio = defineChain({
  id: 8866,
  name: "SuperLumio",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.lumio.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Lumio explorer",
      url: "https://explorer.lumio.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/superposition.js
var superposition = defineChain({
  id: 55244,
  name: "Superposition",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc.superposition.so"] }
  },
  blockExplorers: {
    default: {
      name: "Superposition Explorer",
      url: "https://explorer.superposition.so"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 39
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/superseed.js
var sourceId54 = 1;
var superseed = defineChain({
  ...chainConfig2,
  id: 5330,
  name: "Superseed",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Explorer",
      url: "https://explorer.superseed.xyz",
      apiUrl: "https://explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    disputeGameFactory: {
      [sourceId54]: {
        address: "0x8b097CF1f9BbD9cbFD0DD561858a1FCbC8857Be0",
        blockCreated: 20737481
      }
    },
    l2OutputOracle: {
      [sourceId54]: {
        address: "0x693A0F8854F458D282DE3C5b69E8eE5EEE8aA949",
        blockCreated: 20737481
      }
    },
    portal: {
      [sourceId54]: {
        address: "0x2c2150aa5c75A24fB93d4fD2F2a895D618054f07",
        blockCreated: 20737481
      }
    },
    l1StandardBridge: {
      [sourceId54]: {
        address: "0x8b0576E39F1233679109F9b40cFcC2a7E0901Ede",
        blockCreated: 20737481
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    }
  },
  sourceId: sourceId54
});

// node_modules/viem/_esm/chains/definitions/superseedSepolia.js
var sourceId55 = 11155111;
var superseedSepolia = defineChain({
  ...chainConfig2,
  id: 53302,
  name: "Superseed Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.superseed.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Superseed Sepolia Explorer",
      url: "https://sepolia-explorer.superseed.xyz",
      apiUrl: "https://sepolia-explorer.superseed.xyz/api/v2"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    portal: {
      [sourceId55]: {
        address: "0x7A0db8C51432d2C3eb4e8f360a2EeB26FF2809fB",
        blockCreated: 5523438
      }
    },
    l1StandardBridge: {
      [sourceId55]: {
        address: "0x2B227A603fAAdB3De0ED050b63ADD232B5f2c28C",
        blockCreated: 5523442
      }
    }
  },
  testnet: true,
  sourceId: sourceId55
});

// node_modules/viem/_esm/chains/definitions/swan.js
var swan = defineChain({
  id: 254,
  name: "Swan Chain Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://mainnet-rpc.swanchain.org"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://swanscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/swanProximaTestnet.js
var swanProximaTestnet = defineChain({
  id: 20241133,
  name: "Swan Proxima Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://rpc-proxima.swanchain.io	"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://proxima-explorer.swanchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swanSaturnTestnet.js
var swanSaturnTestnet = defineChain({
  id: 2024,
  name: "Swan Saturn Testnet",
  nativeCurrency: { name: "Swan Ether", symbol: "sETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://saturn-rpc.swanchain.io"] }
  },
  blockExplorers: {
    default: {
      name: "Swan Explorer",
      url: "https://saturn-explorer.swanchain.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/swellchain.js
var swellchain = defineChain({
  ...chainConfig2,
  id: 1923,
  name: "Swellchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-mainnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swell Explorer",
      url: "https://explorer.swellnetwork.io",
      apiUrl: "https://explorer.swellnetwork.io/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/swellchainTestnet.js
var swellchainTestnet = defineChain({
  ...chainConfig2,
  id: 1924,
  name: "Swellchain Testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://swell-testnet.alt.technology"]
    }
  },
  blockExplorers: {
    default: {
      name: "Swellchain Testnet Explorer",
      url: "https://swell-testnet-explorer.alt.technology",
      apiUrl: "https://swell-testnet-explorer.alt.technology/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1
    }
  }
});

// node_modules/viem/_esm/chains/definitions/swissdlt.js
var swissdlt = defineChain({
  id: 94,
  name: "SwissDLT Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "BCTS",
    symbol: "BCTS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.swissdlt.ch"]
    }
  },
  blockExplorers: {
    default: {
      name: "SwissDLT Explorer",
      url: "https://explorer.swissdlt.ch"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/syscoin.js
var syscoin = defineChain({
  id: 57,
  name: "Syscoin Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.syscoin.org"],
      webSocket: ["wss://rpc.syscoin.org/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinExplorer",
      url: "https://explorer.syscoin.org",
      apiUrl: "https://explorer.syscoin.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 287139
    }
  }
});

// node_modules/viem/_esm/chains/definitions/syscoinTestnet.js
var syscoinTestnet = defineChain({
  id: 5700,
  name: "Syscoin Tanenbaum Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Syscoin",
    symbol: "SYS"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.tanenbaum.io"],
      webSocket: ["wss://rpc.tanenbaum.io/wss"]
    }
  },
  blockExplorers: {
    default: {
      name: "SyscoinTestnetExplorer",
      url: "https://tanenbaum.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 271288
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taiko.js
var taiko = defineChain({
  id: 167e3,
  name: "Taiko Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taiko.xyz"],
      webSocket: ["wss://ws.mainnet.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://taikoscan.io",
      apiUrl: "https://api.taikoscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcb2436774C3e191c85056d248EF4260ce5f27A9D"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taikoHekla.js
var taikoHekla = defineChain({
  id: 167009,
  name: "Taiko Hekla L2",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.hekla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taikoscan",
      url: "https://hekla.taikoscan.network"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59757
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taikoJolnir.js
var taikoJolnir = defineChain({
  id: 167007,
  name: "Taiko Jolnir (Alpha-5 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.jolnir.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.jolnir.taiko.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 732706
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/taikoKatla.js
var taikoKatla = defineChain({
  id: 167008,
  name: "Taiko Katla (Alpha-6 Testnet)",
  network: "tko-katla",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.katla.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.katla.taiko.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taikoTestnetSepolia.js
var taikoTestnetSepolia = defineChain({
  id: 167005,
  name: "Taiko (Alpha-3 Testnet)",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.test.taiko.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.test.taiko.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taraxa.js
var taraxa = defineChain({
  id: 841,
  name: "Taraxa Mainnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.mainnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.mainnet.taraxa.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/taraxaTestnet.js
var taraxaTestnet = defineChain({
  id: 842,
  name: "Taraxa Testnet",
  nativeCurrency: { name: "Tara", symbol: "TARA", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.taraxa.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Taraxa Explorer",
      url: "https://explorer.testnet.taraxa.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/telcoinTestnet.js
var telcoinTestnet = defineChain({
  id: 2017,
  name: "Telcoin Adiri Testnet",
  nativeCurrency: { name: "Telcoin", symbol: "TEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.telcoin.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "telscan",
      url: "https://telscan.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/telos.js
var telos = defineChain({
  id: 40,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan",
      url: "https://www.teloscan.io/"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 246530709
    }
  }
});

// node_modules/viem/_esm/chains/definitions/telosTestnet.js
var telosTestnet = defineChain({
  id: 41,
  name: "Telos",
  nativeCurrency: {
    decimals: 18,
    name: "Telos",
    symbol: "TLOS"
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.telos.net"] }
  },
  blockExplorers: {
    default: {
      name: "Teloscan (testnet)",
      url: "https://testnet.teloscan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tenet.js
var tenet = defineChain({
  id: 1559,
  name: "Tenet",
  network: "tenet-mainnet",
  nativeCurrency: {
    name: "TENET",
    symbol: "TENET",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.tenet.org"] }
  },
  blockExplorers: {
    default: {
      name: "TenetScan Mainnet",
      url: "https://tenetscan.io",
      apiUrl: "https://tenetscan.io/api"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ternoa.js
var ternoa = defineChain({
  id: 752025,
  name: "Ternoa",
  nativeCurrency: { name: "Capsule Coin", symbol: "CAPS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-mainnet.zkevm.ternoa.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ternoa Explorer",
      url: "https://explorer-mainnet.zkevm.ternoa.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thaiChain.js
var thaiChain = defineChain({
  id: 7,
  name: "ThaiChain",
  nativeCurrency: { name: "TCH", symbol: "TCH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.thaichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://exp.thaichain.org",
      apiUrl: "https://exp.thaichain.org/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0DaD6130e832c21719C5CE3bae93454E16A84826",
      blockCreated: 4806386
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/that.js
var that = defineChain({
  id: 8428,
  name: "THAT Mainnet",
  nativeCurrency: { name: "THAT", symbol: "THAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.thatchain.io/mainnet"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://that.blockscout.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/theta.js
var theta = defineChain({
  id: 361,
  name: "Theta Mainnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://explorer.thetatoken.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thetaTestnet.js
var thetaTestnet = defineChain({
  id: 365,
  name: "Theta Testnet",
  nativeCurrency: { name: "TFUEL", symbol: "TFUEL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth-rpc-api-testnet.thetatoken.org/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Theta Explorer",
      url: "https://testnet-explorer.thetatoken.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/thunderCore.js
var thunderCore = defineChain({
  id: 108,
  name: "ThunderCore Mainnet",
  nativeCurrency: { name: "TT", symbol: "TT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet-rpc.thundercore.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "ThunderCore Explorer",
      url: "https://explorer-mainnet.thundercore.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 0
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/thunderTestnet.js
var thunderTestnet = defineChain({
  id: 997,
  name: "5ireChain Thunder Testnet",
  nativeCurrency: { name: "5ire Token", symbol: "5IRE", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.5ire.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "5ireChain Thunder Explorer",
      url: "https://testnet.5irescan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tiktrixTestnet.js
var tiktrixTestnet = defineChain({
  id: 62092,
  name: "TikTrix Testnet",
  nativeCurrency: {
    name: "tTTX",
    symbol: "tTTX",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://tiktrix-rpc.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "TikTrix Testnet Explorer",
      url: "https://tiktrix.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tomb.js
var tomb = defineChain({
  id: 6969,
  name: "Tomb Mainnet",
  nativeCurrency: { name: "TOMB", symbol: "TOMB", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.tombchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tomb Explorer",
      url: "https://tombscout.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/treasure.js
var treasure = defineChain({
  ...chainConfig,
  id: 61166,
  name: "Treasure",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.treasure.lol"],
      webSocket: ["wss://rpc.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Block Explorer",
      url: "https://treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0x2e29fe39496a56856D8698bD43e1dF4D0CE6266a",
      blockCreated: 101
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/treasureTopaz.js
var treasureTopaz = defineChain({
  ...chainConfig,
  id: 978658,
  name: "Treasure Topaz Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "MAGIC",
    symbol: "MAGIC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.topaz.treasure.lol"],
      webSocket: ["wss://rpc.topaz.treasure.lol/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Treasure Topaz Block Explorer",
      url: "https://topaz.treasurescan.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963",
      blockCreated: 108112
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/tron.js
var tron = defineChain({
  id: 728126428,
  name: "Tron",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://tronscan.org",
      apiUrl: "https://apilist.tronscanapi.com/api"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/tronShasta.js
var tronShasta = defineChain({
  id: 2494104990,
  name: "Tron Shasta",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.shasta.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://shasta.tronscan.org"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ubiq.js
var ubiq = defineChain({
  id: 8,
  name: "Ubiq Mainnet",
  nativeCurrency: { name: "UBQ", symbol: "UBQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://pyrus2.ubiqscan.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ubiq Scan",
      url: "https://ubiqscan.io"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ultra.js
var ultra = defineChain({
  id: 19991,
  name: "Ultra EVM",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Explorer",
      url: "https://evmexplorer.ultra.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/ultraTestnet.js
var ultraTestnet = defineChain({
  id: 18881,
  name: "Ultra EVM Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ultra Token",
    symbol: "UOS"
  },
  rpcUrls: {
    default: { http: ["https://evm.test.ultra.eosusa.io"] }
  },
  blockExplorers: {
    default: {
      name: "Ultra EVM Testnet Explorer",
      url: "https://evmexplorer.testnet.ultra.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/ultron.js
var ultron = defineChain({
  id: 1231,
  name: "Ultron Mainnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-rpc.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://ulxscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/ultronTestnet.js
var ultronTestnet = defineChain({
  id: 1230,
  name: "Ultron Testnet",
  nativeCurrency: { name: "ULX", symbol: "ULX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://ultron-dev.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ultron Scan",
      url: "https://explorer.ultron-dev.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/unichain.js
var sourceId56 = 1;
var unichain = defineChain({
  ...chainConfig2,
  id: 130,
  name: "Unichain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.unichain.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://uniscan.xyz",
      apiUrl: "https://api.uniscan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId56]: {
        address: "0x2F12d621a16e2d3285929C9996f478508951dFe4"
      }
    },
    portal: {
      [sourceId56]: {
        address: "0x0bd48f6B86a26D3a217d0Fa6FfE2B491B956A7a2"
      }
    },
    l1StandardBridge: {
      [sourceId56]: {
        address: "0x81014F44b0a345033bB2b3B21C7a1A308B35fEeA"
      }
    }
  },
  sourceId: sourceId56
});

// node_modules/viem/_esm/chains/definitions/unichainSepolia.js
var sourceId57 = 11155111;
var unichainSepolia = defineChain({
  ...chainConfig2,
  id: 1301,
  name: "Unichain Sepolia",
  nativeCurrency: {
    name: "Ether",
    symbol: "ETH",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.unichain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Uniscan",
      url: "https://sepolia.uniscan.xyz",
      apiUrl: "https://api-sepolia.uniscan.xyz/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    portal: {
      [sourceId57]: {
        address: "0x0d83dab629f0e0F9d36c0Cbc89B69a489f0751bD"
      }
    },
    l1StandardBridge: {
      [sourceId57]: {
        address: "0xea58fcA6849d79EAd1f26608855c2D6407d54Ce2"
      }
    },
    disputeGameFactory: {
      [sourceId57]: {
        address: "0xeff73e5aa3B9AEC32c659Aa3E00444d20a84394b"
      }
    }
  },
  testnet: true,
  sourceId: sourceId57
});

// node_modules/viem/_esm/chains/definitions/unique.js
var unique = defineChain({
  id: 8880,
  name: "Unique Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "UNQ",
    symbol: "UNQ"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Unique Subscan",
      url: "https://unique.subscan.io/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/uniqueOpal.js
var uniqueOpal = defineChain({
  id: 8882,
  name: "Opal Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OPL",
    symbol: "OPL"
  },
  rpcUrls: {
    default: { http: ["https://rpc-opal.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Opal Subscan",
      url: "https://opal.subscan.io/"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/uniqueQuartz.js
var uniqueQuartz = defineChain({
  id: 8881,
  name: "Quartz Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "QTZ",
    symbol: "QTZ"
  },
  rpcUrls: {
    default: { http: ["https://rpc-quartz.unique.network"] }
  },
  blockExplorers: {
    default: {
      name: "Quartz Subscan",
      url: "https://quartz.subscan.io/"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/unreal.js
var unreal = defineChain({
  id: 18233,
  name: "Unreal",
  nativeCurrency: {
    name: "reETH",
    decimals: 18,
    symbol: "reETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.unreal-orbit.gelato.digital"] }
  },
  blockExplorers: {
    default: {
      name: "Unreal Explorer",
      url: "https://unreal.blockscout.com",
      apiUrl: "https://unreal.blockscout.com/api/v2"
    }
  },
  testnet: true,
  contracts: {
    multicall3: {
      address: "0x8b6B0e60D8CD84898Ea8b981065A12F876eA5677",
      blockCreated: 1745
    }
  }
});

// node_modules/viem/_esm/chains/definitions/vanar.js
var vanar = defineChain({
  id: 2040,
  name: "Vanar Mainnet",
  nativeCurrency: { name: "VANRY", symbol: "VANRY", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.vanarchain.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vanar Mainnet Explorer",
      url: "https://explorer.vanarchain.com/"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/vechain.js
var vechain = defineChain({
  id: 100009,
  name: "Vechain",
  nativeCurrency: { name: "VeChain", symbol: "VET", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.vechain.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vechain Explorer",
      url: "https://explore.vechain.org"
    },
    vechainStats: {
      name: "Vechain Stats",
      url: "https://vechainstats.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/velas.js
var velas = defineChain({
  id: 106,
  name: "Velas EVM Mainnet",
  nativeCurrency: { name: "VLX", symbol: "VLX", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmexplorer.velas.com/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Velas Explorer",
      url: "https://evmexplorer.velas.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 55883577
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/viction.js
var viction = defineChain({
  id: 88,
  name: "Viction",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://vicscan.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/victionTestnet.js
var victionTestnet = defineChain({
  id: 89,
  name: "Viction Testnet",
  nativeCurrency: { name: "Viction", symbol: "VIC", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.viction.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "VIC Scan",
      url: "https://testnet.vicscan.xyz"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 12170179
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/vision.js
var vision = defineChain({
  id: 888888,
  name: "Vision",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/visionTestnet.js
var visionTestnet = defineChain({
  id: 666666,
  name: "Vision Testnet",
  nativeCurrency: { name: "VISION", symbol: "VS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://vpioneer.infragrid.v.network/ethereum/compatible"]
    }
  },
  blockExplorers: {
    default: {
      name: "Vision Scan",
      url: "https://visionscan.org/?chain=vpioneer"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/wanchain.js
var wanchain = defineChain({
  id: 888,
  name: "Wanchain",
  nativeCurrency: { name: "WANCHAIN", symbol: "WAN", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://gwan-ssl.wandevs.org:56891",
        "https://gwan2-ssl.wandevs.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScan",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcDF6A1566e78EB4594c86Fe73Fcdc82429e97fbB",
      blockCreated: 25312390
    }
  }
});

// node_modules/viem/_esm/chains/definitions/wanchainTestnet.js
var wanchainTestnet = defineChain({
  id: 999,
  name: "Wanchain Testnet",
  nativeCurrency: { name: "WANCHAIN", symbol: "WANt", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://gwan-ssl.wandevs.org:46891"]
    }
  },
  blockExplorers: {
    default: {
      name: "WanScanTest",
      url: "https://wanscan.org"
    }
  },
  contracts: {
    multicall3: {
      address: "0x11c89bF4496c39FB80535Ffb4c92715839CC5324",
      blockCreated: 24743448
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/weavevmAlphanet.js
var weaveVMAlphanet = defineChain({
  id: 9496,
  name: "WeaveVM Alphanet",
  nativeCurrency: { name: "Testnet WeaveVM", symbol: "tWVM", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://testnet-rpc.wvm.dev"] }
  },
  blockExplorers: {
    default: {
      name: "WeaveVM Alphanet Explorer",
      url: "https://explorer.wvm.dev"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/wemix.js
var wemix = defineChain({
  id: 1111,
  name: "WEMIX",
  network: "wemix-mainnet",
  nativeCurrency: { name: "WEMIX", symbol: "WEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://explorer.wemix.com"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/wemixTestnet.js
var wemixTestnet = defineChain({
  id: 1112,
  name: "WEMIX Testnet",
  network: "wemix-testnet",
  nativeCurrency: { name: "WEMIX", symbol: "tWEMIX", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://api.test.wemix.com"] }
  },
  blockExplorers: {
    default: {
      name: "wemixExplorer",
      url: "https://testnet.wemixscan.com",
      apiUrl: "https://testnet.wemixscan.com/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/westendAssetHub.js
var westendAssetHub = defineChain({
  id: 420420421,
  name: "Westend Asset Hub",
  nativeCurrency: {
    decimals: 18,
    name: "Westies",
    symbol: "WND"
  },
  rpcUrls: {
    default: { http: ["https://westend-asset-hub-eth-rpc.polkadot.io"] }
  },
  blockExplorers: {
    default: {
      name: "subscan",
      url: "https://westend-asset-hub-eth-explorer.parity.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/whitechain.js
var whitechain = defineChain({
  testnet: false,
  name: "Whitechain",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://explorer.whitechain.io"
    }
  },
  id: 1875,
  rpcUrls: {
    default: {
      http: ["https://rpc.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 25212237
    }
  }
});

// node_modules/viem/_esm/chains/definitions/whitechainTestnet.js
var whitechainTestnet = defineChain({
  testnet: true,
  name: "Whitechain Testnet",
  blockExplorers: {
    default: {
      name: "Whitechain Explorer",
      url: "https://testnet.whitechain.io"
    }
  },
  id: 2625,
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet.whitechain.io"]
    }
  },
  nativeCurrency: {
    decimals: 18,
    name: "WhiteBIT Coin",
    symbol: "WBT"
  }
});

// node_modules/viem/_esm/chains/definitions/wmcTestnet.js
var wmcTestnet = defineChain({
  id: 42070,
  name: "WMC Testnet",
  nativeCurrency: { name: "WMTx", symbol: "WMTx", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc-testnet-base.worldmobile.net"]
    }
  },
  blockExplorers: {
    default: {
      name: "WMC Explorer",
      url: "https://explorer2-base-testnet.worldmobile.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/worldchain.js
var sourceId58 = 1;
var worldchain = defineChain({
  ...chainConfig2,
  id: 480,
  name: "World Chain",
  network: "worldchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-mainnet.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan",
      url: "https://worldscan.org",
      apiUrl: "https://api.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-mainnet.explorer.alchemy.com",
      apiUrl: "https://worldchain-mainnet.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId58]: {
        address: "0x069c4c579671f8c120b1327a73217D01Ea2EC5ea"
      }
    },
    l2OutputOracle: {
      [sourceId58]: {
        address: "0x19A6d1E9034596196295CF148509796978343c5D"
      }
    },
    portal: {
      [sourceId58]: {
        address: "0xd5ec14a83B7d95BE1E2Ac12523e2dEE12Cbeea6C"
      }
    },
    l1StandardBridge: {
      [sourceId58]: {
        address: "0x470458C91978D2d929704489Ad730DC3E3001113"
      }
    }
  },
  testnet: false,
  sourceId: sourceId58
});

// node_modules/viem/_esm/chains/definitions/worldchainSepolia.js
var sourceId59 = 11155111;
var worldchainSepolia = defineChain({
  ...chainConfig2,
  id: 4801,
  name: "World Chain Sepolia",
  network: "worldchain-sepolia",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://worldchain-sepolia.g.alchemy.com/public"] }
  },
  blockExplorers: {
    default: {
      name: "Worldscan Sepolia",
      url: "https://sepolia.worldscan.org",
      apiUrl: "https://api-sepolia.worldscan.org/api"
    },
    blockscout: {
      name: "Blockscout",
      url: "https://worldchain-sepolia.explorer.alchemy.com",
      apiUrl: "https://worldchain-sepolia.explorer.alchemy.com/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 0
    },
    disputeGameFactory: {
      [sourceId59]: {
        address: "0x8cF97Ee616C986a070F5020d973b456D0120C253"
      }
    },
    l2OutputOracle: {
      [sourceId59]: {
        address: "0xc8886f8BAb6Eaeb215aDB5f1c686BF699248300e"
      }
    },
    portal: {
      [sourceId59]: {
        address: "0xFf6EBa109271fe6d4237EeeD4bAb1dD9A77dD1A4"
      }
    },
    l1StandardBridge: {
      [sourceId59]: {
        address: "0xd7DF54b3989855eb66497301a4aAEc33Dbb3F8DE"
      }
    }
  },
  testnet: true,
  sourceId: sourceId59
});

// node_modules/viem/_esm/chains/definitions/worldLand.js
var worldLand = defineChain({
  id: 103,
  name: "WorldLand Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "WLC",
    symbol: "WLC"
  },
  rpcUrls: {
    default: {
      http: ["https://seoul.worldland.foundation"]
    }
  },
  blockExplorers: {
    default: {
      name: "WorldLand Scan",
      url: "https://scan.worldland.foundation"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xai.js
var xai = defineChain({
  id: 660279,
  name: "Xai Mainnet",
  nativeCurrency: { name: "Xai", symbol: "XAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://explorer.xai-chain.net"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 222549
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xaiTestnet.js
var xaiTestnet = defineChain({
  id: 37714555429,
  name: "Xai Testnet",
  nativeCurrency: { name: "sXai", symbol: "sXAI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://testnet-v2.xai-chain.net/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://testnet-explorer-v2.xai-chain.net"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xdc.js
var xdc = defineChain({
  id: 50,
  name: "XDC Network",
  nativeCurrency: {
    decimals: 18,
    name: "XDC",
    symbol: "XDC"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xdcrpc.com"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0x0B1795ccA8E4eC4df02346a082df54D437F8D9aF",
      blockCreated: 75884020
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xdcTestnet.js
var xdcTestnet = defineChain({
  id: 51,
  name: "Apothem Network",
  nativeCurrency: {
    decimals: 18,
    name: "TXDC",
    symbol: "TXDC"
  },
  rpcUrls: {
    default: { http: ["https://erpc.apothem.network"] }
  },
  blockExplorers: {
    default: {
      name: "XDCScan",
      url: "https://testnet.xdcscan.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 59765389
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xLayer.js
var xLayer = defineChain({
  id: 196,
  name: "X Layer Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://rpc.xlayer.tech"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer",
      apiUrl: "https://www.oklink.com/api/v5/explorer/xlayer/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 47416
    }
  }
});

// node_modules/viem/_esm/chains/definitions/xLayerTestnet.js
var xLayerTestnet = defineChain({
  id: 195,
  name: "X1 Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "OKB",
    symbol: "OKB"
  },
  rpcUrls: {
    default: { http: ["https://xlayertestrpc.okx.com"] }
  },
  blockExplorers: {
    default: {
      name: "OKLink",
      url: "https://www.oklink.com/xlayer-test"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 624344
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrOne.js
var xrOne = defineChain({
  id: 273,
  name: "XR One",
  nativeCurrency: {
    decimals: 18,
    name: "XR1",
    symbol: "XR1"
  },
  rpcUrls: {
    default: {
      http: ["https://xr1.calderachain.xyz/http"],
      webSocket: ["wss://xr1.calderachain.xyz/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr1.calderaexplorer.xyz"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/xrplevmDevnet.js
var xrplevmDevnet = defineChain({
  id: 1440002,
  name: "XRPL EVM Devnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.xrplevm.org/"]
    },
    public: {
      http: ["https://rpc.xrplevm.org/"]
    }
  },
  blockExplorers: {
    default: {
      name: "XRPLEVM Devnet Explorer",
      url: "https://explorer.xrplevm.org/"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 15237286
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrplevmTestnet.js
var xrplevmTestnet = defineChain({
  id: 1449e3,
  name: "XRPL EVM Testnet",
  nativeCurrency: {
    name: "XRP",
    symbol: "XRP",
    decimals: 18
  },
  rpcUrls: {
    default: { http: ["https://rpc.testnet.xrplevm.org"] }
  },
  blockExplorers: {
    default: {
      name: "blockscout",
      url: "https://explorer.testnet.xrplevm.org",
      apiUrl: "https://explorer.testnet.xrplevm.org/api/v2"
    }
  },
  contracts: {
    multicall3: {
      address: "0x82Cc144D7d0AD4B1c27cb41420e82b82Ad6e9B31",
      blockCreated: 492302
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/xrSepolia.js
var xrSepolia = defineChain({
  id: 2730,
  name: "XR Sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "tXR",
    symbol: "tXR"
  },
  rpcUrls: {
    default: { http: ["https://xr-sepolia-testnet.rpc.caldera.xyz/http"] }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "https://xr-sepolia-testnet.explorer.caldera.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/yooldoVerse.js
var yooldoVerse = defineChain({
  id: 50005,
  name: "Yooldo Verse",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Explorer",
      url: "https://explorer.yooldo-verse.xyz"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/yooldoVerseTestnet.js
var yooldoVerseTestnet = defineChain({
  id: 50006,
  name: "Yooldo Verse Testnet",
  nativeCurrency: { name: "OAS", symbol: "OAS", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.testnet.yooldo-verse.xyz"]
    }
  },
  blockExplorers: {
    default: {
      name: "Yooldo Verse Testnet Explorer",
      url: "https://explorer.testnet.yooldo-verse.xyz"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zenchainTestnet.js
var zenchainTestnet = defineChain({
  id: 8408,
  name: "ZenChain Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ZTC",
    symbol: "ZTC"
  },
  rpcUrls: {
    default: {
      http: ["https://zenchain-testnet.api.onfinality.io/public"],
      webSocket: ["wss://zenchain-testnet.api.onfinality.io/public-ws"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 230019
    }
  },
  blockExplorers: {
    default: {
      name: "Zentrace",
      url: "https://zentrace.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zeniq.js
var zeniq = defineChain({
  id: 383414847825,
  name: "Zeniq Mainnet",
  nativeCurrency: { name: "ZENIQ", symbol: "ZENIQ", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zeniq.network"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zeniq Explorer",
      url: "https://zeniqscan.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/0g.js
var zeroG = defineChain({
  id: 16600,
  name: "0G Newton Testnet",
  nativeCurrency: { name: "A0GI", symbol: "A0GI", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://evmrpc-testnet.0g.ai"]
    }
  },
  blockExplorers: {
    default: {
      name: "0G BlockChain Explorer",
      url: "https://chainscan-newton.0g.ai"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zeroNetwork.js
var zeroNetwork = defineChain({
  id: 543210,
  name: "Zero Network",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zerion.io/v1/zero"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zero Network Explorer",
      url: "https://explorer.zero.network"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zetachain.js
var zetachain = defineChain({
  id: 7e3,
  name: "ZetaChain",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "ZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 1632781
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://explorer.zetachain.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zetachainAthensTestnet.js
var zetachainAthensTestnet = defineChain({
  id: 7001,
  name: "ZetaChain Athens Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zeta",
    symbol: "aZETA"
  },
  rpcUrls: {
    default: {
      http: ["https://zetachain-athens-evm.blockpi.network/v1/rpc/public"]
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 2715217
    }
  },
  blockExplorers: {
    default: {
      name: "ZetaScan",
      url: "https://athens.explorer.zetachain.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zhejiang.js
var zhejiang = defineChain({
  id: 1337803,
  name: "Zhejiang",
  nativeCurrency: { name: "Zhejiang Ether", symbol: "ZhejETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://rpc.zhejiang.ethpandaops.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Beaconchain",
      url: "https://zhejiang.beaconcha.in"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zilliqa.js
var zilliqa = defineChain({
  id: 32769,
  name: "Zilliqa",
  network: "zilliqa",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.zilliqa.com"
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zilliqaTestnet.js
var zilliqaTestnet = defineChain({
  id: 33101,
  name: "Zilliqa Testnet",
  network: "zilliqa-testnet",
  nativeCurrency: { name: "Zilliqa", symbol: "ZIL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://dev-api.zilliqa.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "Ethernal",
      url: "https://evmx.testnet.zilliqa.com"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zircuit.js
var sourceId60 = 1;
var zircuit = defineChain({
  ...chainConfig2,
  id: 48900,
  name: "Zircuit Mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: [
        "https://mainnet.zircuit.com",
        "https://zircuit1-mainnet.liquify.com",
        "https://zircuit1-mainnet.p2pify.com",
        "https://zircuit-mainnet.drpc.org"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Explorer",
      url: "https://explorer.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [sourceId60]: {
        address: "0x92Ef6Af472b39F1b363da45E35530c24619245A4"
      }
    },
    portal: {
      [sourceId60]: {
        address: "0x17bfAfA932d2e23Bd9B909Fd5B4D2e2a27043fb1"
      }
    },
    l1StandardBridge: {
      [sourceId60]: {
        address: "0x386B76D9cA5F5Fb150B6BFB35CF5379B22B26dd8"
      }
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zircuitGarfieldTestnet.js
var sourceId61 = 11155111;
var zircuitGarfieldTestnet = defineChain({
  ...chainConfig2,
  id: 48898,
  name: "Zircuit Garfield Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://garfield-testnet.zircuit.com/"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Garfield Testnet Explorer",
      url: "https://explorer.garfield-testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11"
    },
    l2OutputOracle: {
      [sourceId61]: {
        address: "0xd69D3AC5CA686cCF94b258291772bc520FEAf211"
      }
    },
    portal: {
      [sourceId61]: {
        address: "0x4E21A71Ac3F7607Da5c06153A17B1DD20E702c21"
      }
    },
    l1StandardBridge: {
      [sourceId61]: {
        address: "0x87a7E2bCA9E35BA49282E832a28A6023904460D8"
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zircuitTestnet.js
var sourceId62 = 11155111;
var zircuitTestnet = defineChain({
  ...chainConfig2,
  id: 48899,
  name: "Zircuit Testnet",
  nativeCurrency: { name: "ETH", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: [
        "https://testnet.zircuit.com",
        "https://zircuit1-testnet.p2pify.com",
        "https://zircuit1-testnet.liquify.com"
      ]
    }
  },
  blockExplorers: {
    default: {
      name: "Zircuit Testnet Explorer",
      url: "https://explorer.testnet.zircuit.com"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 6040287
    },
    l2OutputOracle: {
      [sourceId62]: {
        address: "0x740C2dac453aEf7140809F80b72bf0e647af8148"
      }
    },
    portal: {
      [sourceId62]: {
        address: "0x787f1C8c5924178689E0560a43D848bF8E54b23e"
      }
    },
    l1StandardBridge: {
      [sourceId62]: {
        address: "0x0545c5fe980098C16fcD0eCB5E79753afa6d9af9"
      }
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zkFair.js
var zkFair = defineChain({
  id: 42766,
  name: "ZKFair Mainnet",
  network: "zkfair-mainnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://scan.zkfair.io",
      apiUrl: "https://scan.zkfair.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 6090959
    }
  },
  testnet: false
});

// node_modules/viem/_esm/chains/definitions/zkFairTestnet.js
var zkFairTestnet = defineChain({
  id: 43851,
  name: "ZKFair Testnet",
  network: "zkfair-testnet",
  nativeCurrency: {
    decimals: 18,
    name: "USD Coin",
    symbol: "USDC"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet-rpc.zkfair.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "zkFair Explorer",
      url: "https://testnet-scan.zkfair.io"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zkLinkNova.js
var zkLinkNova = defineChain({
  id: 810180,
  name: "zkLink Nova",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://explorer.zklink.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zkLinkNovaSepoliaTestnet.js
var zkLinkNovaSepoliaTestnet = defineChain({
  id: 810181,
  name: "zkLink Nova Sepolia Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "ETH",
    symbol: "ETH"
  },
  rpcUrls: {
    default: { http: ["https://sepolia.rpc.zklink.io"] }
  },
  blockExplorers: {
    default: {
      name: "zkLink Nova Block Explorer",
      url: "https://sepolia.explorer.zklink.io"
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zksync.js
var zksync = defineChain({
  ...chainConfig,
  id: 324,
  name: "ZKsync Era",
  network: "zksync-era",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://mainnet.era.zksync.io"],
      webSocket: ["wss://mainnet.era.zksync.io/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://era.zksync.network/",
      apiUrl: "https://api-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://explorer.zksync.io/",
      apiUrl: "https://block-explorer-api.mainnet.zksync.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 45659388
    }
  }
});

// node_modules/viem/_esm/chains/definitions/zksyncInMemoryNode.js
var zksyncInMemoryNode = defineChain({
  ...chainConfig,
  id: 260,
  name: "ZKsync InMemory Node",
  network: "zksync-in-memory-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:8011"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalCustomHyperchain.js
var zksyncLocalCustomHyperchain = defineChain({
  ...chainConfig,
  id: 272,
  name: "ZKsync CLI Local Custom Hyperchain",
  nativeCurrency: { name: "BAT", symbol: "BAT", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15200"],
      webSocket: ["ws://localhost:15201"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalHyperchain.js
var zksyncLocalHyperchain = defineChain({
  ...chainConfig,
  id: 270,
  name: "ZKsync CLI Local Hyperchain",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15100"],
      webSocket: ["ws://localhost:15101"]
    }
  },
  blockExplorers: {
    default: {
      name: "ZKsync explorer",
      url: "http://localhost:15005/",
      apiUrl: "http://localhost:15005/api"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalHyperchainL1.js
var zksyncLocalHyperchainL1 = defineChain({
  id: 9,
  name: "ZKsync CLI Local Hyperchain L1",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:15045"]
    }
  },
  blockExplorers: {
    default: {
      name: "Blockscout",
      url: "http://localhost:15001/",
      apiUrl: "http://localhost:15001/api/v2"
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncLocalNode.js
var zksyncLocalNode = defineChain({
  ...chainConfig,
  id: 270,
  name: "ZKsync CLI Local Node",
  network: "zksync-cli-local-node",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["http://localhost:3050"]
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zksyncSepoliaTestnet.js
var zksyncSepoliaTestnet = defineChain({
  ...chainConfig,
  id: 300,
  name: "ZKsync Sepolia Testnet",
  network: "zksync-sepolia-testnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://sepolia.era.zksync.dev"],
      webSocket: ["wss://sepolia.era.zksync.dev/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://sepolia-era.zksync.network/",
      apiUrl: "https://api-sepolia-era.zksync.network/api"
    },
    native: {
      name: "ZKsync Explorer",
      url: "https://sepolia.explorer.zksync.io/",
      blockExplorerApi: "https://block-explorer-api.sepolia.zksync.dev/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xF9cda624FBC7e059355ce98a31693d299FACd963"
    },
    universalSignatureVerifier: {
      address: "0xfB688330379976DA81eB64Fe4BF50d7401763B9C",
      blockCreated: 3855712
    }
  },
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zora.js
var sourceId63 = 1;
var zora = defineChain({
  ...chainConfig2,
  id: 7777777,
  name: "Zora",
  nativeCurrency: {
    decimals: 18,
    name: "Ether",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.zora.energy"],
      webSocket: ["wss://rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://explorer.zora.energy",
      apiUrl: "https://explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId63]: {
        address: "0x9E6204F750cD866b299594e2aC9eA824E2e5f95c"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 5882
    },
    portal: {
      [sourceId63]: {
        address: "0x1a0ad011913A150f69f6A19DF447A0CfD9551054"
      }
    },
    l1StandardBridge: {
      [sourceId63]: {
        address: "0x3e2Ea9B92B7E48A52296fD261dc26fd995284631"
      }
    }
  },
  sourceId: sourceId63
});

// node_modules/viem/_esm/chains/definitions/zoraSepolia.js
var sourceId64 = 11155111;
var zoraSepolia = defineChain({
  ...chainConfig2,
  id: 999999999,
  name: "Zora Sepolia",
  network: "zora-sepolia",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Sepolia",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://sepolia.rpc.zora.energy"],
      webSocket: ["wss://sepolia.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Zora Sepolia Explorer",
      url: "https://sepolia.explorer.zora.energy/",
      apiUrl: "https://sepolia.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    l2OutputOracle: {
      [sourceId64]: {
        address: "0x2615B481Bd3E5A1C0C7Ca3Da1bdc663E8615Ade9"
      }
    },
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 83160
    },
    portal: {
      [sourceId64]: {
        address: "0xeffE2C6cA9Ab797D418f0D91eA60807713f3536f"
      }
    },
    l1StandardBridge: {
      [sourceId64]: {
        address: "0x5376f1D543dcbB5BD416c56C189e4cB7399fCcCB"
      }
    }
  },
  sourceId: sourceId64,
  testnet: true
});

// node_modules/viem/_esm/chains/definitions/zoraTestnet.js
var sourceId65 = 5;
var zoraTestnet = defineChain({
  ...chainConfig2,
  id: 999,
  name: "Zora Goerli Testnet",
  nativeCurrency: {
    decimals: 18,
    name: "Zora Goerli",
    symbol: "ETH"
  },
  rpcUrls: {
    default: {
      http: ["https://testnet.rpc.zora.energy"],
      webSocket: ["wss://testnet.rpc.zora.energy"]
    }
  },
  blockExplorers: {
    default: {
      name: "Explorer",
      url: "https://testnet.explorer.zora.energy",
      apiUrl: "https://testnet.explorer.zora.energy/api"
    }
  },
  contracts: {
    ...chainConfig2.contracts,
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 189123
    },
    portal: {
      [sourceId65]: {
        address: "0xDb9F51790365e7dc196e7D072728df39Be958ACe"
      }
    }
  },
  sourceId: sourceId65,
  testnet: true
});

// node_modules/@wagmi/connectors/dist/esm/coinbaseWallet.js
coinbaseWallet.type = "coinbaseWallet";
function coinbaseWallet(parameters = {}) {
  if (parameters.version === "3" || parameters.headlessMode)
    return version3(parameters);
  return version4(parameters);
}
function version4(parameters) {
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect3;
  return createConnector((config) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    type: coinbaseWallet.type,
    async connect({ chainId, ...rest } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = (await provider.request({
          method: "eth_requestAccounts",
          params: "instantOnboarding" in rest && rest.instantOnboarding ? [{ onboarding: "instant" }] : []
        })).map((x2) => getAddress(x2));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect3) {
          disconnect3 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect3);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain2 = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain2 == null ? void 0 : chain2.id) ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account|request rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a2;
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
      provider.disconnect();
      (_a2 = provider.close) == null ? void 0 : _a2.call(provider);
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      if (!walletProvider) {
        const preference = (() => {
          var _a2;
          if (typeof parameters.preference === "string")
            return { options: parameters.preference };
          return {
            ...parameters.preference,
            options: ((_a2 = parameters.preference) == null ? void 0 : _a2.options) ?? "all"
          };
        })();
        const { createCoinbaseWalletSDK } = await import("./dist-JRCPH3HO.js");
        const sdk = createCoinbaseWalletSDK({
          ...parameters,
          appChainIds: config.chains.map((x2) => x2.id),
          preference
        });
        walletProvider = sdk.getProvider();
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b, _c2, _d;
      const chain2 = config.chains.find((chain3) => chain3.id === chainId);
      if (!chain2)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain2.id) }]
        });
        return chain2;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a2 = chain2.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b = chain2.blockExplorers) == null ? void 0 : _b.default.url] : [];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d = chain2.rpcUrls.default) == null ? void 0 : _d.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain2.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain2.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain2;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain2) {
      const chainId = Number(chain2);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
    }
  }));
}
function version3(parameters) {
  const reloadOnDisconnect = false;
  let sdk;
  let walletProvider;
  let accountsChanged;
  let chainChanged;
  let disconnect3;
  return createConnector((config) => ({
    id: "coinbaseWalletSDK",
    name: "Coinbase Wallet",
    rdns: "com.coinbase.wallet",
    type: coinbaseWallet.type,
    async connect({ chainId } = {}) {
      try {
        const provider = await this.getProvider();
        const accounts = (await provider.request({
          method: "eth_requestAccounts"
        })).map((x2) => getAddress(x2));
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect3) {
          disconnect3 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect3);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain2 = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain2 == null ? void 0 : chain2.id) ?? currentChainId;
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user closed modal|accounts received is empty|user denied account)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
      provider.disconnect();
      provider.close();
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return (await provider.request({
        method: "eth_accounts"
      })).map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      const chainId = await provider.request({
        method: "eth_chainId"
      });
      return Number(chainId);
    },
    async getProvider() {
      var _a2;
      if (!walletProvider) {
        const CoinbaseWalletSDK = await (async () => {
          const { default: SDK } = await import("./dist-AS3T67X2.js");
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        sdk = new CoinbaseWalletSDK({ ...parameters, reloadOnDisconnect });
        const walletExtensionChainId = (_a2 = sdk.walletExtension) == null ? void 0 : _a2.getChainId();
        const chain2 = config.chains.find((chain3) => parameters.chainId ? chain3.id === parameters.chainId : chain3.id === walletExtensionChainId) || config.chains[0];
        const chainId = parameters.chainId || (chain2 == null ? void 0 : chain2.id);
        const jsonRpcUrl = parameters.jsonRpcUrl || (chain2 == null ? void 0 : chain2.rpcUrls.default.http[0]);
        walletProvider = sdk.makeWeb3Provider(jsonRpcUrl, chainId);
      }
      return walletProvider;
    },
    async isAuthorized() {
      try {
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b, _c2, _d;
      const chain2 = config.chains.find((chain3) => chain3.id === chainId);
      if (!chain2)
        throw new SwitchChainError(new ChainNotConfiguredError());
      const provider = await this.getProvider();
      try {
        await provider.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chain2.id) }]
        });
        return chain2;
      } catch (error) {
        if (error.code === 4902) {
          try {
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else
              blockExplorerUrls = ((_a2 = chain2.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b = chain2.blockExplorers) == null ? void 0 : _b.default.url] : [];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d = chain2.rpcUrls.default) == null ? void 0 : _d.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain2.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain2.nativeCurrency,
              rpcUrls
            };
            await provider.request({
              method: "wallet_addEthereumChain",
              params: [addEthereumChain]
            });
            return chain2;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain2) {
      const chainId = Number(chain2);
      config.emitter.emit("change", { chainId });
    },
    async onDisconnect(_error) {
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
    }
  }));
}

// node_modules/@wagmi/connectors/dist/esm/metaMask.js
metaMask.type = "metaMask";
function metaMask(parameters = {}) {
  let sdk;
  let provider;
  let providerPromise;
  let accountsChanged;
  let chainChanged;
  let connect3;
  let displayUri;
  let disconnect3;
  return createConnector((config) => ({
    id: "metaMaskSDK",
    name: "MetaMask",
    rdns: ["io.metamask", "io.metamask.mobile"],
    type: metaMask.type,
    async setup() {
      const provider2 = await this.getProvider();
      if (provider2 == null ? void 0 : provider2.on) {
        if (!connect3) {
          connect3 = this.onConnect.bind(this);
          provider2.on("connect", connect3);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      const provider2 = await this.getProvider();
      if (!displayUri) {
        displayUri = this.onDisplayUri;
        provider2.on("display_uri", displayUri);
      }
      let accounts = [];
      if (isReconnecting2)
        accounts = await this.getAccounts().catch(() => []);
      try {
        let signResponse;
        let connectWithResponse;
        if (!(accounts == null ? void 0 : accounts.length)) {
          if (parameters.connectAndSign || parameters.connectWith) {
            if (parameters.connectAndSign)
              signResponse = await sdk.connectAndSign({
                msg: parameters.connectAndSign
              });
            else if (parameters.connectWith)
              connectWithResponse = await sdk.connectWith({
                method: parameters.connectWith.method,
                params: parameters.connectWith.params
              });
            accounts = await this.getAccounts();
          } else {
            const requestedAccounts = await sdk.connect();
            accounts = requestedAccounts.map((x2) => getAddress(x2));
          }
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain2 = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain2 == null ? void 0 : chain2.id) ?? currentChainId;
        }
        if (displayUri) {
          provider2.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (signResponse)
          provider2.emit("connectAndSign", {
            accounts,
            chainId: currentChainId,
            signResponse
          });
        else if (connectWithResponse)
          provider2.emit("connectWith", {
            accounts,
            chainId: currentChainId,
            connectWithResponse
          });
        if (connect3) {
          provider2.removeListener("connect", connect3);
          connect3 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider2.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider2.on("chainChanged", chainChanged);
        }
        if (!disconnect3) {
          disconnect3 = this.onDisconnect.bind(this);
          provider2.on("disconnect", disconnect3);
        }
        return { accounts, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      const provider2 = await this.getProvider();
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider2.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
      if (!connect3) {
        connect3 = this.onConnect.bind(this);
        provider2.on("connect", connect3);
      }
      await sdk.terminate();
    },
    async getAccounts() {
      const provider2 = await this.getProvider();
      const accounts = await provider2.request({
        method: "eth_accounts"
      });
      return accounts.map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider2 = await this.getProvider();
      const chainId = provider2.getChainId() || await (provider2 == null ? void 0 : provider2.request({ method: "eth_chainId" }));
      return Number(chainId);
    },
    async getProvider() {
      async function initProvider() {
        var _a2, _b, _c2, _d, _e2;
        const MetaMaskSDK = await (async () => {
          const { default: SDK } = await import("./metamask-sdk-XDIPCXXW.js");
          if (typeof SDK !== "function" && typeof SDK.default === "function")
            return SDK.default;
          return SDK;
        })();
        const readonlyRPCMap = {};
        for (const chain2 of config.chains)
          readonlyRPCMap[numberToHex(chain2.id)] = (_a2 = extractRpcUrls({
            chain: chain2,
            transports: config.transports
          })) == null ? void 0 : _a2[0];
        sdk = new MetaMaskSDK({
          _source: "wagmi",
          forceDeleteProvider: false,
          forceInjectProvider: false,
          injectProvider: false,
          // Workaround cast since MetaMask SDK does not support `'exactOptionalPropertyTypes'`
          ...parameters,
          readonlyRPCMap,
          dappMetadata: {
            ...parameters.dappMetadata,
            // Test if name and url are set AND not empty
            name: ((_b = parameters.dappMetadata) == null ? void 0 : _b.name) ? (_c2 = parameters.dappMetadata) == null ? void 0 : _c2.name : "wagmi",
            url: ((_d = parameters.dappMetadata) == null ? void 0 : _d.url) ? (_e2 = parameters.dappMetadata) == null ? void 0 : _e2.url : typeof window !== "undefined" ? window.location.origin : "https://wagmi.sh"
          },
          useDeeplink: parameters.useDeeplink ?? true
        });
        const result = await sdk.init();
        const provider2 = (() => {
          if (result == null ? void 0 : result.activeProvider)
            return result.activeProvider;
          return sdk.getProvider();
        })();
        if (!provider2)
          throw new ProviderNotFoundError();
        return provider2;
      }
      if (!provider) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider = await providerPromise;
      }
      return provider;
    },
    async isAuthorized() {
      try {
        const timeout = 200;
        const accounts = await withRetry(() => withTimeout(() => this.getAccounts(), { timeout }), {
          delay: timeout + 1,
          retryCount: 3
        });
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b;
      const provider2 = await this.getProvider();
      const chain2 = config.chains.find((x2) => x2.id === chainId);
      if (!chain2)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await provider2.request({
          method: "wallet_switchEthereumChain",
          params: [{ chainId: numberToHex(chainId) }]
        });
        await waitForChainIdToSync();
        await sendAndWaitForChangeEvent(chainId);
        return chain2;
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((_b = (_a2 = error == null ? void 0 : error.data) == null ? void 0 : _a2.originalError) == null ? void 0 : _b.code) === 4902) {
          try {
            await provider2.request({
              method: "wallet_addEthereumChain",
              params: [
                {
                  blockExplorerUrls: (() => {
                    const { default: blockExplorer, ...blockExplorers } = chain2.blockExplorers ?? {};
                    if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
                      return addEthereumChainParameter.blockExplorerUrls;
                    if (blockExplorer)
                      return [
                        blockExplorer.url,
                        ...Object.values(blockExplorers).map((x2) => x2.url)
                      ];
                    return;
                  })(),
                  chainId: numberToHex(chainId),
                  chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain2.name,
                  iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
                  nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain2.nativeCurrency,
                  rpcUrls: (() => {
                    var _a3, _b2;
                    if ((_a3 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _a3.length)
                      return addEthereumChainParameter.rpcUrls;
                    return [((_b2 = chain2.rpcUrls.default) == null ? void 0 : _b2.http[0]) ?? ""];
                  })()
                }
              ]
            });
            await waitForChainIdToSync();
            await sendAndWaitForChangeEvent(chainId);
            return chain2;
          } catch (err2) {
            const error2 = err2;
            if (error2.code === UserRejectedRequestError.code)
              throw new UserRejectedRequestError(error2);
            throw new SwitchChainError(error2);
          }
        }
        throw new SwitchChainError(error);
      }
      async function waitForChainIdToSync() {
        await withRetry(async () => {
          const value = hexToNumber(
            // `'eth_chainId'` is cached by the MetaMask SDK side to avoid unnecessary deeplinks
            await provider2.request({ method: "eth_chainId" })
          );
          if (value !== chainId)
            throw new Error("User rejected switch after adding network.");
          return value;
        }, {
          delay: 50,
          retryCount: 20
          // android device encryption is slower
        });
      }
      async function sendAndWaitForChangeEvent(chainId2) {
        await new Promise((resolve) => {
          const listener = (data) => {
            if ("chainId" in data && data.chainId === chainId2) {
              config.emitter.off("change", listener);
              resolve();
            }
          };
          config.emitter.on("change", listener);
          config.emitter.emit("change", { chainId: chainId2 });
        });
      }
    },
    async onAccountsChanged(accounts) {
      if (accounts.length === 0) {
        if (sdk.isExtensionActive())
          this.onDisconnect();
        else
          return;
      } else if (config.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
      } else
        config.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain2) {
      const chainId = Number(chain2);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts();
      if (accounts.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config.emitter.emit("connect", { accounts, chainId });
      const provider2 = await this.getProvider();
      if (connect3) {
        provider2.removeListener("connect", connect3);
        connect3 = void 0;
      }
      if (!accountsChanged) {
        accountsChanged = this.onAccountsChanged.bind(this);
        provider2.on("accountsChanged", accountsChanged);
      }
      if (!chainChanged) {
        chainChanged = this.onChainChanged.bind(this);
        provider2.on("chainChanged", chainChanged);
      }
      if (!disconnect3) {
        disconnect3 = this.onDisconnect.bind(this);
        provider2.on("disconnect", disconnect3);
      }
    },
    async onDisconnect(error) {
      const provider2 = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider2 && !!(await this.getAccounts()).length)
          return;
      }
      config.emitter.emit("disconnect");
      if (chainChanged) {
        provider2.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider2.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
      if (!connect3) {
        connect3 = this.onConnect.bind(this);
        provider2.on("connect", connect3);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    }
  }));
}

// node_modules/@wagmi/connectors/dist/esm/safe.js
safe.type = "safe";
function safe(parameters = {}) {
  const { shimDisconnect = false } = parameters;
  let provider_;
  let disconnect3;
  return createConnector((config) => ({
    id: "safe",
    name: "Safe",
    type: safe.type,
    async connect() {
      var _a2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const accounts = await this.getAccounts();
      const chainId = await this.getChainId();
      if (!disconnect3) {
        disconnect3 = this.onDisconnect.bind(this);
        provider.on("disconnect", disconnect3);
      }
      if (shimDisconnect)
        await ((_a2 = config.storage) == null ? void 0 : _a2.removeItem("safe.disconnected"));
      return { accounts, chainId };
    },
    async disconnect() {
      var _a2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      if (disconnect3) {
        provider.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
      if (shimDisconnect)
        await ((_a2 = config.storage) == null ? void 0 : _a2.setItem("safe.disconnected", true));
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      return (await provider.request({ method: "eth_accounts" })).map(getAddress);
    },
    async getProvider() {
      const isIframe = typeof window !== "undefined" && (window == null ? void 0 : window.parent) !== window;
      if (!isIframe)
        return;
      if (!provider_) {
        const { default: SDK } = await import("./esm-QM7S45J3.js");
        const sdk = new SDK(parameters);
        const safe2 = await withTimeout(() => sdk.safe.getInfo(), {
          timeout: parameters.unstable_getInfoTimeout ?? 10
        });
        if (!safe2)
          throw new Error("Could not load Safe information");
        const SafeAppProvider = await (async () => {
          const Provider = await import("./dist-XWHVEQLA.js");
          if (typeof Provider.SafeAppProvider !== "function" && typeof Provider.default.SafeAppProvider === "function")
            return Provider.default.SafeAppProvider;
          return Provider.SafeAppProvider;
        })();
        provider_ = new SafeAppProvider(safe2, sdk);
      }
      return provider_;
    },
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      return Number(provider.chainId);
    },
    async isAuthorized() {
      var _a2;
      try {
        const isDisconnected = shimDisconnect && // If shim exists in storage, connector is disconnected
        await ((_a2 = config.storage) == null ? void 0 : _a2.getItem("safe.disconnected"));
        if (isDisconnected)
          return false;
        const accounts = await this.getAccounts();
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    onAccountsChanged() {
    },
    onChainChanged() {
    },
    onDisconnect() {
      config.emitter.emit("disconnect");
    }
  }));
}

// node_modules/@wagmi/connectors/dist/esm/walletConnect.js
walletConnect.type = "walletConnect";
function walletConnect(parameters) {
  const isNewChainsStale = parameters.isNewChainsStale ?? true;
  let provider_;
  let providerPromise;
  const NAMESPACE = "eip155";
  let accountsChanged;
  let chainChanged;
  let connect3;
  let displayUri;
  let sessionDelete;
  let disconnect3;
  return createConnector((config) => ({
    id: "walletConnect",
    name: "WalletConnect",
    type: walletConnect.type,
    async setup() {
      const provider = await this.getProvider().catch(() => null);
      if (!provider)
        return;
      if (!connect3) {
        connect3 = this.onConnect.bind(this);
        provider.on("connect", connect3);
      }
      if (!sessionDelete) {
        sessionDelete = this.onSessionDelete.bind(this);
        provider.on("session_delete", sessionDelete);
      }
    },
    async connect({ chainId, ...rest } = {}) {
      var _a2, _b;
      try {
        const provider = await this.getProvider();
        if (!provider)
          throw new ProviderNotFoundError();
        if (!displayUri) {
          displayUri = this.onDisplayUri;
          provider.on("display_uri", displayUri);
        }
        let targetChainId = chainId;
        if (!targetChainId) {
          const state = await ((_a2 = config.storage) == null ? void 0 : _a2.getItem("state")) ?? {};
          const isChainSupported = config.chains.some((x2) => x2.id === state.chainId);
          if (isChainSupported)
            targetChainId = state.chainId;
          else
            targetChainId = (_b = config.chains[0]) == null ? void 0 : _b.id;
        }
        if (!targetChainId)
          throw new Error("No chains found on connector.");
        const isChainsStale = await this.isChainsStale();
        if (provider.session && isChainsStale)
          await provider.disconnect();
        if (!provider.session || isChainsStale) {
          const optionalChains = config.chains.filter((chain2) => chain2.id !== targetChainId).map((optionalChain) => optionalChain.id);
          await provider.connect({
            optionalChains: [targetChainId, ...optionalChains],
            ..."pairingTopic" in rest ? { pairingTopic: rest.pairingTopic } : {}
          });
          this.setRequestedChainsIds(config.chains.map((x2) => x2.id));
        }
        const accounts = (await provider.enable()).map((x2) => getAddress(x2));
        const currentChainId = await this.getChainId();
        if (displayUri) {
          provider.removeListener("display_uri", displayUri);
          displayUri = void 0;
        }
        if (connect3) {
          provider.removeListener("connect", connect3);
          connect3 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect3) {
          disconnect3 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect3);
        }
        if (!sessionDelete) {
          sessionDelete = this.onSessionDelete.bind(this);
          provider.on("session_delete", sessionDelete);
        }
        return { accounts, chainId: currentChainId };
      } catch (error) {
        if (/(user rejected|connection request reset)/i.test(error == null ? void 0 : error.message)) {
          throw new UserRejectedRequestError(error);
        }
        throw error;
      }
    },
    async disconnect() {
      const provider = await this.getProvider();
      try {
        await (provider == null ? void 0 : provider.disconnect());
      } catch (error) {
        if (!/No matching key/i.test(error.message))
          throw error;
      } finally {
        if (chainChanged) {
          provider == null ? void 0 : provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect3) {
          provider == null ? void 0 : provider.removeListener("disconnect", disconnect3);
          disconnect3 = void 0;
        }
        if (!connect3) {
          connect3 = this.onConnect.bind(this);
          provider == null ? void 0 : provider.on("connect", connect3);
        }
        if (accountsChanged) {
          provider == null ? void 0 : provider.removeListener("accountsChanged", accountsChanged);
          accountsChanged = void 0;
        }
        if (sessionDelete) {
          provider == null ? void 0 : provider.removeListener("session_delete", sessionDelete);
          sessionDelete = void 0;
        }
        this.setRequestedChainsIds([]);
      }
    },
    async getAccounts() {
      const provider = await this.getProvider();
      return provider.accounts.map((x2) => getAddress(x2));
    },
    async getProvider({ chainId } = {}) {
      var _a2;
      async function initProvider() {
        const optionalChains = config.chains.map((x2) => x2.id);
        if (!optionalChains.length)
          return;
        const { EthereumProvider: EthereumProvider2 } = await import("./index.es-XV3EL4K7.js");
        return await EthereumProvider2.init({
          ...parameters,
          disableProviderPing: true,
          optionalChains,
          projectId: parameters.projectId,
          rpcMap: Object.fromEntries(config.chains.map((chain2) => {
            const [url] = extractRpcUrls({
              chain: chain2,
              transports: config.transports
            });
            return [chain2.id, url];
          })),
          showQrModal: parameters.showQrModal ?? true
        });
      }
      if (!provider_) {
        if (!providerPromise)
          providerPromise = initProvider();
        provider_ = await providerPromise;
        provider_ == null ? void 0 : provider_.events.setMaxListeners(Number.POSITIVE_INFINITY);
      }
      if (chainId)
        await ((_a2 = this.switchChain) == null ? void 0 : _a2.call(this, { chainId }));
      return provider_;
    },
    async getChainId() {
      const provider = await this.getProvider();
      return provider.chainId;
    },
    async isAuthorized() {
      try {
        const [accounts, provider] = await Promise.all([
          this.getAccounts(),
          this.getProvider()
        ]);
        if (!accounts.length)
          return false;
        const isChainsStale = await this.isChainsStale();
        if (isChainsStale && provider.session) {
          await provider.disconnect().catch(() => {
          });
          return false;
        }
        return true;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b, _c2;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError();
      const chain2 = config.chains.find((x2) => x2.id === chainId);
      if (!chain2)
        throw new SwitchChainError(new ChainNotConfiguredError());
      try {
        await Promise.all([
          new Promise((resolve) => {
            const listener = ({ chainId: currentChainId }) => {
              if (currentChainId === chainId) {
                config.emitter.off("change", listener);
                resolve();
              }
            };
            config.emitter.on("change", listener);
          }),
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          })
        ]);
        const requestedChains = await this.getRequestedChainsIds();
        this.setRequestedChainsIds([...requestedChains, chainId]);
        return chain2;
      } catch (err) {
        const error = err;
        if (/(user rejected)/i.test(error.message))
          throw new UserRejectedRequestError(error);
        try {
          let blockExplorerUrls;
          if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
            blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
          else
            blockExplorerUrls = ((_a2 = chain2.blockExplorers) == null ? void 0 : _a2.default.url) ? [(_b = chain2.blockExplorers) == null ? void 0 : _b.default.url] : [];
          let rpcUrls;
          if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
            rpcUrls = addEthereumChainParameter.rpcUrls;
          else
            rpcUrls = [...chain2.rpcUrls.default.http];
          const addEthereumChain = {
            blockExplorerUrls,
            chainId: numberToHex(chainId),
            chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain2.name,
            iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
            nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain2.nativeCurrency,
            rpcUrls
          };
          await provider.request({
            method: "wallet_addEthereumChain",
            params: [addEthereumChain]
          });
          const requestedChains = await this.getRequestedChainsIds();
          this.setRequestedChainsIds([...requestedChains, chainId]);
          return chain2;
        } catch (error2) {
          throw new UserRejectedRequestError(error2);
        }
      }
    },
    onAccountsChanged(accounts) {
      if (accounts.length === 0)
        this.onDisconnect();
      else
        config.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain2) {
      const chainId = Number(chain2);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const chainId = Number(connectInfo.chainId);
      const accounts = await this.getAccounts();
      config.emitter.emit("connect", { accounts, chainId });
    },
    async onDisconnect(_error) {
      this.setRequestedChainsIds([]);
      config.emitter.emit("disconnect");
      const provider = await this.getProvider();
      if (accountsChanged) {
        provider.removeListener("accountsChanged", accountsChanged);
        accountsChanged = void 0;
      }
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
      if (sessionDelete) {
        provider.removeListener("session_delete", sessionDelete);
        sessionDelete = void 0;
      }
      if (!connect3) {
        connect3 = this.onConnect.bind(this);
        provider.on("connect", connect3);
      }
    },
    onDisplayUri(uri) {
      config.emitter.emit("message", { type: "display_uri", data: uri });
    },
    onSessionDelete() {
      this.onDisconnect();
    },
    getNamespaceChainsIds() {
      var _a2, _b, _c2;
      if (!provider_)
        return [];
      const chainIds = (_c2 = (_b = (_a2 = provider_.session) == null ? void 0 : _a2.namespaces[NAMESPACE]) == null ? void 0 : _b.accounts) == null ? void 0 : _c2.map((account) => Number.parseInt(account.split(":")[1] || ""));
      return chainIds ?? [];
    },
    async getRequestedChainsIds() {
      var _a2;
      return await ((_a2 = config.storage) == null ? void 0 : _a2.getItem(this.requestedChainsStorageKey)) ?? [];
    },
    /**
     * Checks if the target chains match the chains that were
     * initially requested by the connector for the WalletConnect session.
     * If there is a mismatch, this means that the chains on the connector
     * are considered stale, and need to be revalidated at a later point (via
     * connection).
     *
     * There may be a scenario where a dapp adds a chain to the
     * connector later on, however, this chain will not have been approved or rejected
     * by the wallet. In this case, the chain is considered stale.
     */
    async isChainsStale() {
      if (!isNewChainsStale)
        return false;
      const connectorChains = config.chains.map((x2) => x2.id);
      const namespaceChains = this.getNamespaceChainsIds();
      if (namespaceChains.length && !namespaceChains.some((id3) => connectorChains.includes(id3)))
        return false;
      const requestedChains = await this.getRequestedChainsIds();
      return !connectorChains.every((id3) => requestedChains.includes(id3));
    },
    async setRequestedChainsIds(chains) {
      var _a2;
      await ((_a2 = config.storage) == null ? void 0 : _a2.setItem(this.requestedChainsStorageKey, chains));
    },
    get requestedChainsStorageKey() {
      return `${this.id}.requestedChains`;
    }
  }));
}

// node_modules/family/lib/family-accounts-connector-DNek4H7L.js
var import_events = __toESM(require_events(), 1);
var isString = (input) => {
  return typeof input === "string";
};
var CausedError = class extends Error {
  constructor(message, options) {
    super(message, options);
    __publicField(this, "cause");
    if (options == null ? void 0 : options.cause) {
      this.cause = options.cause;
      this.message = `${this.message}
CAUSE: ${this.cause.message}`;
      if (typeof this.cause.stack === "string") {
        this.stack = (this.stack ?? "") + "\nCAUSE: " + this.cause.stack;
      }
    }
  }
};
var Deferred = class {
  constructor() {
    __publicField(this, "promise");
    __publicField(this, "resolve");
    __publicField(this, "reject");
    this.promise = new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
    });
  }
};
var delay = (ms2) => new Promise((resolve) => setTimeout(resolve, ms2));
var minutesToMs = (minutes) => minutes * 6e4;
var secondsToMs = (seconds) => seconds * 1e3;
var msToSeconds = (ms2) => ms2 / 1e3;
var InvariantError = class extends CausedError {
  constructor(message, options) {
    super(`InvariantError: ${message}`, options);
  }
};
function invariant2(condition, message, cause) {
  if (!condition) {
    throw new InvariantError(message, { cause });
  }
}
function assertError(error) {
  if (!(error instanceof Error)) {
    throw new InvariantError(
      `Invalid error type. Received ${typeof error}, expected instance of Error`
    );
  }
}
function never(message, options) {
  throw new InvariantError(message, options);
}
var SessionStatus;
(function(SessionStatus2) {
  SessionStatus2["AUTHENTICATED"] = "AUTHENTICATED";
  SessionStatus2["NOT_AUTHENTICATED"] = "NOT_AUTHENTICATED";
})(SessionStatus || (SessionStatus = {}));
var CommunicationTypes;
(function(CommunicationTypes2) {
  CommunicationTypes2["sessionInit"] = "sessionInit";
  CommunicationTypes2["sessionGetCurrent"] = "sessionGetCurrent";
  CommunicationTypes2["sessionClear"] = "sessionClear";
  CommunicationTypes2["ethereumJsonRpcRequest"] = "ethereumJsonRpcRequest";
  CommunicationTypes2["ethereumJsonRpcRequiresApproval"] = "ethereumJsonRpcRequiresApproval";
})(CommunicationTypes || (CommunicationTypes = {}));
var SubscriptionTypes;
(function(SubscriptionTypes2) {
  SubscriptionTypes2["sessionChanged"] = "sessionChanged";
  SubscriptionTypes2["ethereumNetworkChanged"] = "ethereumNetworkChanged";
  SubscriptionTypes2["modalOpen"] = "modalOpen";
  SubscriptionTypes2["modalClose"] = "modalClose";
  SubscriptionTypes2["modalUpdate"] = "modalUpdate";
})(SubscriptionTypes || (SubscriptionTypes = {}));
var PopupCommunicationTypes;
(function(PopupCommunicationTypes2) {
  PopupCommunicationTypes2["authStart"] = "authStart";
  PopupCommunicationTypes2["rpcRequest"] = "rpcRequest";
})(PopupCommunicationTypes || (PopupCommunicationTypes = {}));
var State = class {
};
__publicField(State, "setExecutorWindow", (_window) => {
  var _a2;
  window.____fa_wrapper = {
    window: _window,
    origin: (_a2 = window.____fa_wrapper) == null ? void 0 : _a2.origin
  };
});
__publicField(State, "getExecutorWindow", () => {
  var _a2;
  if (!((_a2 = window.____fa_wrapper) == null ? void 0 : _a2.window)) {
    throw new Error("You must call `connect` to start up the sdk-web-elements");
  }
  return window.____fa_wrapper.window;
});
__publicField(State, "setExecutorOrigin", (origin2) => {
  var _a2;
  const instance = window.____fa_wrapper;
  if (instance) {
    instance.origin = origin2;
    return;
  }
  window.____fa_wrapper = {
    origin: origin2,
    window: (_a2 = window.____fa_wrapper) == null ? void 0 : _a2.window
  };
});
__publicField(State, "getExecutorOrigin", () => {
  var _a2;
  if (!((_a2 = window.____fa_wrapper) == null ? void 0 : _a2.origin)) {
    throw new Error("You must call `connect` to start up the sdk-web-elements");
  }
  return window.____fa_wrapper.origin;
});
var postRobot = null;
var initPostRobot = async () => {
  postRobot = await import("./index-DD_kndDs-I372VQEH.js").then(function(n2) {
    return n2.i;
  });
};
var getPostRobot = () => {
  invariant2(postRobot, "You need to init post robot first");
  return postRobot;
};
var DEFAULT_PROXY_TIMEOUT$1 = minutesToMs(1);
var proxy = async (request, config) => {
  if (typeof window === "undefined") {
    throw new Error("Can't proxy in a non browser environment");
  }
  const data = "data" in request ? request.data : void 0;
  const event = await getPostRobot().send(State.getExecutorWindow(), request.type, data, {
    timeout: (config == null ? void 0 : config.timeout) ?? DEFAULT_PROXY_TIMEOUT$1
  });
  return event.data;
};
var listeners = /* @__PURE__ */ new Map();
var subscribe = (type6, callback) => {
  var _a2;
  if (typeof window === "undefined") {
    throw new Error("Can't subscribe in a non browser environment");
  }
  if (listeners.has(type6)) {
    (_a2 = listeners.get(type6)) == null ? void 0 : _a2.callbacks.push(callback);
  } else {
    const listener = getPostRobot().on(type6, { window: State.getExecutorWindow() }, (event) => {
      var _a3;
      (_a3 = listeners.get(type6)) == null ? void 0 : _a3.callbacks.forEach((c3) => c3(event.data));
      return Promise.resolve();
    });
    listeners.set(type6, { listener, callbacks: [callback] });
  }
  return () => {
    const listenerInfo = listeners.get(type6);
    if (!listenerInfo) {
      return;
    }
    const newCallbacks = listenerInfo.callbacks.filter((c3) => c3 !== callback);
    if (newCallbacks.length === 0) {
      listenerInfo.listener.cancel();
      listeners.delete(type6);
    } else {
      listenerInfo.callbacks = newCallbacks;
    }
  };
};
var getMasterIframeUrl = () => {
  return State.getExecutorOrigin() + "/injected/master";
};
var IntegratedClientModalController = class {
  constructor(container, iframe) {
    __publicField(this, "unsubscribe");
    __publicField(this, "autoHeight", false);
    const modalOpenUnsubscribe = subscribe(SubscriptionTypes.modalOpen, ({ height }) => {
      document.body.style.setProperty("overflow", "hidden", "important");
      document.body.style.setProperty("padding-right", "15px", "important");
      container.style.setProperty("display", "flex");
      if (this.autoHeight)
        iframe.style.setProperty("height", height.toString() + "px");
    });
    const modalCloseUnsubscribe = subscribe(SubscriptionTypes.modalClose, () => {
      document.body.style.removeProperty("overflow");
      document.body.style.removeProperty("padding-right");
      container.style.setProperty("display", "none");
    });
    const modalUpdateUnsubscribe = subscribe(SubscriptionTypes.modalUpdate, ({ height }) => {
      if (this.autoHeight)
        iframe.style.setProperty("height", height.toString() + "px");
    });
    this.unsubscribe = () => {
      modalOpenUnsubscribe();
      modalCloseUnsubscribe();
      modalUpdateUnsubscribe();
    };
  }
  disconnect() {
    this.unsubscribe();
  }
};
var IFRAME_ID = "family-accounts-master-iframe";
var CONNECTION_TIMEOUT$1 = 2e4;
var modalController = null;
var createElements = ({ fullscreen } = {}) => {
  if (fullscreen) {
    const container = document.createElement("div");
    container.style.display = "none";
    container.style.position = "fixed";
    container.style.inset = "0";
    container.style.zIndex = "2147483647";
    const iframe = document.createElement("iframe");
    iframe.style.position = "absolute";
    iframe.style.top = "0";
    iframe.style.left = "0";
    iframe.style.width = "100vw";
    iframe.style.height = "100vh";
    iframe.id = IFRAME_ID;
    iframe.src = getMasterIframeUrl();
    container.appendChild(iframe);
    return { container, iframe };
  } else {
    const container = document.createElement("div");
    container.style.display = "none";
    container.style.alignItems = "center";
    container.style.justifyContent = "center";
    container.style.position = "fixed";
    container.style.top = "0";
    container.style.left = "0";
    container.style.width = "100vw";
    container.style.height = "100vh";
    container.style.zIndex = "2147483647";
    const backdrop = document.createElement("div");
    backdrop.style.position = "absolute";
    backdrop.style.inset = "0";
    backdrop.style.backgroundColor = "rgba(0,0,0,0.5)";
    backdrop.style.zIndex = "-1";
    const iframe = document.createElement("iframe");
    iframe.style.borderRadius = "10px";
    iframe.style.boxShadow = "0 0 10px 0 rgba(0,0,0,0.5)";
    iframe.id = IFRAME_ID;
    iframe.src = getMasterIframeUrl();
    container.appendChild(backdrop);
    container.appendChild(iframe);
    return { container, iframe };
  }
};
var connect2 = ({ environment }) => {
  const connected = isConnected();
  if (connected) {
    return null;
  }
  return new Promise((resolve, reject) => {
    let fulfilled = false;
    const timeout = setTimeout(() => {
      fulfilled = true;
      reject(`The sdk-web-elements failed to connect within ${msToSeconds(CONNECTION_TIMEOUT$1)} seconds, please contact support.`);
    }, CONNECTION_TIMEOUT$1);
    const origin2 = environment.webElementsAppUrl;
    State.setExecutorOrigin(origin2);
    const { container, iframe } = createElements({
      fullscreen: true
    });
    iframe.onload = () => {
      if (fulfilled) {
        return;
      }
      fulfilled = true;
      clearTimeout(timeout);
      State.setExecutorWindow(iframe.contentWindow);
      modalController = new IntegratedClientModalController(container, iframe);
      resolve();
    };
    void initPostRobot().then(() => {
      document.body.appendChild(container);
    });
  });
};
var isConnected = () => {
  const connector = document.getElementById(IFRAME_ID);
  return !!connector && !!modalController;
};
var disconnect2 = () => {
  const connected = isConnected();
  if (!connected) {
    return;
  }
  const connector = document.getElementById(IFRAME_ID);
  invariant2(connector, "The connector is not defined");
  invariant2(modalController, "The modal controller is not defined");
  modalController.disconnect();
  connector.remove();
};
var DEVICE_LOCAL_STORAGE_KEY = "family_accounts__device_id";
var getDeviceId = () => localStorage.getItem(DEVICE_LOCAL_STORAGE_KEY);
var setDeviceId = (deviceId) => localStorage.setItem(DEVICE_LOCAL_STORAGE_KEY, deviceId);
var SESSION_KEY_LOCAL_STORAGE_KEY = "family_accounts__session_key";
var getSessionKey = () => {
  return localStorage.getItem(SESSION_KEY_LOCAL_STORAGE_KEY);
};
var setSessionKey = (sessionKey) => {
  return localStorage.setItem(SESSION_KEY_LOCAL_STORAGE_KEY, sessionKey);
};
var removeSessionKey = () => {
  return localStorage.removeItem(SESSION_KEY_LOCAL_STORAGE_KEY);
};
var production = {
  name: "production",
  webElementsAppUrl: "https://app.family.co"
};
var DEFAULT_PROXY_TIMEOUT = minutesToMs(1);
var calculatePopupPosition = (width, height) => {
  const left = window.screenX + (window.outerWidth - width) / 2;
  const top = window.screenY + (window.outerHeight - height) / 2;
  return {
    left,
    top
  };
};
var getPopupSize = (size5) => {
  switch (size5) {
    case PopupSize.MEDIUM:
      return {
        width: 444,
        height: 586
      };
    case PopupSize.INHERITED:
      return {
        width: window.outerWidth,
        height: window.outerHeight
      };
  }
};
var PopupSize;
(function(PopupSize2) {
  PopupSize2["MEDIUM"] = "MEDIUM";
  PopupSize2["INHERITED"] = "INHERITED";
})(PopupSize || (PopupSize = {}));
var openPopup = (url, name, size5 = PopupSize.MEDIUM) => {
  const { width, height } = getPopupSize(size5);
  const { top, left } = calculatePopupPosition(width, height);
  const options = `width=${width},height=${height},left=${left},top=${top},menubar=no,toolbar=no,location=no,status=no`;
  return window.open(url, name, options);
};
var proxyPopup = async (popup, request, config) => {
  const data = "data" in request ? request.data : void 0;
  const event = await getPostRobot().send(popup, request.type, data, {
    timeout: (config == null ? void 0 : config.timeout) ?? DEFAULT_PROXY_TIMEOUT
  });
  return event.data;
};
var connectionChangeListeners = [];
var SdkStatus;
(function(SdkStatus2) {
  SdkStatus2[SdkStatus2["DISCONNECTED"] = 0] = "DISCONNECTED";
  SdkStatus2[SdkStatus2["CONNECTING"] = 1] = "CONNECTING";
  SdkStatus2[SdkStatus2["CONNECTED"] = 2] = "CONNECTED";
})(SdkStatus || (SdkStatus = {}));
var sdkStatus = SdkStatus.DISCONNECTED;
var requireConnectedSdk = () => {
  if (sdkStatus !== SdkStatus.CONNECTED) {
    throw new Error("Family Accounts is not connected. Make sure to call FamilyAccountsSdk.connect() first.");
  }
};
var SessionCreateResult;
(function(SessionCreateResult2) {
  SessionCreateResult2["SUCCESS"] = "SUCCESS";
  SessionCreateResult2["USER_CANCELLED"] = "USER_CANCELLED";
  SessionCreateResult2["BROWSER_BLOCKED"] = "BROWSER_BLOCKED";
})(SessionCreateResult || (SessionCreateResult = {}));
var FamilyAccountsSdk = {
  async connect(config = { environment: production }) {
    if (sdkStatus === SdkStatus.CONNECTED) {
      throw new Error("Family Accounts is already connected. Do not call FamilyAccountsSdk.connect() more than once.");
    }
    if (sdkStatus === SdkStatus.CONNECTING) {
      throw new Error("Family Accounts is already connecting. Do not call FamilyAccountsSdk.connect() more than once.");
    }
    sdkStatus = SdkStatus.CONNECTING;
    await connect2(config);
    await this.session.init();
    sdkStatus = SdkStatus.CONNECTED;
    connectionChangeListeners.forEach((listener) => listener(true));
  },
  isConnected: () => sdkStatus === SdkStatus.CONNECTED,
  isConnecting: () => sdkStatus === SdkStatus.CONNECTING,
  async disconnect() {
    if (sdkStatus !== SdkStatus.CONNECTED) {
      throw new Error("Family accounts is not connected");
    }
    const currentSession = await this.session.getCurrent();
    if (currentSession.status === SessionStatus.AUTHENTICATED) {
      await this.session.clear();
    }
    disconnect2();
    sdkStatus = SdkStatus.DISCONNECTED;
    connectionChangeListeners.forEach((listener) => listener(false));
    return Promise.resolve();
  },
  onConnectionChange: (callback) => {
    connectionChangeListeners.push(callback);
    return () => {
      connectionChangeListeners = connectionChangeListeners.filter((listener) => listener !== callback);
    };
  },
  session: {
    create: async () => {
      requireConnectedSdk();
      const popup = openPopup(`${State.getExecutorOrigin()}/popup/auth`, "FamilyAccountsAuthentication");
      if (!popup) {
        return {
          status: SessionCreateResult.BROWSER_BLOCKED
        };
      }
      try {
        const response = await proxyPopup(popup, {
          type: PopupCommunicationTypes.authStart
        }, {
          // note: popup has own timeout, this is purely to keep the event alive
          timeout: minutesToMs(10)
        });
        setSessionKey(response.clientSessionKey);
        setDeviceId(response.deviceId);
        return {
          status: SessionCreateResult.SUCCESS,
          deviceId: response.deviceId,
          clientSessionKey: response.clientSessionKey,
          idToken: response.idToken,
          wallet: {
            address: response.wallet.address
          }
        };
      } catch {
        return {
          status: SessionCreateResult.USER_CANCELLED
        };
      }
    },
    // TODO: Remove `init` from the public API
    init: () => {
      const deviceId = getDeviceId();
      const clientSessionKey = getSessionKey();
      return proxy({
        type: CommunicationTypes.sessionInit,
        data: {
          deviceId,
          clientSessionKey
        }
      });
    },
    getCurrent: () => {
      requireConnectedSdk();
      return proxy({
        type: CommunicationTypes.sessionGetCurrent
      });
    },
    onChange: (callback) => {
      requireConnectedSdk();
      return subscribe(SubscriptionTypes.sessionChanged, callback);
    },
    clear: () => {
      requireConnectedSdk();
      removeSessionKey();
      return proxy({
        type: CommunicationTypes.sessionClear
      });
    }
  },
  ethereum: {
    onNetworkChange: (callback) => {
      requireConnectedSdk();
      return subscribe(SubscriptionTypes.ethereumNetworkChanged, callback);
    }
  }
};
var isIntersectionObserverV2Supported = () => "IntersectionObserverEntry" in window && "isVisible" in IntersectionObserverEntry.prototype;
var POTENTIALLY_APPROVAL_REQUIRED_METHODS = [
  "personal_sign",
  "eth_sendTransaction",
  "eth_signTypedData_v4",
  "wallet_addEthereumChain",
  "family_switchAccounts"
];
var RpcError = class _RpcError extends Error {
  constructor(code, message) {
    super(message);
    __publicField(this, "code");
    __publicField(this, "message");
    this.code = code;
    this.message = message;
  }
  static userRejectedRequest(message) {
    return new _RpcError(4001, message);
  }
  static unauthorized(message) {
    return new _RpcError(4100, message);
  }
};
var LocalRpcHandler = class {
  constructor(args) {
    __publicField(this, "args");
    this.args = args;
  }
  async handle() {
    switch (this.args.method) {
      case "eth_requestAccounts":
        return this.handleRequestAccounts();
      default: {
        never("Unsupported method");
      }
    }
  }
  async handleRequestAccounts() {
    try {
      const session = await FamilyAccountsSdk.session.getCurrent();
      if (session.status === SessionStatus.AUTHENTICATED) {
        return [session.wallet.address];
      }
      const createdSession = await FamilyAccountsSdk.session.create();
      switch (createdSession.status) {
        case SessionCreateResult.SUCCESS:
          return [createdSession.wallet.address];
        case SessionCreateResult.BROWSER_BLOCKED:
          throw RpcError.userRejectedRequest("Browser blocked Family Accounts authentication popup");
        case SessionCreateResult.USER_CANCELLED:
          throw RpcError.userRejectedRequest("User cancelled authentication request");
      }
    } catch (error) {
      if (error instanceof Error && "code" in error) {
        throw error;
      }
      throw RpcError.userRejectedRequest("Unknown reason");
    }
  }
};
var MasterIframeRpcHandler = class {
  constructor(args) {
    __publicField(this, "args");
    // The default post message timeout is 10 seconds
    __publicField(this, "DEFAULT_RPC_CALL_TIMEOUT", secondsToMs(10));
    __publicField(this, "DEFAULT_RPC_SIGN_TIMEOUT", minutesToMs(10));
    this.args = args;
  }
  async handle() {
    const timeout = POTENTIALLY_APPROVAL_REQUIRED_METHODS.includes(this.args.method) ? (
      // if its sending a transaction make the timeout very
      // long as they may get a approval modal displayed
      // and if so have a `forever` time to approval it
      this.DEFAULT_RPC_SIGN_TIMEOUT
    ) : this.DEFAULT_RPC_CALL_TIMEOUT;
    try {
      const result = await proxy({
        type: CommunicationTypes.ethereumJsonRpcRequest,
        data: this.args
      }, {
        timeout
      });
      invariant2(result !== void 0, "The JSON RPC result should not be undefined");
      return result;
    } catch (error) {
      if (error instanceof Error && "code" in error) {
        throw error;
      }
      throw RpcError.userRejectedRequest("Unknown reason");
    }
  }
};
var PopupModalRpcHandler = class {
  constructor(args) {
    __publicField(this, "args");
    // if it takes longer to detect if approval is required (e.g. simulation time intensive)
    // we would then treat it as approval required to not block the UI
    __publicField(this, "APPROVAL_REQUIRED_TIMEOUT", 300);
    this.args = args;
  }
  handle() {
    let requestRequiresApproval = null;
    void requiresUserApproval(this.args).then((result) => {
      requestRequiresApproval = result;
    });
    const deferred = new Deferred();
    setTimeout(async () => {
      if (requestRequiresApproval === false) {
        new MasterIframeRpcHandler(this.args).handle().then(deferred.resolve, deferred.reject);
        return;
      }
      const popup = openPopup(`${State.getExecutorOrigin()}/popup/rpc`, "FamilyAccountsRpc", PopupSize.INHERITED);
      if (!popup) {
        deferred.reject(RpcError.userRejectedRequest("Popup blocked"));
        return;
      }
      const clientSessionKey = getSessionKey();
      const deviceId = getDeviceId();
      if (!clientSessionKey || !deviceId) {
        deferred.reject(RpcError.unauthorized("User not authorized"));
        return;
      }
      try {
        const result = await proxyPopup(popup, {
          type: PopupCommunicationTypes.rpcRequest,
          data: {
            request: this.args,
            clientSessionKey,
            deviceId
          }
        }, {
          // note: popup has own timeout, this is purely to keep the event alive
          timeout: minutesToMs(10)
        });
        deferred.resolve(result);
      } catch (error) {
        assertError(error);
        if (error instanceof Error && "code" in error) {
          deferred.reject(error);
          return;
        }
        deferred.reject(RpcError.userRejectedRequest("Popup was closed by the user"));
      }
    }, this.APPROVAL_REQUIRED_TIMEOUT);
    return deferred.promise;
  }
};
var requiresUserApproval = async (args) => {
  try {
    return await proxy({
      type: CommunicationTypes.ethereumJsonRpcRequiresApproval,
      data: args
    });
  } catch (error) {
    if (error instanceof Error && "code" in error) {
      throw error;
    }
    throw RpcError.userRejectedRequest("Unknown reason");
  }
};
function getRpcRequestHandler(args) {
  if (args.method === "eth_requestAccounts") {
    return new LocalRpcHandler(args);
  }
  if (isIntersectionObserverV2Supported()) {
    return new MasterIframeRpcHandler(args);
  }
  if (!POTENTIALLY_APPROVAL_REQUIRED_METHODS.includes(args.method)) {
    return new MasterIframeRpcHandler(args);
  }
  return new PopupModalRpcHandler(args);
}
var CONNECTION_TIMEOUT = secondsToMs(5);
var EthereumProviderConnectionTimeoutError = class extends Error {
  constructor() {
    super("EIP1193 provider connection timeout. Make sure to call `FamilyAccountsSdk.connect()` before using the provider.");
  }
};
var EthereumProvider = class {
  constructor(options) {
    __publicField(this, "_eventEmitter", new import_events.EventEmitter());
    __publicField(this, "_accountsChangedUnsubscriptionCallback", null);
    __publicField(this, "_networkChangedUnsubscriptionCallback", null);
    __publicField(this, "_connectUnsubscriptionCallback", null);
    __publicField(this, "_disconnectUnsubscriptionCallback", null);
    __publicField(this, "_config");
    this._config = options;
  }
  log(...args) {
    var _a2;
    if ((_a2 = this._config) == null ? void 0 : _a2.debug) {
      console.log(...args);
    }
  }
  /**
   * @returns true if the provider is connected and ready to process requests
   */
  isConnected() {
    return FamilyAccountsSdk.isConnected();
  }
  /**
   * JSONRPC request
   * @param args The request arguments
   */
  // return type is loose as we don't want to type all the possible return types given it's a proxy
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  async request(args) {
    await this.waitForConnection();
    const requestHandler = getRpcRequestHandler({
      method: args.method,
      // normalize params to be an array
      params: Array.isArray(args.params) ? args.params : [args.params]
    });
    return requestHandler.handle();
  }
  /**
   * JSONRPC request
   * @param method The request jsonrpc method
   * @param params The request parameters
   * @deprecated Please use `request` instead.
   */
  async send(method, params) {
    return this.request({ method, params });
  }
  on(eventName, listener) {
    if (eventName === "message") {
      return this;
    }
    this.log("on", eventName);
    if (this._eventEmitter.listenerCount(eventName) === 0) {
      switch (eventName) {
        case "accountsChanged":
          void this.subscribeToAccountChangeEvent().catch((...args) => this.log("accountsChanged", args));
          break;
        case "chainChanged":
          void this.subscribeToNetworkChangeEvent();
          break;
        case "connect":
          void this.subscribeToConnectEvent().catch((...args) => this.log("connect", args));
          break;
        case "disconnect":
          void this.subscribeToDisconnectEvent().catch((...args) => this.log("disconnect", args));
          break;
      }
    }
    this._eventEmitter.on(eventName, listener);
    return this;
  }
  /**
   * Remove the provider event emitters
   * @param eventName The event name
   * @param listener The listener to callback
   */
  removeListener(eventName, listener) {
    if (eventName === "message") {
      return this;
    }
    this._eventEmitter.removeListener(eventName, listener);
    if (this._eventEmitter.listenerCount(eventName) === 0) {
      switch (eventName) {
        case "accountsChanged":
          void this.unsubscribeFromAccountChangeEvent().catch((...args) => this.log("accountsChanged", args));
          break;
        case "chainChanged":
          void this.unsubscribeFromNetworkChangeEvent();
          break;
        case "connect":
          void this.unsubscribeFromConnectEvent().catch((...args) => this.log("connect", args));
          break;
        case "disconnect":
          void this.unsubscribeFromDisconnectEvent().catch((...args) => this.log("disconnect", args));
          break;
      }
    }
    return this;
  }
  subscribeToNetworkChangeEvent() {
    invariant2(!this._networkChangedUnsubscriptionCallback, "Already subscribed to network change event");
    this._networkChangedUnsubscriptionCallback = FamilyAccountsSdk.ethereum.onNetworkChange((newValue) => {
      this._eventEmitter.emit("chainChanged", newValue.chainId);
    });
  }
  unsubscribeFromNetworkChangeEvent() {
    invariant2(this._networkChangedUnsubscriptionCallback, "Not subscribed to network change event");
    this._networkChangedUnsubscriptionCallback();
    this._networkChangedUnsubscriptionCallback = null;
  }
  async subscribeToAccountChangeEvent() {
    await this.waitForConnection();
    invariant2(!this._accountsChangedUnsubscriptionCallback, "Already subscribed to account change event");
    let prevConnectedAccount = null;
    void FamilyAccountsSdk.session.getCurrent().then((currentSession) => {
      prevConnectedAccount = currentSession.status === SessionStatus.AUTHENTICATED ? currentSession.wallet.address : null;
    });
    this._accountsChangedUnsubscriptionCallback = FamilyAccountsSdk.session.onChange((newValue) => {
      const newConnectedAccount = newValue.status === SessionStatus.AUTHENTICATED ? newValue.wallet.address : null;
      if (prevConnectedAccount !== newConnectedAccount) {
        this._eventEmitter.emit("accountsChanged", newConnectedAccount === null ? [] : [newConnectedAccount]);
        prevConnectedAccount = newConnectedAccount;
      }
    });
  }
  async unsubscribeFromAccountChangeEvent() {
    await this.waitForConnection();
    invariant2(this._accountsChangedUnsubscriptionCallback, "Not subscribed to account change event");
    this._accountsChangedUnsubscriptionCallback();
    this._accountsChangedUnsubscriptionCallback = null;
  }
  async subscribeToConnectEvent() {
    await this.waitForConnection();
    invariant2(!this._connectUnsubscriptionCallback, "Already subscribed to connect event");
    this._connectUnsubscriptionCallback = FamilyAccountsSdk.onConnectionChange(async (isConnected2) => {
      if (isConnected2) {
        const chainId = await this.request({ method: "eth_chainId" });
        if (!isString(chainId))
          return;
        invariant2(isString(chainId), "Invalid chainId");
        this._eventEmitter.emit("connect", {
          chainId
        });
      }
    });
  }
  async unsubscribeFromConnectEvent() {
    await this.waitForConnection();
    invariant2(this._connectUnsubscriptionCallback, "Not subscribed to connect event");
    this._connectUnsubscriptionCallback();
    this._connectUnsubscriptionCallback = null;
  }
  async subscribeToDisconnectEvent() {
    await this.waitForConnection();
    invariant2(!this._disconnectUnsubscriptionCallback, "Already subscribed to disconnect event");
    this._disconnectUnsubscriptionCallback = FamilyAccountsSdk.onConnectionChange((isConnected2) => {
      if (!isConnected2) {
        this._eventEmitter.emit("disconnect");
      }
    });
  }
  async unsubscribeFromDisconnectEvent() {
    await this.waitForConnection();
    invariant2(this._disconnectUnsubscriptionCallback, "Not subscribed to account disconnect event");
    this._disconnectUnsubscriptionCallback();
    this._disconnectUnsubscriptionCallback = null;
  }
  /**
   * Wait for the provider to be connected
   * This is done to make provider compatible with `wagmi` `injected` connector that tries to attach events before the provider is connected
   */
  async waitForConnection() {
    var _a2;
    if (FamilyAccountsSdk.isConnected()) {
      return;
    }
    if (FamilyAccountsSdk.isConnecting()) {
      const deferred = new Deferred();
      const unsubscribe = FamilyAccountsSdk.onConnectionChange((isConnected2) => {
        if (isConnected2) {
          deferred.resolve();
        }
      });
      const { timeout: timeout2 } = await Promise.race([
        deferred.promise.then(() => ({ timeout: false })),
        delay(CONNECTION_TIMEOUT).then(() => ({ timeout: true }))
      ]);
      unsubscribe();
      if (timeout2) {
        throw new EthereumProviderConnectionTimeoutError();
      }
      return;
    }
    const { timeout } = await Promise.race([
      FamilyAccountsSdk.connect((_a2 = this._config) == null ? void 0 : _a2.options).then(() => ({ timeout: false })),
      delay(CONNECTION_TIMEOUT).then(() => ({ timeout: true }))
    ]);
    if (timeout) {
      throw new EthereumProviderConnectionTimeoutError();
    }
  }
};
var version$1 = "2.16.5";
var getVersion3 = () => `@wagmi/core@${version$1}`;
var __classPrivateFieldGet2 = function(receiver, state, kind, f3) {
  if (kind === "a" && !f3) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f3 : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f3 : kind === "a" ? f3.call(receiver) : f3 ? f3.value : state.get(receiver);
};
var _BaseError_instances2;
var _BaseError_walk3;
var BaseError5 = class _BaseError extends Error {
  get docsBaseUrl() {
    return "https://wagmi.sh/core";
  }
  get version() {
    return getVersion3();
  }
  constructor(shortMessage, options = {}) {
    var _a2;
    super();
    _BaseError_instances2.add(this);
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WagmiCoreError"
    });
    const details = options.cause instanceof _BaseError ? options.cause.details : ((_a2 = options.cause) == null ? void 0 : _a2.message) ? options.cause.message : options.details;
    const docsPath = options.cause instanceof _BaseError ? options.cause.docsPath || options.docsPath : options.docsPath;
    this.message = [
      shortMessage || "An error occurred.",
      "",
      ...options.metaMessages ? [...options.metaMessages, ""] : [],
      ...docsPath ? [
        `Docs: ${this.docsBaseUrl}${docsPath}.html${options.docsSlug ? `#${options.docsSlug}` : ""}`
      ] : [],
      ...details ? [`Details: ${details}`] : [],
      `Version: ${this.version}`
    ].join("\n");
    if (options.cause)
      this.cause = options.cause;
    this.details = details;
    this.docsPath = docsPath;
    this.metaMessages = options.metaMessages;
    this.shortMessage = shortMessage;
  }
  walk(fn2) {
    return __classPrivateFieldGet2(this, _BaseError_instances2, "m", _BaseError_walk3).call(this, this, fn2);
  }
};
_BaseError_instances2 = /* @__PURE__ */ new WeakSet(), _BaseError_walk3 = function _BaseError_walk4(err, fn2) {
  if (fn2 == null ? void 0 : fn2(err))
    return err;
  if (err.cause)
    return __classPrivateFieldGet2(this, _BaseError_instances2, "m", _BaseError_walk4).call(this, err.cause, fn2);
  return err;
};
var ChainNotConfiguredError2 = class extends BaseError5 {
  constructor() {
    super("Chain not configured.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ChainNotConfiguredError"
    });
  }
};
var ProviderNotFoundError2 = class extends BaseError5 {
  constructor() {
    super("Provider not found.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderNotFoundError"
    });
  }
};
function createConnector2(createConnectorFn) {
  return createConnectorFn;
}
injected2.type = "injected";
function injected2(parameters = {}) {
  const { shimDisconnect = true, unstable_shimAsyncInject } = parameters;
  function getTarget() {
    const target = parameters.target;
    if (typeof target === "function") {
      const result = target();
      if (result)
        return result;
    }
    if (typeof target === "object")
      return target;
    if (typeof target === "string")
      return {
        ...targetMap2[target] ?? {
          id: target,
          name: `${target[0].toUpperCase()}${target.slice(1)}`,
          provider: `is${target[0].toUpperCase()}${target.slice(1)}`
        }
      };
    return {
      id: "injected",
      name: "Injected",
      provider(window2) {
        return window2 == null ? void 0 : window2.ethereum;
      }
    };
  }
  let accountsChanged;
  let chainChanged;
  let connect3;
  let disconnect3;
  return createConnector2((config) => ({
    get icon() {
      return getTarget().icon;
    },
    get id() {
      return getTarget().id;
    },
    get name() {
      return getTarget().name;
    },
    /** @deprecated */
    get supportsSimulation() {
      return true;
    },
    type: injected2.type,
    async setup() {
      const provider = await this.getProvider();
      if ((provider == null ? void 0 : provider.on) && parameters.target) {
        if (!connect3) {
          connect3 = this.onConnect.bind(this);
          provider.on("connect", connect3);
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
      }
    },
    async connect({ chainId, isReconnecting: isReconnecting2 } = {}) {
      var _a2, _b, _c2, _d, _e2, _f;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError2();
      let accounts = [];
      if (isReconnecting2)
        accounts = await this.getAccounts().catch(() => []);
      else if (shimDisconnect) {
        try {
          const permissions = await provider.request({
            method: "wallet_requestPermissions",
            params: [{ eth_accounts: {} }]
          });
          accounts = (_d = (_c2 = (_b = (_a2 = permissions[0]) == null ? void 0 : _a2.caveats) == null ? void 0 : _b[0]) == null ? void 0 : _c2.value) == null ? void 0 : _d.map((x2) => getAddress(x2));
          if (accounts.length > 0) {
            const sortedAccounts = await this.getAccounts();
            accounts = sortedAccounts;
          }
        } catch (err) {
          const error = err;
          if (error.code === UserRejectedRequestError.code)
            throw new UserRejectedRequestError(error);
          if (error.code === ResourceUnavailableRpcError.code)
            throw error;
        }
      }
      try {
        if (!(accounts == null ? void 0 : accounts.length) && !isReconnecting2) {
          const requestedAccounts = await provider.request({
            method: "eth_requestAccounts"
          });
          accounts = requestedAccounts.map((x2) => getAddress(x2));
        }
        if (connect3) {
          provider.removeListener("connect", connect3);
          connect3 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect3) {
          disconnect3 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect3);
        }
        let currentChainId = await this.getChainId();
        if (chainId && currentChainId !== chainId) {
          const chain2 = await this.switchChain({ chainId }).catch((error) => {
            if (error.code === UserRejectedRequestError.code)
              throw error;
            return { id: currentChainId };
          });
          currentChainId = (chain2 == null ? void 0 : chain2.id) ?? currentChainId;
        }
        if (shimDisconnect)
          await ((_e2 = config.storage) == null ? void 0 : _e2.removeItem(`${this.id}.disconnected`));
        if (!parameters.target)
          await ((_f = config.storage) == null ? void 0 : _f.setItem("injected.connected", true));
        return { accounts, chainId: currentChainId };
      } catch (err) {
        const error = err;
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        if (error.code === ResourceUnavailableRpcError.code)
          throw new ResourceUnavailableRpcError(error);
        throw error;
      }
    },
    async disconnect() {
      var _a2, _b;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError2();
      if (chainChanged) {
        provider.removeListener("chainChanged", chainChanged);
        chainChanged = void 0;
      }
      if (disconnect3) {
        provider.removeListener("disconnect", disconnect3);
        disconnect3 = void 0;
      }
      if (!connect3) {
        connect3 = this.onConnect.bind(this);
        provider.on("connect", connect3);
      }
      try {
        await withTimeout(() => (
          // TODO: Remove explicit type for viem@3
          provider.request({
            // `'wallet_revokePermissions'` added in `viem@2.10.3`
            method: "wallet_revokePermissions",
            params: [{ eth_accounts: {} }]
          })
        ), { timeout: 100 });
      } catch {
      }
      if (shimDisconnect) {
        await ((_a2 = config.storage) == null ? void 0 : _a2.setItem(`${this.id}.disconnected`, true));
      }
      if (!parameters.target)
        await ((_b = config.storage) == null ? void 0 : _b.removeItem("injected.connected"));
    },
    async getAccounts() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError2();
      const accounts = await provider.request({ method: "eth_accounts" });
      return accounts.map((x2) => getAddress(x2));
    },
    async getChainId() {
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError2();
      const hexChainId = await provider.request({ method: "eth_chainId" });
      return Number(hexChainId);
    },
    async getProvider() {
      if (typeof window === "undefined")
        return void 0;
      let provider;
      const target = getTarget();
      if (typeof target.provider === "function")
        provider = target.provider(window);
      else if (typeof target.provider === "string")
        provider = findProvider2(window, target.provider);
      else
        provider = target.provider;
      if (provider && !provider.removeListener) {
        if ("off" in provider && typeof provider.off === "function")
          provider.removeListener = provider.off;
        else
          provider.removeListener = () => {
          };
      }
      return provider;
    },
    async isAuthorized() {
      var _a2, _b;
      try {
        const isDisconnected = shimDisconnect && // If shim exists in storage, connector is disconnected
        await ((_a2 = config.storage) == null ? void 0 : _a2.getItem(`${this.id}.disconnected`));
        if (isDisconnected)
          return false;
        if (!parameters.target) {
          const connected = await ((_b = config.storage) == null ? void 0 : _b.getItem("injected.connected"));
          if (!connected)
            return false;
        }
        const provider = await this.getProvider();
        if (!provider) {
          if (unstable_shimAsyncInject !== void 0 && unstable_shimAsyncInject !== false) {
            const handleEthereum = async () => {
              if (typeof window !== "undefined")
                window.removeEventListener("ethereum#initialized", handleEthereum);
              const provider2 = await this.getProvider();
              return !!provider2;
            };
            const timeout = typeof unstable_shimAsyncInject === "number" ? unstable_shimAsyncInject : 1e3;
            const res = await Promise.race([
              ...typeof window !== "undefined" ? [
                new Promise((resolve) => window.addEventListener("ethereum#initialized", () => resolve(handleEthereum()), { once: true }))
              ] : [],
              new Promise((resolve) => setTimeout(() => resolve(handleEthereum()), timeout))
            ]);
            if (res)
              return true;
          }
          throw new ProviderNotFoundError2();
        }
        const accounts = await withRetry(() => this.getAccounts());
        return !!accounts.length;
      } catch {
        return false;
      }
    },
    async switchChain({ addEthereumChainParameter, chainId }) {
      var _a2, _b, _c2, _d;
      const provider = await this.getProvider();
      if (!provider)
        throw new ProviderNotFoundError2();
      const chain2 = config.chains.find((x2) => x2.id === chainId);
      if (!chain2)
        throw new SwitchChainError(new ChainNotConfiguredError2());
      const promise = new Promise((resolve) => {
        const listener = (data) => {
          if ("chainId" in data && data.chainId === chainId) {
            config.emitter.off("change", listener);
            resolve();
          }
        };
        config.emitter.on("change", listener);
      });
      try {
        await Promise.all([
          provider.request({
            method: "wallet_switchEthereumChain",
            params: [{ chainId: numberToHex(chainId) }]
          }).then(async () => {
            const currentChainId = await this.getChainId();
            if (currentChainId === chainId)
              config.emitter.emit("change", { chainId });
          }),
          promise
        ]);
        return chain2;
      } catch (err) {
        const error = err;
        if (error.code === 4902 || // Unwrapping for MetaMask Mobile
        // https://github.com/MetaMask/metamask-mobile/issues/2944#issuecomment-976988719
        ((_b = (_a2 = error == null ? void 0 : error.data) == null ? void 0 : _a2.originalError) == null ? void 0 : _b.code) === 4902) {
          try {
            const { default: blockExplorer, ...blockExplorers } = chain2.blockExplorers ?? {};
            let blockExplorerUrls;
            if (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.blockExplorerUrls)
              blockExplorerUrls = addEthereumChainParameter.blockExplorerUrls;
            else if (blockExplorer)
              blockExplorerUrls = [
                blockExplorer.url,
                ...Object.values(blockExplorers).map((x2) => x2.url)
              ];
            let rpcUrls;
            if ((_c2 = addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.rpcUrls) == null ? void 0 : _c2.length)
              rpcUrls = addEthereumChainParameter.rpcUrls;
            else
              rpcUrls = [((_d = chain2.rpcUrls.default) == null ? void 0 : _d.http[0]) ?? ""];
            const addEthereumChain = {
              blockExplorerUrls,
              chainId: numberToHex(chainId),
              chainName: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.chainName) ?? chain2.name,
              iconUrls: addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.iconUrls,
              nativeCurrency: (addEthereumChainParameter == null ? void 0 : addEthereumChainParameter.nativeCurrency) ?? chain2.nativeCurrency,
              rpcUrls
            };
            await Promise.all([
              provider.request({
                method: "wallet_addEthereumChain",
                params: [addEthereumChain]
              }).then(async () => {
                const currentChainId = await this.getChainId();
                if (currentChainId === chainId)
                  config.emitter.emit("change", { chainId });
                else
                  throw new UserRejectedRequestError(new Error("User rejected switch after adding network."));
              }),
              promise
            ]);
            return chain2;
          } catch (error2) {
            throw new UserRejectedRequestError(error2);
          }
        }
        if (error.code === UserRejectedRequestError.code)
          throw new UserRejectedRequestError(error);
        throw new SwitchChainError(error);
      }
    },
    async onAccountsChanged(accounts) {
      var _a2;
      if (accounts.length === 0)
        this.onDisconnect();
      else if (config.emitter.listenerCount("connect")) {
        const chainId = (await this.getChainId()).toString();
        this.onConnect({ chainId });
        if (shimDisconnect)
          await ((_a2 = config.storage) == null ? void 0 : _a2.removeItem(`${this.id}.disconnected`));
      } else
        config.emitter.emit("change", {
          accounts: accounts.map((x2) => getAddress(x2))
        });
    },
    onChainChanged(chain2) {
      const chainId = Number(chain2);
      config.emitter.emit("change", { chainId });
    },
    async onConnect(connectInfo) {
      const accounts = await this.getAccounts();
      if (accounts.length === 0)
        return;
      const chainId = Number(connectInfo.chainId);
      config.emitter.emit("connect", { accounts, chainId });
      const provider = await this.getProvider();
      if (provider) {
        if (connect3) {
          provider.removeListener("connect", connect3);
          connect3 = void 0;
        }
        if (!accountsChanged) {
          accountsChanged = this.onAccountsChanged.bind(this);
          provider.on("accountsChanged", accountsChanged);
        }
        if (!chainChanged) {
          chainChanged = this.onChainChanged.bind(this);
          provider.on("chainChanged", chainChanged);
        }
        if (!disconnect3) {
          disconnect3 = this.onDisconnect.bind(this);
          provider.on("disconnect", disconnect3);
        }
      }
    },
    async onDisconnect(error) {
      const provider = await this.getProvider();
      if (error && error.code === 1013) {
        if (provider && !!(await this.getAccounts()).length)
          return;
      }
      config.emitter.emit("disconnect");
      if (provider) {
        if (chainChanged) {
          provider.removeListener("chainChanged", chainChanged);
          chainChanged = void 0;
        }
        if (disconnect3) {
          provider.removeListener("disconnect", disconnect3);
          disconnect3 = void 0;
        }
        if (!connect3) {
          connect3 = this.onConnect.bind(this);
          provider.on("connect", connect3);
        }
      }
    }
  }));
}
var targetMap2 = {
  coinbaseWallet: {
    id: "coinbaseWallet",
    name: "Coinbase Wallet",
    provider(window2) {
      if (window2 == null ? void 0 : window2.coinbaseWalletExtension)
        return window2.coinbaseWalletExtension;
      return findProvider2(window2, "isCoinbaseWallet");
    }
  },
  metaMask: {
    id: "metaMask",
    name: "MetaMask",
    provider(window2) {
      return findProvider2(window2, (provider) => {
        if (!provider.isMetaMask)
          return false;
        if (provider.isBraveWallet && !provider._events && !provider._state)
          return false;
        const flags = [
          "isApexWallet",
          "isAvalanche",
          "isBitKeep",
          "isBlockWallet",
          "isKuCoinWallet",
          "isMathWallet",
          "isOkxWallet",
          "isOKExWallet",
          "isOneInchIOSWallet",
          "isOneInchAndroidWallet",
          "isOpera",
          "isPhantom",
          "isPortal",
          "isRabby",
          "isTokenPocket",
          "isTokenary",
          "isUniswapWallet",
          "isZerion"
        ];
        for (const flag of flags)
          if (provider[flag])
            return false;
        return true;
      });
    }
  },
  phantom: {
    id: "phantom",
    name: "Phantom",
    provider(window2) {
      var _a2, _b;
      if ((_a2 = window2 == null ? void 0 : window2.phantom) == null ? void 0 : _a2.ethereum)
        return (_b = window2.phantom) == null ? void 0 : _b.ethereum;
      return findProvider2(window2, "isPhantom");
    }
  }
};
function findProvider2(window2, select) {
  function isProvider(provider) {
    if (typeof select === "function")
      return select(provider);
    if (typeof select === "string")
      return provider[select];
    return true;
  }
  const ethereum = window2.ethereum;
  if (ethereum == null ? void 0 : ethereum.providers)
    return ethereum.providers.find((provider) => isProvider(provider));
  if (ethereum && isProvider(ethereum))
    return ethereum;
  return void 0;
}
var Logo = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAABQGlDQ1BzUDNDAAB4nGNgYHyQk5xbzKLAwJCbV1IU5O6kEBEZpcD+iIGZQYSBk4GPQTYxubjAN9gthAEIihPLi5NLinIYUMC3awyMIPqybkZiXopc+xz3pvOzD4rlWyascy2VY8APuFJSi5OB9B8gVkkuKCphYGAEuoZBqbykAMR2AbJFkjMSU4DsCCBbpwjoQCC7BSSeDmHPALGTIOw1IHZRSJAzkH0AyFZIR2InIbFzc0qToW4AuZ4nNS80GEhzALEMQzFDAIMxgzMONWxgNc5AaMCgCAov9HAoTjM2gujicWJgYL33//9nVQYG9skMDH8n/P//e+H////8GBiYZzEwHBBB6G++z8Bgux/EQoh5AfkbzYHBtBUhpmHBwCDIxcBwoqIgsSgRLMQMxExpmQwMn5YzMPBGMjAIXwDqiQYAOQZcLsEClb4AAGmfSURBVHgB1b0J1G3HVR6497n3/98o6Q0anubBludJeAiTbYwd2gGC6UACBFZY7gVNB3CaJEB3VhbQhNW9OtDQkAYSIOkEGhJCGJrEBGzJkrEsT7Jky5JszXrSexqf3qw3/v891TXsvWvvferce/8nyabrvfPfc+rUqdq166u9d+06pwrP+/CHA3AI8RQRmqFxbyRliVdpcSQ9jj27IASwdAVHVxi7l65hcZAn6NlFdOOce4vCgB5Fc5iXdiN1abSFP1/2PrRoUtiYR/Oy9C9Tr7EwNVc4pwojTDFxC0CMI2nH8hwlhX4D5ZOvWwzy9cHlS8FlzhfwZNlyDN2pPlSXwT0VAtd7yTL8+SDuHOvCzzKdyOButIeuj6HfpTXtu8Ew3WD6NpjnALnFuI1IPB9GK0n5ZiCM9H4GyTJhLqAX1GHZMoJK70Etp0tK4nlhLqBfQF08CFnAgPrN8SHMz0N1YmjluYGwNKDnSeV5DEOnttHnpZ7fKBDyuWJWUHnKqWLUsgyaJ4WbjT2nDv56TCWL6gaw0vklrAv/vpD2mNcWrTpAI00+H9G0G5XWU/1gs8fBSCM1gMq/Y/d9BzD3WiqUpS4zQakyBkDQ6k7HQ5uZi4CgQepphJE66DiuC9PM57lcpsU1auA6Ul1Q1S399o6mF1qXFDq5NbyHqi7QoBmZ5wp8wdn+3G6o6qifRV0vQ3QtbxGwPUbT+RSXeEj/NiUyqQwP5BaIOw8Gl94HAwTKS0viXkk1fejeru02k2+jrNb1gE7d4GA7YwtEYYEtHyhN0HWh6/Q7AQV4bmidPwzDaF00rbpdGnHQqI+vh26LoPjNdQCi3XeAlL7zcaA6g5PYCDBqMup70xahvpK2DkMACmjVvc4904EFApL08dJgAAxVUX3OTEIlFcYYigooPi9fZ0nPtCj6fKPr+2MSD+fUARzNDBCJ0yBR9ZT6qjKC8jRImcxfvuf4b84pLXBdsG1bG94pLSL00i0taHpdP4rv6XnoOiut1aDSaCyYI3AV7aM29KAyc1QwNqSyZ5gHdEcM7kbyaAXfmOYg5vaF2MrQxCzFGFZ3Oj9dH98xPc263t0YQKAdPCA0CHxn1CDo+Z4ysSQvrovTPjkksHCdoLYDtOpCaY3AAZgvYBjABFShWdGfjs7VKcepugSiS3dK/6vt80HHUnVfalA4b2CHDROCG1uDmM87dd4Cgy5HiG1I2OB6uwEC9VhOhxosytZrSSAg2nU9dZ2wRT+MaB+mXwdtd7pD6qJA3ENtQCOxAYZ2d6M+Y3w2dQEL9rntQXXSAGOaO2f+zcACGZVwMRJZ5QtULxE+/OvKHAvTFhMs7bZx5XyOVNZg7kAxT0nkTkmNVNFunoRz6rZXKi4xxvR2YhoDm5ntJRxxroJhBMQtIHe+vj6e8muBTMwKJgFqg/eUV0/8aNWnWRfn/QBV/gDUrh2w0Un9PZMv063axEtfXxehn/JhgdNzHRoDQM2fWiU12Hb3OMyV0K3KeDAbadUA8AQsIDqVRqS1VndOOoCuWCBmIavgdE0MI/D2JCl61eAi7RSYWVWO1Rddp9QN7evQAnk5tJyRUgemknQ6rgMfyozyoNHqfTDo1PWAtkQWuhttxveB6lDqpWtQz7XG0HTqw8fNFF3mOWU+5eKcRNYSG6AN6qk2wNHZKWJPkgqQHstSFZxUpvOJZhTlNaHryQig828AwBFzoFQ0MQ8ziDOYMTGhJ6akhq+gnjGoYWjD8YBEQK0GFbrjAYyD2AAhd6KSFQNZQBCcOMDaTj1wfahjgjU5pB7U2B1UbcPqfCDJuC6qzYxWTPGR3xPTBqm9dD1R6gLAHdO2SSDaU6MJX/u+CA3XMWdES0edk6UzUr14nNDxs/QrfnPlANBSnmkKCsNTQ6gGk+r1A3uR47ykggrmibrWcRbQLOGGErEVqkRT6jjm2qtG5/MJAXwGwajApunhB0QODFrTtECd03VWwmk+1QqEobnBEjrTXkDOkjkBYUIgSHGmkyIaST/wCuCQnk4ETW2TBOSBSei1UkMDcJlFkBBPu0mhnwA6I3BO0nlMs574SrydoRt7Qe0A2VRRYDbjKIVRI6kpvpgcaJWjrkCnC8Wh50I3rkhhdT1RQJ5AZaIBNjZUdqOHDtSub2xEB+5YTpSQM2ApUk0PaA0wEF3Du/qBBcBE1Vnbn1wXAKtxuNzg6qCBrTtlp0FO5Zl0YMHMdeBfDUoteSe+ftxhVVov3TWPQNOv24bbIZ33SaOU81mU4h1pmBkdPEBE6rg6yLgIQAb1fvAbPF0UN5hY0b3GxI+AWYOXwTzRYCYglHN7TzPQgDoUM0QTUCUrSzEl4bCaGTOodhoDPEvr9Gwo5kp+tsOB71ZLpPpb6DYN7+qLyBpJaRwYDqiCrouugx8HxLqzNJ5BBbnutMYT4iUoCYNkBhWTCJrmoBU0heaJ/Or2BlUbMjWAgdww9aCAWOoQUnukMgjY8VgHEBM3g5qvCcAz6vxsZg0EkBIOmsfW5OCEKpGW2PMkM/fwdD51gJ4OAA71GfRmS2oAa9MOJxpIMkOpeJZiufGKqVFUNWSmiS2HKObKhJiuxw8AUMtnerDS5U2nOh6gdMD1YL5hFZYChfpbxwDa/scMBLYnRf1C6aCdgF55CAhMpmWx2vBm4Ad2LMNAnrTa1LW/RkVQvz0SqEmbzLDSOyOAI4E4CyqlTGYAYusz9tiG7uhX28/efQsNoFsJ7aTVIjNDwAkV2CsUxyCepgEIn9MzU8VII6mBTZxu0Mm4LxZgFk9HH9hOLoydEUNnGeCJjpAlQxo4zrB6C/TslkhodLYmWM1R60qgRjAdskq5CuiuYkB0pAZzoQVIqiHVAXPdZoE7axBg8AAraFDTL41ATVsyLRMPaAJz4k+HOJDURZr7+tiKsJZhM7AnwTIjzZN+14nvqdz19BsHjetprBH6iq0krWO8ES5OUouzAut7MQxs78qbagaAIV7hSR2+FwuDSBJPiTHTzsalgqY0us73FSgK07vCQG0OKsIDeQuyT0M1fC82clFjEwZ1aphQ8u9j3myKGFCr+gFJBRiRVtV0AiPhJtToDPTKJwvu5KGRupBUyx0T2EYO1VSCamumDjkDZUqxlA7VG1AHuEPtqr0YRiKHInSqhq0dtQ7WM+VO42DtlCylCdgzoT+QidFl4dLFmGw/0zQ3BvqNQM64i/HrDNqgXsrCOkcR9GA4uPc7FKiH73JQZtq3DNBQXQrMGsgGxJHQBOQVD/RScJVwWCUgWEEjhBYGBlHB1b5ij0Yqm+w1sTeBwIDk4bAN4AdTnZNqbFMycLWZNAUwEk1AQLDNT5PNL1PtSH+oSPbozUgDyYAqJliPfzU41sksYcnNklGm+509WQFNNjSoekDxykwRlLSm9KFAll18bIYBtbuRNsjjGDVucQIl//ZdHiCugRWWeZzUB4lc122OzMnqj0elVVEBHxRd1YbGxswSWneOPrRknjgJzQBeSQXEXlriC4jzgWAGi2xf8UBjU6zohaurcPnmzXDhpk2wfTrN6VJYiww4urYGz545HY8z8FQ8nl9fJ3VTGmad6ElgTnlP2FOAIICBUAEFaAFQzQ0w9r4e3IrXgyVYKEp4c6J902a4YssW2BXrcIGifT0mObJ2Fg6ePQvPpuP0aTg163MjBCqnF7o7GkwFMg0YLKTaMZCEZ5+8FUwMYgxBBniTGDPpap0Sz/PAkbr6aqR9T+T3ZYnvkfYdK6uwQoPztShNj6yvwcHI70OR/wfi71oocnKSNVDRmKklspuuLzRnV12H1L4I1P0K3mKesZoQLRAxwQCgvl0Itl49COKNIBLhBM5tJ+2Lbb+z9zUXScUgJRBHBqxgjVtByEcBeKxsVwBfGFmBsDsy7y07dsDrLjgfrti61fiijXoBG1Lc/pOn4LaDB+ELR4/CExHoE6h2bx6ksInCg8v0r3MAgDqZoDutsZs7HhBSJ8y9IsDO1RV4285d8MZI+1WRdmjQPhYeO3kSPnv4MNx97Dg8d/ZMAW/uOB3Z0oX2DBJkSVht7p5MFxYG0oaBtARWLcJ1wcD+4BA73Ap89a6d8NadO+G6bduk8y0KqaxHnj8Bdx45DPcePw6HI8iZ71nDTAqPOnLfFewEKLosZDv6LCIBtmfXjwCbQd0pHgplJJmDaT9Kt+MjHwk8KzaQ0NAYAPJvNicSgK1kLkeXpfCKiqu2NKu3ItleFpn4zgsvhOu3b4ctkwm8kHB6NovgOJLB/cCJE1k6BG50UDNxoQ5okMSz7rzae6HtzokAuaS7LoL37ZH2V5+3HbZON/w1mwlnorS668hR+EwE94PPP0/mRPWArIdgBl3F2xGMXz6HUA2PjqU0qAF3KGB/VaT5a3ftjkDeAdsi7QHOPSS+fz7Sfnuk/eHIdx6j5MkUoj0da3Tocx233vO9XsxGGUuE6n/n+vo3FLOpvDMCWrtl6mDASWMA671g4HYKzPE+S+gVksgrnQI0VKYmc+JvXroHXhGBPO06eDFDqmgCx588+SQ8dupUUUuIakDGDAABM1uKqEAsPmg2LWg0tCNKte+96kp4RQRFt6REWzakBrvv+PPwB/v3Z9Ok0A7i1eBJojqrCKJ1St1BNA2bUEDSOMTEF0VT4u9ccTm8MWrDTS8y35O34gtHj8EHn34q0r5WXHohmYAgIE6/ZxuA1qBOgF4nQK+HOljWM6UMaDZD+Bp33Xxz0CaHnhmc52NOYNbSeVWBd8VdywCQ7Ll3XXQRvOfii7JkaIWNSosxSCVb+2PPHYQ/fvIJksQo7wME9aAfQ0xATUJAsTETs1L811+4G755z55RbfJi0v6JSPtHDhwgW5VnRosZUj02QTSOJyKra3LzrcZn3x35/k2XXAI7VlfgpaT9yNnE9+ci7c/KmCWZSwLoBFqwYD4bO0MaNM76XtLMwIGaB8TpnREqS795mTvurltuCaJuQzBvvlW7y87wMWjT+aoyMzKQs6nRxQFGBfOUpNv2CIIkHb4q2msvBkOXZfDnjhyB33p0b2Za1j7Kfg5gvTnFi6EnWbJ+jwDu4G9dfjm8ddcu+HLSfmek/T/t2x8HjzOlaQqoxdMR9Dsiyk/bFzAngfM9V14B74yA/nLRnvL89KFD8B8j7Wtk+qUB4zowgIskzucB5HyNJHO6z+aKMT+CMrNC48MHA2iwgz8D6K4TG9hIZgEzCLg3sX0NNOqMBe6Oqu6HrrsWLo+j/40GPSgcY+BY4LTPxFH5P7/vfng+AmNKkpols6TDAuKJPFsAcX40MX7k5S+Di6IHwOcbXkKaOSTT41cfeih6SNbFF6xfudQ0VDdnAcN5UYj841dcD5cpvnvazoXmscGuj9sXTb5/8eBDcCJ1yA5zR0yS+GwC9qzPQD4DUCV1qCA+21vTQ3zxLVDT0XkwyygZ3bsWQC4eBOuLJjuT/bJTSsv2cpIS26YT+B8jIOaBOcw5ACzzwxLpfdqLIxj/yateCTsjLezDLrOWoUz6xCN1wNUcTxM+8cGdEcwfePnLDZiXpWEjNM9Lm9x/P3jttdF2n+aIRHv2HvFv5j/Vg/hfbP0p/Nj1L4dLI99btL0QmmHJuOS+/PFXviK6AKcZC0lIVCFZvDlm4goAzNt/+gDCKGITsymY2Vk5x6HbLoOYZv8Q0cyUsSuLz6eB3paKPWwaH/yxCIjdDhAA4yB8oWEsz+TT/tFIy7YotbJ/FoqfXA9icx1K14etUdP8wHXXRdpXR8v5ctCdQgLlD0RQbyVbMQsNHnhD0pQdTV4V03FTbKvUEa9wbkRd1osdxvJMwuSHIh+3RH5mUCczKJDQwzp/IJNYIRiBarCovEwcPE6rVG4k4BlCfmlHu4D8Sy/sh8xqi1Tf9111VXTUb5HWCvqAL++RQmrg74r2JKT3B/o+D/hEYkDxj2fAxOM7or1/6ZbN0lhfrqMfof2yrVvgu6++Kr8TAQQMkWpQ/L1pliIB5TuvuCLWdcuXnfYW3SlcRXzPcQqU5lVWsO/PdAp7nZPMgxluCnV4pG1JgIGETrf1K5R62rcQRUzNPE1+xB7ee8nF0c+5SzLVFQwNTmuwvxghjFy/OQ7s3hcHeOkLizRb1ZG0Tu8cYF80y7suvhjeSIPXVj4vEomjYYz2115wAXxDpC3RWKamifaYgGl/T/RkfG30j4/l81LS7vPX52+LfH9XpCthIwuTAFkay3Q8VN8/v5ZbDmhaDC1wdwMgq0FhzdD2EHnHFqDOygHbL2UgtXtlJYOCy9Ijz6B+5RysGmkBeyMNEUae4eu3RffbxXGKOvFWXm/MXoEeLki077lk8Py5gOFcaB4rj8+/Mfrvz4/2cT8rHbC8OlDAvCvOuL7z4osG+W2E9hdCcyten39LpP3S1U3lDUEynXhsVj+WAPNujFgIjEXKK3umDCaR3zdBaAE7hQ6UkR7Um1dQ3+LStk5ShcmX+LejykvA4AoxOMNYhdGCXqQ6Abtn6Q3LHbAgPvnA33fl5TCLo+9AhfDvt0Xa03sNPh9Ysuxl6Fg2bav8RNu3RA2TrvI3lUR3mtj45ssugy1q5u/FouNc+Qzu/LyIif82mnKJ1uyfCEraOiBrSZzGb4IxJZH1dQG2KlQjXq7pqvYO/Uph8QTwb5J2aaYnzf69Kc5E+RoGOg/+gJGggM00eft7meAZy9evjur7+jjb10dQJ2CvR4l37bbtMf78QVqfz5crjJX/hl074cpol84izcl0Sr9Xb9sGN+zeJWm/krTPK+/1ke/plYdEM7/fzC9KCZC1V0OeVBIZrEbnIINCbTvbN++GtrQBNhFUZqSi37CfwTuiAz+5YzJTcQnGkgTmY9DjvfSmZzY6uHRF5uPN0aY7G8GcfaKR9q+O6ppnE33ar/QB7vyrI5+TPbq2Pst1+Np43QLyV5pWH59ej/jr0aRLUrr40QO9C88vMhG20L71yVhMQeNUBzOZrxN7/Egvol+2oXMhGVTllcH0rsCbd9XB1DKAA1eWGRx6JKrE6MySdm+hNCPlJkm3ParB9HLQjmjbXRslNkC7cb5SoQWQFF5NLxYl2tNk1us03+ErS/uA38Eerzv/fNgZ+Z60S5bSYSg8BWuUZwuT4OI6j3C9iqjpHfyk8QNW8Zu+8k3S+YZoamzuJpaZDqCtwd4ouAFGvR+BEjMjFqVtSY80A/raHTvh9NpaNjW2OvtT/4LLw9/zYUEfW5i2Va4+ki39mgt2RNrX4U27d2fJt0g6Amyc5jAvrQYqzOlMzgmQbOmviTRnKd0HSay/jClvWllvhuDVu+1kzDdyQ//1lCGpB21upJ6WiHt7GmEzfaqiwgBo91h9T38q5cOoaYJDcoNKp6vg6bkhejwSU18f7U//OuY8UMwDzyIwLpMWRtLo+K+6KJlM6/CGSPsi8J4rzfk6WN7XT9nASqAlAueb3HjrNAaQdesIECZbusWYRBwvrJgcPBhEhwh1qW1oLUoLcPpsbqR3Oa7Zus2+orlMMOIYqKcOogwdfHPgs2ZzREVpid2i6Yrt2+DKaGpcFgcqPixdh69QuChO/FwaeZ7q4MMLpd0IHGXmedNg9Hn368PLIs83T8qSDcnlmIM1ksupLgRdMu2hQ2wsY8CJWnlnFcCfvDCxxXZOg5Mr4/RsNufnSEU5H6slMasPrmyowPb0ttKaHsGnrYehfLz7/a98BWyaTJqS8K9K8OSn8+Si++HXvUZo1/LmnGhXHb8lCJfOM7QvjQ0cC0gfdtx19BgNxIORXg0cm3P5rhBqvQfvcmAjgzCH2rKEVcgumEs2bR6kNwM2fQ5O/XFd+grQfA9hYBer7IRWbUMbApwo8WYIh0u3DT+d+qsEZg7ebEjh4q1bBvc3Srsx/RAA8RyedXlou9nPMbBQ27N5c563KFI6qDqotwiDbetyUgnUpE45A6uiw8iKlvy5ePksP3+wG4BeVezzSygepIqmltC00tql5xNDiQNry+LQeQ7UFXeKAYeGQUu8ZVTruaSFBenH6FgE2IV0NDr9WN4BRm4w/9Hauj5/LZUlPQmqHXFwuN6XGc8cJ5KvpA668jqP0OZANTmCRwC6HqJBXpbVKgPR4ktMZsfO6LIbY0aABpBhhOkuk7JiZTud1BXbWTSqpeq0iJBmXxsN55J2o+mXSQtz0hqgIcylKbQyGbFpwlhGMJBBtU2gzNjmla7y6wdxcIjsqXEfwQawcxojKqR+A4X606QqDyxYaPlXypzX880zVfHgT96NdG5wtRJllmVogkrw5/Ix74gEIddKEyXWQqg2dtBV9OmXCBtI+pKl3UhoDZxxUVqvQkbas4X3VnwrTQrJbzyjl9nSnbqVSC2B1zSEUZpraVO9ZpgRYnrWAvVqOQRqqMtQycIuDTUwhmvd+42QNBfjjGlpHNTPeomsymxJa/ldwgTxfWHs2WUat5UNwNDEOJfgeYwNXrQGS0IDQ2OJCmi54mmw5myNSD/5S3bCDkthvY43Y80WhgYAemZX1uXwRJjtD/ggiSrrytFUJS9Ntdb3g3zsicqfajSo7AgnWjakUV9OOiMo6Y3OjgtOKyiEaknuA7rGsDcd6apcHwZAddoE5jy7LMq9jdx8BNtpuYFawqiBfwFmq6eH8WLzvfTuD+Mnf4zc1wWBAjWG4C/Ubwh9EEB7kMivNkEALLAlU6xfIMfrQ2fOwrygwWKkMcVBsCCE0KDNSxmVN5Fd74V2A+j7Uvw825oBho1ygorXtGObJtN/VL76PuCweB1QlTsgtQHkwQCYCup7MJqMXzBbpKX0SQAYdGauc3BpMAyzPr6+Jt9FzqROdUGg1rs9GZshGHwyn6ZjBGu+lAWoSwHF7KjL2aaIQIXuP3lCAGEc8uAq54HrCmaws1aQ4FoX1X2fDUtIkZbqIS2dg6s8qvOA7lmwwJdrBa65aVs0jKQfpNW9YSRt0M+4zqo7aRPgUPntaWNBpNtM918tBExnVcW0tG+i8eDpM/myeMxC9p7NNNbQdSLXiX2Y2loHVwt+URTM7J9soQCgtkwL8PCxYzZ3lrrQICLYiqP8aUgc5rCTKMF3UXAA1M/qcnF4v2VqoEqLwdanNXtViXb5jkk8Fy9pcTytpFEAb3ouNPhCOy8BH47w3AHID/SDa191a3BtOmX9gX0nnidMlQ8VeACY41AJR6jxY9u7pTynLL7NGryZWDRiP73SVwqoawLnRbiB4xAeTUtYETe0lOW6hFYtVY8HJ0m1JNeSkxvJ8XyYt6LBgEpJHANULdl0owebdlAejv9ii8hGPSUtzEkHVnJL3Rp5SRZhPEsxl9x90xah/SxHDPgPDUHUCEWDB7jr0GGpOO/XUsZpYCS0frfHrO+dC6x77ph3OXSFmkcI5uWU+hJRaeWT6zP40tGjlWBVcZM5MyOoHti6Vs9YOmqcgF3HaSkL4xJSD/JETTcaEjXQwdWlBdRBy4/ELUqLjfLcuQGzT9voOIYVaNvItEGjOAN0V2xwYNHtxGj05Dx8/Hgcd52Bmiw4XLmX0EKbxRrYHYQxTquKgj3MwuEApJbLikS3PP1UW2L6YlABERxjW+USsz1t6PI22l9JNX101H99fOvFG7nm3wD23V2+9s/jgrRjecNIOWP0wkjeisd8H4iPqPjX7Bz+NrWFFgAtkOnnTMBKiw4f3L+/rBFNpq3BWAB5+V+RaPvpYGYo1Hc5Br0xhCaIZcX5YFe+LEtsdfCnjz1e1mv2EgOlzLoCaF/j+De4Hu4ldx+cNACwkhpUgxIgOK2Ol3vQAAo4oIzdw0baMPIcNs7DAqAvQ4dLq4OPF0VsUNEGS4ARgOs2ChbUrUOeDWDGYQkjH3v6aUCqgDYtZgrIjDcWnB6bPgxXS5TBoAO3KhChuurqCv8F1M+cOg23PPkUfOtVV7KWg3pSOaMlMmgm4zDeMFeBeHRgFm8eiAPUX/uvN8Itd98Ljzz9bHmJnAYdQHUCfW5Y0GKVC75OX4GAjgGI6pdGl3yetNLVl1wE3/yWr4L3//V3wJ6dO5qg5mphcKBs1FU/Y9pUxfPGR3oskU4/8sST0YlwHLZu2SQTI7LhKNTtLVodRM65/VT81NOq24l3nLITLOU9Dl54G4mxefPytIfKpIM/2/84vPuyS2HTpLG6KDa4xyBtiASHU0D9S8/pdk2ndzyyF3783/4ePPzMgbL1wuoq1YfBqlbsDB7AwXSa5cKLhWzceCqsMSztUF3n866k2H/4KPzGh2+Gm+66B37m7/4teMdrXmUpZyk6B+iDENrxnkYvqz74+OMZK2kfFiD8yC6yAAN7uXo6lM0DNk0Kxm3H6omEtAUwsi8aRUqXtdgrqvKn5t0EbjvwLHzi2WfhGy+9rPoudal8GhYzh/2ixdNimSRpCPgp7dNHjsBP/s5/gMfi6HnTls3QTTrgr9eFKUEDur3Y4cbDQMYtkR4b58uHgmVU1ygS0KwBR+Ixz8LF2ZS9Bw/Bz/z7P4Y/+MkPwIXnn2coCiOdOYTlu62ZA9BgJto+9tRTcMfBg9CtTq0NjTwwrGt56y9jqmljcaf5YTYNkiZBNhXQVLIAuSxAy4tts0rJ2wuThJ5EUP/SPXfDDbt25w9PTd6qsAANldaQ0uLvbIlrVaf08zt/eVtssCOwGsE8XZlGQE/iDVkCR9nwQWyxcnPcLvurGgyUFS9kKwoAMMsApO/30nINa2uwL0rrf/Whm+Gn/vb7hnVWPAdoyqMBDUGZE14ia1v+udOn4dfv/SL0Xfr6e5K1esDi/O1J89e9cJwLD6qQLQJMVZqk8HSebPAyJEAFcJbUNKuTpTP9TiKAJtMJPB5nDX/v4YfgR1/zWjOy1p0GWtKAJQHdN+mGnXLA2Q994V6YblqBlc2bIh0rmR7eT4VHzWIfkqQmWQ3a1Pr/Q/DbaeQ4GvnJFhRpu7wcn+od22wWB+y5k5+FW+970OQnPGAB4u61QmgkYsmsaWP6/t9H98IXo2t38+bV3DbscgoaxIRP3oexVtjZlp4W0CaH2BlhUEGZfqSK9iSlda8pNkiXiVxJ77hGSfDvHnwQrty2Hb7tqqsNogNn7mgzQlqBGHUicNJApU/k7z9yDFY2rWa7eZpWbsoSgF5L5IKdk1zAremDNsMcKXNDeInSChFOl5PlXPmFtF5cR1I7DeLTNlhpQ6J4/vjhozUrJYb1Ng/6RGNA32e6/edP3u34l3Eg+Cv33AMrqyswjeOrpM2hKwLH+J8DezawmhoIRuhUPljMmlFbq8FEMoeqzvI0JZQtEpAkXsZzUh1RVCdCp2m9iPUz8M/uvANu2L0brti2XTJHpdKQKiGMUi1rOr+Xzq4XiPaJHapLpkZaS3lazA1WU9zri7M+iATQqkyX5XnDHaf1vgNAm4e1OkPI6mLQp9WFjKBd6hwqoHl5NqzGdH5c9u7uijadRFCtr88smMGaFyw4vAbVNDNtehZVDgXmJ54/AT/56U+RwEuAnkRaJlmjyN7lAOKA6D0tMAR0K24KDZ7lc2r0uksnmvqwlObBGm+VkBmWiY5Xqz2cOXMWvufmm+DfvvNdcP35F9AmkZYo6fTEiWDfQm2/3O2AzDSD9Ppim+XdmEKdgSrbKBd7LZUle3SEYkblvLyNpKSSLns0YCsNbjytL9NlgQElNQOnjHOwbBQPdQHxkjDfibwJNOZB40vWRQlQwljZNVp2/3XWAS/X9cSJk/C9N90EZ2K61diRVnhsk9sIaG9G/R50FTS8G5h8Fui0g6Y5hc7c1IMk0lu5PtTVOHPvpzbraEQik6E/nRbTI1XgWLTb/v7Hb4UHjx6pPVcfjpONCaAB4b5Ckm9Z4zcDOm+yQwxjpuV9s9PCuVi2HS4b8WBNg/W8z3sFduZ+jW/FdYP82mnxHNI6OmIdNK25LnIfch3T/bQ7a+nENW1S8XkgNumsKefaQeJY7atGD475DH7pXJTggcOH4e/d9JG8WedqBHI6knTuJp3gSBcZNB3KzNCf/8EgroYpqFGwF0b1RR0U/SNTkYhkhvB+00XChdz5yzYDsBIonwDPnj0N33fLzfBPb/gq+JtXX2PVujNDRFqHBoCVamtpZt2oxT/Oe/uhbFzJEkBLAlMO+g7TkK7YkKI6rWHkBtKCq5BPjzpLvbBmbT9eLVb+kOTgvbtzW3WlA4ArqmVe6JccXbOZKqA7v3HfPvi5z34Wjsfx1OYo2FbjuCZJ5zJQ74rggerVYJdw0fb1qyiRcoxB3wkVhqfMS6cxABrXtQdVYHPv7aUiJbfiwpvStG5B5um1s/Czd3wWnj55Er7r5dfDedGW0iZIAMs548NWNKBOr86RmUEHsIQOxcyozvsuL2ySpTiZF1rFNqXPWMAN3NtI2kacviQuS4fmMb0AHRU/gDs6zR1QR2cV7sHMJsigo3s6sJobYi/H4+jZM/DnceLkf7/jzuzx2kxATho7gVkPTGWvcuqsUi7jF2AgtT1PNG3NhWYM0whY+VyjP5SlDMoItPai6oHA7P7tphORGskaOLO2Dr9y793wx48+Aj/+hhvgXXmd48qcAahYuIVKQ3A0GymtGhDZrMh7pPO0Kt3vOqG9NCC9P0CACE1mgJK6MB40gWGDaeflrdIiEYNQec03i2sVqRN38tyMUicu9L6OVDc2LTy4USdDa1boLD7zzDPwC5+7Ex46djSCeKVI5vg7mRavBsrYpjzBZoN0Iqz1GJC3iJfQeJdDp8fGRVCMqB8nltlEFv/lHY+ySHXeeWVSV2fn7eGeOnUK/sFtH4M3X3gRfHeU1u+4LC0yPjHdrSWB5VqBWDc0qywg27MyivbHBm1ysJkSiO7CgaDz9CDrGvdAXaOLgzlpfZqxMJJ3BXX1bBThwa634oPONjPUmThklU6SmkVgUHQEHQfz+1paV+NjTz4Bf/rww3BrnAVcjUJsS5TKCcjpSJIZp8WrUex3EiAde6CoDEQZ2LIlUDRkQ8DAkK0pND/B4i/BRb2PqMNSKGWJaGbeOJ8M7OzIR7OBZ1p+ay322LsOH4Q7Pvks7Nq0Cb7lqmuixL4Krt+xE7bweyCKaiEFhxI7aNpp8ANYJDX7oYsqq1+r16lV8lMj2spR+lbdze+8+EVpF8VBlYrlHBWJhSPsnWHPQpXQJR3PFmY3a+Jbj9U+cNXrnYT2gQVJAvEjcYLkxsf2ws37H4f90S2XgLs1zgGsxl82MVaS63SiwUzg7IY7+labWZXnGTF2j8LiHde70rih2TDV7uGepCdoGHCFoR1lR5t2pj3Bk786VnatW4Nj62vwOw98CX73/i/Ba3buhn90w1vgDbsvqiNrxUwPbFR08UieX/EKaNcRoW+L6QWroDoGCkAss+iLHlAdRvcwGArPSh89q0yKuWkBqixqgUp5BWyfIdrJHu0oF9GgCNVTRav29B2aF314QoNp4l8Wavprnk8+9QT89r33wL0HD8GZfj0DN5sWUwZx8WQkTxeqyZMwUDGoOiWohgzDSoYhL8zkBJ2bdzncyGIYjLejlCIOfCWpAar3gPPN7xbQQjRp0iNJ6TWoWy3vXtkEb9+zB959xVVw+bbzYOvU7ketgc2VNUKVkYEgHpcisrC6nGQQRINazZScB6qBUjD15iv28zINoOJ1lNYYAezNABbYtmrtvJstQhJX92jdgUHbp2xeUHygjh+g0q5DaERw3F+79DJ444UXw31Ru378ySfh9gPPwoEzp2ETSeTslovnub3JfVqkcjUltMYx5xCknaB5rhpd45TOp55BzaCYY0ZlWlwEqC48oJdlggKNPE47amUvCMCrdu2CvxHt57dGBq120/rJTbDMNLadizNMR6RBBw9AFHjp+WK/seYJkl0gaVwYr9A3KKZVeDv5RtLOS18lGLi6IzC1JZq0ZrruCuDZwigdPNW9LLnVXGc5VPzojqabPGmArdE2fsvFe+Ctl+yBY2tn4IuHDsGH9u+HLx47UvaLx/IFk3QiZRoZ/57vwFxRb+uKhaBxOORgc1CIMGSp//5uUJBIarAtpVpCppbjvws3b4YfuO56+Gu7L8r3+c0q8I/6iwaILT1l4oBGSQPnuwGG0Kt8mxnwCAohoKU1UqfR/dkIEh8C2nuhLRPqPTRpAXU60g3iuAikPVhSS2yFeadJwWreZN50ltRgAayBDfqaeMUvqp2/ugm+bs+l8DUR3HceOgD/5oEH4bkIcp223XnRMQGbKVuxHmqcxvih7RMoX4KjtAC9DxCKqYE4LE5G3iqa7dfEsbQo33dffS18xxVX5+18jUTW57XWVkUH27HBVaA0ElKjkfM+qA7lXtDGvN1mLSuHLpjy0XGnIdeqUBkJvt04Lc5J65WgScPI5tC18iquVQSe8QVaSCYR0NkJCmJN0/8cwChvXo+QvSkyEI0Rb4ua9g07d8EfRz/0H+57nFZUqsANHQg2mnWngpDOMVRXKig8tviSzo0fuiWZwT3APbxcl0LQi3+XSa5U/HNe9Fz85KtfBW+Jg76UfBbA+D39wSG430ERWrqWjRXJBYRgjewuI0kkMNh69I1M2xgdioA5WG4+Pf+uLdvWm7UcKhMABCXycr1ko1qVToPSXgbAI4JEYYmAVuLLuiwwCJtjO3/ftdfB1du3wa8/9CAcm/W84WWdETb2L/+xqo5BDXpQDvP5JyYHKoNbZ8T3cCQbrBlAVYzCk/IhQBxa74l+yZ97zevg2q3bq2sogJHQ5hdqJtzJW0HUpLRbJ35osaeNnletzVIJQEkr1zkVHca8Gr0HTg8uEN1G1CxoLq4o6t+guF7Kqnv1odDGg+L8YlJP2qthjgXNE1ASWl3Ly0hhKGR6dfH2iy6BK7Zug5+OHpEDZ8/mWWQ2c7Rg5NP0spVwQN8DaJsc4kWisQ+03HZa2rLNxSYGQEOKq/cJlE0UmNXx2Uuib/J/ffUb4OqtWwXM/QiY5V3cMGS0x1MLQ0H21sU8wma3ox4to3JXFcb1ogvZzRbAlaFB6wE8L8zrjc30uDBv3dSIxUmHZD4hMUrkS1fbMGutbC90xQ5HrPxXgsT4oYPjf2WjlMPP8cJDoO6njUx//g1vhH941+fhUHTN5o29lamErYqhh7Adh4jJYdxc5bmpj5BfY0JY6YagdpNlVQcsjOoL88npeX5k3v/5ujfl7SqCA7Ps5qWYKcwYntbrUM+Hn2WhSCdWbahsONMiHM8vOoogx0Wy8q9EQP4rAGBxE2rHEMFdUvNsXK5zN7/niI8elHRW9yQdHR1Ld/plMi7dvAV+IYL6A5//HDyfHOFsCmqLAEBwlalDmnFW5UubaPeyEr4pzH2XgxM2l8BqPUeABQJzGgD+WJzW3hPB3Dsga6kMYNWbzm8ecaH1y7NRWkJDxbKWLEkqB6xAyA6+vkqA+XyBNuJH9eNI/EbyCPayaht1M3tVwlDFSGU64g00KyhtElyxaCV15k8Q2ZGD2NRKg/KA8cotW+GHr3sZ/MJDD2QTlN/HblW9OFpxXvVH443JYfdVrg/o32GoAxEkRCbpnDYRev+VV8G74qh3RvyVjx6DVW0M5EWgboGMn5FBEBKQlaRm+rVG4YmXOmaszn+v4kYDLhGvicZzzMPFockbQcxBJYmLAGqMfZBMDuyabjvdETS4fZPoTkpkiCFhNn2C2jbfFN16Xzp+DP746afyhBroBQO5h5hCQMZvdWIsGHb4ybHpUjzGsXviECKi6POmWRkEfssll8rdwYaNAYy7bOA6WzJ47PCAkO3o8oEsyzOa9JFrkPNiawcY2GV/BUMFNO+HbU3A6glRTwhgqKPzx6lKW0q2MJwTGITgzBBqQ7HulPmhxeh/d821cMtzB+Bw3xfes7YIunbBncHgeuzeYFs3YRS0TArbOwYVTPZzP4vM6OEfvex62B0d7t7UGAAbykyWH1mbQzEPYHhuAzUUSSFtS/M1H2VNiI4kujs6d+jnx9K37p1zWlycdkA/A6Q8i4Zm7uz10zTWUF4ocOgd7+e1j1l2IKhz/RuP7ZMV+J+vfxX0eQfZWRlrkVoWM4qaUVNWh3fYanH5nXrjXJ4USVWnseug0Kk9ILdJktDRvnjz+RfAW3fstBUMbXNDshgisxmkh/ruyT/80g37rrCtU8oFWXjKLBHN5gtONh+oPj3kay2LPAtBO283nFY3Zn15B3X7gDSRekYzQ8kxPRWKlS8esADtpgijF8N0rOwkwvHzzXHi5TXbt8M9J54v73uI6w0sr5qmQgAzsYI4tKFReTcqb9BkI7OFRtgr1RbKyjzrsxm8N/ofJzQL6D9Pp6SGgWBya7d/UCUX26kt1QXELK2okYMbrVRgFy8I22KoO3cj4AbMkRczLbbSq9E+irnU0W8gs4C4xun5fWQ2O8AKFD43g/URAHuQ61WuUnHyNT/3XSjaOEpR+PZLL4e77v9iERSqg5VHEDS6ZfYwODMDcWCC1IkVIcy95Ic1XoM5AMggsDCgz+bGZdF2/oY4EBQprA5tZoxJZ31vDNj6XkuSAgNUg5pEmbz8wxKM/LPS4AttaNUxXtKgy7Fl6rZiQAfVGUVrsqKiNmKbuZoxEzCZqnWcA6g5AU0WtinlW/4LfcEB1inzBOqv3r0bLlxZhYNRAOYPQeT9GX7jztY7SAGqrEZbdbBsUGq5UkvgTqYGSee377oQtqaPIIP+LB2Mm24emD0zlr2WjpDaU+xFqIMOusZO2dHs1tMLRstX41jvdapzmOdHDnTn89Jj49rRhnw+llbFo7qHavwQlLEs0hnB2MEBqubTkhX8NcC4hg1Drcn5azxcsLIC3xy9HrM05upDNbnE1aILC0uLkMUv+EOVxmikcwDRDInYtHliNPT/mz17bCXCEMQtZkAjDnWcEqymyugliGtoMTPUr5zSm2qctndpPTGtc4ChzD7XtO5ap0V3L5/yC0n0joShHVUm5rrUtX7eVJONfZQMYSg8WjS2Qu8S6OWY33HRRfBvHtsLOOlLpx18V1d/gzIFw5zy7KZBriba3PDACvKbattnQG+NRL32vAvs5Ik2ORxj5klnVRTRB1Vz+oQaBB3NGKRGS+9Dd0oJyeCKPkmCMnUcnA0HG7B9XfHzQ9hY1rggr/rKXnnpCrlRsIKgY3OEHhETjNfm8HlqQamiF5LiyAoj0lyPn14dsXJB1ObHI3Y6Ze4FJbwG5bNpOBKmJoE/x0Ym6CrN3o1I1FVxNihIPAzUmSbOMyHYrEcFjA4BGpJf1KlSxYoZuQzj1cAqybsRCb1IDPm0sGR6nXaZMlxDy/MdGmbkAS91Ho378kxXPUHs6XBFDMqcd3+cTPMrOLCkwuuiR+y2o4dpJ1l6E3IseHzqXwplYqUlnRq1rMCriM5xaZnWKH6v2LRlkFayCENmhJFffW56Png6hs9l6sh2lKqoypeGxkGvL14P+hpPNXTpAG06TJpavPyMpZVztGXk5yhikNbRUYuiiSKPA9brA8mgvt6RASSozgADb9QYqNHdGhM62toRgUeRaUq8P3woC0R24dVdrtCqaHFV4qBcvh68D+0TDRpGIbMuHl4k9OVbNksluIB+RDpr4C8bWkJs8LwaELHZUdIRc9jNhUoasBpOL3KEKqnH+AKN61Zj4pxrXPD8vLRyHqrJkZtYOX+T1yC9KoryDVa5F7ind50BO7fJAMwAoxLcn7faJwV245mBJ52nwWGfPWRBFv0Z9GgYCscxwSFbUjCDEGqeY8xmKc1M6DMxPVyc3qijAoNmDljmhEa+LWAjjEvqUQZifTFJv/OLyn6uJgY/UtaHkI/vEIcEtK49sQDj4mtR5TaSFlx6+hAY5X4BhJga7JqmRkWZfOqaoIQl4lokzrsXGkcK50+nWRim9+YnQZfB4MGBK9CU5ezp5tt23r2XgRPql9wazGn5liyho4djhQcZyPdcviPXY20ZYAhkfz54hiUzYm04ig+6p2p9T/H5o1pwlQdoistip4Zx0Zry7lRaiVwi30Vp+TrU2V3UqMlx/N5KAQfS8g252syjFhe57VqdGRptRTxsC5eaxC+DwaRO0xp7PUvoOEwPk6pNQGEPsfqdEcwYQYfhV9+ukUKw0XI7aNWhP3+d36vDkBeD66YEp5tjQK51ACijfiA7ml1UoZohQNKqq2BnCnLDIwgUhm6JWgM0XgJHNbq0tefAIh1l0/K9IR0y1ymDXPvqKPtyzFOsobImAwGjBnGohGgrpkFpO4L6mrkGbW6ox4omD7Q8c5AbgiHU7WMLEY0bKgF2j5VQGhCDpdB/5lIWlOmFKHaMn+2HKzxocI+B2l+3znXP9irMlJdmvzITOkA9oWDcc7TgjEiNrvCFyK+DDt0qWHsVYKPkF5LW10yn82AucXnhHiGYOhaPAVDlxy8pM3o6GnSxJ4iYyLf1uzatxWf8uadUSg42Xg8INajX88tsALw9CHIOiA47wfGMsBhq2hRGJlawimNNpDpnYiszAhw4c8YkEGKCajMVWsxyVLTvIaiJhMqknBetDT1w2ynJVDJQkhTppKP3GNEDiIjttN5EW1EESxB1pJKKJXkD2NyKUmZXy0NVvhaX4r7p1HVQC3CoorraYbIZxhMrPDBcFEYb4dyCl7VHzq4De8sEzgFk3ZQCZWw8PcRoCnZQOC8IKIPKS1aLzoBK65uNVUKDG7AthwZFamwFlxiH9Jm2V9PdbC+iXo6KXXUpiQyqUibO5FDpLSEAyki2BIrbTzcTQlMkqLSoOWI6VWjGiVyiupTlFwIYkwP7KsgJ1IHfhR5r9OB+/fmisKDNdLGHzpxWu1yR10xWuwrVtSht28hEheZOsnriodanfjdYrtU9Sv+lo0dMVnodZzHtGrgQ6a3vIQw6pCETxqQ3DwRbElmBAt15Dp27bnFtDAXYiBnrdSNpTc92PdSnTzT2TmLnx6r6KnzH+h2UpMX6bjQzUh1sGnAeVZiBUVgGqBqwpDElmvujA3U69j7/PN1U5QGBG5mkOsAFw6Kg+Ffip/OaDsTBbXnt6CfN2MGjJ07YfCihMRPVvSwV6X6v2xOHNAVdOLTpzUlY+nTki+bGk7fu6Gl97Xs9joEWYOAC8gTMedTcHEsrrYbDDu4DWwyo0BBoYRleST4zF0zd9Bp3TSqDJUeK16BDm2asKuZAe53CHYcO5gUdDVhHtLjGoKePabSbBhGAsfGQDhrg+suHE7N1uOfIEXj1BTtECxtCAYxTnEEN/p76Ne6eMKTDS+rgpHIYvHlGQ/tOZcrJ6btCSUu3tAsLtaoOtaEZ52bGT2hScWj7hC5Hp9Vli6Zr8AD1M4VAZegkBvblDbwAMksK4qeHJhINPz24AgxNFVS0oQK/l3ooJObzew4fhsNnz8KmrZuBNWt5rBpgGi8BxgMX01x9NP/wZwdYkwfu/RDcrCpmoKRnbnrqCXgNAZrHKkiNItovDCnBFsGacfNqY55RElmtcWdEBADZ01Dqgwi23+iPZw0LJI3vqeKCd5qESGqmnZt3GD47SKsBBLXs/NupXsCjcn43lDulAnrvf0EJiwDW5Ajgx2IVzKF2QvMsBzXs+C/7HiNw86KanJXqlNJulqGhD4M4lX2lqV7YIU2NDiY9q3mkrZH/095H4ejaWT0e81ga/Dqa7L0W4+YF5eEQWxoa3+Pxd/z6+73WN4PdyDH2zaD/1m/ed4MbyXtuWqx1oLoGXy64Dx8kfn4QLUhAbbE/KNCKpFYdUoSbki0n19fhpiefzPtKopiHXusODYzABSr6NHC6eRXRBXCGrDL11g98JFto/+mTcOszT1WhCCPA5huuUF7rwRhG0Eg7Qi9wBVlKo3rfOfub6yc/SGDgOJQ0uLGjewFxG8nTHVy3vGKS1EXFq06Kgii0nX6kzduMBSudhwJSNLKAVwnS3K2IhA8/sR/2nnietmmuryWIpA6s+RXQCUDBla1De0sKHYEAowYl1M+XMO9PWDYj/92HH4L3XnZlZig6LonPODgGhhEilJrT9yWJZm4AA+QUiV1tSLZ/6/d7WnzoOo/3ngF/5oSXKq0OIhz0tWJa8YagVHXoARqRumCBGwKMaktUJWozE8DKFv54KE1x/+lje8uGUoQdmfhqcMJYCsr90vrca6nN6wcdklWPTCWhmB2JyNsPHoBPH3g2rxfM9rNIaEUTzFFVnhCDaWyrQjZ/RGNojsoBYNUE1MkHwTlaOhSfscUwn5ZPfdpRhqq0rV+X1uSlz/vWbWI+zRnJjc4C2vCzYqZkyd8aNuqi95fMbFM0yJyWO2575hm47dmnodu8iSQ0vaNNhRQPFZg6t+RaK4jJYfg1gvD6fmopzXx7lmzo1OOmUwiTKfzE7Z+EE2trw3EZDPHVbDgP7jGafLwTCbwCaVZVtF5FGIC8cZAnwHzLR6bAeNpuGN+65vRj9xalbeVtxGCNs68AKPOLhJBrYBh0QNUuGGyctB3/hNq+HbTJOnDqJPzs7Z/JGOmmK1kAajpaUleEk2nnNiQkK1NhegI9UMBKSRRgM4PSlrfRcbIyhSdOn4JfufcusZs6B2JU+TAjhIeoDo4Plr/eQtGVr7OBZD8SEbxoIxoQdEbtobI/669dtEXHDY+WPe7Tdy9aWvYu1WsHXKyTKKCAzfaoB4n8jhyadYM4Hr9ilQUTdaTrP3r0Edh76gR0ar9v+QwuI0pnVvFl5R2aejJm01/jtsMBeOuLSkGii+7S343l4vKHmph73GQ2hX5lFX4v2tJvu/ASeM/lVxq1xhNXKBnTj1J180JL60s+Ipn1OtGd6kUMZLAMFB2KhgeguFPobaQdBGKw7f0ATZni00JFy2ASpzZcHXgQHUGLTRDzA5VNwO7VIDbrkNdGcKibTQsoVHKR6sCSmf1I+vjQY4/Br3/x3gjm1bKpUPZwdCJsRKhKmSisq6apIxrrgBLAezkaDVSXX2UGQ2OmiRidXXeTDOrUA0/F6J/49Cfg8RPHW9pwKLFR52aZGRo3jJRGVQctIsTe6ZR/uhPpXJct6KoYaal4oz+7kYq8GGlV2XPpoLQTdHXRYpK0ledHp+IavOSIlsWH/ly1H4N5oorg86dPPg8/dfunIyYCdKvTMiCcVI9T0BkCmEkfng6pn9LBaOhcHUYuGDRob6OKZ/EfiUxmx2Ql2kfxOBxm8Hdu/At4MlZIqx7+1W0EXB+0jJMylQQPY3Tq4XSngQE0cKV7WHdq4nhxebmGx5EDGgduIP2yaXFeeqRBlJEWYNLXDtM4Wk3ueBoabOZ26kCKGxxT+n306BH4rg9/CA716xkXk2Q7J9OUJbRkCCQwa+sHVRY06Bs0v7s2NrLEMZPSuZ9w6RQSsdiiidBJlNCT1Uh8VC9PnTkD33PTX8ADRw4bKe3bwHTAxZ1R6OXReaGHpVpn3/vN0SVeJJh0xG5wjs5nbQ1F1YFR27rdaFpYKm3XTAsL6bA0DydcbBsBS22aWGHzQgRGsKaHP/ghxpluvwmBin8fPHwI3v+RG+GJU6cyFiarqxkbWUJrDcT0UaMHwhpAo0NhbXsfOhgBSTNoCY1Qu49Bo5bSkfhNqzDdvAqPxQr93QjqG/ftNSqJe3h+NNjyvStJ3Ejuvr7WYBYA53g1KGJpTGqbvR9GbWu1bI5W3Fj6jabFJdP6vMlkEoaWZwIOTZb6+ijV3fFRL//FfGfvRnDto9stS2k6WBN//Mn98L0f/gvYf+Y0TDYXLGTNnSSz0Aa1XRAHps4A7GBp8KEbfbCRUQUMqQP5pY8tOyWBaDfRrGJSr9y0CZ6brcP/8LFb4Ne+8Hk4G8/FAwJOUsOQeSKFg13ERjO6dLBOJFzQnc1LbLpn1sDDZQ5YMl1JixtIu3y+7WPgmlMdeCipARaqPxeUAJUsuO20kEpt+y9jG//AzTfCkX4WBdommCYMrK5kTGAyNzplP3tBKQV6c8QR3cCo9XIggneBYagP1BdPyug7u8LVtkeBE2WTFYtbhhFHjF6P5sc/v+sO+I8P3g8/+7avha+77AroqGdWVUOg1nWDOZpDh86ty6HB5cAMUD69yq3gRs7NkSnfaxHCBBpCUf1dIm2rks20dN2P01FeUIK6vFlHz6e6zpQrb0HAxq/xXiggJwR8dN9j8HOf+VR+BWKyGoG8aSUem/J4aiKejfoWpOSM5aW4YsLWOQ5U9ytGHJCVN8h89R0aFZFzLDM5qKa+q1slqNnxOmLNg5KQPB6g7K0C7Mejn/oHPvpheMeey+F7rn813HDRHtgeGSBVRD26tcQNANJqhdzhnBRj0KBqZE5jnsd2nq3zVhos3JlLqUeKxDeeW3qTG2jYA1TvvHmMykd3Wq0Ng9WGuh8PqkTnZ9bX4RNPPA6/f/+X4PY4A7geTc4E4mxukmROE27JA8ZChds56GxVG/G7JxnHlD40qleJK2G6kEdoMxGzQ14thboXAYRqKrD663jbsSlotdrHnjo7uwY3P/0k3BR79cvPuwDefeXV8O6rXgYv27ELNiW1BNbkgAXnOSgpHJRak0EQn2dSOjvBYEAwYMNyGkLS15dsFvVAk3fAdiO00vYqQlqcwMvCINU12WhZCyW7OQBPJmVtZmy6eqp/TTXo5MTZs7Dv2BH4yGOPwI3xeOLkiTj7F8dOEbwrEcRddgqsFqkcvRri0UD13jNrfmTgwiivREjC/GA3DZITBPvmfbkZ2Mxwb3MHrqn+4lg5+vOCgdk/XRo6/eu7AvY+MmEWzx+Obr2H4szib3/xbrjhwovh+197A3zd5VfDhgMDtkPTgXiWMDhJXc0SVVVss83HLsIqAixuAZ1WnczLW+LJYrB9oHzRXn4Lv+sH4gG8vc0dQX+VrUNo0Hd3lML/4vbb4AsHnoX1DsskSQTylFy1xWU7zWDOQJ6wZGZzIYCxjzletw2otmkxZKSNllpOV2cU5BoHta9fW2C1a/QX0HmwqOhR7qjLz9sE33jJ5fDeK6+BV+68EFYi+oMzM4x6GqW1SmLjV9amBzOqQ/uc/CyHQhyLDHMeWFLM40bSpj9iR6ajr5n02ZAmEzTxJdS6Iw68HABK0IfBcCCH1128B371ve+D+w8diJ6MffDnUcMenK1VIOf3NJyfGSwPeE2QodStLbwRjcjB7LEy/AwBbLycC3KJokBblWC9nVxCZdM/Mt0C8FfX2CO9btrD11xyKXzbZVfCe/ZcASsR7bNQN5rx1VwUcppOgVkDubMvJaEGt3CW69nBUDb5EUZonNM1wsj91j0Yzwtxflpt6HLaPCDsgPe8yRvk9sSLvD8gVp88DYbFdlb28wDkQVEY/yST8IaLL4W3xPb7wJveDB9/5in4w8cfgTuPxrmGSXm/pJPBH4A2NcoMZeE5GlSXOkg6biO91MPgdQAbP1w5qRVK9zbnvKwWybXKb/TdOkjanjiVlOE1286Dn3j5q+DtaR/DvgBY9jNUDB0DdvAHdyQjkbvqjyXah+48MqMKp3NupYrooIgiO4LUDdTdSldJg4oDnq817xeWlmhGereG+V2NDRnz8DYPdrJo6OUII7+ozBJjosRjJZqT74neqvdefgV8/MAz8MsP3RfnHU4W5QCVd0QARTZ+0X16pXgglPjnJEm5njZvclwYkYvcTSEM5IecZYEXKpMTE/JK6D384wjkb4/ejQumq4PdZf1Os5l/oTYoV00kCJEpzB645kDZyQTgfG1n30QikEEq/VMGEIqXUtdQCcAKtIIdFzfCRsKZZtsG0iJotMueNyqS6ShNljpzqLzocCAg+BwaUhpIe7KXk/dM4SPt9Z02rH/Lrt3wh08+Dr+59xE4lRJNwCjCIZi5HIc3w3AcxjfCYLHGEQib3o6NpQ3Mjp6uQxWA9rAj2lX/5JWvgW+95LKs/WYklc0Os6HSMSotGnGmsomU5kQJVIYydjWDU2C7us6lU77BcUP9emnirwchuLS+Zv63kRYdkynfMGhN3TtJCqIaFFKy4A+wgqRXxfAneEyxFNMVUG+N5sj7r7oO9mzaAv9blNbHs9dlonSLpxABYBykLBs8R1ph2krQAngrs0DgZmmuP60qpwhld6weLp6swK+//k3w6u3nZxNDwByUuaHALYAOlo4x2iSQe66+OwwCYuOX5tyQGQq2dTqcwxVY4t5G0uPwXFwX6l4mrZEWgpIlLKor+upileX5Ym3UOrbmZ3QI6sSbHTOlHWbBPvM3on39qvPPgx+9+/PwRHTzsWjX4GTpjKrTDYVUW6gN6IM6tWAOL4sQYKBua9paQ/SFJWamrSo2bYbfueGtAzDro2+B2REcWoeW6MGWbSkFhxtqhczNAGbRlnlYNJxZNpxD2mX6COLwRnNixj9cz/0rBgOtDwp8dF/zno8kmVvteu2W7fCrr78BLkoLmye1TFPLlhrukFWGLzo8jXw05z4HvJxjsyDX0quSUNb73Rzjf/N1b4IrN2+pYO7L0fcwvmWyVn3QALWTBmJzEyDlKwZsdEiSyhKvegO6f8OY8TsvVdp5sRr/ui9WBw4qa0vlxgNk02YDPMt173ivN1RddyBed8e1W7fBb0dPyBagtaB94wEqqylsrP+DqjDwywz+0IlEPyB4VW2lYFCMKVtUhNkMfj7azFdu3poBvM5gdpI5gxvqN7cayPPUod9mOf121FA4QLEmHWGABu6aGMwnYKDOFx0vVdrR9GDrxSc8bezrzQffTrzywqS5lTUdJr6haVP7roXazuuUJv1etmkr/PT1r8wCToN6gF0vPNER3sKnGmS2306ZI5HtbIdlWrlVtkhOYP5AHBi8e/fFUjEBtTv0xucMYgE4wGAHWi+5tdS4dss2KHYYGrFleRHUOJElFplMga6VoMCRAxZc4waePae8pV+GKoFd29kxMXVaSp037HG8Np2l0YFyeyAd6lltcmTJDOVYU3HfEv3W358+x5uVcVXGClHklbwZ3Noq1Yo1wuLXrRoZFdwSBUEbBMVESlskvyqqme+Mg4Je+ZhbPV8kQG+vPWKD+pUSdT5E0jt27C43mvyocAiidSiepjnrErX+2QYrFlzDBp49p7xFyhH9pUe6p+jJUCU9R31TFDYiSPQBVUiYNoDKd/DtF6yEZxD3wQqx74mAvnrTpgzoIJMMWDMUTJ1baAPaZ4g1PkiN1G8oPSrQILCLhP5InMK+cLqpAlnZzTPFjL53IFUMazKTy1MdQXeOH7z0Srgu2ut17epGPQjwQYMXB4leYNhoo5xLIypa1Xsdhluo40udE2+u2bwZvvviy9rjGA9saJsecg8aZkivzA5lelwQvV3/8NqXw2w2K4PEXm0wDgCGD9KrYNgsI6BfOChEWCClGOBU2z5K59dt2w7v2nWRVJQrpE0LPb3N6o7pbOBZ953BoRti12QVfvaKl0cpsBlkyznJQzMrEB898AMMnbLncsBLnD6AbnypR4BBXYJOE5l01epm+PHLrxWBMwsLvEtt7EBotQmDnto15w9qvBSPr9mxC752x84ipUN1OdbC69ziMkFjdKojszkRQrNSOgbliTrNyv7mZDt/Z5w4SSKhNdhoTW97Bo2FIKWWIPtGh+oDTRL7TVvPh//76lfBfzj8LNx04hjsWz9b3u7Ls2MBZEbFuQXqYBEWE8IsWCaElzAtAAE5WAQy4Gn/m0k8rooA/przt8P7d10KO+Lkx3oYd5kOMDZGQgDxG3DQryuke6mMVKX8Bkc8X8UJfOtFe+AThw/n5eOwo0y4QxIOB+MBqPc8G6QZr/zc54Khbiwl9yRmlJIU6R2NZOj3a+tw9XQFfv+Nb4Wt3VTUTFY7oLwZWiipopbqlGgHRfqrCfP5fGfvySCqYRsvwo+wgXnOeVTz1CUcVsV3xrFyWhdhIWGNfILVYPyrJSW3j0jSoDxNUCXuouB5qj+p4+8Lk+Rc6cpMXvo906/D++74FDwXZuo7w5RJZ8c22mMl5gcOC6fQ3tZtNDiZGhTz8vbIM3jHzj2wXfX+BGRjZsBiMGsKsEWCAk2vHkg/HVeqr9O1MgseKrCNlFV5oqNBbrtxCzSJs7QMgmOvATnXqdETmnkpAseEQQvQRlsqU3AWbHuMgVnzReKUlEZVJn9bkLUoS+oE8FCmx7/9kj3wm0/ui2OuXjZ6KjPPAIOGyVEIi4Te+PvQwVLcYnQVA8U266O58b7o2WBm8K+RyP1iMAdXDEtkRY6pL4M6v/mbpA5JZ1ZzvDa2dHpfgKOhiXdsly8NqYGH86VqcHUz5PT1HsC8hGCcA2G8OBEi+lcG51B/Nfh9xwOY3y6jpgfWNpAxFYH6XdHL8hv79kKYTgkYtOmm+WKBrkE34niY/4I/jkVaSBbDvoft0R56RRwQ9r2VBMbPOXi6hnmN0orLL3sqUAeSCtnzgUpCsHRmvsASQQM2OECrziQrbbFBD3Pq1ei4SBfVC1HycvJETK1BXvPAHCyvjaTW5wADIeTzHGsDqQO0EwTVBjKvEEr7vHr7edGWn8Dx7MIjW7qR2+CrtDmFjgO6qU6D+Q2kQ9ldl97ZSB/RejDLyDfUAYNm9Fw1PacOjCEtLVhjZQYqUwOUyTFWPak6g1gBTfZHYWIoE2PChXHpls/RpjP14/yDep46CpepAb3MABpcegYT09gSMqZdXB4Lg2okLXD0hlB6MmYSmfem83bAx44fIQnd1Rfecl4NaQIwt/GW+wSLM/FiRzhTAH11nOI2zApgZv9aDGMA9rA4GFCH2nNR1T+Fju7rdanB9fJWXKtAb37kaIMspWoV6JlWkbzBdQamP9g00ik4bbD1NnnoOLD5mijX0Xr1nO+AXGed91weUcCRa22embKo8Ku3xDmDo4cgKCeDBTAuTwRoQOveYIxUzlSLEBCq2NzI/s0tWw2TmPktuwwABlJkmdACtcRRRjMGOsWZX9daZsDM0b5RqQDhSHDEBKspWCoNaO+H4OOj19KbeaeaQOc94JeOYI0UhvwN7tx3njAn26WDaiCNIoMLrFJ618pqeVUiqK2RWw1l7A4vnapEGF1ON5DI45f5pXrefqSMEqgvXl09J6ZslHEe1PnHixWwDNUiTpsdxmsBMBRPrV/uREoG1AxV52U54B7XhLEnRkwxnT6UTmBkSytoHjQawJM/qFIYz/6cQO2e58O/sZeO5BHLApEJocDv2QudWN8S1PSa5or3pjhCxXyzxc7uBPJyrKrF/7Q0mFvbcwweh9yJmdZBIwZlZzfuWZ0+LKw18NZb1Q1wpKTUoDyv6MCaXKIRejVJ0UKj7jDObhupxvBeWKqvzA1Olw9IDa5T9aqtpjxRQgdrU+ZvS4OKFmpgdLENHdwTvSabDupd2HhUKhLmM/lcwqCXslSkc98pQ+MZnJPvWJwHRl+LFm1g0rPkZomu81BSHdTzHNcaW7SUSIvoMHLOEWO832ibeDDjgnTmmhHu7o7lsSi0AY3zSQmtk/j/bD9rpB420jyh84IDc3TOWKIFiEWNEFS+Bgyq4wiY6ab3agwGfT5/cB1jhLCxDjdicQyfUXTASF6Lgi5Paz7vixYJje2815K5YXo4M9S3nrseabDFEpoNdG1jtDgXw4H03Rice+861zAA7ghKrb1VG0LuKZu49y0W6jNmyarQaDDNrgatetCk+ajBF8bqBjC0+VWn4nGBLr8fo2MD8YvShpEbWpjla1eZo2trdqKLnsqbHcHGQ3sZA+/t0Ht1NVqLXxx//OTz0AxBnhyZcXzhodnwPl4B0WNiEHDeTRATysgSVRizbzApADAwL4LuFOpmcOmXeXndegpgYOJwXPNZeHFDZrcXKmhZe/DMaStZ+I5vUNSN5+6rVza6QYlS1EhmY8THNPcdP9rOQUmkpY6wgbTqWDRRwA0pC3QjyAtLT508XgYbxPBOV1uZMNLowXaUfM+lL8sKQ/2MyjEGNV0ufw8uDVIGCh97jx2SF7DkRSx+bn6zgarOSxsUb5nuFPaePAGAOK6FdMVb9+W6ZLrxL1YG+aLs9bH35EkzA6zbFlzcgkzPOXhADDp+UGCAAoDT62vwU7feCCfXzgy3yZhTzkCdAhg/awZyB+Ir77GCmz9h8p2Ega3rwLQbIEPpdGcj7b92+62wlhaQx9oRDajn0B/ghYPZ8ELFGbrdM3x95+GDwMtL4AtoeH6y8xH+nK+1NMJB4gLq07MZ3HX4kH3DDU2yHIQBYdigoxKW1TLMl8IAI+q1IcH4uP/wAbj38LPw2LGjAzBji3bXQoYOBOvShBYT7XOeZgQHCFQNRuf8WuYjRw7C3QefhYcjMMxWH1jrr/mnJ7n80W/wCHMOUOVKBR1f7z16GI6tr6sNmywP2sbDfNB3vicbZvq8JK1ycgt6u7wA40effdqCYQTUfC70BYB5HVR7DFoEekmsJzs8OBnY6Z3pvBfIU/vyB50373vEbJFhwI2OfvrtB4UrglogpjgvffVvUHXQr7wybXonsdueeAzOhBnc/PhDeaOeCdo3DXGMPGyTvGzABfn5cvnddW0q/dmTT+S94dHZIsVERpMPjuXr7rU/wZL80c6CNbzcslsTrff8n5/cF3vd2YpzsKAGaDBzpCcNJK0CA0uZQXq0z0rHAQUKtRfPegTDBx9/OK9r/JEnH8/7gzDQtQoXm9rTzWVjI16VG3D00VJ1tI0tDYm1ofSmPGlG7EQ0kW6NnTEtKP6XTz2e66K3zht83ADDjq95tdEwT8Nwh2Sa0V2fipL5o88+WRbEz4viE44oB6HTjyLVKTZoqoPCUVGO4FBd+w6DGQuY01cHaW+NTx08INKtpeI1R7TP1khhPtVpggWtJtnYs3T4vqhpYgmdAHHo7Jm8nvEzZ07BbU/vL4DohuobdB1QsUafa3taHbpqZnbP5cv30cWL1ugK3QnQ9xx6FvadeD7TfuDMGfjoE3ulM2pQG23uCYPaDmGePeeO0MjDXxvtAlbz3fLMk/BYHBAWCd3ROtKVIShMrlxo2tjGBOBBoQY16tZxD+pfUzhmwhKg03Zuv/3og1Fa9Haf584x2BXjpzmFIegOxSgNfKQ8AG0dfZnc0FNq+D945AHaT3ElRk7gDx59ANIaHQO6u6G0KwXU8oNli6mLodPfV52iU3XWHUoDuWweG+BPEu0rtNNYPP7r44/k+1NVP94vUH8W5VsQG829TPDmpD40r/QncumYRWz80eN7C16mE6h7lcMAoCBqDsCqe0c0nXeLKWZydbzKHMBK6UjgZw8fhk8ceNbaoyo76bnpYTWAMJILQQZY5gA7AOMgj9JJLrdTQAb1fRv9fjRK589GKVf2AynA+Pyh5+DmaHrkNJ0FtedfRx0MGuuj67FBa5UjbwJ4a85rEk37Sjw+9fST8JkDz5TOmGmfwO3x+rZYp6kCvv7WUuMBHQIzL5VdE9y9sCCNViWylU2ngKzOb33mqYiRg2WV/7RVCdvRhhEOc9Bo7EYYWTlp/AEDcAXsBOZJ2rh+WnYJ/cUv3Q1HkirvhpIGPXMBmpLLd0gtfX16VCdMYl6DEWGw/Vhi7snZGvzS3Z+j7cZou960oGC8+fN33Zk/4vS2aBMcmpOuIoM06K7pOW0nC5hBgRpq2Qmsa5G2n7/r9kxrJ7SXHVp/8Qt3wrGzpwX8GtiirbpGh/L8bPEch+0DFgbVvFC8zr9Q6DgUafs/vvSFrA0TXspq/938Rm0V7KJ0M7haUHBq0qJQIqXGbAfljesjqO8/cQx+66H7TQ9t2XVjzNJBC785nXNIIsLAK8DH7z98P+w9cTyrvdQJ80HnT0Vb+l/fd4+R5gLmDoZmEMAArEYC6mvFtk5dexOpc+VqcP72/V+CJ6LPP29sSkJkQttR74t26Z/sfUjS+kN3Ri/0/CBca00+b74Oy3UAMB4Wz7e0PevvP/IQ7Dt1qmw0lPZi6SZ1E07B05BAnNfoKtTldEe7HxLDVeaoDHSyfdjLUTeuX4V/F23pv4heD89QM2iBBjhgSAo6svw9n0fnmUkdKn1C/2f7HoV/dd+9tO902egmdcQJb0UWj9+4/4vRJNkvdqsxQbBhRvE5qVyhFRtp6DrofEKVnppfbGLw70eeeBx+6767YbJphWznKe3YOy3aJpog/9e9d8EHH3ukLBvAtndXXXrieXD0MG+D8x0HjXZ0fAcwGiXzvquSeaqOD0Us/OsoSDK/eb/vSfFwaKnG66Ogxp2AvB2Ylo6XVA30LqrYwwDGrgl8nW3CCnIGNw8MJxMyPSLBSSX+7BfugPuPHxEpzcAYmCKKud0yAFdpWGoaNY1qMIWlQdPx8LEj8M8+91k4neIJEJM8mJ3IICXFpy+R/6fPfBIeOHJ4KOXAaprW3uVeeosUVucizdSzvizmVwLzQ0ePwM/dcXve4zGbSStTorsjTVNAjvH3FyLfvxTt1Ck9K/ynQ0tQGTAC2MEjtoFrTCN18GCUtcNKVzvjo8ePwk9/7jMZE4nG6YRox44GhYwnICHJjKo49HjTeGWCO/CR0kVrJtJrOK3qRbr1qvuu7vF9pO/h73/qY/DUqeeNlOPKD4DtQO1tuGYcOHBpqaSkUwLzf3/bR+F4nA6ZrGySBU462ksvg2JSpF3aATVtpfBDH/8oPBif0w017WwjzgOzsSvBSmNtVmg7mQ8GQzqePPk8/Eik/XC0n7u8sWWL9kmW0NN4HItt+IGYfv/zxwywWl4Q7QnhJs3XwQK8C/Y+P5eWJBC6QbUvnT8daX//rTfDmSTwWCtOaTBoGlrkp+BPRFhLOjfi8Jq777ZmqTeSsMTJJzLKuDIfNvI6ZbQc2PraOqyfPQuzeKydOg07I/H/z9e/G1523gV1ERq1ao9fxXKMFEt9Za6W7hpszOj90V7+7ls+BIfixEnatndKG0VOaC89pDLSAoJ9JGx97Wykfy3vTb5ndTP8+298D1y6bbssnCOL6GClmd/h0DSHEdqZnZn+INURAE2hStEnjh+Dv3fLTXAg0lRoX420k4RTtCfez/pZoZtov2LTFvj1r3sXXHXe+WZpW1lkJkBzNasgRDqWV9w1B9zaPEudKAmDf/DJKNDiZFvexD7SzzvNdnkTe16irQ5OMsidLc2Se8BMB+rJjh/+4f8F5gXUDzHruDx1DaxeiSiAahvFcDLODP3Row/BVdu2wSsuuADqrBAMTQgYSl4ttb1fU2zkzrrlsrqNx3+JNvMPfvwWeD7Fpf2naQ/qTjZT76qGEW3TSWHHYqf8k0cehiu2b4NX7txR6Waed65DUaWEXufZYfWuTZiJphlrPT6yfx/8yMf/Eg5HbZGBvKlIuMmAdiKEAA4EiuRp+qM4lnlZBPT1519glKqx7xVfEYbnk86acVrbshZc0b8x/qZo7//EZ2+DgyxEEqBXqqmU7WfXuIXvAjBiXrUUKtBUI8wF9NiDgzgEh2eTRNs6DP61KEFujJWcxd/E3G3J3tNMhSG4NXM7BQ593emBlDIzjsXG/K0Hvgi/GAdJZ7ATIBdATCoglC9LQN0RE2mvw1NR69y0b1/+oPOa886D80Zo9+aQNkUMQBqAnlJ8+j0ZJdov3fU5+OV774aTKT7SvbKpRXsnTKu0E7CJiLUofv/8sUdz21x7/vmwPdEOli5PoxEg6toM7qE9eH0+8v1f3veFyPfPw6mYMG9kT6ZQcZFW2mUDUGIceheYs6PngTlHDUyOFEbeAA+ik/oq+vvyxXf169BC1oEWcEzmx/paND3Ws/nBZsjVm7fAT7z+q+Cdey6PDOkG664xGU1KcAh+bYOeiRLhtmefjgOjO2FvtN+K5yKZGKt5AiK7ubqJME73fl7ZMn9aH9X3bD3RT+bTWqrHGlweaf+ZN78Fvv7Sy/KAzK8IZNQ22DpgY9aQ9yzqch49fPqZZ+CffvqTcSr+tKO9uOk6nioeoT0RMiPaZ5n2tczzRPsroqT+4de8Hr7h0itz6WZrEGi76wy9CmsT/qXzNAP4mQNPwy/f8zl44Pnj0RNDAmS1emTy/t9KIxpTg8EdQIHcSWeDg3mA1jf79rIvZhlT/rDR2NIAvKQBr4Bd1rxbz4ydra1npiZw9BEcIca9bfdF8J3XvBzefdmVsGU6ta84wpCxqOpiJEk8PxE7zs3RNfSf47Tqrc8+lScdpnkWjcAgdudEADEaAtAq831enDuDOY0Loh3bn020z+CrL74Y3nfttfBNV12Vpd5gSVq0tOuLTL+yoY9Ge/fWOPv3+w8+CHcefC6q47Qh/JRUdOmIxW/bKdpHVKTQXkGd6M/AjnXoYn1eu2MnfMe1L4f3XH41bIt80qtc8a8Onu9a2xyPPLk9Avl3H7ov0n6gDFizRF6VafmJTHNP8kNDMAOYUT8BGnXB8r1hI9B9vPaeeyrt/EAIlVXaCB8MDivajJSmDhFohfZAA60C7JlIugRqZvY1ccD1jXuugG+/5jp4ZWR2KrQlJTSDS90C3HP4UDZl/mTvI/DM6VNlKpt8s8zQjtR0deRzvii4EJ4BrUUSaBFKBsdaAkcBxSw2YqpLH+m/aus2eOell8L7XnYdvCl2UNmPRPjW6JBQAH3Xc8/Bjfsehz999FF4+vQpmiyZin9cBq5Tol1UNEiDq2ar3CJQ8+ZNBdhr0jHT0sepPa7del7eb/19174MXnXBTuClxlvaUWMuCbG7Dz0Ht0Zf/QejAHni9IncCQvPiwDp2MRIbsWueGOA5ityfmn/9XTSVds5l58L6gSnAuKgpAEUya35mqHKgJYIboMgzW1upLWg7ar9UJpfJHZGcr6OrAQkSd0rEySBOAFhRkdibmJ4ktipEc6PDfrmCy+Ga7afBxdG9X5+sh+JgLWYz/FoXx6MnpO9cTbyzgiIw2tnyjsBNEvJEw1ZKrB7iyRbp2xOgkRFXf6rUVjq03OnTEeiN0vsdalHn4AdwZHqd0Es780XXQTXRFt195bNcEGincpKtuzRqJ0OnY60R8/F5yPtB8+cNTOs2Q+eNEukP7vjplUqi5mhGzV3HKwLs7DJpMxD9twk/s4GtJf6JNp3Rtpft+vC7InavXlzHCes5vXnUogp8uD4udjpHovmxF1RixyJnRrFB86TJVM5Ty5QZD851lFlBm1nB4DJdg7GxKjnDDcWQlxngKGSzYCGVhizo/meA3WGtTJDyAdW05NbLzO2nxWJvb4uUruAYpalSU8bsvRkk4vIMHqvU7OTXQX0ZCqDJlZx7O+UKVbdc1HLzGDrzp0V2Kb2wE6dcVb2CyHaWRsF3gXJ85JUbWrUTDcN7jKQJ9OqSQztRL+g2dPebjutZRI9zPvAZghpzcT7zHfZnaov30XrsZIMygotQhdpDn6Hp+NOyG0y6Spw2dRA6/bRAG4OBFth5N507gMNR7CVZ6yuS/dJdMoH4lyBQFvzpsqnDYUmHc009qUh+8QIZuiMVCRtbxF6JWmG6gZI4qK8utoViUHqLcejArLoTPVrEUKVq4BG6qBZgmA5WFp2swn00zhJQ2BIC75nLUQ7pga/vpfy+Ajtk05evUUBwRzaofFrQgC2eVghs/RLwOr7JB2TCRP5nrXKtPB9VjsrjPGdaJeX8h3txa9M8ZjukX0iLjkE4xoCBWapTwPMWgCN1ruEja0+ajLkxkKoi9xpUEvXjrf7AuJU2QQOJID0XWZiVqWRKazaZTMZ9qAAGCM0k9LV/bxRqWQUkNMLUwbAlXFo6qUrF4oECUGtA106dx7ERTDk1wQS7dRJQ+pM3AFZktPoVvY/UdKg0K20hjmQ7HwE80qlp320UQvRTdonpNozj0t5YdIX2jXfaYJM+J6Obg7tJIUHmlAdAzCjm53WUrpVJTkfB3MK87ek8NcmKS/oSAAQBhCoZRVwECAH0AwuwM62VPo0ui9xxUwJ4vrLwHKjKv0yS/W9FjUIZI8NmCXPcSbYZpjaQAXVaMvQnssk2vtUZho4VrNKz6AuTTv7wVu0E78r7Ypo075YtaVI6hbtSUqHzHfueL3srxdqHTiPIu6HtJP/3ggWJzw8sOvzmnjbHrgAtPPCdID4RZlpTwjSICr34I7AX6RRYQOafJH91KoiWVqTfZx/J50CBVTGUnrJ34AUrY2pQbsIzD54aZCL6/NC7kHVveTYZ6lXBiwh84D3Aay0g6IfLO2IDiScxA1ccQHtWvAgOl5pkms65HwTnV2QjhkE1OD4DoYW4bumXUtZHSevH+pnoKaFeo4D3jfqOicsb3IMCiJQA3diRQ1J7jwY6INdEQgnWU2D8BZFMiCbLZSH2WAueJsDrOo1IKZ8jIRGWwd5RpUpZCqpyvqWO1w2RZj4yQjtQeUFA1ygq8eARlyedqx2jOOXTT+gXQ1YBdx0rbvfwFyaR7t0QAAZ+Ml9UJ1X5aE6wQsFcwpTjbVmUBWVtHwyCupQJFpKlE0KxewQSJqTVOPGR8pUhFooDGBJgR1UicP54RDQAIBO5QV9XzO2PmJPVQ+sp1ReNjPSNfnaNY8g1A1FSL1L5waiGX2h2KAdXN0U0M11bYpyqfilaWfNwlqS8hCNw3wXcwWE/wGHgsTSrujmarBEVmlqvQCqr/nFBXMKZuNNqxhrvj5/c88wiWznTHxhEtLgShqXMFyaVzFZSYKgGbsMHU6CMYil8QXElZm2fjpXMqW4oQgkgW1+BmgyL6h+tSOivDq3iOZKru2QfM31CqoDapkRTI4cF1Q+NTGbbTJ2z0IGlKSu6ZaiGSzfmc+8KLmhnUAr5ikDGXGw4ZW0G8LAyGydt/hsTI5Bp9C/oma5cCApCwLKoOINgVoqAJJkhjpBg1WKo86EH2MbW2qAhglYiTRSgJlHlqq6Jyn0IxIbGBcQNANMvVnDBKKd0RKU1gJdd8VHLY1atNdzpElBHKWdfwLUzgdEOypeMFSlGZE1iGpXqhwaLWlpr+RZMGvaUfO9EV/4AnYFWBU/aBPEAZDBXfPvtJVoNKAd+fsGQGJCYG5nSwHNLKKuYHBbSxUQ8iruOOyGo3S5E7TMMw/XnmB/VTkCwlDjURAkibI2MqzO/3WdYJB3m3aFTAI5eoDDCO0WiyBodPtTiMQOoaLJPSwQDUMyxWxxJGnazMcgDhtSjsqjVNcxhdvNlbcURmN66+XwROtrf48yKPdUkRrY8uYUWN3AmBB7SW9xQYl0e4wCQV0oqSESQz/fArDPSC/sAa7uwRPD0ockMxfm9iscFINQeRkqregb3nQAtHVo0WzOcQjaUhFgyVnpINoNwGEIalO+ohNgfudjfqqOizAHS63rFib9L92bbjhTbLSWAU8thIWCrHOlgco2HD2jwQ1BD+Ra4qIWjIY2dUuBxdI9TKvlgDEQdJ1QgxqgaigCJPuv2YaeR7uyK5envUkwKAMGzFggKBAx7SLRg8qXaCeAByZg0Mw4LLFFO0e0OiBWSBth2IBUE2emTBymyxL6XAMDV65BEVh7jICaEykholV6uV0NKA2yprRoE1V/Rhg693F/Txfd6pRMuxoUV6nlM2gV0Cj9y017TqsEi87pXPhO+bQ6oBE+nP9GwLxEOHdAc8HB1boBbNR+WZYaGvgi/eYxcsT+QEePv4HtpMsyzXhwwNPuAMIheDJeGO3nQrce0M2lXZMHG6AdWvSPgNikASvUBnmeO5hTeGGA1gRsANg5WtMtEgSy0h/uOei7MsK4SoTlgTAmIXS80zZMrpSQcNGhnVkz9L8ItGs6WjT6eJ++QTt7c2paR7sZM+j7uDHacUFHWJTWPRZgfpiWdzKU/5Ey1e9D13rj0FdJUjo4aT2UDjZvW+nyE9QFC4eQB5RolEGllU3DlqhRNOtn1L3RJW7RyyVUQABomloZpx1REXj8pX0HjmbK19RaiAaemBnQ7Mod3ENFM+eNdWyQ2cltizUH7o+opLmlGW2nMGmpDYxbF4c0W9IVzTgfdy6PeWmnzDh9Ax0T6qyXTQtgO4GvVKD0qK8BqQJg03K5YGuueA4amrVMUPR48FJa3Umw0iVxaqTcphkkt1J2nbVUpKoGwDbNFG/GMTDkfYnoVL1KJ9kQzahyD5UHmndgylQ059lcrM/pduBidVr0g/OC9ADu+RbNiJYOVQ+NBXR8ZozKfcp78HJSMxNNqAuDwrWKtuLINYh6CtXzXnqbwlpVtfc4b1XVQXLfKXW95tLMZ452uRPCKF0wXqsB7fYe/yyg2WQ3ntaoJcUaQ3urvceq0alpbj3YxAU0y8ts87NvhWYayvuF29Cjpere2mroxjPB3RiIrbFnwOqnpbiyGGBNurmMFg2A42lg7Bl4cWmXPM+R9nk81+rPP78M7Yjzr1+E8P8B0szv+tLrxRwAAAAASUVORK5CYII=";
var version6 = "0.1.0";
var familyAccountsConnector = (options) => {
  const provider = new EthereumProvider(options);
  return injected2({
    // note: we don't support `wallet_requestPermissions` at this point
    shimDisconnect: false,
    target() {
      return {
        id: "familyAccountsProvider",
        name: "Family Accounts",
        provider,
        icon: Logo
      };
    }
  });
};
familyAccountsConnector.version = version6;

// node_modules/family/lib/sdk.js
var import_events2 = __toESM(require_events());
var UsernameType = ((UsernameType2) => {
  UsernameType2["EMAIL"] = "EMAIL";
  UsernameType2["PHONE"] = "PHONE";
  return UsernameType2;
})(UsernameType || {});

// node_modules/connectkit/build/index.es.js
var import_jsx_runtime = __toESM(require_jsx_runtime());
var import_react70 = __toESM(require_react());
var import_buffer = __toESM(require_buffer());

// node_modules/framer-motion/dist/es/render/dom/motion.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/motion/index.mjs
init_tslib_es6();
var React2 = __toESM(require_react(), 1);
var import_react33 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/motion/features/use-features.mjs
init_tslib_es6();
var React = __toESM(require_react(), 1);
var import_react19 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/process.mjs
var defaultEnvironment = "production";
var env = typeof process === "undefined" || process.env === void 0 ? defaultEnvironment : "development";

// node_modules/framer-motion/dist/es/motion/features/definitions.mjs
var createDefinition = function(propNames) {
  return {
    isEnabled: function(props) {
      return propNames.some(function(name) {
        return !!props[name];
      });
    }
  };
};
var featureDefinitions = {
  measureLayout: createDefinition(["layout", "layoutId", "drag"]),
  animation: createDefinition([
    "animate",
    "exit",
    "variants",
    "whileHover",
    "whileTap",
    "whileFocus",
    "whileDrag",
    "whileInView"
  ]),
  exit: createDefinition(["exit"]),
  drag: createDefinition(["drag", "dragControls"]),
  focus: createDefinition(["whileFocus"]),
  hover: createDefinition(["whileHover", "onHoverStart", "onHoverEnd"]),
  tap: createDefinition(["whileTap", "onTap", "onTapStart", "onTapCancel"]),
  pan: createDefinition([
    "onPan",
    "onPanStart",
    "onPanSessionStart",
    "onPanEnd"
  ]),
  inView: createDefinition([
    "whileInView",
    "onViewportEnter",
    "onViewportLeave"
  ])
};
function loadFeatures(features) {
  for (var key in features) {
    if (features[key] === null)
      continue;
    if (key === "projectionNodeConstructor") {
      featureDefinitions.projectionNodeConstructor = features[key];
    } else {
      featureDefinitions[key].Component = features[key];
    }
  }
}

// node_modules/framer-motion/dist/es/context/LazyContext.mjs
var import_react18 = __toESM(require_react(), 1);
var LazyContext = (0, import_react18.createContext)({ strict: false });

// node_modules/framer-motion/dist/es/motion/features/use-features.mjs
var featureNames = Object.keys(featureDefinitions);
var numFeatures = featureNames.length;
function useFeatures(props, visualElement2, preloadedFeatures) {
  var features = [];
  var lazyContext = (0, import_react19.useContext)(LazyContext);
  if (!visualElement2)
    return null;
  if (env !== "production" && preloadedFeatures && lazyContext.strict) {
    invariant(false, "You have rendered a `motion` component within a `LazyMotion` component. This will break tree shaking. Import and render a `m` component instead.");
  }
  for (var i2 = 0; i2 < numFeatures; i2++) {
    var name_1 = featureNames[i2];
    var _a2 = featureDefinitions[name_1], isEnabled = _a2.isEnabled, Component = _a2.Component;
    if (isEnabled(props) && Component) {
      features.push(React.createElement(Component, __assign({ key: name_1 }, props, { visualElement: visualElement2 })));
    }
  }
  return features;
}

// node_modules/framer-motion/dist/es/context/MotionConfigContext.mjs
var import_react20 = __toESM(require_react(), 1);
var MotionConfigContext = (0, import_react20.createContext)({
  transformPagePoint: function(p2) {
    return p2;
  },
  isStatic: false,
  reducedMotion: "never"
});

// node_modules/framer-motion/dist/es/context/MotionContext/index.mjs
var import_react21 = __toESM(require_react(), 1);
var MotionContext = (0, import_react21.createContext)({});
function useVisualElementContext() {
  return (0, import_react21.useContext)(MotionContext).visualElement;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
var import_react25 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/PresenceContext.mjs
var import_react22 = __toESM(require_react(), 1);
var PresenceContext = (0, import_react22.createContext)(null);

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var import_react23 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-browser.mjs
var isBrowser = typeof document !== "undefined";

// node_modules/framer-motion/dist/es/utils/use-isomorphic-effect.mjs
var useIsomorphicLayoutEffect = isBrowser ? import_react23.useLayoutEffect : import_react23.useEffect;

// node_modules/framer-motion/dist/es/utils/use-reduced-motion.mjs
init_tslib_es6();
var import_react24 = __toESM(require_react(), 1);
var prefersReducedMotion = { current: null };
var hasDetected = false;
function initPrefersReducedMotion() {
  hasDetected = true;
  if (!isBrowser)
    return;
  if (window.matchMedia) {
    var motionMediaQuery_1 = window.matchMedia("(prefers-reduced-motion)");
    var setReducedMotionPreferences = function() {
      return prefersReducedMotion.current = motionMediaQuery_1.matches;
    };
    motionMediaQuery_1.addListener(setReducedMotionPreferences);
    setReducedMotionPreferences();
  } else {
    prefersReducedMotion.current = false;
  }
}
function useReducedMotion() {
  !hasDetected && initPrefersReducedMotion();
  var _a2 = __read((0, import_react24.useState)(prefersReducedMotion.current), 1), shouldReduceMotion = _a2[0];
  return shouldReduceMotion;
}
function useReducedMotionConfig() {
  var reducedMotionPreference = useReducedMotion();
  var reducedMotion = (0, import_react24.useContext)(MotionConfigContext).reducedMotion;
  if (reducedMotion === "never") {
    return false;
  } else if (reducedMotion === "always") {
    return true;
  } else {
    return reducedMotionPreference;
  }
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-element.mjs
function useVisualElement(Component, visualState, props, createVisualElement) {
  var lazyContext = (0, import_react25.useContext)(LazyContext);
  var parent = useVisualElementContext();
  var presenceContext = (0, import_react25.useContext)(PresenceContext);
  var shouldReduceMotion = useReducedMotionConfig();
  var visualElementRef = (0, import_react25.useRef)(void 0);
  if (!createVisualElement)
    createVisualElement = lazyContext.renderer;
  if (!visualElementRef.current && createVisualElement) {
    visualElementRef.current = createVisualElement(Component, {
      visualState,
      parent,
      props,
      presenceId: presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.id,
      blockInitialAnimation: (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false,
      shouldReduceMotion
    });
  }
  var visualElement2 = visualElementRef.current;
  useIsomorphicLayoutEffect(function() {
    visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
  });
  (0, import_react25.useEffect)(function() {
    var _a2;
    (_a2 = visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.animateChanges();
  });
  useIsomorphicLayoutEffect(function() {
    return function() {
      return visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.notifyUnmount();
    };
  }, []);
  return visualElement2;
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
var import_react26 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/is-ref-object.mjs
function isRefObject(ref) {
  return typeof ref === "object" && Object.prototype.hasOwnProperty.call(ref, "current");
}

// node_modules/framer-motion/dist/es/motion/utils/use-motion-ref.mjs
function useMotionRef(visualState, visualElement2, externalRef) {
  return (0, import_react26.useCallback)(
    function(instance) {
      var _a2;
      instance && ((_a2 = visualState.mount) === null || _a2 === void 0 ? void 0 : _a2.call(visualState, instance));
      if (visualElement2) {
        instance ? visualElement2.mount(instance) : visualElement2.unmount();
      }
      if (externalRef) {
        if (typeof externalRef === "function") {
          externalRef(instance);
        } else if (isRefObject(externalRef)) {
          externalRef.current = instance;
        }
      }
    },
    /**
     * Only pass a new ref callback to React if we've received a visual element
     * factory. Otherwise we'll be mounting/remounting every time externalRef
     * or other dependencies change.
     */
    [visualElement2]
  );
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
var import_react27 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/utils/variants.mjs
function isVariantLabels(v2) {
  return Array.isArray(v2);
}
function isVariantLabel(v2) {
  return typeof v2 === "string" || isVariantLabels(v2);
}
function getCurrent(visualElement2) {
  var current = {};
  visualElement2.forEachValue(function(value, key) {
    return current[key] = value.get();
  });
  return current;
}
function getVelocity(visualElement2) {
  var velocity = {};
  visualElement2.forEachValue(function(value, key) {
    return velocity[key] = value.getVelocity();
  });
  return velocity;
}
function resolveVariantFromProps(props, definition, custom2, currentValues, currentVelocity) {
  var _a2;
  if (currentValues === void 0) {
    currentValues = {};
  }
  if (currentVelocity === void 0) {
    currentVelocity = {};
  }
  if (typeof definition === "function") {
    definition = definition(custom2 !== null && custom2 !== void 0 ? custom2 : props.custom, currentValues, currentVelocity);
  }
  if (typeof definition === "string") {
    definition = (_a2 = props.variants) === null || _a2 === void 0 ? void 0 : _a2[definition];
  }
  if (typeof definition === "function") {
    definition = definition(custom2 !== null && custom2 !== void 0 ? custom2 : props.custom, currentValues, currentVelocity);
  }
  return definition;
}
function resolveVariant(visualElement2, definition, custom2) {
  var props = visualElement2.getProps();
  return resolveVariantFromProps(props, definition, custom2 !== null && custom2 !== void 0 ? custom2 : props.custom, getCurrent(visualElement2), getVelocity(visualElement2));
}
function checkIfControllingVariants(props) {
  var _a2;
  return typeof ((_a2 = props.animate) === null || _a2 === void 0 ? void 0 : _a2.start) === "function" || isVariantLabel(props.initial) || isVariantLabel(props.animate) || isVariantLabel(props.whileHover) || isVariantLabel(props.whileDrag) || isVariantLabel(props.whileTap) || isVariantLabel(props.whileFocus) || isVariantLabel(props.exit);
}
function checkIfVariantNode(props) {
  return Boolean(checkIfControllingVariants(props) || props.variants);
}

// node_modules/framer-motion/dist/es/context/MotionContext/utils.mjs
function getCurrentTreeVariants(props, context) {
  if (checkIfControllingVariants(props)) {
    var initial = props.initial, animate4 = props.animate;
    return {
      initial: initial === false || isVariantLabel(initial) ? initial : void 0,
      animate: isVariantLabel(animate4) ? animate4 : void 0
    };
  }
  return props.inherit !== false ? context : {};
}

// node_modules/framer-motion/dist/es/context/MotionContext/create.mjs
function useCreateMotionContext(props) {
  var _a2 = getCurrentTreeVariants(props, (0, import_react27.useContext)(MotionContext)), initial = _a2.initial, animate4 = _a2.animate;
  return (0, import_react27.useMemo)(function() {
    return { initial, animate: animate4 };
  }, [variantLabelsAsDependency(initial), variantLabelsAsDependency(animate4)]);
}
function variantLabelsAsDependency(prop) {
  return Array.isArray(prop) ? prop.join(" ") : prop;
}

// node_modules/framer-motion/dist/es/utils/use-constant.mjs
var import_react28 = __toESM(require_react(), 1);
function useConstant(init2) {
  var ref = (0, import_react28.useRef)(null);
  if (ref.current === null) {
    ref.current = init2();
  }
  return ref.current;
}

// node_modules/framer-motion/dist/es/projection/node/state.mjs
var globalProjectionState = {
  /**
   * Global flag as to whether the tree has animated since the last time
   * we resized the window
   */
  hasAnimatedSinceResize: true,
  /**
   * We set this to true once, on the first update. Any nodes added to the tree beyond that
   * update will be given a `data-projection-id` attribute.
   */
  hasEverUpdated: false
};

// node_modules/framer-motion/dist/es/projection/node/id.mjs
var id = 1;
function useProjectionId() {
  return useConstant(function() {
    if (globalProjectionState.hasEverUpdated) {
      return id++;
    }
  });
}

// node_modules/framer-motion/dist/es/context/LayoutGroupContext.mjs
var import_react29 = __toESM(require_react(), 1);
var LayoutGroupContext = (0, import_react29.createContext)({});

// node_modules/framer-motion/dist/es/motion/features/use-projection.mjs
var import_react31 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/SwitchLayoutGroupContext.mjs
var import_react30 = __toESM(require_react(), 1);
var SwitchLayoutGroupContext = (0, import_react30.createContext)({});

// node_modules/framer-motion/dist/es/motion/features/use-projection.mjs
function useProjection(projectionId, _a2, visualElement2, ProjectionNodeConstructor) {
  var _b;
  var layoutId = _a2.layoutId, layout = _a2.layout, drag2 = _a2.drag, dragConstraints = _a2.dragConstraints, layoutScroll = _a2.layoutScroll;
  var initialPromotionConfig = (0, import_react31.useContext)(SwitchLayoutGroupContext);
  if (!ProjectionNodeConstructor || !visualElement2 || (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.projection)) {
    return;
  }
  visualElement2.projection = new ProjectionNodeConstructor(projectionId, visualElement2.getLatestValues(), (_b = visualElement2.parent) === null || _b === void 0 ? void 0 : _b.projection);
  visualElement2.projection.setOptions({
    layoutId,
    layout,
    alwaysMeasureLayout: Boolean(drag2) || dragConstraints && isRefObject(dragConstraints),
    visualElement: visualElement2,
    scheduleRender: function() {
      return visualElement2.scheduleRender();
    },
    /**
     * TODO: Update options in an effect. This could be tricky as it'll be too late
     * to update by the time layout animations run.
     * We also need to fix this safeToRemove by linking it up to the one returned by usePresence,
     * ensuring it gets called if there's no potential layout animations.
     *
     */
    animationType: typeof layout === "string" ? layout : "both",
    initialPromotionConfig,
    layoutScroll
  });
}

// node_modules/framer-motion/dist/es/motion/utils/VisualElementHandler.mjs
init_tslib_es6();
var import_react32 = __toESM(require_react(), 1);
var VisualElementHandler = (
  /** @class */
  function(_super) {
    __extends(VisualElementHandler2, _super);
    function VisualElementHandler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VisualElementHandler2.prototype.getSnapshotBeforeUpdate = function() {
      this.updateProps();
      return null;
    };
    VisualElementHandler2.prototype.componentDidUpdate = function() {
    };
    VisualElementHandler2.prototype.updateProps = function() {
      var _a2 = this.props, visualElement2 = _a2.visualElement, props = _a2.props;
      if (visualElement2)
        visualElement2.setProps(props);
    };
    VisualElementHandler2.prototype.render = function() {
      return this.props.children;
    };
    return VisualElementHandler2;
  }(import_react32.default.Component)
);

// node_modules/framer-motion/dist/es/motion/index.mjs
function createMotionComponent(_a2) {
  var preloadedFeatures = _a2.preloadedFeatures, createVisualElement = _a2.createVisualElement, projectionNodeConstructor = _a2.projectionNodeConstructor, useRender = _a2.useRender, useVisualState2 = _a2.useVisualState, Component = _a2.Component;
  preloadedFeatures && loadFeatures(preloadedFeatures);
  function MotionComponent(props, externalRef) {
    var layoutId = useLayoutId(props);
    props = __assign(__assign({}, props), { layoutId });
    var config = (0, import_react33.useContext)(MotionConfigContext);
    var features = null;
    var context = useCreateMotionContext(props);
    var projectionId = config.isStatic ? void 0 : useProjectionId();
    var visualState = useVisualState2(props, config.isStatic);
    if (!config.isStatic && isBrowser) {
      context.visualElement = useVisualElement(Component, visualState, __assign(__assign({}, config), props), createVisualElement);
      useProjection(projectionId, props, context.visualElement, projectionNodeConstructor || featureDefinitions.projectionNodeConstructor);
      features = useFeatures(props, context.visualElement, preloadedFeatures);
    }
    return React2.createElement(
      VisualElementHandler,
      { visualElement: context.visualElement, props: __assign(__assign({}, config), props) },
      features,
      React2.createElement(MotionContext.Provider, { value: context }, useRender(Component, props, projectionId, useMotionRef(visualState, context.visualElement, externalRef), visualState, config.isStatic, context.visualElement))
    );
  }
  return (0, import_react33.forwardRef)(MotionComponent);
}
function useLayoutId(_a2) {
  var _b;
  var layoutId = _a2.layoutId;
  var layoutGroupId = (_b = (0, import_react33.useContext)(LayoutGroupContext)) === null || _b === void 0 ? void 0 : _b.id;
  return layoutGroupId && layoutId !== void 0 ? layoutGroupId + "-" + layoutId : layoutId;
}

// node_modules/framer-motion/dist/es/render/dom/motion-proxy.mjs
function createMotionProxy(createConfig2) {
  function custom2(Component, customMotionComponentConfig) {
    if (customMotionComponentConfig === void 0) {
      customMotionComponentConfig = {};
    }
    return createMotionComponent(createConfig2(Component, customMotionComponentConfig));
  }
  if (typeof Proxy === "undefined") {
    return custom2;
  }
  var componentCache = /* @__PURE__ */ new Map();
  return new Proxy(custom2, {
    /**
     * Called when `motion` is referenced with a prop: `motion.div`, `motion.input` etc.
     * The prop name is passed through as `key` and we can use that to generate a `motion`
     * DOM component with that name.
     */
    get: function(_target, key) {
      if (!componentCache.has(key)) {
        componentCache.set(key, custom2(key));
      }
      return componentCache.get(key);
    }
  });
}

// node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/render/svg/lowercase-elements.mjs
var lowercaseSVGElements = [
  "animate",
  "circle",
  "defs",
  "desc",
  "ellipse",
  "g",
  "image",
  "line",
  "filter",
  "marker",
  "mask",
  "metadata",
  "path",
  "pattern",
  "polygon",
  "polyline",
  "rect",
  "stop",
  "svg",
  "switch",
  "symbol",
  "text",
  "tspan",
  "use",
  "view"
];

// node_modules/framer-motion/dist/es/render/dom/utils/is-svg-component.mjs
function isSVGComponent(Component) {
  if (
    /**
     * If it's not a string, it's a custom React component. Currently we only support
     * HTML custom React components.
     */
    typeof Component !== "string" || /**
     * If it contains a dash, the element is a custom HTML webcomponent.
     */
    Component.includes("-")
  ) {
    return false;
  } else if (
    /**
     * If it's in our list of lowercase SVG tags, it's an SVG component
     */
    lowercaseSVGElements.indexOf(Component) > -1 || /**
     * If it contains a capital letter, it's an SVG component
     */
    /[A-Z]/.test(Component)
  ) {
    return true;
  }
  return false;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
init_tslib_es6();
var import_react36 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
init_tslib_es6();
var import_react34 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/styles/scale-correction.mjs
var scaleCorrectors = {};
function addScaleCorrector(correctors) {
  Object.assign(scaleCorrectors, correctors);
}

// node_modules/framer-motion/dist/es/render/html/utils/transform.mjs
var transformAxes = ["", "X", "Y", "Z"];
var order = ["translate", "scale", "rotate", "skew"];
var transformProps = ["transformPerspective", "x", "y", "z"];
order.forEach(function(operationKey) {
  return transformAxes.forEach(function(axesKey) {
    return transformProps.push(operationKey + axesKey);
  });
});
function sortTransformProps(a3, b4) {
  return transformProps.indexOf(a3) - transformProps.indexOf(b4);
}
var transformPropSet = new Set(transformProps);
function isTransformProp(key) {
  return transformPropSet.has(key);
}
var transformOriginProps = /* @__PURE__ */ new Set(["originX", "originY", "originZ"]);
function isTransformOriginProp(key) {
  return transformOriginProps.has(key);
}

// node_modules/framer-motion/dist/es/motion/utils/is-forced-motion-value.mjs
function isForcedMotionValue(key, _a2) {
  var layout = _a2.layout, layoutId = _a2.layoutId;
  return isTransformProp(key) || isTransformOriginProp(key) || (layout || layoutId !== void 0) && (!!scaleCorrectors[key] || key === "opacity");
}

// node_modules/framer-motion/dist/es/value/utils/is-motion-value.mjs
var isMotionValue = function(value) {
  return Boolean(value !== null && typeof value === "object" && value.getVelocity);
};

// node_modules/framer-motion/dist/es/render/html/utils/build-transform.mjs
var translateAlias = {
  x: "translateX",
  y: "translateY",
  z: "translateZ",
  transformPerspective: "perspective"
};
function buildTransform(_a2, _b, transformIsDefault, transformTemplate) {
  var transform2 = _a2.transform, transformKeys2 = _a2.transformKeys;
  var _c2 = _b.enableHardwareAcceleration, enableHardwareAcceleration = _c2 === void 0 ? true : _c2, _d = _b.allowTransformNone, allowTransformNone = _d === void 0 ? true : _d;
  var transformString = "";
  transformKeys2.sort(sortTransformProps);
  var transformHasZ = false;
  var numTransformKeys = transformKeys2.length;
  for (var i2 = 0; i2 < numTransformKeys; i2++) {
    var key = transformKeys2[i2];
    transformString += "".concat(translateAlias[key] || key, "(").concat(transform2[key], ") ");
    if (key === "z")
      transformHasZ = true;
  }
  if (!transformHasZ && enableHardwareAcceleration) {
    transformString += "translateZ(0)";
  } else {
    transformString = transformString.trim();
  }
  if (transformTemplate) {
    transformString = transformTemplate(transform2, transformIsDefault ? "" : transformString);
  } else if (allowTransformNone && transformIsDefault) {
    transformString = "none";
  }
  return transformString;
}
function buildTransformOrigin(_a2) {
  var _b = _a2.originX, originX = _b === void 0 ? "50%" : _b, _c2 = _a2.originY, originY = _c2 === void 0 ? "50%" : _c2, _d = _a2.originZ, originZ = _d === void 0 ? 0 : _d;
  return "".concat(originX, " ").concat(originY, " ").concat(originZ);
}

// node_modules/framer-motion/dist/es/render/dom/utils/is-css-variable.mjs
function isCSSVariable(key) {
  return key.startsWith("--");
}

// node_modules/framer-motion/dist/es/render/dom/value-types/get-as-type.mjs
var getValueAsType = function(value, type6) {
  return type6 && typeof value === "number" ? type6.transform(value) : value;
};

// node_modules/style-value-types/dist/es/utils.mjs
var clamp = (min, max) => (v2) => Math.max(Math.min(v2, max), min);
var sanitize = (v2) => v2 % 1 ? Number(v2.toFixed(5)) : v2;
var floatRegex = /(-)?([\d]*\.?[\d])+/g;
var colorRegex = /(#[0-9a-f]{6}|#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))/gi;
var singleColorRegex = /^(#[0-9a-f]{3}|#(?:[0-9a-f]{2}){2,4}|(rgb|hsl)a?\((-?[\d\.]+%?[,\s]+){2,3}\s*\/*\s*[\d\.]+%?\))$/i;
function isString2(v2) {
  return typeof v2 === "string";
}

// node_modules/style-value-types/dist/es/numbers/index.mjs
var number = {
  test: (v2) => typeof v2 === "number",
  parse: parseFloat,
  transform: (v2) => v2
};
var alpha = Object.assign(Object.assign({}, number), { transform: clamp(0, 1) });
var scale = Object.assign(Object.assign({}, number), { default: 1 });

// node_modules/style-value-types/dist/es/numbers/units.mjs
var createUnitType = (unit) => ({
  test: (v2) => isString2(v2) && v2.endsWith(unit) && v2.split(" ").length === 1,
  parse: parseFloat,
  transform: (v2) => `${v2}${unit}`
});
var degrees = createUnitType("deg");
var percent = createUnitType("%");
var px = createUnitType("px");
var vh = createUnitType("vh");
var vw = createUnitType("vw");
var progressPercentage = Object.assign(Object.assign({}, percent), { parse: (v2) => percent.parse(v2) / 100, transform: (v2) => percent.transform(v2 * 100) });

// node_modules/style-value-types/dist/es/color/utils.mjs
var isColorString = (type6, testProp) => (v2) => {
  return Boolean(isString2(v2) && singleColorRegex.test(v2) && v2.startsWith(type6) || testProp && Object.prototype.hasOwnProperty.call(v2, testProp));
};
var splitColor = (aName, bName, cName) => (v2) => {
  if (!isString2(v2))
    return v2;
  const [a3, b4, c3, alpha2] = v2.match(floatRegex);
  return {
    [aName]: parseFloat(a3),
    [bName]: parseFloat(b4),
    [cName]: parseFloat(c3),
    alpha: alpha2 !== void 0 ? parseFloat(alpha2) : 1
  };
};

// node_modules/style-value-types/dist/es/color/hsla.mjs
var hsla = {
  test: isColorString("hsl", "hue"),
  parse: splitColor("hue", "saturation", "lightness"),
  transform: ({ hue, saturation, lightness, alpha: alpha$1 = 1 }) => {
    return "hsla(" + Math.round(hue) + ", " + percent.transform(sanitize(saturation)) + ", " + percent.transform(sanitize(lightness)) + ", " + sanitize(alpha.transform(alpha$1)) + ")";
  }
};

// node_modules/style-value-types/dist/es/color/rgba.mjs
var clampRgbUnit = clamp(0, 255);
var rgbUnit = Object.assign(Object.assign({}, number), { transform: (v2) => Math.round(clampRgbUnit(v2)) });
var rgba = {
  test: isColorString("rgb", "red"),
  parse: splitColor("red", "green", "blue"),
  transform: ({ red, green, blue, alpha: alpha$1 = 1 }) => "rgba(" + rgbUnit.transform(red) + ", " + rgbUnit.transform(green) + ", " + rgbUnit.transform(blue) + ", " + sanitize(alpha.transform(alpha$1)) + ")"
};

// node_modules/style-value-types/dist/es/color/hex.mjs
function parseHex(v2) {
  let r2 = "";
  let g3 = "";
  let b4 = "";
  let a3 = "";
  if (v2.length > 5) {
    r2 = v2.substr(1, 2);
    g3 = v2.substr(3, 2);
    b4 = v2.substr(5, 2);
    a3 = v2.substr(7, 2);
  } else {
    r2 = v2.substr(1, 1);
    g3 = v2.substr(2, 1);
    b4 = v2.substr(3, 1);
    a3 = v2.substr(4, 1);
    r2 += r2;
    g3 += g3;
    b4 += b4;
    a3 += a3;
  }
  return {
    red: parseInt(r2, 16),
    green: parseInt(g3, 16),
    blue: parseInt(b4, 16),
    alpha: a3 ? parseInt(a3, 16) / 255 : 1
  };
}
var hex = {
  test: isColorString("#"),
  parse: parseHex,
  transform: rgba.transform
};

// node_modules/style-value-types/dist/es/color/index.mjs
var color = {
  test: (v2) => rgba.test(v2) || hex.test(v2) || hsla.test(v2),
  parse: (v2) => {
    if (rgba.test(v2)) {
      return rgba.parse(v2);
    } else if (hsla.test(v2)) {
      return hsla.parse(v2);
    } else {
      return hex.parse(v2);
    }
  },
  transform: (v2) => {
    return isString2(v2) ? v2 : v2.hasOwnProperty("red") ? rgba.transform(v2) : hsla.transform(v2);
  }
};

// node_modules/style-value-types/dist/es/complex/index.mjs
var colorToken = "${c}";
var numberToken = "${n}";
function test(v2) {
  var _a2, _b, _c2, _d;
  return isNaN(v2) && isString2(v2) && ((_b = (_a2 = v2.match(floatRegex)) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b !== void 0 ? _b : 0) + ((_d = (_c2 = v2.match(colorRegex)) === null || _c2 === void 0 ? void 0 : _c2.length) !== null && _d !== void 0 ? _d : 0) > 0;
}
function analyse(v2) {
  if (typeof v2 === "number")
    v2 = `${v2}`;
  const values = [];
  let numColors = 0;
  const colors = v2.match(colorRegex);
  if (colors) {
    numColors = colors.length;
    v2 = v2.replace(colorRegex, colorToken);
    values.push(...colors.map(color.parse));
  }
  const numbers = v2.match(floatRegex);
  if (numbers) {
    v2 = v2.replace(floatRegex, numberToken);
    values.push(...numbers.map(number.parse));
  }
  return { values, numColors, tokenised: v2 };
}
function parse(v2) {
  return analyse(v2).values;
}
function createTransformer(v2) {
  const { values, numColors, tokenised } = analyse(v2);
  const numValues = values.length;
  return (v3) => {
    let output = tokenised;
    for (let i2 = 0; i2 < numValues; i2++) {
      output = output.replace(i2 < numColors ? colorToken : numberToken, i2 < numColors ? color.transform(v3[i2]) : sanitize(v3[i2]));
    }
    return output;
  };
}
var convertNumbersToZero = (v2) => typeof v2 === "number" ? 0 : v2;
function getAnimatableNone(v2) {
  const parsed = parse(v2);
  const transformer = createTransformer(v2);
  return transformer(parsed.map(convertNumbersToZero));
}
var complex = { test, parse, createTransformer, getAnimatableNone };

// node_modules/style-value-types/dist/es/complex/filter.mjs
var maxDefaults = /* @__PURE__ */ new Set(["brightness", "contrast", "saturate", "opacity"]);
function applyDefaultFilter(v2) {
  let [name, value] = v2.slice(0, -1).split("(");
  if (name === "drop-shadow")
    return v2;
  const [number2] = value.match(floatRegex) || [];
  if (!number2)
    return v2;
  const unit = value.replace(number2, "");
  let defaultValue = maxDefaults.has(name) ? 1 : 0;
  if (number2 !== value)
    defaultValue *= 100;
  return name + "(" + defaultValue + unit + ")";
}
var functionRegex = /([a-z-]*)\(.*?\)/g;
var filter = Object.assign(Object.assign({}, complex), { getAnimatableNone: (v2) => {
  const functions = v2.match(functionRegex);
  return functions ? functions.map(applyDefaultFilter).join(" ") : v2;
} });

// node_modules/framer-motion/dist/es/render/dom/value-types/type-int.mjs
init_tslib_es6();
var int = __assign(__assign({}, number), { transform: Math.round });

// node_modules/framer-motion/dist/es/render/dom/value-types/number.mjs
var numberValueTypes = {
  // Border props
  borderWidth: px,
  borderTopWidth: px,
  borderRightWidth: px,
  borderBottomWidth: px,
  borderLeftWidth: px,
  borderRadius: px,
  radius: px,
  borderTopLeftRadius: px,
  borderTopRightRadius: px,
  borderBottomRightRadius: px,
  borderBottomLeftRadius: px,
  // Positioning props
  width: px,
  maxWidth: px,
  height: px,
  maxHeight: px,
  size: px,
  top: px,
  right: px,
  bottom: px,
  left: px,
  // Spacing props
  padding: px,
  paddingTop: px,
  paddingRight: px,
  paddingBottom: px,
  paddingLeft: px,
  margin: px,
  marginTop: px,
  marginRight: px,
  marginBottom: px,
  marginLeft: px,
  // Transform props
  rotate: degrees,
  rotateX: degrees,
  rotateY: degrees,
  rotateZ: degrees,
  scale,
  scaleX: scale,
  scaleY: scale,
  scaleZ: scale,
  skew: degrees,
  skewX: degrees,
  skewY: degrees,
  distance: px,
  translateX: px,
  translateY: px,
  translateZ: px,
  x: px,
  y: px,
  z: px,
  perspective: px,
  transformPerspective: px,
  opacity: alpha,
  originX: progressPercentage,
  originY: progressPercentage,
  originZ: px,
  // Misc
  zIndex: int,
  // SVG
  fillOpacity: alpha,
  strokeOpacity: alpha,
  numOctaves: int
};

// node_modules/framer-motion/dist/es/render/html/utils/build-styles.mjs
function buildHTMLStyles(state, latestValues, options, transformTemplate) {
  var _a2;
  var style2 = state.style, vars = state.vars, transform2 = state.transform, transformKeys2 = state.transformKeys, transformOrigin = state.transformOrigin;
  transformKeys2.length = 0;
  var hasTransform2 = false;
  var hasTransformOrigin = false;
  var transformIsNone = true;
  for (var key in latestValues) {
    var value = latestValues[key];
    if (isCSSVariable(key)) {
      vars[key] = value;
      continue;
    }
    var valueType = numberValueTypes[key];
    var valueAsType = getValueAsType(value, valueType);
    if (isTransformProp(key)) {
      hasTransform2 = true;
      transform2[key] = valueAsType;
      transformKeys2.push(key);
      if (!transformIsNone)
        continue;
      if (value !== ((_a2 = valueType.default) !== null && _a2 !== void 0 ? _a2 : 0))
        transformIsNone = false;
    } else if (isTransformOriginProp(key)) {
      transformOrigin[key] = valueAsType;
      hasTransformOrigin = true;
    } else {
      style2[key] = valueAsType;
    }
  }
  if (hasTransform2) {
    style2.transform = buildTransform(state, options, transformIsNone, transformTemplate);
  } else if (transformTemplate) {
    style2.transform = transformTemplate({}, "");
  } else if (!latestValues.transform && style2.transform) {
    style2.transform = "none";
  }
  if (hasTransformOrigin) {
    style2.transformOrigin = buildTransformOrigin(transformOrigin);
  }
}

// node_modules/framer-motion/dist/es/render/html/utils/create-render-state.mjs
var createHtmlRenderState = function() {
  return {
    style: {},
    transform: {},
    transformKeys: [],
    transformOrigin: {},
    vars: {}
  };
};

// node_modules/framer-motion/dist/es/render/html/use-props.mjs
function copyRawValuesOnly(target, source, props) {
  for (var key in source) {
    if (!isMotionValue(source[key]) && !isForcedMotionValue(key, props)) {
      target[key] = source[key];
    }
  }
}
function useInitialMotionValues(_a2, visualState, isStatic) {
  var transformTemplate = _a2.transformTemplate;
  return (0, import_react34.useMemo)(function() {
    var state = createHtmlRenderState();
    buildHTMLStyles(state, visualState, { enableHardwareAcceleration: !isStatic }, transformTemplate);
    var vars = state.vars, style2 = state.style;
    return __assign(__assign({}, vars), style2);
  }, [visualState]);
}
function useStyle(props, visualState, isStatic) {
  var styleProp = props.style || {};
  var style2 = {};
  copyRawValuesOnly(style2, styleProp, props);
  Object.assign(style2, useInitialMotionValues(props, visualState, isStatic));
  if (props.transformValues) {
    style2 = props.transformValues(style2);
  }
  return style2;
}
function useHTMLProps(props, visualState, isStatic) {
  var htmlProps = {};
  var style2 = useStyle(props, visualState, isStatic);
  if (Boolean(props.drag) && props.dragListener !== false) {
    htmlProps.draggable = false;
    style2.userSelect = style2.WebkitUserSelect = style2.WebkitTouchCallout = "none";
    style2.touchAction = props.drag === true ? "none" : "pan-".concat(props.drag === "x" ? "y" : "x");
  }
  htmlProps.style = style2;
  return htmlProps;
}

// node_modules/framer-motion/dist/es/motion/utils/valid-prop.mjs
var validMotionProps = /* @__PURE__ */ new Set([
  "initial",
  "animate",
  "exit",
  "style",
  "variants",
  "transition",
  "transformTemplate",
  "transformValues",
  "custom",
  "inherit",
  "layout",
  "layoutId",
  "layoutDependency",
  "onLayoutAnimationStart",
  "onLayoutAnimationComplete",
  "onLayoutMeasure",
  "onBeforeLayoutMeasure",
  "onAnimationStart",
  "onAnimationComplete",
  "onUpdate",
  "onDragStart",
  "onDrag",
  "onDragEnd",
  "onMeasureDragConstraints",
  "onDirectionLock",
  "onDragTransitionEnd",
  "drag",
  "dragControls",
  "dragListener",
  "dragConstraints",
  "dragDirectionLock",
  "dragSnapToOrigin",
  "_dragX",
  "_dragY",
  "dragElastic",
  "dragMomentum",
  "dragPropagation",
  "dragTransition",
  "whileDrag",
  "onPan",
  "onPanStart",
  "onPanEnd",
  "onPanSessionStart",
  "onTap",
  "onTapStart",
  "onTapCancel",
  "onHoverStart",
  "onHoverEnd",
  "whileFocus",
  "whileTap",
  "whileHover",
  "whileInView",
  "onViewportEnter",
  "onViewportLeave",
  "viewport",
  "layoutScroll"
]);
function isValidMotionProp(key) {
  return validMotionProps.has(key);
}

// node_modules/framer-motion/dist/es/render/dom/utils/filter-props.mjs
var shouldForward = function(key) {
  return !isValidMotionProp(key);
};
function loadExternalIsValidProp(isValidProp) {
  if (!isValidProp)
    return;
  shouldForward = function(key) {
    return key.startsWith("on") ? !isValidMotionProp(key) : isValidProp(key);
  };
}
try {
  loadExternalIsValidProp((init_is_prop_valid_browser_esm(), __toCommonJS(is_prop_valid_browser_esm_exports)).default);
} catch (_a2) {
}
function filterProps(props, isDom, forwardMotionProps) {
  var filteredProps = {};
  for (var key in props) {
    if (shouldForward(key) || forwardMotionProps === true && isValidMotionProp(key) || !isDom && !isValidMotionProp(key) || // If trying to use native HTML drag events, forward drag listeners
    props["draggable"] && key.startsWith("onDrag")) {
      filteredProps[key] = props[key];
    }
  }
  return filteredProps;
}

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
init_tslib_es6();
var import_react35 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/render/svg/utils/transform-origin.mjs
function calcOrigin(origin2, offset, size5) {
  return typeof origin2 === "string" ? origin2 : px.transform(offset + size5 * origin2);
}
function calcSVGTransformOrigin(dimensions, originX, originY) {
  var pxOriginX = calcOrigin(originX, dimensions.x, dimensions.width);
  var pxOriginY = calcOrigin(originY, dimensions.y, dimensions.height);
  return "".concat(pxOriginX, " ").concat(pxOriginY);
}

// node_modules/framer-motion/dist/es/render/svg/utils/path.mjs
var dashKeys = {
  offset: "stroke-dashoffset",
  array: "stroke-dasharray"
};
var camelKeys = {
  offset: "strokeDashoffset",
  array: "strokeDasharray"
};
function buildSVGPath(attrs, length2, spacing, offset, useDashCase) {
  if (spacing === void 0) {
    spacing = 1;
  }
  if (offset === void 0) {
    offset = 0;
  }
  if (useDashCase === void 0) {
    useDashCase = true;
  }
  attrs.pathLength = 1;
  var keys = useDashCase ? dashKeys : camelKeys;
  attrs[keys.offset] = px.transform(-offset);
  var pathLength = px.transform(length2);
  var pathSpacing = px.transform(spacing);
  attrs[keys.array] = "".concat(pathLength, " ").concat(pathSpacing);
}

// node_modules/framer-motion/dist/es/render/svg/utils/build-attrs.mjs
function buildSVGAttrs(state, _a2, options, transformTemplate) {
  var attrX = _a2.attrX, attrY = _a2.attrY, originX = _a2.originX, originY = _a2.originY, pathLength = _a2.pathLength, _b = _a2.pathSpacing, pathSpacing = _b === void 0 ? 1 : _b, _c2 = _a2.pathOffset, pathOffset = _c2 === void 0 ? 0 : _c2, latest = __rest(_a2, ["attrX", "attrY", "originX", "originY", "pathLength", "pathSpacing", "pathOffset"]);
  buildHTMLStyles(state, latest, options, transformTemplate);
  state.attrs = state.style;
  state.style = {};
  var attrs = state.attrs, style2 = state.style, dimensions = state.dimensions;
  if (attrs.transform) {
    if (dimensions)
      style2.transform = attrs.transform;
    delete attrs.transform;
  }
  if (dimensions && (originX !== void 0 || originY !== void 0 || style2.transform)) {
    style2.transformOrigin = calcSVGTransformOrigin(dimensions, originX !== void 0 ? originX : 0.5, originY !== void 0 ? originY : 0.5);
  }
  if (attrX !== void 0)
    attrs.x = attrX;
  if (attrY !== void 0)
    attrs.y = attrY;
  if (pathLength !== void 0) {
    buildSVGPath(attrs, pathLength, pathSpacing, pathOffset, false);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/create-render-state.mjs
init_tslib_es6();
var createSvgRenderState = function() {
  return __assign(__assign({}, createHtmlRenderState()), { attrs: {} });
};

// node_modules/framer-motion/dist/es/render/svg/use-props.mjs
function useSVGProps(props, visualState) {
  var visualProps = (0, import_react35.useMemo)(function() {
    var state = createSvgRenderState();
    buildSVGAttrs(state, visualState, { enableHardwareAcceleration: false }, props.transformTemplate);
    return __assign(__assign({}, state.attrs), { style: __assign({}, state.style) });
  }, [visualState]);
  if (props.style) {
    var rawStyles = {};
    copyRawValuesOnly(rawStyles, props.style, props);
    visualProps.style = __assign(__assign({}, rawStyles), visualProps.style);
  }
  return visualProps;
}

// node_modules/framer-motion/dist/es/render/dom/use-render.mjs
function createUseRender(forwardMotionProps) {
  if (forwardMotionProps === void 0) {
    forwardMotionProps = false;
  }
  var useRender = function(Component, props, projectionId, ref, _a2, isStatic) {
    var latestValues = _a2.latestValues;
    var useVisualProps = isSVGComponent(Component) ? useSVGProps : useHTMLProps;
    var visualProps = useVisualProps(props, latestValues, isStatic);
    var filteredProps = filterProps(props, typeof Component === "string", forwardMotionProps);
    var elementProps = __assign(__assign(__assign({}, filteredProps), visualProps), { ref });
    if (projectionId) {
      elementProps["data-projection-id"] = projectionId;
    }
    return (0, import_react36.createElement)(Component, elementProps);
  };
  return useRender;
}

// node_modules/framer-motion/dist/es/render/dom/utils/camel-to-dash.mjs
var CAMEL_CASE_PATTERN = /([a-z])([A-Z])/g;
var REPLACE_TEMPLATE = "$1-$2";
var camelToDash = function(str) {
  return str.replace(CAMEL_CASE_PATTERN, REPLACE_TEMPLATE).toLowerCase();
};

// node_modules/framer-motion/dist/es/render/html/utils/render.mjs
function renderHTML(element, _a2, styleProp, projection) {
  var style2 = _a2.style, vars = _a2.vars;
  Object.assign(element.style, style2, projection && projection.getProjectionStyles(styleProp));
  for (var key in vars) {
    element.style.setProperty(key, vars[key]);
  }
}

// node_modules/framer-motion/dist/es/render/svg/utils/camel-case-attrs.mjs
var camelCaseAttributes = /* @__PURE__ */ new Set([
  "baseFrequency",
  "diffuseConstant",
  "kernelMatrix",
  "kernelUnitLength",
  "keySplines",
  "keyTimes",
  "limitingConeAngle",
  "markerHeight",
  "markerWidth",
  "numOctaves",
  "targetX",
  "targetY",
  "surfaceScale",
  "specularConstant",
  "specularExponent",
  "stdDeviation",
  "tableValues",
  "viewBox",
  "gradientTransform",
  "pathLength"
]);

// node_modules/framer-motion/dist/es/render/svg/utils/render.mjs
function renderSVG(element, renderState, _styleProp, projection) {
  renderHTML(element, renderState, void 0, projection);
  for (var key in renderState.attrs) {
    element.setAttribute(!camelCaseAttributes.has(key) ? camelToDash(key) : key, renderState.attrs[key]);
  }
}

// node_modules/framer-motion/dist/es/render/html/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps(props) {
  var style2 = props.style;
  var newValues = {};
  for (var key in style2) {
    if (isMotionValue(style2[key]) || isForcedMotionValue(key, props)) {
      newValues[key] = style2[key];
    }
  }
  return newValues;
}

// node_modules/framer-motion/dist/es/render/svg/utils/scrape-motion-values.mjs
function scrapeMotionValuesFromProps2(props) {
  var newValues = scrapeMotionValuesFromProps(props);
  for (var key in props) {
    if (isMotionValue(props[key])) {
      var targetKey = key === "x" || key === "y" ? "attr" + key.toUpperCase() : key;
      newValues[targetKey] = props[key];
    }
  }
  return newValues;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
init_tslib_es6();
var import_react37 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/animation/utils/is-animation-controls.mjs
function isAnimationControls(v2) {
  return typeof v2 === "object" && typeof v2.start === "function";
}

// node_modules/framer-motion/dist/es/animation/utils/is-keyframes-target.mjs
var isKeyframesTarget = function(v2) {
  return Array.isArray(v2);
};

// node_modules/framer-motion/dist/es/utils/resolve-value.mjs
var isCustomValue = function(v2) {
  return Boolean(v2 && typeof v2 === "object" && v2.mix && v2.toValue);
};
var resolveFinalValueInKeyframes = function(v2) {
  return isKeyframesTarget(v2) ? v2[v2.length - 1] || 0 : v2;
};

// node_modules/framer-motion/dist/es/value/utils/resolve-motion-value.mjs
function resolveMotionValue(value) {
  var unwrappedValue = isMotionValue(value) ? value.get() : value;
  return isCustomValue(unwrappedValue) ? unwrappedValue.toValue() : unwrappedValue;
}

// node_modules/framer-motion/dist/es/motion/utils/use-visual-state.mjs
function makeState(_a2, props, context, presenceContext) {
  var scrapeMotionValuesFromProps3 = _a2.scrapeMotionValuesFromProps, createRenderState = _a2.createRenderState, onMount = _a2.onMount;
  var state = {
    latestValues: makeLatestValues(props, context, presenceContext, scrapeMotionValuesFromProps3),
    renderState: createRenderState()
  };
  if (onMount) {
    state.mount = function(instance) {
      return onMount(props, instance, state);
    };
  }
  return state;
}
var makeUseVisualState = function(config) {
  return function(props, isStatic) {
    var context = (0, import_react37.useContext)(MotionContext);
    var presenceContext = (0, import_react37.useContext)(PresenceContext);
    return isStatic ? makeState(config, props, context, presenceContext) : useConstant(function() {
      return makeState(config, props, context, presenceContext);
    });
  };
};
function makeLatestValues(props, context, presenceContext, scrapeMotionValues) {
  var values = {};
  var blockInitialAnimation = (presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.initial) === false;
  var motionValues = scrapeMotionValues(props);
  for (var key in motionValues) {
    values[key] = resolveMotionValue(motionValues[key]);
  }
  var initial = props.initial, animate4 = props.animate;
  var isControllingVariants = checkIfControllingVariants(props);
  var isVariantNode = checkIfVariantNode(props);
  if (context && isVariantNode && !isControllingVariants && props.inherit !== false) {
    initial !== null && initial !== void 0 ? initial : initial = context.initial;
    animate4 !== null && animate4 !== void 0 ? animate4 : animate4 = context.animate;
  }
  var initialAnimationIsBlocked = blockInitialAnimation || initial === false;
  var variantToSet = initialAnimationIsBlocked ? animate4 : initial;
  if (variantToSet && typeof variantToSet !== "boolean" && !isAnimationControls(variantToSet)) {
    var list = Array.isArray(variantToSet) ? variantToSet : [variantToSet];
    list.forEach(function(definition) {
      var resolved = resolveVariantFromProps(props, definition);
      if (!resolved)
        return;
      var transitionEnd = resolved.transitionEnd;
      resolved.transition;
      var target = __rest(resolved, ["transitionEnd", "transition"]);
      for (var key2 in target) {
        var valueTarget = target[key2];
        if (Array.isArray(valueTarget)) {
          var index5 = initialAnimationIsBlocked ? valueTarget.length - 1 : 0;
          valueTarget = valueTarget[index5];
        }
        if (valueTarget !== null) {
          values[key2] = valueTarget;
        }
      }
      for (var key2 in transitionEnd)
        values[key2] = transitionEnd[key2];
    });
  }
  return values;
}

// node_modules/framer-motion/dist/es/render/svg/config-motion.mjs
var svgMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2,
    createRenderState: createSvgRenderState,
    onMount: function(props, instance, _a2) {
      var renderState = _a2.renderState, latestValues = _a2.latestValues;
      try {
        renderState.dimensions = typeof instance.getBBox === "function" ? instance.getBBox() : instance.getBoundingClientRect();
      } catch (e2) {
        renderState.dimensions = {
          x: 0,
          y: 0,
          width: 0,
          height: 0
        };
      }
      buildSVGAttrs(renderState, latestValues, { enableHardwareAcceleration: false }, props.transformTemplate);
      renderSVG(instance, renderState);
    }
  })
};

// node_modules/framer-motion/dist/es/render/html/config-motion.mjs
var htmlMotionConfig = {
  useVisualState: makeUseVisualState({
    scrapeMotionValuesFromProps,
    createRenderState: createHtmlRenderState
  })
};

// node_modules/framer-motion/dist/es/render/dom/utils/create-config.mjs
function createDomMotionConfig(Component, _a2, preloadedFeatures, createVisualElement, projectionNodeConstructor) {
  var _b = _a2.forwardMotionProps, forwardMotionProps = _b === void 0 ? false : _b;
  var baseConfig = isSVGComponent(Component) ? svgMotionConfig : htmlMotionConfig;
  return __assign(__assign({}, baseConfig), { preloadedFeatures, useRender: createUseRender(forwardMotionProps), createVisualElement, projectionNodeConstructor, Component });
}

// node_modules/framer-motion/dist/es/render/utils/types.mjs
var AnimationType;
(function(AnimationType2) {
  AnimationType2["Animate"] = "animate";
  AnimationType2["Hover"] = "whileHover";
  AnimationType2["Tap"] = "whileTap";
  AnimationType2["Drag"] = "whileDrag";
  AnimationType2["Focus"] = "whileFocus";
  AnimationType2["InView"] = "whileInView";
  AnimationType2["Exit"] = "exit";
})(AnimationType || (AnimationType = {}));

// node_modules/framer-motion/dist/es/events/use-dom-event.mjs
var import_react38 = __toESM(require_react(), 1);
function addDomEvent(target, eventName, handler, options) {
  if (options === void 0) {
    options = { passive: true };
  }
  target.addEventListener(eventName, handler, options);
  return function() {
    return target.removeEventListener(eventName, handler);
  };
}
function useDomEvent(ref, eventName, handler, options) {
  (0, import_react38.useEffect)(function() {
    var element = ref.current;
    if (handler && element) {
      return addDomEvent(element, eventName, handler, options);
    }
  }, [ref, eventName, handler, options]);
}

// node_modules/framer-motion/dist/es/gestures/use-focus-gesture.mjs
function useFocusGesture(_a2) {
  var whileFocus = _a2.whileFocus, visualElement2 = _a2.visualElement;
  var onFocus = function() {
    var _a3;
    (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Focus, true);
  };
  var onBlur = function() {
    var _a3;
    (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Focus, false);
  };
  useDomEvent(visualElement2, "focus", whileFocus ? onFocus : void 0);
  useDomEvent(visualElement2, "blur", whileFocus ? onBlur : void 0);
}

// node_modules/framer-motion/dist/es/gestures/utils/event-type.mjs
function isMouseEvent(event) {
  if (typeof PointerEvent !== "undefined" && event instanceof PointerEvent) {
    return !!(event.pointerType === "mouse");
  }
  return event instanceof MouseEvent;
}
function isTouchEvent(event) {
  var hasTouches = !!event.touches;
  return hasTouches;
}

// node_modules/framer-motion/dist/es/events/event-info.mjs
function filterPrimaryPointer(eventHandler) {
  return function(event) {
    var isMouseEvent2 = event instanceof MouseEvent;
    var isPrimaryPointer = !isMouseEvent2 || isMouseEvent2 && event.button === 0;
    if (isPrimaryPointer) {
      eventHandler(event);
    }
  };
}
var defaultPagePoint = { pageX: 0, pageY: 0 };
function pointFromTouch(e2, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  var primaryTouch = e2.touches[0] || e2.changedTouches[0];
  var point = primaryTouch || defaultPagePoint;
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function pointFromMouse(point, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    x: point[pointType + "X"],
    y: point[pointType + "Y"]
  };
}
function extractEventInfo(event, pointType) {
  if (pointType === void 0) {
    pointType = "page";
  }
  return {
    point: isTouchEvent(event) ? pointFromTouch(event, pointType) : pointFromMouse(event, pointType)
  };
}
var wrapHandler = function(handler, shouldFilterPrimaryPointer) {
  if (shouldFilterPrimaryPointer === void 0) {
    shouldFilterPrimaryPointer = false;
  }
  var listener = function(event) {
    return handler(event, extractEventInfo(event));
  };
  return shouldFilterPrimaryPointer ? filterPrimaryPointer(listener) : listener;
};

// node_modules/framer-motion/dist/es/events/utils.mjs
var supportsPointerEvents = function() {
  return isBrowser && window.onpointerdown === null;
};
var supportsTouchEvents = function() {
  return isBrowser && window.ontouchstart === null;
};
var supportsMouseEvents = function() {
  return isBrowser && window.onmousedown === null;
};

// node_modules/framer-motion/dist/es/events/use-pointer-event.mjs
var mouseEventNames = {
  pointerdown: "mousedown",
  pointermove: "mousemove",
  pointerup: "mouseup",
  pointercancel: "mousecancel",
  pointerover: "mouseover",
  pointerout: "mouseout",
  pointerenter: "mouseenter",
  pointerleave: "mouseleave"
};
var touchEventNames = {
  pointerdown: "touchstart",
  pointermove: "touchmove",
  pointerup: "touchend",
  pointercancel: "touchcancel"
};
function getPointerEventName(name) {
  if (supportsPointerEvents()) {
    return name;
  } else if (supportsTouchEvents()) {
    return touchEventNames[name];
  } else if (supportsMouseEvents()) {
    return mouseEventNames[name];
  }
  return name;
}
function addPointerEvent(target, eventName, handler, options) {
  return addDomEvent(target, getPointerEventName(eventName), wrapHandler(handler, eventName === "pointerdown"), options);
}
function usePointerEvent(ref, eventName, handler, options) {
  return useDomEvent(ref, getPointerEventName(eventName), handler && wrapHandler(handler, eventName === "pointerdown"), options);
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/lock.mjs
function createLock(name) {
  var lock = null;
  return function() {
    var openLock = function() {
      lock = null;
    };
    if (lock === null) {
      lock = name;
      return openLock;
    }
    return false;
  };
}
var globalHorizontalLock = createLock("dragHorizontal");
var globalVerticalLock = createLock("dragVertical");
function getGlobalLock(drag2) {
  var lock = false;
  if (drag2 === "y") {
    lock = globalVerticalLock();
  } else if (drag2 === "x") {
    lock = globalHorizontalLock();
  } else {
    var openHorizontal_1 = globalHorizontalLock();
    var openVertical_1 = globalVerticalLock();
    if (openHorizontal_1 && openVertical_1) {
      lock = function() {
        openHorizontal_1();
        openVertical_1();
      };
    } else {
      if (openHorizontal_1)
        openHorizontal_1();
      if (openVertical_1)
        openVertical_1();
    }
  }
  return lock;
}
function isDragActive() {
  var openGestureLock = getGlobalLock(true);
  if (!openGestureLock)
    return true;
  openGestureLock();
  return false;
}

// node_modules/framer-motion/dist/es/gestures/use-hover-gesture.mjs
function createHoverEvent(visualElement2, isActive, callback) {
  return function(event, info) {
    var _a2;
    if (!isMouseEvent(event) || isDragActive())
      return;
    (_a2 = visualElement2.animationState) === null || _a2 === void 0 ? void 0 : _a2.setActive(AnimationType.Hover, isActive);
    callback === null || callback === void 0 ? void 0 : callback(event, info);
  };
}
function useHoverGesture(_a2) {
  var onHoverStart = _a2.onHoverStart, onHoverEnd = _a2.onHoverEnd, whileHover = _a2.whileHover, visualElement2 = _a2.visualElement;
  usePointerEvent(visualElement2, "pointerenter", onHoverStart || whileHover ? createHoverEvent(visualElement2, true, onHoverStart) : void 0, { passive: !onHoverStart });
  usePointerEvent(visualElement2, "pointerleave", onHoverEnd || whileHover ? createHoverEvent(visualElement2, false, onHoverEnd) : void 0, { passive: !onHoverEnd });
}

// node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs
var import_react40 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/gestures/utils/is-node-or-child.mjs
var isNodeOrChild = function(parent, child) {
  if (!child) {
    return false;
  } else if (parent === child) {
    return true;
  } else {
    return isNodeOrChild(parent, child.parentElement);
  }
};

// node_modules/framer-motion/dist/es/utils/use-unmount-effect.mjs
var import_react39 = __toESM(require_react(), 1);
function useUnmountEffect(callback) {
  return (0, import_react39.useEffect)(function() {
    return function() {
      return callback();
    };
  }, []);
}

// node_modules/popmotion/dist/es/animations/index.mjs
init_tslib_es6();

// node_modules/popmotion/dist/es/animations/generators/spring.mjs
init_tslib_es6();

// node_modules/popmotion/dist/es/utils/clamp.mjs
var clamp2 = (min, max, v2) => Math.min(Math.max(v2, min), max);

// node_modules/popmotion/dist/es/animations/utils/find-spring.mjs
var safeMin = 1e-3;
var minDuration = 0.01;
var maxDuration = 10;
var minDamping = 0.05;
var maxDamping = 1;
function findSpring({ duration = 800, bounce = 0.25, velocity = 0, mass = 1 }) {
  let envelope;
  let derivative;
  warning(duration <= maxDuration * 1e3, "Spring duration must be 10 seconds or less");
  let dampingRatio = 1 - bounce;
  dampingRatio = clamp2(minDamping, maxDamping, dampingRatio);
  duration = clamp2(minDuration, maxDuration, duration / 1e3);
  if (dampingRatio < 1) {
    envelope = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const a3 = exponentialDecay - velocity;
      const b4 = calcAngularFreq(undampedFreq2, dampingRatio);
      const c3 = Math.exp(-delta);
      return safeMin - a3 / b4 * c3;
    };
    derivative = (undampedFreq2) => {
      const exponentialDecay = undampedFreq2 * dampingRatio;
      const delta = exponentialDecay * duration;
      const d2 = delta * velocity + velocity;
      const e2 = Math.pow(dampingRatio, 2) * Math.pow(undampedFreq2, 2) * duration;
      const f3 = Math.exp(-delta);
      const g3 = calcAngularFreq(Math.pow(undampedFreq2, 2), dampingRatio);
      const factor = -envelope(undampedFreq2) + safeMin > 0 ? -1 : 1;
      return factor * ((d2 - e2) * f3) / g3;
    };
  } else {
    envelope = (undampedFreq2) => {
      const a3 = Math.exp(-undampedFreq2 * duration);
      const b4 = (undampedFreq2 - velocity) * duration + 1;
      return -safeMin + a3 * b4;
    };
    derivative = (undampedFreq2) => {
      const a3 = Math.exp(-undampedFreq2 * duration);
      const b4 = (velocity - undampedFreq2) * (duration * duration);
      return a3 * b4;
    };
  }
  const initialGuess = 5 / duration;
  const undampedFreq = approximateRoot(envelope, derivative, initialGuess);
  duration = duration * 1e3;
  if (isNaN(undampedFreq)) {
    return {
      stiffness: 100,
      damping: 10,
      duration
    };
  } else {
    const stiffness = Math.pow(undampedFreq, 2) * mass;
    return {
      stiffness,
      damping: dampingRatio * 2 * Math.sqrt(mass * stiffness),
      duration
    };
  }
}
var rootIterations = 12;
function approximateRoot(envelope, derivative, initialGuess) {
  let result = initialGuess;
  for (let i2 = 1; i2 < rootIterations; i2++) {
    result = result - envelope(result) / derivative(result);
  }
  return result;
}
function calcAngularFreq(undampedFreq, dampingRatio) {
  return undampedFreq * Math.sqrt(1 - dampingRatio * dampingRatio);
}

// node_modules/popmotion/dist/es/animations/generators/spring.mjs
var durationKeys = ["duration", "bounce"];
var physicsKeys = ["stiffness", "damping", "mass"];
function isSpringType(options, keys) {
  return keys.some((key) => options[key] !== void 0);
}
function getSpringOptions(options) {
  let springOptions = Object.assign({ velocity: 0, stiffness: 100, damping: 10, mass: 1, isResolvedFromDuration: false }, options);
  if (!isSpringType(options, physicsKeys) && isSpringType(options, durationKeys)) {
    const derived = findSpring(options);
    springOptions = Object.assign(Object.assign(Object.assign({}, springOptions), derived), { velocity: 0, mass: 1 });
    springOptions.isResolvedFromDuration = true;
  }
  return springOptions;
}
function spring2(_a2) {
  var { from: from26 = 0, to: to4 = 1, restSpeed = 2, restDelta } = _a2, options = __rest(_a2, ["from", "to", "restSpeed", "restDelta"]);
  const state = { done: false, value: from26 };
  let { stiffness, damping, mass, velocity, duration, isResolvedFromDuration } = getSpringOptions(options);
  let resolveSpring = zero;
  let resolveVelocity = zero;
  function createSpring() {
    const initialVelocity = velocity ? -(velocity / 1e3) : 0;
    const initialDelta = to4 - from26;
    const dampingRatio = damping / (2 * Math.sqrt(stiffness * mass));
    const undampedAngularFreq = Math.sqrt(stiffness / mass) / 1e3;
    if (restDelta === void 0) {
      restDelta = Math.min(Math.abs(to4 - from26) / 100, 0.4);
    }
    if (dampingRatio < 1) {
      const angularFreq = calcAngularFreq(undampedAngularFreq, dampingRatio);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return to4 - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq * Math.sin(angularFreq * t2) + initialDelta * Math.cos(angularFreq * t2));
      };
      resolveVelocity = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        return dampingRatio * undampedAngularFreq * envelope * (Math.sin(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) / angularFreq + initialDelta * Math.cos(angularFreq * t2)) - envelope * (Math.cos(angularFreq * t2) * (initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) - angularFreq * initialDelta * Math.sin(angularFreq * t2));
      };
    } else if (dampingRatio === 1) {
      resolveSpring = (t2) => to4 - Math.exp(-undampedAngularFreq * t2) * (initialDelta + (initialVelocity + undampedAngularFreq * initialDelta) * t2);
    } else {
      const dampedAngularFreq = undampedAngularFreq * Math.sqrt(dampingRatio * dampingRatio - 1);
      resolveSpring = (t2) => {
        const envelope = Math.exp(-dampingRatio * undampedAngularFreq * t2);
        const freqForT = Math.min(dampedAngularFreq * t2, 300);
        return to4 - envelope * ((initialVelocity + dampingRatio * undampedAngularFreq * initialDelta) * Math.sinh(freqForT) + dampedAngularFreq * initialDelta * Math.cosh(freqForT)) / dampedAngularFreq;
      };
    }
  }
  createSpring();
  return {
    next: (t2) => {
      const current = resolveSpring(t2);
      if (!isResolvedFromDuration) {
        const currentVelocity = resolveVelocity(t2) * 1e3;
        const isBelowVelocityThreshold = Math.abs(currentVelocity) <= restSpeed;
        const isBelowDisplacementThreshold = Math.abs(to4 - current) <= restDelta;
        state.done = isBelowVelocityThreshold && isBelowDisplacementThreshold;
      } else {
        state.done = t2 >= duration;
      }
      state.value = state.done ? to4 : current;
      return state;
    },
    flipTarget: () => {
      velocity = -velocity;
      [from26, to4] = [to4, from26];
      createSpring();
    }
  };
}
spring2.needsInterpolation = (a3, b4) => typeof a3 === "string" || typeof b4 === "string";
var zero = (_t2) => 0;

// node_modules/popmotion/dist/es/utils/progress.mjs
var progress = (from26, to4, value) => {
  const toFromDifference = to4 - from26;
  return toFromDifference === 0 ? 1 : (value - from26) / toFromDifference;
};

// node_modules/popmotion/dist/es/utils/mix.mjs
var mix = (from26, to4, progress3) => -progress3 * from26 + progress3 * to4 + from26;

// node_modules/popmotion/dist/es/utils/hsla-to-rgba.mjs
function hueToRgb(p2, q3, t2) {
  if (t2 < 0)
    t2 += 1;
  if (t2 > 1)
    t2 -= 1;
  if (t2 < 1 / 6)
    return p2 + (q3 - p2) * 6 * t2;
  if (t2 < 1 / 2)
    return q3;
  if (t2 < 2 / 3)
    return p2 + (q3 - p2) * (2 / 3 - t2) * 6;
  return p2;
}
function hslaToRgba({ hue, saturation, lightness, alpha: alpha2 }) {
  hue /= 360;
  saturation /= 100;
  lightness /= 100;
  let red = 0;
  let green = 0;
  let blue = 0;
  if (!saturation) {
    red = green = blue = lightness;
  } else {
    const q3 = lightness < 0.5 ? lightness * (1 + saturation) : lightness + saturation - lightness * saturation;
    const p2 = 2 * lightness - q3;
    red = hueToRgb(p2, q3, hue + 1 / 3);
    green = hueToRgb(p2, q3, hue);
    blue = hueToRgb(p2, q3, hue - 1 / 3);
  }
  return {
    red: Math.round(red * 255),
    green: Math.round(green * 255),
    blue: Math.round(blue * 255),
    alpha: alpha2
  };
}

// node_modules/popmotion/dist/es/utils/mix-color.mjs
var mixLinearColor = (from26, to4, v2) => {
  const fromExpo = from26 * from26;
  const toExpo = to4 * to4;
  return Math.sqrt(Math.max(0, v2 * (toExpo - fromExpo) + fromExpo));
};
var colorTypes = [hex, rgba, hsla];
var getColorType = (v2) => colorTypes.find((type6) => type6.test(v2));
var notAnimatable = (color2) => `'${color2}' is not an animatable color. Use the equivalent color code instead.`;
var mixColor = (from26, to4) => {
  let fromColorType = getColorType(from26);
  let toColorType = getColorType(to4);
  invariant(!!fromColorType, notAnimatable(from26));
  invariant(!!toColorType, notAnimatable(to4));
  let fromColor = fromColorType.parse(from26);
  let toColor = toColorType.parse(to4);
  if (fromColorType === hsla) {
    fromColor = hslaToRgba(fromColor);
    fromColorType = rgba;
  }
  if (toColorType === hsla) {
    toColor = hslaToRgba(toColor);
    toColorType = rgba;
  }
  const blended = Object.assign({}, fromColor);
  return (v2) => {
    for (const key in blended) {
      if (key !== "alpha") {
        blended[key] = mixLinearColor(fromColor[key], toColor[key], v2);
      }
    }
    blended.alpha = mix(fromColor.alpha, toColor.alpha, v2);
    return fromColorType.transform(blended);
  };
};

// node_modules/popmotion/dist/es/utils/inc.mjs
var isNum = (v2) => typeof v2 === "number";

// node_modules/popmotion/dist/es/utils/pipe.mjs
var combineFunctions = (a3, b4) => (v2) => b4(a3(v2));
var pipe = (...transformers) => transformers.reduce(combineFunctions);

// node_modules/popmotion/dist/es/utils/mix-complex.mjs
function getMixer(origin2, target) {
  if (isNum(origin2)) {
    return (v2) => mix(origin2, target, v2);
  } else if (color.test(origin2)) {
    return mixColor(origin2, target);
  } else {
    return mixComplex(origin2, target);
  }
}
var mixArray = (from26, to4) => {
  const output = [...from26];
  const numValues = output.length;
  const blendValue = from26.map((fromThis, i2) => getMixer(fromThis, to4[i2]));
  return (v2) => {
    for (let i2 = 0; i2 < numValues; i2++) {
      output[i2] = blendValue[i2](v2);
    }
    return output;
  };
};
var mixObject = (origin2, target) => {
  const output = Object.assign(Object.assign({}, origin2), target);
  const blendValue = {};
  for (const key in output) {
    if (origin2[key] !== void 0 && target[key] !== void 0) {
      blendValue[key] = getMixer(origin2[key], target[key]);
    }
  }
  return (v2) => {
    for (const key in blendValue) {
      output[key] = blendValue[key](v2);
    }
    return output;
  };
};
function analyse2(value) {
  const parsed = complex.parse(value);
  const numValues = parsed.length;
  let numNumbers = 0;
  let numRGB = 0;
  let numHSL = 0;
  for (let i2 = 0; i2 < numValues; i2++) {
    if (numNumbers || typeof parsed[i2] === "number") {
      numNumbers++;
    } else {
      if (parsed[i2].hue !== void 0) {
        numHSL++;
      } else {
        numRGB++;
      }
    }
  }
  return { parsed, numNumbers, numRGB, numHSL };
}
var mixComplex = (origin2, target) => {
  const template = complex.createTransformer(target);
  const originStats = analyse2(origin2);
  const targetStats = analyse2(target);
  const canInterpolate = originStats.numHSL === targetStats.numHSL && originStats.numRGB === targetStats.numRGB && originStats.numNumbers >= targetStats.numNumbers;
  if (canInterpolate) {
    return pipe(mixArray(originStats.parsed, targetStats.parsed), template);
  } else {
    warning(true, `Complex values '${origin2}' and '${target}' too different to mix. Ensure all colors are of the same type, and that each contains the same quantity of number and color values. Falling back to instant transition.`);
    return (p2) => `${p2 > 0 ? target : origin2}`;
  }
};

// node_modules/popmotion/dist/es/utils/interpolate.mjs
var mixNumber = (from26, to4) => (p2) => mix(from26, to4, p2);
function detectMixerFactory(v2) {
  if (typeof v2 === "number") {
    return mixNumber;
  } else if (typeof v2 === "string") {
    if (color.test(v2)) {
      return mixColor;
    } else {
      return mixComplex;
    }
  } else if (Array.isArray(v2)) {
    return mixArray;
  } else if (typeof v2 === "object") {
    return mixObject;
  }
}
function createMixers(output, ease, customMixer) {
  const mixers = [];
  const mixerFactory = customMixer || detectMixerFactory(output[0]);
  const numMixers = output.length - 1;
  for (let i2 = 0; i2 < numMixers; i2++) {
    let mixer = mixerFactory(output[i2], output[i2 + 1]);
    if (ease) {
      const easingFunction = Array.isArray(ease) ? ease[i2] : ease;
      mixer = pipe(easingFunction, mixer);
    }
    mixers.push(mixer);
  }
  return mixers;
}
function fastInterpolate([from26, to4], [mixer]) {
  return (v2) => mixer(progress(from26, to4, v2));
}
function slowInterpolate(input, mixers) {
  const inputLength = input.length;
  const lastInputIndex = inputLength - 1;
  return (v2) => {
    let mixerIndex = 0;
    let foundMixerIndex = false;
    if (v2 <= input[0]) {
      foundMixerIndex = true;
    } else if (v2 >= input[lastInputIndex]) {
      mixerIndex = lastInputIndex - 1;
      foundMixerIndex = true;
    }
    if (!foundMixerIndex) {
      let i2 = 1;
      for (; i2 < inputLength; i2++) {
        if (input[i2] > v2 || i2 === lastInputIndex) {
          break;
        }
      }
      mixerIndex = i2 - 1;
    }
    const progressInRange = progress(input[mixerIndex], input[mixerIndex + 1], v2);
    return mixers[mixerIndex](progressInRange);
  };
}
function interpolate(input, output, { clamp: isClamp = true, ease, mixer } = {}) {
  const inputLength = input.length;
  invariant(inputLength === output.length, "Both input and output ranges must be the same length");
  invariant(!ease || !Array.isArray(ease) || ease.length === inputLength - 1, "Array of easing functions must be of length `input.length - 1`, as it applies to the transitions **between** the defined values.");
  if (input[0] > input[inputLength - 1]) {
    input = [].concat(input);
    output = [].concat(output);
    input.reverse();
    output.reverse();
  }
  const mixers = createMixers(output, ease, mixer);
  const interpolator = inputLength === 2 ? fastInterpolate(input, mixers) : slowInterpolate(input, mixers);
  return isClamp ? (v2) => interpolator(clamp2(input[0], input[inputLength - 1], v2)) : interpolator;
}

// node_modules/popmotion/dist/es/easing/utils.mjs
var reverseEasing = (easing) => (p2) => 1 - easing(1 - p2);
var mirrorEasing = (easing) => (p2) => p2 <= 0.5 ? easing(2 * p2) / 2 : (2 - easing(2 * (1 - p2))) / 2;
var createExpoIn = (power) => (p2) => Math.pow(p2, power);
var createBackIn = (power) => (p2) => p2 * p2 * ((power + 1) * p2 - power);
var createAnticipate = (power) => {
  const backEasing = createBackIn(power);
  return (p2) => (p2 *= 2) < 1 ? 0.5 * backEasing(p2) : 0.5 * (2 - Math.pow(2, -10 * (p2 - 1)));
};

// node_modules/popmotion/dist/es/easing/index.mjs
var DEFAULT_OVERSHOOT_STRENGTH = 1.525;
var BOUNCE_FIRST_THRESHOLD = 4 / 11;
var BOUNCE_SECOND_THRESHOLD = 8 / 11;
var BOUNCE_THIRD_THRESHOLD = 9 / 10;
var linear = (p2) => p2;
var easeIn = createExpoIn(2);
var easeOut = reverseEasing(easeIn);
var easeInOut = mirrorEasing(easeIn);
var circIn = (p2) => 1 - Math.sin(Math.acos(p2));
var circOut = reverseEasing(circIn);
var circInOut = mirrorEasing(circOut);
var backIn = createBackIn(DEFAULT_OVERSHOOT_STRENGTH);
var backOut = reverseEasing(backIn);
var backInOut = mirrorEasing(backIn);
var anticipate = createAnticipate(DEFAULT_OVERSHOOT_STRENGTH);
var ca = 4356 / 361;
var cb = 35442 / 1805;
var cc = 16061 / 1805;
var bounceOut = (p2) => {
  if (p2 === 1 || p2 === 0)
    return p2;
  const p22 = p2 * p2;
  return p2 < BOUNCE_FIRST_THRESHOLD ? 7.5625 * p22 : p2 < BOUNCE_SECOND_THRESHOLD ? 9.075 * p22 - 9.9 * p2 + 3.4 : p2 < BOUNCE_THIRD_THRESHOLD ? ca * p22 - cb * p2 + cc : 10.8 * p2 * p2 - 20.52 * p2 + 10.72;
};
var bounceIn = reverseEasing(bounceOut);
var bounceInOut = (p2) => p2 < 0.5 ? 0.5 * (1 - bounceOut(1 - p2 * 2)) : 0.5 * bounceOut(p2 * 2 - 1) + 0.5;

// node_modules/popmotion/dist/es/animations/generators/keyframes.mjs
function defaultEasing(values, easing) {
  return values.map(() => easing || easeInOut).splice(0, values.length - 1);
}
function defaultOffset(values) {
  const numValues = values.length;
  return values.map((_value, i2) => i2 !== 0 ? i2 / (numValues - 1) : 0);
}
function convertOffsetToTimes(offset, duration) {
  return offset.map((o2) => o2 * duration);
}
function keyframes({ from: from26 = 0, to: to4 = 1, ease, offset, duration = 300 }) {
  const state = { done: false, value: from26 };
  const values = Array.isArray(to4) ? to4 : [from26, to4];
  const times = convertOffsetToTimes(offset && offset.length === values.length ? offset : defaultOffset(values), duration);
  function createInterpolator() {
    return interpolate(times, values, {
      ease: Array.isArray(ease) ? ease : defaultEasing(values, ease)
    });
  }
  let interpolator = createInterpolator();
  return {
    next: (t2) => {
      state.value = interpolator(t2);
      state.done = t2 >= duration;
      return state;
    },
    flipTarget: () => {
      values.reverse();
      interpolator = createInterpolator();
    }
  };
}

// node_modules/popmotion/dist/es/animations/generators/decay.mjs
function decay({ velocity = 0, from: from26 = 0, power = 0.8, timeConstant = 350, restDelta = 0.5, modifyTarget }) {
  const state = { done: false, value: from26 };
  let amplitude = power * velocity;
  const ideal = from26 + amplitude;
  const target = modifyTarget === void 0 ? ideal : modifyTarget(ideal);
  if (target !== ideal)
    amplitude = target - from26;
  return {
    next: (t2) => {
      const delta = -amplitude * Math.exp(-t2 / timeConstant);
      state.done = !(delta > restDelta || delta < -restDelta);
      state.value = state.done ? target : target + delta;
      return state;
    },
    flipTarget: () => {
    }
  };
}

// node_modules/popmotion/dist/es/animations/utils/detect-animation-from-options.mjs
var types = { keyframes, spring: spring2, decay };
function detectAnimationFromOptions(config) {
  if (Array.isArray(config.to)) {
    return keyframes;
  } else if (types[config.type]) {
    return types[config.type];
  }
  const keys = new Set(Object.keys(config));
  if (keys.has("ease") || keys.has("duration") && !keys.has("dampingRatio")) {
    return keyframes;
  } else if (keys.has("dampingRatio") || keys.has("stiffness") || keys.has("mass") || keys.has("damping") || keys.has("restSpeed") || keys.has("restDelta")) {
    return spring2;
  }
  return keyframes;
}

// node_modules/framesync/dist/es/on-next-frame.mjs
var defaultTimestep = 1 / 60 * 1e3;
var getCurrentTime = typeof performance !== "undefined" ? () => performance.now() : () => Date.now();
var onNextFrame = typeof window !== "undefined" ? (callback) => window.requestAnimationFrame(callback) : (callback) => setTimeout(() => callback(getCurrentTime()), defaultTimestep);

// node_modules/framesync/dist/es/create-render-step.mjs
function createRenderStep(runNextFrame2) {
  let toRun = [];
  let toRunNextFrame = [];
  let numToRun = 0;
  let isProcessing2 = false;
  let flushNextFrame = false;
  const toKeepAlive = /* @__PURE__ */ new WeakSet();
  const step2 = {
    schedule: (callback, keepAlive = false, immediate = false) => {
      const addToCurrentFrame = immediate && isProcessing2;
      const buffer3 = addToCurrentFrame ? toRun : toRunNextFrame;
      if (keepAlive)
        toKeepAlive.add(callback);
      if (buffer3.indexOf(callback) === -1) {
        buffer3.push(callback);
        if (addToCurrentFrame && isProcessing2)
          numToRun = toRun.length;
      }
      return callback;
    },
    cancel: (callback) => {
      const index5 = toRunNextFrame.indexOf(callback);
      if (index5 !== -1)
        toRunNextFrame.splice(index5, 1);
      toKeepAlive.delete(callback);
    },
    process: (frameData) => {
      if (isProcessing2) {
        flushNextFrame = true;
        return;
      }
      isProcessing2 = true;
      [toRun, toRunNextFrame] = [toRunNextFrame, toRun];
      toRunNextFrame.length = 0;
      numToRun = toRun.length;
      if (numToRun) {
        for (let i2 = 0; i2 < numToRun; i2++) {
          const callback = toRun[i2];
          callback(frameData);
          if (toKeepAlive.has(callback)) {
            step2.schedule(callback);
            runNextFrame2();
          }
        }
      }
      isProcessing2 = false;
      if (flushNextFrame) {
        flushNextFrame = false;
        step2.process(frameData);
      }
    }
  };
  return step2;
}

// node_modules/framesync/dist/es/index.mjs
var maxElapsed = 40;
var useDefaultElapsed = true;
var runNextFrame = false;
var isProcessing = false;
var frame = {
  delta: 0,
  timestamp: 0
};
var stepsOrder = [
  "read",
  "update",
  "preRender",
  "render",
  "postRender"
];
var steps = stepsOrder.reduce((acc, key) => {
  acc[key] = createRenderStep(() => runNextFrame = true);
  return acc;
}, {});
var sync = stepsOrder.reduce((acc, key) => {
  const step2 = steps[key];
  acc[key] = (process2, keepAlive = false, immediate = false) => {
    if (!runNextFrame)
      startLoop();
    return step2.schedule(process2, keepAlive, immediate);
  };
  return acc;
}, {});
var cancelSync = stepsOrder.reduce((acc, key) => {
  acc[key] = steps[key].cancel;
  return acc;
}, {});
var flushSync = stepsOrder.reduce((acc, key) => {
  acc[key] = () => steps[key].process(frame);
  return acc;
}, {});
var processStep = (stepId) => steps[stepId].process(frame);
var processFrame = (timestamp) => {
  runNextFrame = false;
  frame.delta = useDefaultElapsed ? defaultTimestep : Math.max(Math.min(timestamp - frame.timestamp, maxElapsed), 1);
  frame.timestamp = timestamp;
  isProcessing = true;
  stepsOrder.forEach(processStep);
  isProcessing = false;
  if (runNextFrame) {
    useDefaultElapsed = false;
    onNextFrame(processFrame);
  }
};
var startLoop = () => {
  runNextFrame = true;
  useDefaultElapsed = true;
  if (!isProcessing)
    onNextFrame(processFrame);
};
var getFrameData = () => frame;
var es_default = sync;

// node_modules/popmotion/dist/es/animations/utils/elapsed.mjs
function loopElapsed(elapsed, duration, delay2 = 0) {
  return elapsed - duration - delay2;
}
function reverseElapsed(elapsed, duration, delay2 = 0, isForwardPlayback = true) {
  return isForwardPlayback ? loopElapsed(duration + -elapsed, duration, delay2) : duration - (elapsed - duration) + delay2;
}
function hasRepeatDelayElapsed(elapsed, duration, delay2, isForwardPlayback) {
  return isForwardPlayback ? elapsed >= duration + delay2 : elapsed <= -delay2;
}

// node_modules/popmotion/dist/es/animations/index.mjs
var framesync = (update) => {
  const passTimestamp = ({ delta }) => update(delta);
  return {
    start: () => es_default.update(passTimestamp, true),
    stop: () => cancelSync.update(passTimestamp)
  };
};
function animate(_a2) {
  var _b, _c2;
  var { from: from26, autoplay = true, driver = framesync, elapsed = 0, repeat: repeatMax = 0, repeatType = "loop", repeatDelay = 0, onPlay, onStop, onComplete, onRepeat, onUpdate } = _a2, options = __rest(_a2, ["from", "autoplay", "driver", "elapsed", "repeat", "repeatType", "repeatDelay", "onPlay", "onStop", "onComplete", "onRepeat", "onUpdate"]);
  let { to: to4 } = options;
  let driverControls;
  let repeatCount = 0;
  let computedDuration = options.duration;
  let latest;
  let isComplete = false;
  let isForwardPlayback = true;
  let interpolateFromNumber;
  const animator = detectAnimationFromOptions(options);
  if ((_c2 = (_b = animator).needsInterpolation) === null || _c2 === void 0 ? void 0 : _c2.call(_b, from26, to4)) {
    interpolateFromNumber = interpolate([0, 100], [from26, to4], {
      clamp: false
    });
    from26 = 0;
    to4 = 100;
  }
  const animation = animator(Object.assign(Object.assign({}, options), { from: from26, to: to4 }));
  function repeat() {
    repeatCount++;
    if (repeatType === "reverse") {
      isForwardPlayback = repeatCount % 2 === 0;
      elapsed = reverseElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback);
    } else {
      elapsed = loopElapsed(elapsed, computedDuration, repeatDelay);
      if (repeatType === "mirror")
        animation.flipTarget();
    }
    isComplete = false;
    onRepeat && onRepeat();
  }
  function complete() {
    driverControls.stop();
    onComplete && onComplete();
  }
  function update(delta) {
    if (!isForwardPlayback)
      delta = -delta;
    elapsed += delta;
    if (!isComplete) {
      const state = animation.next(Math.max(0, elapsed));
      latest = state.value;
      if (interpolateFromNumber)
        latest = interpolateFromNumber(latest);
      isComplete = isForwardPlayback ? state.done : elapsed <= 0;
    }
    onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(latest);
    if (isComplete) {
      if (repeatCount === 0)
        computedDuration !== null && computedDuration !== void 0 ? computedDuration : computedDuration = elapsed;
      if (repeatCount < repeatMax) {
        hasRepeatDelayElapsed(elapsed, computedDuration, repeatDelay, isForwardPlayback) && repeat();
      } else {
        complete();
      }
    }
  }
  function play() {
    onPlay === null || onPlay === void 0 ? void 0 : onPlay();
    driverControls = driver(update);
    driverControls.start();
  }
  autoplay && play();
  return {
    stop: () => {
      onStop === null || onStop === void 0 ? void 0 : onStop();
      driverControls.stop();
    }
  };
}

// node_modules/popmotion/dist/es/utils/velocity-per-second.mjs
function velocityPerSecond(velocity, frameDuration) {
  return frameDuration ? velocity * (1e3 / frameDuration) : 0;
}

// node_modules/popmotion/dist/es/animations/inertia.mjs
function inertia({ from: from26 = 0, velocity = 0, min, max, power = 0.8, timeConstant = 750, bounceStiffness = 500, bounceDamping = 10, restDelta = 1, modifyTarget, driver, onUpdate, onComplete, onStop }) {
  let currentAnimation;
  function isOutOfBounds(v2) {
    return min !== void 0 && v2 < min || max !== void 0 && v2 > max;
  }
  function boundaryNearest(v2) {
    if (min === void 0)
      return max;
    if (max === void 0)
      return min;
    return Math.abs(min - v2) < Math.abs(max - v2) ? min : max;
  }
  function startAnimation2(options) {
    currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop();
    currentAnimation = animate(Object.assign(Object.assign({}, options), {
      driver,
      onUpdate: (v2) => {
        var _a2;
        onUpdate === null || onUpdate === void 0 ? void 0 : onUpdate(v2);
        (_a2 = options.onUpdate) === null || _a2 === void 0 ? void 0 : _a2.call(options, v2);
      },
      onComplete,
      onStop
    }));
  }
  function startSpring(options) {
    startAnimation2(Object.assign({ type: "spring", stiffness: bounceStiffness, damping: bounceDamping, restDelta }, options));
  }
  if (isOutOfBounds(from26)) {
    startSpring({ from: from26, velocity, to: boundaryNearest(from26) });
  } else {
    let target = power * velocity + from26;
    if (typeof modifyTarget !== "undefined")
      target = modifyTarget(target);
    const boundary = boundaryNearest(target);
    const heading = boundary === min ? -1 : 1;
    let prev;
    let current;
    const checkBoundary = (v2) => {
      prev = current;
      current = v2;
      velocity = velocityPerSecond(v2 - prev, getFrameData().delta);
      if (heading === 1 && v2 > boundary || heading === -1 && v2 < boundary) {
        startSpring({ from: v2, to: boundary, velocity });
      }
    };
    startAnimation2({
      type: "decay",
      from: from26,
      velocity,
      timeConstant,
      power,
      restDelta,
      modifyTarget,
      onUpdate: isOutOfBounds(target) ? checkBoundary : void 0
    });
  }
  return {
    stop: () => currentAnimation === null || currentAnimation === void 0 ? void 0 : currentAnimation.stop()
  };
}

// node_modules/popmotion/dist/es/utils/attract.mjs
var identity = (v2) => v2;
var createAttractor = (alterDisplacement = identity) => (constant, origin2, v2) => {
  const displacement = origin2 - v2;
  const springModifiedDisplacement = -(0 - constant + 1) * (0 - alterDisplacement(Math.abs(displacement)));
  return displacement <= 0 ? origin2 + springModifiedDisplacement : origin2 - springModifiedDisplacement;
};
var attract = createAttractor();
var attractExpo = createAttractor(Math.sqrt);

// node_modules/popmotion/dist/es/utils/is-point.mjs
var isPoint = (point) => point.hasOwnProperty("x") && point.hasOwnProperty("y");

// node_modules/popmotion/dist/es/utils/is-point-3d.mjs
var isPoint3D = (point) => isPoint(point) && point.hasOwnProperty("z");

// node_modules/popmotion/dist/es/utils/distance.mjs
var distance1D = (a3, b4) => Math.abs(a3 - b4);
function distance(a3, b4) {
  if (isNum(a3) && isNum(b4)) {
    return distance1D(a3, b4);
  } else if (isPoint(a3) && isPoint(b4)) {
    const xDelta = distance1D(a3.x, b4.x);
    const yDelta = distance1D(a3.y, b4.y);
    const zDelta = isPoint3D(a3) && isPoint3D(b4) ? distance1D(a3.z, b4.z) : 0;
    return Math.sqrt(Math.pow(xDelta, 2) + Math.pow(yDelta, 2) + Math.pow(zDelta, 2));
  }
}

// node_modules/popmotion/dist/es/easing/cubic-bezier.mjs
var a = (a1, a22) => 1 - 3 * a22 + 3 * a1;
var b = (a1, a22) => 3 * a22 - 6 * a1;
var c = (a1) => 3 * a1;
var calcBezier = (t2, a1, a22) => ((a(a1, a22) * t2 + b(a1, a22)) * t2 + c(a1)) * t2;
var getSlope = (t2, a1, a22) => 3 * a(a1, a22) * t2 * t2 + 2 * b(a1, a22) * t2 + c(a1);
var subdivisionPrecision = 1e-7;
var subdivisionMaxIterations = 10;
function binarySubdivide(aX, aA, aB, mX1, mX2) {
  let currentX;
  let currentT;
  let i2 = 0;
  do {
    currentT = aA + (aB - aA) / 2;
    currentX = calcBezier(currentT, mX1, mX2) - aX;
    if (currentX > 0) {
      aB = currentT;
    } else {
      aA = currentT;
    }
  } while (Math.abs(currentX) > subdivisionPrecision && ++i2 < subdivisionMaxIterations);
  return currentT;
}
var newtonIterations = 8;
var newtonMinSlope = 1e-3;
function newtonRaphsonIterate(aX, aGuessT, mX1, mX2) {
  for (let i2 = 0; i2 < newtonIterations; ++i2) {
    const currentSlope = getSlope(aGuessT, mX1, mX2);
    if (currentSlope === 0) {
      return aGuessT;
    }
    const currentX = calcBezier(aGuessT, mX1, mX2) - aX;
    aGuessT -= currentX / currentSlope;
  }
  return aGuessT;
}
var kSplineTableSize = 11;
var kSampleStepSize = 1 / (kSplineTableSize - 1);
function cubicBezier(mX1, mY1, mX2, mY2) {
  if (mX1 === mY1 && mX2 === mY2)
    return linear;
  const sampleValues = new Float32Array(kSplineTableSize);
  for (let i2 = 0; i2 < kSplineTableSize; ++i2) {
    sampleValues[i2] = calcBezier(i2 * kSampleStepSize, mX1, mX2);
  }
  function getTForX(aX) {
    let intervalStart = 0;
    let currentSample = 1;
    const lastSample = kSplineTableSize - 1;
    for (; currentSample !== lastSample && sampleValues[currentSample] <= aX; ++currentSample) {
      intervalStart += kSampleStepSize;
    }
    --currentSample;
    const dist2 = (aX - sampleValues[currentSample]) / (sampleValues[currentSample + 1] - sampleValues[currentSample]);
    const guessForT = intervalStart + dist2 * kSampleStepSize;
    const initialSlope = getSlope(guessForT, mX1, mX2);
    if (initialSlope >= newtonMinSlope) {
      return newtonRaphsonIterate(aX, guessForT, mX1, mX2);
    } else if (initialSlope === 0) {
      return guessForT;
    } else {
      return binarySubdivide(aX, intervalStart, intervalStart + kSampleStepSize, mX1, mX2);
    }
  }
  return (t2) => t2 === 0 || t2 === 1 ? t2 : calcBezier(getTForX(t2), mY1, mY2);
}

// node_modules/framer-motion/dist/es/gestures/use-tap-gesture.mjs
function useTapGesture(_a2) {
  var onTap = _a2.onTap, onTapStart = _a2.onTapStart, onTapCancel = _a2.onTapCancel, whileTap = _a2.whileTap, visualElement2 = _a2.visualElement;
  var hasPressListeners = onTap || onTapStart || onTapCancel || whileTap;
  var isPressing = (0, import_react40.useRef)(false);
  var cancelPointerEndListeners = (0, import_react40.useRef)(null);
  var eventOptions = {
    passive: !(onTapStart || onTap || onTapCancel || onPointerDown)
  };
  function removePointerEndListener() {
    var _a3;
    (_a3 = cancelPointerEndListeners.current) === null || _a3 === void 0 ? void 0 : _a3.call(cancelPointerEndListeners);
    cancelPointerEndListeners.current = null;
  }
  function checkPointerEnd() {
    var _a3;
    removePointerEndListener();
    isPressing.current = false;
    (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Tap, false);
    return !isDragActive();
  }
  function onPointerUp(event, info) {
    if (!checkPointerEnd())
      return;
    !isNodeOrChild(visualElement2.getInstance(), event.target) ? onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info) : onTap === null || onTap === void 0 ? void 0 : onTap(event, info);
  }
  function onPointerCancel(event, info) {
    if (!checkPointerEnd())
      return;
    onTapCancel === null || onTapCancel === void 0 ? void 0 : onTapCancel(event, info);
  }
  function onPointerDown(event, info) {
    var _a3;
    removePointerEndListener();
    if (isPressing.current)
      return;
    isPressing.current = true;
    cancelPointerEndListeners.current = pipe(addPointerEvent(window, "pointerup", onPointerUp, eventOptions), addPointerEvent(window, "pointercancel", onPointerCancel, eventOptions));
    (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Tap, true);
    onTapStart === null || onTapStart === void 0 ? void 0 : onTapStart(event, info);
  }
  usePointerEvent(visualElement2, "pointerdown", hasPressListeners ? onPointerDown : void 0, eventOptions);
  useUnmountEffect(removePointerEndListener);
}

// node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs
var import_react41 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/warn-once.mjs
var warned = /* @__PURE__ */ new Set();
function warnOnce(condition, message, element) {
  if (condition || warned.has(message))
    return;
  console.warn(message);
  if (element)
    console.warn(element);
  warned.add(message);
}

// node_modules/framer-motion/dist/es/motion/features/viewport/observers.mjs
init_tslib_es6();
var observerCallbacks = /* @__PURE__ */ new WeakMap();
var observers = /* @__PURE__ */ new WeakMap();
var fireObserverCallback = function(entry) {
  var _a2;
  (_a2 = observerCallbacks.get(entry.target)) === null || _a2 === void 0 ? void 0 : _a2(entry);
};
var fireAllObserverCallbacks = function(entries) {
  entries.forEach(fireObserverCallback);
};
function initIntersectionObserver(_a2) {
  var root2 = _a2.root, options = __rest(_a2, ["root"]);
  var lookupRoot = root2 || document;
  if (!observers.has(lookupRoot)) {
    observers.set(lookupRoot, {});
  }
  var rootObservers = observers.get(lookupRoot);
  var key = JSON.stringify(options);
  if (!rootObservers[key]) {
    rootObservers[key] = new IntersectionObserver(fireAllObserverCallbacks, __assign({ root: root2 }, options));
  }
  return rootObservers[key];
}
function observeIntersection(element, options, callback) {
  var rootInteresectionObserver = initIntersectionObserver(options);
  observerCallbacks.set(element, callback);
  rootInteresectionObserver.observe(element);
  return function() {
    observerCallbacks.delete(element);
    rootInteresectionObserver.unobserve(element);
  };
}

// node_modules/framer-motion/dist/es/motion/features/viewport/use-viewport.mjs
function useViewport(_a2) {
  var visualElement2 = _a2.visualElement, whileInView = _a2.whileInView, onViewportEnter = _a2.onViewportEnter, onViewportLeave = _a2.onViewportLeave, _b = _a2.viewport, viewport = _b === void 0 ? {} : _b;
  var state = (0, import_react41.useRef)({
    hasEnteredView: false,
    isInView: false
  });
  var shouldObserve = Boolean(whileInView || onViewportEnter || onViewportLeave);
  if (viewport.once && state.current.hasEnteredView)
    shouldObserve = false;
  var useObserver = typeof IntersectionObserver === "undefined" ? useMissingIntersectionObserver : useIntersectionObserver;
  useObserver(shouldObserve, state.current, visualElement2, viewport);
}
var thresholdNames = {
  some: 0,
  all: 1
};
function useIntersectionObserver(shouldObserve, state, visualElement2, _a2) {
  var root2 = _a2.root, rootMargin = _a2.margin, _b = _a2.amount, amount = _b === void 0 ? "some" : _b, once = _a2.once;
  (0, import_react41.useEffect)(function() {
    if (!shouldObserve)
      return;
    var options = {
      root: root2 === null || root2 === void 0 ? void 0 : root2.current,
      rootMargin,
      threshold: typeof amount === "number" ? amount : thresholdNames[amount]
    };
    var intersectionCallback = function(entry) {
      var _a3;
      var isIntersecting = entry.isIntersecting;
      if (state.isInView === isIntersecting)
        return;
      state.isInView = isIntersecting;
      if (once && !isIntersecting && state.hasEnteredView) {
        return;
      } else if (isIntersecting) {
        state.hasEnteredView = true;
      }
      (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.InView, isIntersecting);
      var props = visualElement2.getProps();
      var callback = isIntersecting ? props.onViewportEnter : props.onViewportLeave;
      callback === null || callback === void 0 ? void 0 : callback(entry);
    };
    return observeIntersection(visualElement2.getInstance(), options, intersectionCallback);
  }, [shouldObserve, root2, rootMargin, amount]);
}
function useMissingIntersectionObserver(shouldObserve, state, visualElement2, _a2) {
  var _b = _a2.fallback, fallback3 = _b === void 0 ? true : _b;
  (0, import_react41.useEffect)(function() {
    if (!shouldObserve || !fallback3)
      return;
    if (env !== "production") {
      warnOnce(false, "IntersectionObserver not available on this device. whileInView animations will trigger on mount.");
    }
    requestAnimationFrame(function() {
      var _a3;
      state.hasEnteredView = true;
      var onViewportEnter = visualElement2.getProps().onViewportEnter;
      onViewportEnter === null || onViewportEnter === void 0 ? void 0 : onViewportEnter(null);
      (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.InView, true);
    });
  }, [shouldObserve]);
}

// node_modules/framer-motion/dist/es/motion/utils/make-renderless-component.mjs
var makeRenderlessComponent = function(hook) {
  return function(props) {
    hook(props);
    return null;
  };
};

// node_modules/framer-motion/dist/es/motion/features/gestures.mjs
var gestureAnimations = {
  inView: makeRenderlessComponent(useViewport),
  tap: makeRenderlessComponent(useTapGesture),
  focus: makeRenderlessComponent(useFocusGesture),
  hover: makeRenderlessComponent(useHoverGesture)
};

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
init_tslib_es6();
var import_react43 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
var import_react42 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-id.mjs
var counter = 0;
var incrementId = function() {
  return counter++;
};
var useId = function() {
  return useConstant(incrementId);
};

// node_modules/framer-motion/dist/es/components/AnimatePresence/use-presence.mjs
function usePresence() {
  var context = (0, import_react42.useContext)(PresenceContext);
  if (context === null)
    return [true, null];
  var isPresent2 = context.isPresent, onExitComplete = context.onExitComplete, register = context.register;
  var id3 = useId();
  (0, import_react42.useEffect)(function() {
    return register(id3);
  }, []);
  var safeToRemove = function() {
    return onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete(id3);
  };
  return !isPresent2 && onExitComplete ? [false, safeToRemove] : [true];
}

// node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/utils/shallow-compare.mjs
function shallowCompare(next, prev) {
  if (!Array.isArray(prev))
    return false;
  var prevLength = prev.length;
  if (prevLength !== next.length)
    return false;
  for (var i2 = 0; i2 < prevLength; i2++) {
    if (prev[i2] !== next[i2])
      return false;
  }
  return true;
}

// node_modules/framer-motion/dist/es/render/utils/animation.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/utils/time-conversion.mjs
var secondsToMilliseconds = function(seconds) {
  return seconds * 1e3;
};

// node_modules/framer-motion/dist/es/animation/utils/easing.mjs
init_tslib_es6();
var easingLookup = {
  linear,
  easeIn,
  easeInOut,
  easeOut,
  circIn,
  circInOut,
  circOut,
  backIn,
  backInOut,
  backOut,
  anticipate,
  bounceIn,
  bounceInOut,
  bounceOut
};
var easingDefinitionToFunction = function(definition) {
  if (Array.isArray(definition)) {
    invariant(definition.length === 4, "Cubic bezier arrays must contain four numerical values.");
    var _a2 = __read(definition, 4), x1 = _a2[0], y1 = _a2[1], x2 = _a2[2], y2 = _a2[3];
    return cubicBezier(x1, y1, x2, y2);
  } else if (typeof definition === "string") {
    invariant(easingLookup[definition] !== void 0, "Invalid easing type '".concat(definition, "'"));
    return easingLookup[definition];
  }
  return definition;
};
var isEasingArray = function(ease) {
  return Array.isArray(ease) && typeof ease[0] !== "number";
};

// node_modules/framer-motion/dist/es/animation/utils/is-animatable.mjs
var isAnimatable = function(key, value) {
  if (key === "zIndex")
    return false;
  if (typeof value === "number" || Array.isArray(value))
    return true;
  if (typeof value === "string" && // It's animatable if we have a string
  complex.test(value) && // And it contains numbers and/or colors
  !value.startsWith("url(")) {
    return true;
  }
  return false;
};

// node_modules/framer-motion/dist/es/animation/utils/default-transitions.mjs
init_tslib_es6();
var underDampedSpring = function() {
  return {
    type: "spring",
    stiffness: 500,
    damping: 25,
    restSpeed: 10
  };
};
var criticallyDampedSpring = function(to4) {
  return {
    type: "spring",
    stiffness: 550,
    damping: to4 === 0 ? 2 * Math.sqrt(550) : 30,
    restSpeed: 10
  };
};
var linearTween = function() {
  return {
    type: "keyframes",
    ease: "linear",
    duration: 0.3
  };
};
var keyframes2 = function(values) {
  return {
    type: "keyframes",
    duration: 0.8,
    values
  };
};
var defaultTransitions = {
  x: underDampedSpring,
  y: underDampedSpring,
  z: underDampedSpring,
  rotate: underDampedSpring,
  rotateX: underDampedSpring,
  rotateY: underDampedSpring,
  rotateZ: underDampedSpring,
  scaleX: criticallyDampedSpring,
  scaleY: criticallyDampedSpring,
  scale: criticallyDampedSpring,
  opacity: linearTween,
  backgroundColor: linearTween,
  color: linearTween,
  default: criticallyDampedSpring
};
var getDefaultTransition = function(valueKey, to4) {
  var transitionFactory;
  if (isKeyframesTarget(to4)) {
    transitionFactory = keyframes2;
  } else {
    transitionFactory = defaultTransitions[valueKey] || defaultTransitions.default;
  }
  return __assign({ to: to4 }, transitionFactory(to4));
};

// node_modules/framer-motion/dist/es/render/dom/value-types/defaults.mjs
init_tslib_es6();
var defaultValueTypes = __assign(__assign({}, numberValueTypes), {
  // Color props
  color,
  backgroundColor: color,
  outlineColor: color,
  fill: color,
  stroke: color,
  // Border props
  borderColor: color,
  borderTopColor: color,
  borderRightColor: color,
  borderBottomColor: color,
  borderLeftColor: color,
  filter,
  WebkitFilter: filter
});
var getDefaultValueType = function(key) {
  return defaultValueTypes[key];
};

// node_modules/framer-motion/dist/es/render/dom/value-types/animatable-none.mjs
function getAnimatableNone2(key, value) {
  var _a2;
  var defaultValueType = getDefaultValueType(key);
  if (defaultValueType !== filter)
    defaultValueType = complex;
  return (_a2 = defaultValueType.getAnimatableNone) === null || _a2 === void 0 ? void 0 : _a2.call(defaultValueType, value);
}

// node_modules/framer-motion/dist/es/utils/use-instant-transition-state.mjs
var instantAnimationState = {
  current: false
};

// node_modules/framer-motion/dist/es/animation/utils/transitions.mjs
function isTransitionDefined(_a2) {
  _a2.when;
  _a2.delay;
  _a2.delayChildren;
  _a2.staggerChildren;
  _a2.staggerDirection;
  _a2.repeat;
  _a2.repeatType;
  _a2.repeatDelay;
  _a2.from;
  var transition2 = __rest(_a2, ["when", "delay", "delayChildren", "staggerChildren", "staggerDirection", "repeat", "repeatType", "repeatDelay", "from"]);
  return !!Object.keys(transition2).length;
}
var legacyRepeatWarning = false;
function convertTransitionToAnimationOptions(_a2) {
  var ease = _a2.ease, times = _a2.times, yoyo = _a2.yoyo, flip = _a2.flip, loop2 = _a2.loop, transition2 = __rest(_a2, ["ease", "times", "yoyo", "flip", "loop"]);
  var options = __assign({}, transition2);
  if (times)
    options["offset"] = times;
  if (transition2.duration)
    options["duration"] = secondsToMilliseconds(transition2.duration);
  if (transition2.repeatDelay)
    options.repeatDelay = secondsToMilliseconds(transition2.repeatDelay);
  if (ease) {
    options["ease"] = isEasingArray(ease) ? ease.map(easingDefinitionToFunction) : easingDefinitionToFunction(ease);
  }
  if (transition2.type === "tween")
    options.type = "keyframes";
  if (yoyo || loop2 || flip) {
    warning(!legacyRepeatWarning, "yoyo, loop and flip have been removed from the API. Replace with repeat and repeatType options.");
    legacyRepeatWarning = true;
    if (yoyo) {
      options.repeatType = "reverse";
    } else if (loop2) {
      options.repeatType = "loop";
    } else if (flip) {
      options.repeatType = "mirror";
    }
    options.repeat = loop2 || yoyo || flip || transition2.repeat;
  }
  if (transition2.type !== "spring")
    options.type = "keyframes";
  return options;
}
function getDelayFromTransition(transition2, key) {
  var _a2, _b;
  var valueTransition = getValueTransition(transition2, key) || {};
  return (_b = (_a2 = valueTransition.delay) !== null && _a2 !== void 0 ? _a2 : transition2.delay) !== null && _b !== void 0 ? _b : 0;
}
function hydrateKeyframes(options) {
  if (Array.isArray(options.to) && options.to[0] === null) {
    options.to = __spreadArray([], __read(options.to), false);
    options.to[0] = options.from;
  }
  return options;
}
function getPopmotionAnimationOptions(transition2, options, key) {
  var _a2;
  if (Array.isArray(options.to)) {
    (_a2 = transition2.duration) !== null && _a2 !== void 0 ? _a2 : transition2.duration = 0.8;
  }
  hydrateKeyframes(options);
  if (!isTransitionDefined(transition2)) {
    transition2 = __assign(__assign({}, transition2), getDefaultTransition(key, options.to));
  }
  return __assign(__assign({}, options), convertTransitionToAnimationOptions(transition2));
}
function getAnimation(key, value, target, transition2, onComplete) {
  var _a2;
  var valueTransition = getValueTransition(transition2, key);
  var origin2 = (_a2 = valueTransition.from) !== null && _a2 !== void 0 ? _a2 : value.get();
  var isTargetAnimatable = isAnimatable(key, target);
  if (origin2 === "none" && isTargetAnimatable && typeof target === "string") {
    origin2 = getAnimatableNone2(key, target);
  } else if (isZero(origin2) && typeof target === "string") {
    origin2 = getZeroUnit(target);
  } else if (!Array.isArray(target) && isZero(target) && typeof origin2 === "string") {
    target = getZeroUnit(origin2);
  }
  var isOriginAnimatable = isAnimatable(key, origin2);
  warning(isOriginAnimatable === isTargetAnimatable, "You are trying to animate ".concat(key, ' from "').concat(origin2, '" to "').concat(target, '". ').concat(origin2, " is not an animatable value - to enable this animation set ").concat(origin2, " to a value animatable to ").concat(target, " via the `style` property."));
  function start() {
    var options = {
      from: origin2,
      to: target,
      velocity: value.getVelocity(),
      onComplete,
      onUpdate: function(v2) {
        return value.set(v2);
      }
    };
    return valueTransition.type === "inertia" || valueTransition.type === "decay" ? inertia(__assign(__assign({}, options), valueTransition)) : animate(__assign(__assign({}, getPopmotionAnimationOptions(valueTransition, options, key)), { onUpdate: function(v2) {
      var _a3;
      options.onUpdate(v2);
      (_a3 = valueTransition.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(valueTransition, v2);
    }, onComplete: function() {
      var _a3;
      options.onComplete();
      (_a3 = valueTransition.onComplete) === null || _a3 === void 0 ? void 0 : _a3.call(valueTransition);
    } }));
  }
  function set() {
    var _a3, _b;
    var finalTarget = resolveFinalValueInKeyframes(target);
    value.set(finalTarget);
    onComplete();
    (_a3 = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onUpdate) === null || _a3 === void 0 ? void 0 : _a3.call(valueTransition, finalTarget);
    (_b = valueTransition === null || valueTransition === void 0 ? void 0 : valueTransition.onComplete) === null || _b === void 0 ? void 0 : _b.call(valueTransition);
    return { stop: function() {
    } };
  }
  return !isOriginAnimatable || !isTargetAnimatable || valueTransition.type === false ? set : start;
}
function isZero(value) {
  return value === 0 || typeof value === "string" && parseFloat(value) === 0 && value.indexOf(" ") === -1;
}
function getZeroUnit(potentialUnitType) {
  return typeof potentialUnitType === "number" ? 0 : getAnimatableNone2("", potentialUnitType);
}
function getValueTransition(transition2, key) {
  return transition2[key] || transition2["default"] || transition2;
}
function startAnimation(key, value, target, transition2) {
  if (transition2 === void 0) {
    transition2 = {};
  }
  if (instantAnimationState.current) {
    transition2 = { type: false };
  }
  return value.start(function(onComplete) {
    var delayTimer;
    var controls;
    var animation = getAnimation(key, value, target, transition2, onComplete);
    var delay2 = getDelayFromTransition(transition2, key);
    var start = function() {
      return controls = animation();
    };
    if (delay2) {
      delayTimer = window.setTimeout(start, secondsToMilliseconds(delay2));
    } else {
      start();
    }
    return function() {
      clearTimeout(delayTimer);
      controls === null || controls === void 0 ? void 0 : controls.stop();
    };
  });
}

// node_modules/framer-motion/dist/es/render/utils/setters.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/utils/is-numerical-string.mjs
var isNumericalString = function(v2) {
  return /^\-?\d*\.?\d+$/.test(v2);
};

// node_modules/framer-motion/dist/es/utils/is-zero-value-string.mjs
var isZeroValueString = function(v2) {
  return /^0[^.\s]+$/.test(v2);
};

// node_modules/framer-motion/dist/es/utils/array.mjs
init_tslib_es6();
function addUniqueItem(arr, item) {
  arr.indexOf(item) === -1 && arr.push(item);
}
function removeItem(arr, item) {
  var index5 = arr.indexOf(item);
  index5 > -1 && arr.splice(index5, 1);
}
function moveItem(_a2, fromIndex, toIndex) {
  var _b = __read(_a2), arr = _b.slice(0);
  var startIndex = fromIndex < 0 ? arr.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < arr.length) {
    var endIndex = toIndex < 0 ? arr.length + toIndex : toIndex;
    var _c2 = __read(arr.splice(fromIndex, 1), 1), item = _c2[0];
    arr.splice(endIndex, 0, item);
  }
  return arr;
}

// node_modules/framer-motion/dist/es/utils/subscription-manager.mjs
var SubscriptionManager = (
  /** @class */
  function() {
    function SubscriptionManager2() {
      this.subscriptions = [];
    }
    SubscriptionManager2.prototype.add = function(handler) {
      var _this = this;
      addUniqueItem(this.subscriptions, handler);
      return function() {
        return removeItem(_this.subscriptions, handler);
      };
    };
    SubscriptionManager2.prototype.notify = function(a3, b4, c3) {
      var numSubscriptions = this.subscriptions.length;
      if (!numSubscriptions)
        return;
      if (numSubscriptions === 1) {
        this.subscriptions[0](a3, b4, c3);
      } else {
        for (var i2 = 0; i2 < numSubscriptions; i2++) {
          var handler = this.subscriptions[i2];
          handler && handler(a3, b4, c3);
        }
      }
    };
    SubscriptionManager2.prototype.getSize = function() {
      return this.subscriptions.length;
    };
    SubscriptionManager2.prototype.clear = function() {
      this.subscriptions.length = 0;
    };
    return SubscriptionManager2;
  }()
);

// node_modules/framer-motion/dist/es/value/index.mjs
var isFloat = function(value) {
  return !isNaN(parseFloat(value));
};
var MotionValue = (
  /** @class */
  function() {
    function MotionValue3(init2) {
      var _this = this;
      this.version = "6.5.1";
      this.timeDelta = 0;
      this.lastUpdated = 0;
      this.updateSubscribers = new SubscriptionManager();
      this.velocityUpdateSubscribers = new SubscriptionManager();
      this.renderSubscribers = new SubscriptionManager();
      this.canTrackVelocity = false;
      this.updateAndNotify = function(v2, render) {
        if (render === void 0) {
          render = true;
        }
        _this.prev = _this.current;
        _this.current = v2;
        var _a2 = getFrameData(), delta = _a2.delta, timestamp = _a2.timestamp;
        if (_this.lastUpdated !== timestamp) {
          _this.timeDelta = delta;
          _this.lastUpdated = timestamp;
          es_default.postRender(_this.scheduleVelocityCheck);
        }
        if (_this.prev !== _this.current) {
          _this.updateSubscribers.notify(_this.current);
        }
        if (_this.velocityUpdateSubscribers.getSize()) {
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
        if (render) {
          _this.renderSubscribers.notify(_this.current);
        }
      };
      this.scheduleVelocityCheck = function() {
        return es_default.postRender(_this.velocityCheck);
      };
      this.velocityCheck = function(_a2) {
        var timestamp = _a2.timestamp;
        if (timestamp !== _this.lastUpdated) {
          _this.prev = _this.current;
          _this.velocityUpdateSubscribers.notify(_this.getVelocity());
        }
      };
      this.hasAnimated = false;
      this.prev = this.current = init2;
      this.canTrackVelocity = isFloat(this.current);
    }
    MotionValue3.prototype.onChange = function(subscription) {
      return this.updateSubscribers.add(subscription);
    };
    MotionValue3.prototype.clearListeners = function() {
      this.updateSubscribers.clear();
    };
    MotionValue3.prototype.onRenderRequest = function(subscription) {
      subscription(this.get());
      return this.renderSubscribers.add(subscription);
    };
    MotionValue3.prototype.attach = function(passiveEffect) {
      this.passiveEffect = passiveEffect;
    };
    MotionValue3.prototype.set = function(v2, render) {
      if (render === void 0) {
        render = true;
      }
      if (!render || !this.passiveEffect) {
        this.updateAndNotify(v2, render);
      } else {
        this.passiveEffect(v2, this.updateAndNotify);
      }
    };
    MotionValue3.prototype.get = function() {
      return this.current;
    };
    MotionValue3.prototype.getPrevious = function() {
      return this.prev;
    };
    MotionValue3.prototype.getVelocity = function() {
      return this.canTrackVelocity ? (
        // These casts could be avoided if parseFloat would be typed better
        velocityPerSecond(parseFloat(this.current) - parseFloat(this.prev), this.timeDelta)
      ) : 0;
    };
    MotionValue3.prototype.start = function(animation) {
      var _this = this;
      this.stop();
      return new Promise(function(resolve) {
        _this.hasAnimated = true;
        _this.stopAnimation = animation(resolve);
      }).then(function() {
        return _this.clearAnimation();
      });
    };
    MotionValue3.prototype.stop = function() {
      if (this.stopAnimation)
        this.stopAnimation();
      this.clearAnimation();
    };
    MotionValue3.prototype.isAnimating = function() {
      return !!this.stopAnimation;
    };
    MotionValue3.prototype.clearAnimation = function() {
      this.stopAnimation = null;
    };
    MotionValue3.prototype.destroy = function() {
      this.updateSubscribers.clear();
      this.renderSubscribers.clear();
      this.stop();
    };
    return MotionValue3;
  }()
);
function motionValue(init2) {
  return new MotionValue(init2);
}

// node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/render/dom/value-types/test.mjs
var testValueType = function(v2) {
  return function(type6) {
    return type6.test(v2);
  };
};

// node_modules/framer-motion/dist/es/render/dom/value-types/type-auto.mjs
var auto = {
  test: function(v2) {
    return v2 === "auto";
  },
  parse: function(v2) {
    return v2;
  }
};

// node_modules/framer-motion/dist/es/render/dom/value-types/dimensions.mjs
var dimensionValueTypes = [number, px, percent, degrees, vw, vh, auto];
var findDimensionValueType = function(v2) {
  return dimensionValueTypes.find(testValueType(v2));
};

// node_modules/framer-motion/dist/es/render/dom/value-types/find.mjs
var valueTypes = __spreadArray(__spreadArray([], __read(dimensionValueTypes), false), [color, complex], false);
var findValueType = function(v2) {
  return valueTypes.find(testValueType(v2));
};

// node_modules/framer-motion/dist/es/render/utils/setters.mjs
function setMotionValue(visualElement2, key, value) {
  if (visualElement2.hasValue(key)) {
    visualElement2.getValue(key).set(value);
  } else {
    visualElement2.addValue(key, motionValue(value));
  }
}
function setTarget(visualElement2, definition) {
  var resolved = resolveVariant(visualElement2, definition);
  var _a2 = resolved ? visualElement2.makeTargetAnimatable(resolved, false) : {}, _b = _a2.transitionEnd, transitionEnd = _b === void 0 ? {} : _b;
  _a2.transition;
  var target = __rest(_a2, ["transitionEnd", "transition"]);
  target = __assign(__assign({}, target), transitionEnd);
  for (var key in target) {
    var value = resolveFinalValueInKeyframes(target[key]);
    setMotionValue(visualElement2, key, value);
  }
}
function checkTargetForNewValues(visualElement2, target, origin2) {
  var _a2, _b, _c2;
  var _d;
  var newValueKeys = Object.keys(target).filter(function(key2) {
    return !visualElement2.hasValue(key2);
  });
  var numNewValues = newValueKeys.length;
  if (!numNewValues)
    return;
  for (var i2 = 0; i2 < numNewValues; i2++) {
    var key = newValueKeys[i2];
    var targetValue = target[key];
    var value = null;
    if (Array.isArray(targetValue)) {
      value = targetValue[0];
    }
    if (value === null) {
      value = (_b = (_a2 = origin2[key]) !== null && _a2 !== void 0 ? _a2 : visualElement2.readValue(key)) !== null && _b !== void 0 ? _b : target[key];
    }
    if (value === void 0 || value === null)
      continue;
    if (typeof value === "string" && (isNumericalString(value) || isZeroValueString(value))) {
      value = parseFloat(value);
    } else if (!findValueType(value) && complex.test(targetValue)) {
      value = getAnimatableNone2(key, targetValue);
    }
    visualElement2.addValue(key, motionValue(value));
    (_c2 = (_d = origin2)[key]) !== null && _c2 !== void 0 ? _c2 : _d[key] = value;
    visualElement2.setBaseTarget(key, value);
  }
}
function getOriginFromTransition(key, transition2) {
  if (!transition2)
    return;
  var valueTransition = transition2[key] || transition2["default"] || transition2;
  return valueTransition.from;
}
function getOrigin(target, transition2, visualElement2) {
  var _a2, _b;
  var origin2 = {};
  for (var key in target) {
    origin2[key] = (_a2 = getOriginFromTransition(key, transition2)) !== null && _a2 !== void 0 ? _a2 : (_b = visualElement2.getValue(key)) === null || _b === void 0 ? void 0 : _b.get();
  }
  return origin2;
}

// node_modules/framer-motion/dist/es/render/utils/animation.mjs
function animateVisualElement(visualElement2, definition, options) {
  if (options === void 0) {
    options = {};
  }
  visualElement2.notifyAnimationStart(definition);
  var animation;
  if (Array.isArray(definition)) {
    var animations2 = definition.map(function(variant) {
      return animateVariant(visualElement2, variant, options);
    });
    animation = Promise.all(animations2);
  } else if (typeof definition === "string") {
    animation = animateVariant(visualElement2, definition, options);
  } else {
    var resolvedDefinition = typeof definition === "function" ? resolveVariant(visualElement2, definition, options.custom) : definition;
    animation = animateTarget(visualElement2, resolvedDefinition, options);
  }
  return animation.then(function() {
    return visualElement2.notifyAnimationComplete(definition);
  });
}
function animateVariant(visualElement2, variant, options) {
  var _a2;
  if (options === void 0) {
    options = {};
  }
  var resolved = resolveVariant(visualElement2, variant, options.custom);
  var _b = (resolved || {}).transition, transition2 = _b === void 0 ? visualElement2.getDefaultTransition() || {} : _b;
  if (options.transitionOverride) {
    transition2 = options.transitionOverride;
  }
  var getAnimation2 = resolved ? function() {
    return animateTarget(visualElement2, resolved, options);
  } : function() {
    return Promise.resolve();
  };
  var getChildAnimations = ((_a2 = visualElement2.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.size) ? function(forwardDelay) {
    if (forwardDelay === void 0) {
      forwardDelay = 0;
    }
    var _a3 = transition2.delayChildren, delayChildren = _a3 === void 0 ? 0 : _a3, staggerChildren = transition2.staggerChildren, staggerDirection = transition2.staggerDirection;
    return animateChildren(visualElement2, variant, delayChildren + forwardDelay, staggerChildren, staggerDirection, options);
  } : function() {
    return Promise.resolve();
  };
  var when = transition2.when;
  if (when) {
    var _c2 = __read(when === "beforeChildren" ? [getAnimation2, getChildAnimations] : [getChildAnimations, getAnimation2], 2), first = _c2[0], last = _c2[1];
    return first().then(last);
  } else {
    return Promise.all([getAnimation2(), getChildAnimations(options.delay)]);
  }
}
function animateTarget(visualElement2, definition, _a2) {
  var _b;
  var _c2 = _a2 === void 0 ? {} : _a2, _d = _c2.delay, delay2 = _d === void 0 ? 0 : _d, transitionOverride = _c2.transitionOverride, type6 = _c2.type;
  var _e2 = visualElement2.makeTargetAnimatable(definition), _f = _e2.transition, transition2 = _f === void 0 ? visualElement2.getDefaultTransition() : _f, transitionEnd = _e2.transitionEnd, target = __rest(_e2, ["transition", "transitionEnd"]);
  if (transitionOverride)
    transition2 = transitionOverride;
  var animations2 = [];
  var animationTypeState = type6 && ((_b = visualElement2.animationState) === null || _b === void 0 ? void 0 : _b.getState()[type6]);
  for (var key in target) {
    var value = visualElement2.getValue(key);
    var valueTarget = target[key];
    if (!value || valueTarget === void 0 || animationTypeState && shouldBlockAnimation(animationTypeState, key)) {
      continue;
    }
    var valueTransition = __assign({ delay: delay2 }, transition2);
    if (visualElement2.shouldReduceMotion && isTransformProp(key)) {
      valueTransition = __assign(__assign({}, valueTransition), { type: false, delay: 0 });
    }
    var animation = startAnimation(key, value, valueTarget, valueTransition);
    animations2.push(animation);
  }
  return Promise.all(animations2).then(function() {
    transitionEnd && setTarget(visualElement2, transitionEnd);
  });
}
function animateChildren(visualElement2, variant, delayChildren, staggerChildren, staggerDirection, options) {
  if (delayChildren === void 0) {
    delayChildren = 0;
  }
  if (staggerChildren === void 0) {
    staggerChildren = 0;
  }
  if (staggerDirection === void 0) {
    staggerDirection = 1;
  }
  var animations2 = [];
  var maxStaggerDuration = (visualElement2.variantChildren.size - 1) * staggerChildren;
  var generateStaggerDuration = staggerDirection === 1 ? function(i2) {
    if (i2 === void 0) {
      i2 = 0;
    }
    return i2 * staggerChildren;
  } : function(i2) {
    if (i2 === void 0) {
      i2 = 0;
    }
    return maxStaggerDuration - i2 * staggerChildren;
  };
  Array.from(visualElement2.variantChildren).sort(sortByTreeOrder).forEach(function(child, i2) {
    animations2.push(animateVariant(child, variant, __assign(__assign({}, options), { delay: delayChildren + generateStaggerDuration(i2) })).then(function() {
      return child.notifyAnimationComplete(variant);
    }));
  });
  return Promise.all(animations2);
}
function sortByTreeOrder(a3, b4) {
  return a3.sortNodePosition(b4);
}
function shouldBlockAnimation(_a2, key) {
  var protectedKeys = _a2.protectedKeys, needsAnimating = _a2.needsAnimating;
  var shouldBlock = protectedKeys.hasOwnProperty(key) && needsAnimating[key] !== true;
  needsAnimating[key] = false;
  return shouldBlock;
}

// node_modules/framer-motion/dist/es/render/utils/animation-state.mjs
var variantPriorityOrder = [
  AnimationType.Animate,
  AnimationType.InView,
  AnimationType.Focus,
  AnimationType.Hover,
  AnimationType.Tap,
  AnimationType.Drag,
  AnimationType.Exit
];
var reversePriorityOrder = __spreadArray([], __read(variantPriorityOrder), false).reverse();
var numAnimationTypes = variantPriorityOrder.length;
function animateList(visualElement2) {
  return function(animations2) {
    return Promise.all(animations2.map(function(_a2) {
      var animation = _a2.animation, options = _a2.options;
      return animateVisualElement(visualElement2, animation, options);
    }));
  };
}
function createAnimationState(visualElement2) {
  var animate4 = animateList(visualElement2);
  var state = createState();
  var allAnimatedKeys = {};
  var isInitialRender = true;
  var buildResolvedTypeValues = function(acc, definition) {
    var resolved = resolveVariant(visualElement2, definition);
    if (resolved) {
      resolved.transition;
      var transitionEnd = resolved.transitionEnd, target = __rest(resolved, ["transition", "transitionEnd"]);
      acc = __assign(__assign(__assign({}, acc), target), transitionEnd);
    }
    return acc;
  };
  function isAnimated(key) {
    return allAnimatedKeys[key] !== void 0;
  }
  function setAnimateFunction(makeAnimator) {
    animate4 = makeAnimator(visualElement2);
  }
  function animateChanges(options, changedActiveType) {
    var _a2;
    var props = visualElement2.getProps();
    var context = visualElement2.getVariantContext(true) || {};
    var animations2 = [];
    var removedKeys = /* @__PURE__ */ new Set();
    var encounteredKeys = {};
    var removedVariantIndex = Infinity;
    var _loop_1 = function(i3) {
      var type6 = reversePriorityOrder[i3];
      var typeState = state[type6];
      var prop = (_a2 = props[type6]) !== null && _a2 !== void 0 ? _a2 : context[type6];
      var propIsVariant = isVariantLabel(prop);
      var activeDelta = type6 === changedActiveType ? typeState.isActive : null;
      if (activeDelta === false)
        removedVariantIndex = i3;
      var isInherited = prop === context[type6] && prop !== props[type6] && propIsVariant;
      if (isInherited && isInitialRender && visualElement2.manuallyAnimateOnMount) {
        isInherited = false;
      }
      typeState.protectedKeys = __assign({}, encounteredKeys);
      if (
        // If it isn't active and hasn't *just* been set as inactive
        !typeState.isActive && activeDelta === null || // If we didn't and don't have any defined prop for this animation type
        !prop && !typeState.prevProp || // Or if the prop doesn't define an animation
        isAnimationControls(prop) || typeof prop === "boolean"
      ) {
        return "continue";
      }
      var variantDidChange = checkVariantsDidChange(typeState.prevProp, prop);
      var shouldAnimateType = variantDidChange || // If we're making this variant active, we want to always make it active
      type6 === changedActiveType && typeState.isActive && !isInherited && propIsVariant || // If we removed a higher-priority variant (i is in reverse order)
      i3 > removedVariantIndex && propIsVariant;
      var definitionList = Array.isArray(prop) ? prop : [prop];
      var resolvedValues = definitionList.reduce(buildResolvedTypeValues, {});
      if (activeDelta === false)
        resolvedValues = {};
      var _b = typeState.prevResolvedValues, prevResolvedValues = _b === void 0 ? {} : _b;
      var allKeys = __assign(__assign({}, prevResolvedValues), resolvedValues);
      var markToAnimate = function(key2) {
        shouldAnimateType = true;
        removedKeys.delete(key2);
        typeState.needsAnimating[key2] = true;
      };
      for (var key in allKeys) {
        var next = resolvedValues[key];
        var prev = prevResolvedValues[key];
        if (encounteredKeys.hasOwnProperty(key))
          continue;
        if (next !== prev) {
          if (isKeyframesTarget(next) && isKeyframesTarget(prev)) {
            if (!shallowCompare(next, prev) || variantDidChange) {
              markToAnimate(key);
            } else {
              typeState.protectedKeys[key] = true;
            }
          } else if (next !== void 0) {
            markToAnimate(key);
          } else {
            removedKeys.add(key);
          }
        } else if (next !== void 0 && removedKeys.has(key)) {
          markToAnimate(key);
        } else {
          typeState.protectedKeys[key] = true;
        }
      }
      typeState.prevProp = prop;
      typeState.prevResolvedValues = resolvedValues;
      if (typeState.isActive) {
        encounteredKeys = __assign(__assign({}, encounteredKeys), resolvedValues);
      }
      if (isInitialRender && visualElement2.blockInitialAnimation) {
        shouldAnimateType = false;
      }
      if (shouldAnimateType && !isInherited) {
        animations2.push.apply(animations2, __spreadArray([], __read(definitionList.map(function(animation) {
          return {
            animation,
            options: __assign({ type: type6 }, options)
          };
        })), false));
      }
    };
    for (var i2 = 0; i2 < numAnimationTypes; i2++) {
      _loop_1(i2);
    }
    allAnimatedKeys = __assign({}, encounteredKeys);
    if (removedKeys.size) {
      var fallbackAnimation_1 = {};
      removedKeys.forEach(function(key) {
        var fallbackTarget = visualElement2.getBaseTarget(key);
        if (fallbackTarget !== void 0) {
          fallbackAnimation_1[key] = fallbackTarget;
        }
      });
      animations2.push({ animation: fallbackAnimation_1 });
    }
    var shouldAnimate = Boolean(animations2.length);
    if (isInitialRender && props.initial === false && !visualElement2.manuallyAnimateOnMount) {
      shouldAnimate = false;
    }
    isInitialRender = false;
    return shouldAnimate ? animate4(animations2) : Promise.resolve();
  }
  function setActive(type6, isActive, options) {
    var _a2;
    if (state[type6].isActive === isActive)
      return Promise.resolve();
    (_a2 = visualElement2.variantChildren) === null || _a2 === void 0 ? void 0 : _a2.forEach(function(child) {
      var _a3;
      return (_a3 = child.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(type6, isActive);
    });
    state[type6].isActive = isActive;
    var animations2 = animateChanges(options, type6);
    for (var key in state) {
      state[key].protectedKeys = {};
    }
    return animations2;
  }
  return {
    isAnimated,
    animateChanges,
    setActive,
    setAnimateFunction,
    getState: function() {
      return state;
    }
  };
}
function checkVariantsDidChange(prev, next) {
  if (typeof next === "string") {
    return next !== prev;
  } else if (isVariantLabels(next)) {
    return !shallowCompare(next, prev);
  }
  return false;
}
function createTypeState(isActive) {
  if (isActive === void 0) {
    isActive = false;
  }
  return {
    isActive,
    protectedKeys: {},
    needsAnimating: {},
    prevResolvedValues: {}
  };
}
function createState() {
  var _a2;
  return _a2 = {}, _a2[AnimationType.Animate] = createTypeState(true), _a2[AnimationType.InView] = createTypeState(), _a2[AnimationType.Hover] = createTypeState(), _a2[AnimationType.Tap] = createTypeState(), _a2[AnimationType.Drag] = createTypeState(), _a2[AnimationType.Focus] = createTypeState(), _a2[AnimationType.Exit] = createTypeState(), _a2;
}

// node_modules/framer-motion/dist/es/motion/features/animations.mjs
var animations = {
  animation: makeRenderlessComponent(function(_a2) {
    var visualElement2 = _a2.visualElement, animate4 = _a2.animate;
    visualElement2.animationState || (visualElement2.animationState = createAnimationState(visualElement2));
    if (isAnimationControls(animate4)) {
      (0, import_react43.useEffect)(function() {
        return animate4.subscribe(visualElement2);
      }, [animate4]);
    }
  }),
  exit: makeRenderlessComponent(function(props) {
    var custom2 = props.custom, visualElement2 = props.visualElement;
    var _a2 = __read(usePresence(), 2), isPresent2 = _a2[0], safeToRemove = _a2[1];
    var presenceContext = (0, import_react43.useContext)(PresenceContext);
    (0, import_react43.useEffect)(function() {
      var _a3, _b;
      visualElement2.isPresent = isPresent2;
      var animation = (_a3 = visualElement2.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Exit, !isPresent2, { custom: (_b = presenceContext === null || presenceContext === void 0 ? void 0 : presenceContext.custom) !== null && _b !== void 0 ? _b : custom2 });
      !isPresent2 && (animation === null || animation === void 0 ? void 0 : animation.then(safeToRemove));
    }, [isPresent2]);
  })
};

// node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs
var import_react44 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/gestures/PanSession.mjs
init_tslib_es6();
var PanSession = (
  /** @class */
  function() {
    function PanSession2(event, handlers, _a2) {
      var _this = this;
      var _b = _a2 === void 0 ? {} : _a2, transformPagePoint = _b.transformPagePoint;
      this.startEvent = null;
      this.lastMoveEvent = null;
      this.lastMoveEventInfo = null;
      this.handlers = {};
      this.updatePoint = function() {
        if (!(_this.lastMoveEvent && _this.lastMoveEventInfo))
          return;
        var info2 = getPanInfo(_this.lastMoveEventInfo, _this.history);
        var isPanStarted = _this.startEvent !== null;
        var isDistancePastThreshold = distance(info2.offset, { x: 0, y: 0 }) >= 3;
        if (!isPanStarted && !isDistancePastThreshold)
          return;
        var point2 = info2.point;
        var timestamp2 = getFrameData().timestamp;
        _this.history.push(__assign(__assign({}, point2), { timestamp: timestamp2 }));
        var _a3 = _this.handlers, onStart = _a3.onStart, onMove = _a3.onMove;
        if (!isPanStarted) {
          onStart && onStart(_this.lastMoveEvent, info2);
          _this.startEvent = _this.lastMoveEvent;
        }
        onMove && onMove(_this.lastMoveEvent, info2);
      };
      this.handlePointerMove = function(event2, info2) {
        _this.lastMoveEvent = event2;
        _this.lastMoveEventInfo = transformPoint(info2, _this.transformPagePoint);
        if (isMouseEvent(event2) && event2.buttons === 0) {
          _this.handlePointerUp(event2, info2);
          return;
        }
        es_default.update(_this.updatePoint, true);
      };
      this.handlePointerUp = function(event2, info2) {
        _this.end();
        var _a3 = _this.handlers, onEnd = _a3.onEnd, onSessionEnd = _a3.onSessionEnd;
        var panInfo = getPanInfo(transformPoint(info2, _this.transformPagePoint), _this.history);
        if (_this.startEvent && onEnd) {
          onEnd(event2, panInfo);
        }
        onSessionEnd && onSessionEnd(event2, panInfo);
      };
      if (isTouchEvent(event) && event.touches.length > 1)
        return;
      this.handlers = handlers;
      this.transformPagePoint = transformPagePoint;
      var info = extractEventInfo(event);
      var initialInfo = transformPoint(info, this.transformPagePoint);
      var point = initialInfo.point;
      var timestamp = getFrameData().timestamp;
      this.history = [__assign(__assign({}, point), { timestamp })];
      var onSessionStart = handlers.onSessionStart;
      onSessionStart && onSessionStart(event, getPanInfo(initialInfo, this.history));
      this.removeListeners = pipe(addPointerEvent(window, "pointermove", this.handlePointerMove), addPointerEvent(window, "pointerup", this.handlePointerUp), addPointerEvent(window, "pointercancel", this.handlePointerUp));
    }
    PanSession2.prototype.updateHandlers = function(handlers) {
      this.handlers = handlers;
    };
    PanSession2.prototype.end = function() {
      this.removeListeners && this.removeListeners();
      cancelSync.update(this.updatePoint);
    };
    return PanSession2;
  }()
);
function transformPoint(info, transformPagePoint) {
  return transformPagePoint ? { point: transformPagePoint(info.point) } : info;
}
function subtractPoint(a3, b4) {
  return { x: a3.x - b4.x, y: a3.y - b4.y };
}
function getPanInfo(_a2, history) {
  var point = _a2.point;
  return {
    point,
    delta: subtractPoint(point, lastDevicePoint(history)),
    offset: subtractPoint(point, startDevicePoint(history)),
    velocity: getVelocity2(history, 0.1)
  };
}
function startDevicePoint(history) {
  return history[0];
}
function lastDevicePoint(history) {
  return history[history.length - 1];
}
function getVelocity2(history, timeDelta) {
  if (history.length < 2) {
    return { x: 0, y: 0 };
  }
  var i2 = history.length - 1;
  var timestampedPoint = null;
  var lastPoint = lastDevicePoint(history);
  while (i2 >= 0) {
    timestampedPoint = history[i2];
    if (lastPoint.timestamp - timestampedPoint.timestamp > secondsToMilliseconds(timeDelta)) {
      break;
    }
    i2--;
  }
  if (!timestampedPoint) {
    return { x: 0, y: 0 };
  }
  var time2 = (lastPoint.timestamp - timestampedPoint.timestamp) / 1e3;
  if (time2 === 0) {
    return { x: 0, y: 0 };
  }
  var currentVelocity = {
    x: (lastPoint.x - timestampedPoint.x) / time2,
    y: (lastPoint.y - timestampedPoint.y) / time2
  };
  if (currentVelocity.x === Infinity) {
    currentVelocity.x = 0;
  }
  if (currentVelocity.y === Infinity) {
    currentVelocity.y = 0;
  }
  return currentVelocity;
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/projection/geometry/delta-calc.mjs
function calcLength(axis) {
  return axis.max - axis.min;
}
function isNear(value, target, maxDistance) {
  if (target === void 0) {
    target = 0;
  }
  if (maxDistance === void 0) {
    maxDistance = 0.01;
  }
  return distance(value, target) < maxDistance;
}
function calcAxisDelta(delta, source, target, origin2) {
  if (origin2 === void 0) {
    origin2 = 0.5;
  }
  delta.origin = origin2;
  delta.originPoint = mix(source.min, source.max, delta.origin);
  delta.scale = calcLength(target) / calcLength(source);
  if (isNear(delta.scale, 1, 1e-4) || isNaN(delta.scale))
    delta.scale = 1;
  delta.translate = mix(target.min, target.max, delta.origin) - delta.originPoint;
  if (isNear(delta.translate) || isNaN(delta.translate))
    delta.translate = 0;
}
function calcBoxDelta(delta, source, target, origin2) {
  calcAxisDelta(delta.x, source.x, target.x, origin2 === null || origin2 === void 0 ? void 0 : origin2.originX);
  calcAxisDelta(delta.y, source.y, target.y, origin2 === null || origin2 === void 0 ? void 0 : origin2.originY);
}
function calcRelativeAxis(target, relative, parent) {
  target.min = parent.min + relative.min;
  target.max = target.min + calcLength(relative);
}
function calcRelativeBox(target, relative, parent) {
  calcRelativeAxis(target.x, relative.x, parent.x);
  calcRelativeAxis(target.y, relative.y, parent.y);
}
function calcRelativeAxisPosition(target, layout, parent) {
  target.min = layout.min - parent.min;
  target.max = target.min + calcLength(layout);
}
function calcRelativePosition(target, layout, parent) {
  calcRelativeAxisPosition(target.x, layout.x, parent.x);
  calcRelativeAxisPosition(target.y, layout.y, parent.y);
}

// node_modules/framer-motion/dist/es/gestures/drag/utils/constraints.mjs
function applyConstraints(point, _a2, elastic) {
  var min = _a2.min, max = _a2.max;
  if (min !== void 0 && point < min) {
    point = elastic ? mix(min, point, elastic.min) : Math.max(point, min);
  } else if (max !== void 0 && point > max) {
    point = elastic ? mix(max, point, elastic.max) : Math.min(point, max);
  }
  return point;
}
function calcRelativeAxisConstraints(axis, min, max) {
  return {
    min: min !== void 0 ? axis.min + min : void 0,
    max: max !== void 0 ? axis.max + max - (axis.max - axis.min) : void 0
  };
}
function calcRelativeConstraints(layoutBox, _a2) {
  var top = _a2.top, left = _a2.left, bottom = _a2.bottom, right = _a2.right;
  return {
    x: calcRelativeAxisConstraints(layoutBox.x, left, right),
    y: calcRelativeAxisConstraints(layoutBox.y, top, bottom)
  };
}
function calcViewportAxisConstraints(layoutAxis, constraintsAxis) {
  var _a2;
  var min = constraintsAxis.min - layoutAxis.min;
  var max = constraintsAxis.max - layoutAxis.max;
  if (constraintsAxis.max - constraintsAxis.min < layoutAxis.max - layoutAxis.min) {
    _a2 = __read([max, min], 2), min = _a2[0], max = _a2[1];
  }
  return { min, max };
}
function calcViewportConstraints(layoutBox, constraintsBox) {
  return {
    x: calcViewportAxisConstraints(layoutBox.x, constraintsBox.x),
    y: calcViewportAxisConstraints(layoutBox.y, constraintsBox.y)
  };
}
function calcOrigin2(source, target) {
  var origin2 = 0.5;
  var sourceLength = calcLength(source);
  var targetLength = calcLength(target);
  if (targetLength > sourceLength) {
    origin2 = progress(target.min, target.max - sourceLength, source.min);
  } else if (sourceLength > targetLength) {
    origin2 = progress(source.min, source.max - targetLength, target.min);
  }
  return clamp2(0, 1, origin2);
}
function rebaseAxisConstraints(layout, constraints) {
  var relativeConstraints = {};
  if (constraints.min !== void 0) {
    relativeConstraints.min = constraints.min - layout.min;
  }
  if (constraints.max !== void 0) {
    relativeConstraints.max = constraints.max - layout.min;
  }
  return relativeConstraints;
}
var defaultElastic = 0.35;
function resolveDragElastic(dragElastic) {
  if (dragElastic === void 0) {
    dragElastic = defaultElastic;
  }
  if (dragElastic === false) {
    dragElastic = 0;
  } else if (dragElastic === true) {
    dragElastic = defaultElastic;
  }
  return {
    x: resolveAxisElastic(dragElastic, "left", "right"),
    y: resolveAxisElastic(dragElastic, "top", "bottom")
  };
}
function resolveAxisElastic(dragElastic, minLabel, maxLabel) {
  return {
    min: resolvePointElastic(dragElastic, minLabel),
    max: resolvePointElastic(dragElastic, maxLabel)
  };
}
function resolvePointElastic(dragElastic, label) {
  var _a2;
  return typeof dragElastic === "number" ? dragElastic : (_a2 = dragElastic[label]) !== null && _a2 !== void 0 ? _a2 : 0;
}

// node_modules/framer-motion/dist/es/projection/geometry/models.mjs
var createAxisDelta = function() {
  return {
    translate: 0,
    scale: 1,
    origin: 0,
    originPoint: 0
  };
};
var createDelta = function() {
  return {
    x: createAxisDelta(),
    y: createAxisDelta()
  };
};
var createAxis = function() {
  return { min: 0, max: 0 };
};
var createBox = function() {
  return {
    x: createAxis(),
    y: createAxis()
  };
};

// node_modules/framer-motion/dist/es/projection/utils/each-axis.mjs
function eachAxis(callback) {
  return [callback("x"), callback("y")];
}

// node_modules/framer-motion/dist/es/projection/geometry/conversion.mjs
function convertBoundingBoxToBox(_a2) {
  var top = _a2.top, left = _a2.left, right = _a2.right, bottom = _a2.bottom;
  return {
    x: { min: left, max: right },
    y: { min: top, max: bottom }
  };
}
function convertBoxToBoundingBox(_a2) {
  var x2 = _a2.x, y2 = _a2.y;
  return { top: y2.min, right: x2.max, bottom: y2.max, left: x2.min };
}
function transformBoxPoints(point, transformPoint2) {
  if (!transformPoint2)
    return point;
  var topLeft = transformPoint2({ x: point.left, y: point.top });
  var bottomRight = transformPoint2({ x: point.right, y: point.bottom });
  return {
    top: topLeft.y,
    left: topLeft.x,
    bottom: bottomRight.y,
    right: bottomRight.x
  };
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/projection/utils/has-transform.mjs
function isIdentityScale(scale2) {
  return scale2 === void 0 || scale2 === 1;
}
function hasScale(_a2) {
  var scale2 = _a2.scale, scaleX = _a2.scaleX, scaleY = _a2.scaleY;
  return !isIdentityScale(scale2) || !isIdentityScale(scaleX) || !isIdentityScale(scaleY);
}
function hasTransform(values) {
  return hasScale(values) || hasTranslate(values.x) || hasTranslate(values.y) || values.z || values.rotate || values.rotateX || values.rotateY;
}
function hasTranslate(value) {
  return value && value !== "0%";
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-apply.mjs
function scalePoint(point, scale2, originPoint) {
  var distanceFromOrigin = point - originPoint;
  var scaled = scale2 * distanceFromOrigin;
  return originPoint + scaled;
}
function applyPointDelta(point, translate, scale2, originPoint, boxScale) {
  if (boxScale !== void 0) {
    point = scalePoint(point, boxScale, originPoint);
  }
  return scalePoint(point, scale2, originPoint) + translate;
}
function applyAxisDelta(axis, translate, scale2, originPoint, boxScale) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  axis.min = applyPointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = applyPointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function applyBoxDelta(box, _a2) {
  var x2 = _a2.x, y2 = _a2.y;
  applyAxisDelta(box.x, x2.translate, x2.scale, x2.originPoint);
  applyAxisDelta(box.y, y2.translate, y2.scale, y2.originPoint);
}
function applyTreeDeltas(box, treeScale, treePath, isSharedTransition) {
  var _a2, _b;
  if (isSharedTransition === void 0) {
    isSharedTransition = false;
  }
  var treeLength = treePath.length;
  if (!treeLength)
    return;
  treeScale.x = treeScale.y = 1;
  var node;
  var delta;
  for (var i2 = 0; i2 < treeLength; i2++) {
    node = treePath[i2];
    delta = node.projectionDelta;
    if (((_b = (_a2 = node.instance) === null || _a2 === void 0 ? void 0 : _a2.style) === null || _b === void 0 ? void 0 : _b.display) === "contents")
      continue;
    if (isSharedTransition && node.options.layoutScroll && node.scroll && node !== node.root) {
      transformBox(box, { x: -node.scroll.x, y: -node.scroll.y });
    }
    if (delta) {
      treeScale.x *= delta.x.scale;
      treeScale.y *= delta.y.scale;
      applyBoxDelta(box, delta);
    }
    if (isSharedTransition && hasTransform(node.latestValues)) {
      transformBox(box, node.latestValues);
    }
  }
}
function translateAxis(axis, distance2) {
  axis.min = axis.min + distance2;
  axis.max = axis.max + distance2;
}
function transformAxis(axis, transforms2, _a2) {
  var _b = __read(_a2, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  var axisOrigin = transforms2[originKey] !== void 0 ? transforms2[originKey] : 0.5;
  var originPoint = mix(axis.min, axis.max, axisOrigin);
  applyAxisDelta(axis, transforms2[key], transforms2[scaleKey], originPoint, transforms2.scale);
}
var xKeys = ["x", "scaleX", "originX"];
var yKeys = ["y", "scaleY", "originY"];
function transformBox(box, transform2) {
  transformAxis(box.x, transform2, xKeys);
  transformAxis(box.y, transform2, yKeys);
}

// node_modules/framer-motion/dist/es/projection/utils/measure.mjs
function measureViewportBox(instance, transformPoint2) {
  return convertBoundingBoxToBox(transformBoxPoints(instance.getBoundingClientRect(), transformPoint2));
}
function measurePageBox(element, rootProjectionNode2, transformPagePoint) {
  var viewportBox = measureViewportBox(element, transformPagePoint);
  var scroll3 = rootProjectionNode2.scroll;
  if (scroll3) {
    translateAxis(viewportBox.x, scroll3.x);
    translateAxis(viewportBox.y, scroll3.y);
  }
  return viewportBox;
}

// node_modules/framer-motion/dist/es/gestures/drag/VisualElementDragControls.mjs
var elementDragControls = /* @__PURE__ */ new WeakMap();
var VisualElementDragControls = (
  /** @class */
  function() {
    function VisualElementDragControls2(visualElement2) {
      this.openGlobalLock = null;
      this.isDragging = false;
      this.currentDirection = null;
      this.originPoint = { x: 0, y: 0 };
      this.constraints = false;
      this.hasMutatedConstraints = false;
      this.elastic = createBox();
      this.visualElement = visualElement2;
    }
    VisualElementDragControls2.prototype.start = function(originEvent, _a2) {
      var _this = this;
      var _b = _a2 === void 0 ? {} : _a2, _c2 = _b.snapToCursor, snapToCursor = _c2 === void 0 ? false : _c2;
      if (this.visualElement.isPresent === false)
        return;
      var onSessionStart = function(event) {
        _this.stopAnimation();
        if (snapToCursor) {
          _this.snapToCursor(extractEventInfo(event, "page").point);
        }
      };
      var onStart = function(event, info) {
        var _a3;
        var _b2 = _this.getProps(), drag2 = _b2.drag, dragPropagation = _b2.dragPropagation, onDragStart = _b2.onDragStart;
        if (drag2 && !dragPropagation) {
          if (_this.openGlobalLock)
            _this.openGlobalLock();
          _this.openGlobalLock = getGlobalLock(drag2);
          if (!_this.openGlobalLock)
            return;
        }
        _this.isDragging = true;
        _this.currentDirection = null;
        _this.resolveConstraints();
        if (_this.visualElement.projection) {
          _this.visualElement.projection.isAnimationBlocked = true;
          _this.visualElement.projection.target = void 0;
        }
        eachAxis(function(axis) {
          var _a4, _b3;
          var current = _this.getAxisMotionValue(axis).get() || 0;
          if (percent.test(current)) {
            var measuredAxis = (_b3 = (_a4 = _this.visualElement.projection) === null || _a4 === void 0 ? void 0 : _a4.layout) === null || _b3 === void 0 ? void 0 : _b3.actual[axis];
            if (measuredAxis) {
              var length_1 = calcLength(measuredAxis);
              current = length_1 * (parseFloat(current) / 100);
            }
          }
          _this.originPoint[axis] = current;
        });
        onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(event, info);
        (_a3 = _this.visualElement.animationState) === null || _a3 === void 0 ? void 0 : _a3.setActive(AnimationType.Drag, true);
      };
      var onMove = function(event, info) {
        var _a3 = _this.getProps(), dragPropagation = _a3.dragPropagation, dragDirectionLock = _a3.dragDirectionLock, onDirectionLock = _a3.onDirectionLock, onDrag = _a3.onDrag;
        if (!dragPropagation && !_this.openGlobalLock)
          return;
        var offset = info.offset;
        if (dragDirectionLock && _this.currentDirection === null) {
          _this.currentDirection = getCurrentDirection(offset);
          if (_this.currentDirection !== null) {
            onDirectionLock === null || onDirectionLock === void 0 ? void 0 : onDirectionLock(_this.currentDirection);
          }
          return;
        }
        _this.updateAxis("x", info.point, offset);
        _this.updateAxis("y", info.point, offset);
        _this.visualElement.syncRender();
        onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, info);
      };
      var onSessionEnd = function(event, info) {
        return _this.stop(event, info);
      };
      this.panSession = new PanSession(originEvent, {
        onSessionStart,
        onStart,
        onMove,
        onSessionEnd
      }, { transformPagePoint: this.visualElement.getTransformPagePoint() });
    };
    VisualElementDragControls2.prototype.stop = function(event, info) {
      var isDragging = this.isDragging;
      this.cancel();
      if (!isDragging)
        return;
      var velocity = info.velocity;
      this.startAnimation(velocity);
      var onDragEnd = this.getProps().onDragEnd;
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(event, info);
    };
    VisualElementDragControls2.prototype.cancel = function() {
      var _a2, _b;
      this.isDragging = false;
      if (this.visualElement.projection) {
        this.visualElement.projection.isAnimationBlocked = false;
      }
      (_a2 = this.panSession) === null || _a2 === void 0 ? void 0 : _a2.end();
      this.panSession = void 0;
      var dragPropagation = this.getProps().dragPropagation;
      if (!dragPropagation && this.openGlobalLock) {
        this.openGlobalLock();
        this.openGlobalLock = null;
      }
      (_b = this.visualElement.animationState) === null || _b === void 0 ? void 0 : _b.setActive(AnimationType.Drag, false);
    };
    VisualElementDragControls2.prototype.updateAxis = function(axis, _point, offset) {
      var drag2 = this.getProps().drag;
      if (!offset || !shouldDrag(axis, drag2, this.currentDirection))
        return;
      var axisValue = this.getAxisMotionValue(axis);
      var next = this.originPoint[axis] + offset[axis];
      if (this.constraints && this.constraints[axis]) {
        next = applyConstraints(next, this.constraints[axis], this.elastic[axis]);
      }
      axisValue.set(next);
    };
    VisualElementDragControls2.prototype.resolveConstraints = function() {
      var _this = this;
      var _a2 = this.getProps(), dragConstraints = _a2.dragConstraints, dragElastic = _a2.dragElastic;
      var layout = (this.visualElement.projection || {}).layout;
      var prevConstraints = this.constraints;
      if (dragConstraints && isRefObject(dragConstraints)) {
        if (!this.constraints) {
          this.constraints = this.resolveRefConstraints();
        }
      } else {
        if (dragConstraints && layout) {
          this.constraints = calcRelativeConstraints(layout.actual, dragConstraints);
        } else {
          this.constraints = false;
        }
      }
      this.elastic = resolveDragElastic(dragElastic);
      if (prevConstraints !== this.constraints && layout && this.constraints && !this.hasMutatedConstraints) {
        eachAxis(function(axis) {
          if (_this.getAxisMotionValue(axis)) {
            _this.constraints[axis] = rebaseAxisConstraints(layout.actual[axis], _this.constraints[axis]);
          }
        });
      }
    };
    VisualElementDragControls2.prototype.resolveRefConstraints = function() {
      var _a2 = this.getProps(), constraints = _a2.dragConstraints, onMeasureDragConstraints = _a2.onMeasureDragConstraints;
      if (!constraints || !isRefObject(constraints))
        return false;
      var constraintsElement = constraints.current;
      invariant(constraintsElement !== null, "If `dragConstraints` is set as a React ref, that ref must be passed to another component's `ref` prop.");
      var projection = this.visualElement.projection;
      if (!projection || !projection.layout)
        return false;
      var constraintsBox = measurePageBox(constraintsElement, projection.root, this.visualElement.getTransformPagePoint());
      var measuredConstraints = calcViewportConstraints(projection.layout.actual, constraintsBox);
      if (onMeasureDragConstraints) {
        var userConstraints = onMeasureDragConstraints(convertBoxToBoundingBox(measuredConstraints));
        this.hasMutatedConstraints = !!userConstraints;
        if (userConstraints) {
          measuredConstraints = convertBoundingBoxToBox(userConstraints);
        }
      }
      return measuredConstraints;
    };
    VisualElementDragControls2.prototype.startAnimation = function(velocity) {
      var _this = this;
      var _a2 = this.getProps(), drag2 = _a2.drag, dragMomentum = _a2.dragMomentum, dragElastic = _a2.dragElastic, dragTransition = _a2.dragTransition, dragSnapToOrigin = _a2.dragSnapToOrigin, onDragTransitionEnd = _a2.onDragTransitionEnd;
      var constraints = this.constraints || {};
      var momentumAnimations = eachAxis(function(axis) {
        var _a3;
        if (!shouldDrag(axis, drag2, _this.currentDirection)) {
          return;
        }
        var transition2 = (_a3 = constraints === null || constraints === void 0 ? void 0 : constraints[axis]) !== null && _a3 !== void 0 ? _a3 : {};
        if (dragSnapToOrigin)
          transition2 = { min: 0, max: 0 };
        var bounceStiffness = dragElastic ? 200 : 1e6;
        var bounceDamping = dragElastic ? 40 : 1e7;
        var inertia2 = __assign(__assign({ type: "inertia", velocity: dragMomentum ? velocity[axis] : 0, bounceStiffness, bounceDamping, timeConstant: 750, restDelta: 1, restSpeed: 10 }, dragTransition), transition2);
        return _this.startAxisValueAnimation(axis, inertia2);
      });
      return Promise.all(momentumAnimations).then(onDragTransitionEnd);
    };
    VisualElementDragControls2.prototype.startAxisValueAnimation = function(axis, transition2) {
      var axisValue = this.getAxisMotionValue(axis);
      return startAnimation(axis, axisValue, 0, transition2);
    };
    VisualElementDragControls2.prototype.stopAnimation = function() {
      var _this = this;
      eachAxis(function(axis) {
        return _this.getAxisMotionValue(axis).stop();
      });
    };
    VisualElementDragControls2.prototype.getAxisMotionValue = function(axis) {
      var _a2, _b;
      var dragKey = "_drag" + axis.toUpperCase();
      var externalMotionValue = this.visualElement.getProps()[dragKey];
      return externalMotionValue ? externalMotionValue : this.visualElement.getValue(axis, (_b = (_a2 = this.visualElement.getProps().initial) === null || _a2 === void 0 ? void 0 : _a2[axis]) !== null && _b !== void 0 ? _b : 0);
    };
    VisualElementDragControls2.prototype.snapToCursor = function(point) {
      var _this = this;
      eachAxis(function(axis) {
        var drag2 = _this.getProps().drag;
        if (!shouldDrag(axis, drag2, _this.currentDirection))
          return;
        var projection = _this.visualElement.projection;
        var axisValue = _this.getAxisMotionValue(axis);
        if (projection && projection.layout) {
          var _a2 = projection.layout.actual[axis], min = _a2.min, max = _a2.max;
          axisValue.set(point[axis] - mix(min, max, 0.5));
        }
      });
    };
    VisualElementDragControls2.prototype.scalePositionWithinConstraints = function() {
      var _this = this;
      var _a2;
      var _b = this.getProps(), drag2 = _b.drag, dragConstraints = _b.dragConstraints;
      var projection = this.visualElement.projection;
      if (!isRefObject(dragConstraints) || !projection || !this.constraints)
        return;
      this.stopAnimation();
      var boxProgress = { x: 0, y: 0 };
      eachAxis(function(axis) {
        var axisValue = _this.getAxisMotionValue(axis);
        if (axisValue) {
          var latest = axisValue.get();
          boxProgress[axis] = calcOrigin2({ min: latest, max: latest }, _this.constraints[axis]);
        }
      });
      var transformTemplate = this.visualElement.getProps().transformTemplate;
      this.visualElement.getInstance().style.transform = transformTemplate ? transformTemplate({}, "") : "none";
      (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
      projection.updateLayout();
      this.resolveConstraints();
      eachAxis(function(axis) {
        if (!shouldDrag(axis, drag2, null))
          return;
        var axisValue = _this.getAxisMotionValue(axis);
        var _a3 = _this.constraints[axis], min = _a3.min, max = _a3.max;
        axisValue.set(mix(min, max, boxProgress[axis]));
      });
    };
    VisualElementDragControls2.prototype.addListeners = function() {
      var _this = this;
      var _a2;
      elementDragControls.set(this.visualElement, this);
      var element = this.visualElement.getInstance();
      var stopPointerListener = addPointerEvent(element, "pointerdown", function(event) {
        var _a3 = _this.getProps(), drag2 = _a3.drag, _b = _a3.dragListener, dragListener = _b === void 0 ? true : _b;
        drag2 && dragListener && _this.start(event);
      });
      var measureDragConstraints = function() {
        var dragConstraints = _this.getProps().dragConstraints;
        if (isRefObject(dragConstraints)) {
          _this.constraints = _this.resolveRefConstraints();
        }
      };
      var projection = this.visualElement.projection;
      var stopMeasureLayoutListener = projection.addEventListener("measure", measureDragConstraints);
      if (projection && !projection.layout) {
        (_a2 = projection.root) === null || _a2 === void 0 ? void 0 : _a2.updateScroll();
        projection.updateLayout();
      }
      measureDragConstraints();
      var stopResizeListener = addDomEvent(window, "resize", function() {
        return _this.scalePositionWithinConstraints();
      });
      projection.addEventListener("didUpdate", function(_a3) {
        var delta = _a3.delta, hasLayoutChanged = _a3.hasLayoutChanged;
        if (_this.isDragging && hasLayoutChanged) {
          eachAxis(function(axis) {
            var motionValue2 = _this.getAxisMotionValue(axis);
            if (!motionValue2)
              return;
            _this.originPoint[axis] += delta[axis].translate;
            motionValue2.set(motionValue2.get() + delta[axis].translate);
          });
          _this.visualElement.syncRender();
        }
      });
      return function() {
        stopResizeListener();
        stopPointerListener();
        stopMeasureLayoutListener();
      };
    };
    VisualElementDragControls2.prototype.getProps = function() {
      var props = this.visualElement.getProps();
      var _a2 = props.drag, drag2 = _a2 === void 0 ? false : _a2, _b = props.dragDirectionLock, dragDirectionLock = _b === void 0 ? false : _b, _c2 = props.dragPropagation, dragPropagation = _c2 === void 0 ? false : _c2, _d = props.dragConstraints, dragConstraints = _d === void 0 ? false : _d, _e2 = props.dragElastic, dragElastic = _e2 === void 0 ? defaultElastic : _e2, _f = props.dragMomentum, dragMomentum = _f === void 0 ? true : _f;
      return __assign(__assign({}, props), { drag: drag2, dragDirectionLock, dragPropagation, dragConstraints, dragElastic, dragMomentum });
    };
    return VisualElementDragControls2;
  }()
);
function shouldDrag(direction, drag2, currentDirection) {
  return (drag2 === true || drag2 === direction) && (currentDirection === null || currentDirection === direction);
}
function getCurrentDirection(offset, lockThreshold) {
  if (lockThreshold === void 0) {
    lockThreshold = 10;
  }
  var direction = null;
  if (Math.abs(offset.y) > lockThreshold) {
    direction = "y";
  } else if (Math.abs(offset.x) > lockThreshold) {
    direction = "x";
  }
  return direction;
}

// node_modules/framer-motion/dist/es/gestures/drag/use-drag.mjs
function useDrag(props) {
  var groupDragControls = props.dragControls, visualElement2 = props.visualElement;
  var dragControls = useConstant(function() {
    return new VisualElementDragControls(visualElement2);
  });
  (0, import_react44.useEffect)(function() {
    return groupDragControls && groupDragControls.subscribe(dragControls);
  }, [dragControls, groupDragControls]);
  (0, import_react44.useEffect)(function() {
    return dragControls.addListeners();
  }, [dragControls]);
}

// node_modules/framer-motion/dist/es/gestures/use-pan-gesture.mjs
var import_react45 = __toESM(require_react(), 1);
function usePanGesture(_a2) {
  var onPan = _a2.onPan, onPanStart = _a2.onPanStart, onPanEnd = _a2.onPanEnd, onPanSessionStart = _a2.onPanSessionStart, visualElement2 = _a2.visualElement;
  var hasPanEvents = onPan || onPanStart || onPanEnd || onPanSessionStart;
  var panSession = (0, import_react45.useRef)(null);
  var transformPagePoint = (0, import_react45.useContext)(MotionConfigContext).transformPagePoint;
  var handlers = {
    onSessionStart: onPanSessionStart,
    onStart: onPanStart,
    onMove: onPan,
    onEnd: function(event, info) {
      panSession.current = null;
      onPanEnd && onPanEnd(event, info);
    }
  };
  (0, import_react45.useEffect)(function() {
    if (panSession.current !== null) {
      panSession.current.updateHandlers(handlers);
    }
  });
  function onPointerDown(event) {
    panSession.current = new PanSession(event, handlers, {
      transformPagePoint
    });
  }
  usePointerEvent(visualElement2, "pointerdown", hasPanEvents && onPointerDown);
  useUnmountEffect(function() {
    return panSession.current && panSession.current.end();
  });
}

// node_modules/framer-motion/dist/es/motion/features/drag.mjs
var drag = {
  pan: makeRenderlessComponent(usePanGesture),
  drag: makeRenderlessComponent(useDrag)
};

// node_modules/framer-motion/dist/es/render/html/visual-element.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/render/index.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/render/utils/lifecycles.mjs
init_tslib_es6();
var names = [
  "LayoutMeasure",
  "BeforeLayoutMeasure",
  "LayoutUpdate",
  "ViewportBoxUpdate",
  "Update",
  "Render",
  "AnimationComplete",
  "LayoutAnimationComplete",
  "AnimationStart",
  "LayoutAnimationStart",
  "SetAxisTarget",
  "Unmount"
];
function createLifecycles() {
  var managers = names.map(function() {
    return new SubscriptionManager();
  });
  var propSubscriptions = {};
  var lifecycles = {
    clearAllListeners: function() {
      return managers.forEach(function(manager) {
        return manager.clear();
      });
    },
    updatePropListeners: function(props) {
      names.forEach(function(name) {
        var _a2;
        var on2 = "on" + name;
        var propListener = props[on2];
        (_a2 = propSubscriptions[name]) === null || _a2 === void 0 ? void 0 : _a2.call(propSubscriptions);
        if (propListener) {
          propSubscriptions[name] = lifecycles[on2](propListener);
        }
      });
    }
  };
  managers.forEach(function(manager, i2) {
    lifecycles["on" + names[i2]] = function(handler) {
      return manager.add(handler);
    };
    lifecycles["notify" + names[i2]] = function() {
      var args = [];
      for (var _i2 = 0; _i2 < arguments.length; _i2++) {
        args[_i2] = arguments[_i2];
      }
      return manager.notify.apply(manager, __spreadArray([], __read(args), false));
    };
  });
  return lifecycles;
}

// node_modules/framer-motion/dist/es/render/utils/motion-values.mjs
function updateMotionValuesFromProps(element, next, prev) {
  var _a2;
  for (var key in next) {
    var nextValue = next[key];
    var prevValue = prev[key];
    if (isMotionValue(nextValue)) {
      element.addValue(key, nextValue);
      if (true) {
        warnOnce(nextValue.version === "6.5.1", "Attempting to mix Framer Motion versions ".concat(nextValue.version, " with 6.5.1 may not work as expected."));
      }
    } else if (isMotionValue(prevValue)) {
      element.addValue(key, motionValue(nextValue));
    } else if (prevValue !== nextValue) {
      if (element.hasValue(key)) {
        var existingValue = element.getValue(key);
        !existingValue.hasAnimated && existingValue.set(nextValue);
      } else {
        element.addValue(key, motionValue((_a2 = element.getStaticValue(key)) !== null && _a2 !== void 0 ? _a2 : nextValue));
      }
    }
  }
  for (var key in prev) {
    if (next[key] === void 0)
      element.removeValue(key);
  }
  return next;
}

// node_modules/framer-motion/dist/es/render/index.mjs
var visualElement = function(_a2) {
  var _b = _a2.treeType, treeType = _b === void 0 ? "" : _b, build = _a2.build, getBaseTarget = _a2.getBaseTarget, makeTargetAnimatable = _a2.makeTargetAnimatable, measureViewportBox2 = _a2.measureViewportBox, renderInstance = _a2.render, readValueFromInstance = _a2.readValueFromInstance, removeValueFromRenderState = _a2.removeValueFromRenderState, sortNodePosition = _a2.sortNodePosition, scrapeMotionValuesFromProps3 = _a2.scrapeMotionValuesFromProps;
  return function(_a3, options) {
    var parent = _a3.parent, props = _a3.props, presenceId = _a3.presenceId, blockInitialAnimation = _a3.blockInitialAnimation, visualState = _a3.visualState, shouldReduceMotion = _a3.shouldReduceMotion;
    if (options === void 0) {
      options = {};
    }
    var isMounted = false;
    var latestValues = visualState.latestValues, renderState = visualState.renderState;
    var instance;
    var lifecycles = createLifecycles();
    var values = /* @__PURE__ */ new Map();
    var valueSubscriptions = /* @__PURE__ */ new Map();
    var prevMotionValues = {};
    var baseTarget = __assign({}, latestValues);
    var removeFromVariantTree;
    function render() {
      if (!instance || !isMounted)
        return;
      triggerBuild();
      renderInstance(instance, renderState, props.style, element.projection);
    }
    function triggerBuild() {
      build(element, renderState, latestValues, options, props);
    }
    function update() {
      lifecycles.notifyUpdate(latestValues);
    }
    function bindToMotionValue(key2, value2) {
      var removeOnChange = value2.onChange(function(latestValue) {
        latestValues[key2] = latestValue;
        props.onUpdate && es_default.update(update, false, true);
      });
      var removeOnRenderRequest = value2.onRenderRequest(element.scheduleRender);
      valueSubscriptions.set(key2, function() {
        removeOnChange();
        removeOnRenderRequest();
      });
    }
    var initialMotionValues = scrapeMotionValuesFromProps3(props);
    for (var key in initialMotionValues) {
      var value = initialMotionValues[key];
      if (latestValues[key] !== void 0 && isMotionValue(value)) {
        value.set(latestValues[key], false);
      }
    }
    var isControllingVariants = checkIfControllingVariants(props);
    var isVariantNode = checkIfVariantNode(props);
    var element = __assign(__assign({
      treeType,
      /**
       * This is a mirror of the internal instance prop, which keeps
       * VisualElement type-compatible with React's RefObject.
       */
      current: null,
      /**
       * The depth of this visual element within the visual element tree.
       */
      depth: parent ? parent.depth + 1 : 0,
      parent,
      children: /* @__PURE__ */ new Set(),
      /**
       *
       */
      presenceId,
      shouldReduceMotion,
      /**
       * If this component is part of the variant tree, it should track
       * any children that are also part of the tree. This is essentially
       * a shadow tree to simplify logic around how to stagger over children.
       */
      variantChildren: isVariantNode ? /* @__PURE__ */ new Set() : void 0,
      /**
       * Whether this instance is visible. This can be changed imperatively
       * by the projection tree, is analogous to CSS's visibility in that
       * hidden elements should take up layout, and needs enacting by the configured
       * render function.
       */
      isVisible: void 0,
      /**
       * Normally, if a component is controlled by a parent's variants, it can
       * rely on that ancestor to trigger animations further down the tree.
       * However, if a component is created after its parent is mounted, the parent
       * won't trigger that mount animation so the child needs to.
       *
       * TODO: This might be better replaced with a method isParentMounted
       */
      manuallyAnimateOnMount: Boolean(parent === null || parent === void 0 ? void 0 : parent.isMounted()),
      /**
       * This can be set by AnimatePresence to force components that mount
       * at the same time as it to mount as if they have initial={false} set.
       */
      blockInitialAnimation,
      /**
       * Determine whether this component has mounted yet. This is mostly used
       * by variant children to determine whether they need to trigger their
       * own animations on mount.
       */
      isMounted: function() {
        return Boolean(instance);
      },
      mount: function(newInstance) {
        isMounted = true;
        instance = element.current = newInstance;
        if (element.projection) {
          element.projection.mount(newInstance);
        }
        if (isVariantNode && parent && !isControllingVariants) {
          removeFromVariantTree = parent === null || parent === void 0 ? void 0 : parent.addVariantChild(element);
        }
        values.forEach(function(value2, key2) {
          return bindToMotionValue(key2, value2);
        });
        parent === null || parent === void 0 ? void 0 : parent.children.add(element);
        element.setProps(props);
      },
      /**
       *
       */
      unmount: function() {
        var _a4;
        (_a4 = element.projection) === null || _a4 === void 0 ? void 0 : _a4.unmount();
        cancelSync.update(update);
        cancelSync.render(render);
        valueSubscriptions.forEach(function(remove) {
          return remove();
        });
        removeFromVariantTree === null || removeFromVariantTree === void 0 ? void 0 : removeFromVariantTree();
        parent === null || parent === void 0 ? void 0 : parent.children.delete(element);
        lifecycles.clearAllListeners();
        instance = void 0;
        isMounted = false;
      },
      /**
       * Add a child visual element to our set of children.
       */
      addVariantChild: function(child) {
        var _a4;
        var closestVariantNode = element.getClosestVariantNode();
        if (closestVariantNode) {
          (_a4 = closestVariantNode.variantChildren) === null || _a4 === void 0 ? void 0 : _a4.add(child);
          return function() {
            return closestVariantNode.variantChildren.delete(child);
          };
        }
      },
      sortNodePosition: function(other) {
        if (!sortNodePosition || treeType !== other.treeType)
          return 0;
        return sortNodePosition(element.getInstance(), other.getInstance());
      },
      /**
       * Returns the closest variant node in the tree starting from
       * this visual element.
       */
      getClosestVariantNode: function() {
        return isVariantNode ? element : parent === null || parent === void 0 ? void 0 : parent.getClosestVariantNode();
      },
      /**
       * Expose the latest layoutId prop.
       */
      getLayoutId: function() {
        return props.layoutId;
      },
      /**
       * Returns the current instance.
       */
      getInstance: function() {
        return instance;
      },
      /**
       * Get/set the latest static values.
       */
      getStaticValue: function(key2) {
        return latestValues[key2];
      },
      setStaticValue: function(key2, value2) {
        return latestValues[key2] = value2;
      },
      /**
       * Returns the latest motion value state. Currently only used to take
       * a snapshot of the visual element - perhaps this can return the whole
       * visual state
       */
      getLatestValues: function() {
        return latestValues;
      },
      /**
       * Set the visiblity of the visual element. If it's changed, schedule
       * a render to reflect these changes.
       */
      setVisibility: function(visibility) {
        if (element.isVisible === visibility)
          return;
        element.isVisible = visibility;
        element.scheduleRender();
      },
      /**
       * Make a target animatable by Popmotion. For instance, if we're
       * trying to animate width from 100px to 100vw we need to measure 100vw
       * in pixels to determine what we really need to animate to. This is also
       * pluggable to support Framer's custom value types like Color,
       * and CSS variables.
       */
      makeTargetAnimatable: function(target, canMutate) {
        if (canMutate === void 0) {
          canMutate = true;
        }
        return makeTargetAnimatable(element, target, props, canMutate);
      },
      /**
       * Measure the current viewport box with or without transforms.
       * Only measures axis-aligned boxes, rotate and skew must be manually
       * removed with a re-render to work.
       */
      measureViewportBox: function() {
        return measureViewportBox2(instance, props);
      },
      // Motion values ========================
      /**
       * Add a motion value and bind it to this visual element.
       */
      addValue: function(key2, value2) {
        if (element.hasValue(key2))
          element.removeValue(key2);
        values.set(key2, value2);
        latestValues[key2] = value2.get();
        bindToMotionValue(key2, value2);
      },
      /**
       * Remove a motion value and unbind any active subscriptions.
       */
      removeValue: function(key2) {
        var _a4;
        values.delete(key2);
        (_a4 = valueSubscriptions.get(key2)) === null || _a4 === void 0 ? void 0 : _a4();
        valueSubscriptions.delete(key2);
        delete latestValues[key2];
        removeValueFromRenderState(key2, renderState);
      },
      /**
       * Check whether we have a motion value for this key
       */
      hasValue: function(key2) {
        return values.has(key2);
      },
      /**
       * Get a motion value for this key. If called with a default
       * value, we'll create one if none exists.
       */
      getValue: function(key2, defaultValue) {
        var value2 = values.get(key2);
        if (value2 === void 0 && defaultValue !== void 0) {
          value2 = motionValue(defaultValue);
          element.addValue(key2, value2);
        }
        return value2;
      },
      /**
       * Iterate over our motion values.
       */
      forEachValue: function(callback) {
        return values.forEach(callback);
      },
      /**
       * If we're trying to animate to a previously unencountered value,
       * we need to check for it in our state and as a last resort read it
       * directly from the instance (which might have performance implications).
       */
      readValue: function(key2) {
        var _a4;
        return (_a4 = latestValues[key2]) !== null && _a4 !== void 0 ? _a4 : readValueFromInstance(instance, key2, options);
      },
      /**
       * Set the base target to later animate back to. This is currently
       * only hydrated on creation and when we first read a value.
       */
      setBaseTarget: function(key2, value2) {
        baseTarget[key2] = value2;
      },
      /**
       * Find the base target for a value thats been removed from all animation
       * props.
       */
      getBaseTarget: function(key2) {
        if (getBaseTarget) {
          var target = getBaseTarget(props, key2);
          if (target !== void 0 && !isMotionValue(target))
            return target;
        }
        return baseTarget[key2];
      }
    }, lifecycles), {
      /**
       * Build the renderer state based on the latest visual state.
       */
      build: function() {
        triggerBuild();
        return renderState;
      },
      /**
       * Schedule a render on the next animation frame.
       */
      scheduleRender: function() {
        es_default.render(render, false, true);
      },
      /**
       * Synchronously fire render. It's prefered that we batch renders but
       * in many circumstances, like layout measurement, we need to run this
       * synchronously. However in those instances other measures should be taken
       * to batch reads/writes.
       */
      syncRender: render,
      /**
       * Update the provided props. Ensure any newly-added motion values are
       * added to our map, old ones removed, and listeners updated.
       */
      setProps: function(newProps) {
        if (newProps.transformTemplate || props.transformTemplate) {
          element.scheduleRender();
        }
        props = newProps;
        lifecycles.updatePropListeners(newProps);
        prevMotionValues = updateMotionValuesFromProps(element, scrapeMotionValuesFromProps3(props), prevMotionValues);
      },
      getProps: function() {
        return props;
      },
      // Variants ==============================
      /**
       * Returns the variant definition with a given name.
       */
      getVariant: function(name) {
        var _a4;
        return (_a4 = props.variants) === null || _a4 === void 0 ? void 0 : _a4[name];
      },
      /**
       * Returns the defined default transition on this component.
       */
      getDefaultTransition: function() {
        return props.transition;
      },
      getTransformPagePoint: function() {
        return props.transformPagePoint;
      },
      /**
       * Used by child variant nodes to get the closest ancestor variant props.
       */
      getVariantContext: function(startAtParent) {
        if (startAtParent === void 0) {
          startAtParent = false;
        }
        if (startAtParent)
          return parent === null || parent === void 0 ? void 0 : parent.getVariantContext();
        if (!isControllingVariants) {
          var context_1 = (parent === null || parent === void 0 ? void 0 : parent.getVariantContext()) || {};
          if (props.initial !== void 0) {
            context_1.initial = props.initial;
          }
          return context_1;
        }
        var context = {};
        for (var i2 = 0; i2 < numVariantProps; i2++) {
          var name_1 = variantProps[i2];
          var prop = props[name_1];
          if (isVariantLabel(prop) || prop === false) {
            context[name_1] = prop;
          }
        }
        return context;
      }
    });
    return element;
  };
};
var variantProps = __spreadArray(["initial"], __read(variantPriorityOrder), false);
var numVariantProps = variantProps.length;

// node_modules/framer-motion/dist/es/render/dom/utils/css-variables-conversion.mjs
init_tslib_es6();
function isCSSVariable2(value) {
  return typeof value === "string" && value.startsWith("var(--");
}
var cssVariableRegex = /var\((--[a-zA-Z0-9-_]+),? ?([a-zA-Z0-9 ()%#.,-]+)?\)/;
function parseCSSVariable(current) {
  var match = cssVariableRegex.exec(current);
  if (!match)
    return [,];
  var _a2 = __read(match, 3), token = _a2[1], fallback3 = _a2[2];
  return [token, fallback3];
}
var maxDepth = 4;
function getVariableValue(current, element, depth) {
  if (depth === void 0) {
    depth = 1;
  }
  invariant(depth <= maxDepth, 'Max CSS variable fallback depth detected in property "'.concat(current, '". This may indicate a circular fallback dependency.'));
  var _a2 = __read(parseCSSVariable(current), 2), token = _a2[0], fallback3 = _a2[1];
  if (!token)
    return;
  var resolved = window.getComputedStyle(element).getPropertyValue(token);
  if (resolved) {
    return resolved.trim();
  } else if (isCSSVariable2(fallback3)) {
    return getVariableValue(fallback3, element, depth + 1);
  } else {
    return fallback3;
  }
}
function resolveCSSVariables(visualElement2, _a2, transitionEnd) {
  var _b;
  var target = __rest(_a2, []);
  var element = visualElement2.getInstance();
  if (!(element instanceof Element))
    return { target, transitionEnd };
  if (transitionEnd) {
    transitionEnd = __assign({}, transitionEnd);
  }
  visualElement2.forEachValue(function(value) {
    var current2 = value.get();
    if (!isCSSVariable2(current2))
      return;
    var resolved2 = getVariableValue(current2, element);
    if (resolved2)
      value.set(resolved2);
  });
  for (var key in target) {
    var current = target[key];
    if (!isCSSVariable2(current))
      continue;
    var resolved = getVariableValue(current, element);
    if (!resolved)
      continue;
    target[key] = resolved;
    if (transitionEnd)
      (_b = transitionEnd[key]) !== null && _b !== void 0 ? _b : transitionEnd[key] = current;
  }
  return { target, transitionEnd };
}

// node_modules/framer-motion/dist/es/render/dom/utils/unit-conversion.mjs
init_tslib_es6();
var positionalKeys = /* @__PURE__ */ new Set([
  "width",
  "height",
  "top",
  "left",
  "right",
  "bottom",
  "x",
  "y"
]);
var isPositionalKey = function(key) {
  return positionalKeys.has(key);
};
var hasPositionalKey = function(target) {
  return Object.keys(target).some(isPositionalKey);
};
var setAndResetVelocity = function(value, to4) {
  value.set(to4, false);
  value.set(to4);
};
var isNumOrPxType = function(v2) {
  return v2 === number || v2 === px;
};
var BoundingBoxDimension;
(function(BoundingBoxDimension2) {
  BoundingBoxDimension2["width"] = "width";
  BoundingBoxDimension2["height"] = "height";
  BoundingBoxDimension2["left"] = "left";
  BoundingBoxDimension2["right"] = "right";
  BoundingBoxDimension2["top"] = "top";
  BoundingBoxDimension2["bottom"] = "bottom";
})(BoundingBoxDimension || (BoundingBoxDimension = {}));
var getPosFromMatrix = function(matrix, pos) {
  return parseFloat(matrix.split(", ")[pos]);
};
var getTranslateFromMatrix = function(pos2, pos3) {
  return function(_bbox, _a2) {
    var transform2 = _a2.transform;
    if (transform2 === "none" || !transform2)
      return 0;
    var matrix3d = transform2.match(/^matrix3d\((.+)\)$/);
    if (matrix3d) {
      return getPosFromMatrix(matrix3d[1], pos3);
    } else {
      var matrix = transform2.match(/^matrix\((.+)\)$/);
      if (matrix) {
        return getPosFromMatrix(matrix[1], pos2);
      } else {
        return 0;
      }
    }
  };
};
var transformKeys = /* @__PURE__ */ new Set(["x", "y", "z"]);
var nonTranslationalTransformKeys = transformProps.filter(function(key) {
  return !transformKeys.has(key);
});
function removeNonTranslationalTransform(visualElement2) {
  var removedTransforms = [];
  nonTranslationalTransformKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (value !== void 0) {
      removedTransforms.push([key, value.get()]);
      value.set(key.startsWith("scale") ? 1 : 0);
    }
  });
  if (removedTransforms.length)
    visualElement2.syncRender();
  return removedTransforms;
}
var positionalValues = {
  // Dimensions
  width: function(_a2, _b) {
    var x2 = _a2.x;
    var _c2 = _b.paddingLeft, paddingLeft = _c2 === void 0 ? "0" : _c2, _d = _b.paddingRight, paddingRight = _d === void 0 ? "0" : _d;
    return x2.max - x2.min - parseFloat(paddingLeft) - parseFloat(paddingRight);
  },
  height: function(_a2, _b) {
    var y2 = _a2.y;
    var _c2 = _b.paddingTop, paddingTop = _c2 === void 0 ? "0" : _c2, _d = _b.paddingBottom, paddingBottom = _d === void 0 ? "0" : _d;
    return y2.max - y2.min - parseFloat(paddingTop) - parseFloat(paddingBottom);
  },
  top: function(_bbox, _a2) {
    var top = _a2.top;
    return parseFloat(top);
  },
  left: function(_bbox, _a2) {
    var left = _a2.left;
    return parseFloat(left);
  },
  bottom: function(_a2, _b) {
    var y2 = _a2.y;
    var top = _b.top;
    return parseFloat(top) + (y2.max - y2.min);
  },
  right: function(_a2, _b) {
    var x2 = _a2.x;
    var left = _b.left;
    return parseFloat(left) + (x2.max - x2.min);
  },
  // Transform
  x: getTranslateFromMatrix(4, 13),
  y: getTranslateFromMatrix(5, 14)
};
var convertChangedValueTypes = function(target, visualElement2, changedKeys) {
  var originBbox = visualElement2.measureViewportBox();
  var element = visualElement2.getInstance();
  var elementComputedStyle = getComputedStyle(element);
  var display = elementComputedStyle.display;
  var origin2 = {};
  if (display === "none") {
    visualElement2.setStaticValue("display", target.display || "block");
  }
  changedKeys.forEach(function(key) {
    origin2[key] = positionalValues[key](originBbox, elementComputedStyle);
  });
  visualElement2.syncRender();
  var targetBbox = visualElement2.measureViewportBox();
  changedKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    setAndResetVelocity(value, origin2[key]);
    target[key] = positionalValues[key](targetBbox, elementComputedStyle);
  });
  return target;
};
var checkAndConvertChangedValueTypes = function(visualElement2, target, origin2, transitionEnd) {
  if (origin2 === void 0) {
    origin2 = {};
  }
  if (transitionEnd === void 0) {
    transitionEnd = {};
  }
  target = __assign({}, target);
  transitionEnd = __assign({}, transitionEnd);
  var targetPositionalKeys = Object.keys(target).filter(isPositionalKey);
  var removedTransformValues = [];
  var hasAttemptedToRemoveTransformValues = false;
  var changedValueTypeKeys = [];
  targetPositionalKeys.forEach(function(key) {
    var value = visualElement2.getValue(key);
    if (!visualElement2.hasValue(key))
      return;
    var from26 = origin2[key];
    var fromType = findDimensionValueType(from26);
    var to4 = target[key];
    var toType;
    if (isKeyframesTarget(to4)) {
      var numKeyframes = to4.length;
      var fromIndex = to4[0] === null ? 1 : 0;
      from26 = to4[fromIndex];
      fromType = findDimensionValueType(from26);
      for (var i2 = fromIndex; i2 < numKeyframes; i2++) {
        if (!toType) {
          toType = findDimensionValueType(to4[i2]);
          invariant(toType === fromType || isNumOrPxType(fromType) && isNumOrPxType(toType), "Keyframes must be of the same dimension as the current value");
        } else {
          invariant(findDimensionValueType(to4[i2]) === toType, "All keyframes must be of the same type");
        }
      }
    } else {
      toType = findDimensionValueType(to4);
    }
    if (fromType !== toType) {
      if (isNumOrPxType(fromType) && isNumOrPxType(toType)) {
        var current = value.get();
        if (typeof current === "string") {
          value.set(parseFloat(current));
        }
        if (typeof to4 === "string") {
          target[key] = parseFloat(to4);
        } else if (Array.isArray(to4) && toType === px) {
          target[key] = to4.map(parseFloat);
        }
      } else if ((fromType === null || fromType === void 0 ? void 0 : fromType.transform) && (toType === null || toType === void 0 ? void 0 : toType.transform) && (from26 === 0 || to4 === 0)) {
        if (from26 === 0) {
          value.set(toType.transform(from26));
        } else {
          target[key] = fromType.transform(to4);
        }
      } else {
        if (!hasAttemptedToRemoveTransformValues) {
          removedTransformValues = removeNonTranslationalTransform(visualElement2);
          hasAttemptedToRemoveTransformValues = true;
        }
        changedValueTypeKeys.push(key);
        transitionEnd[key] = transitionEnd[key] !== void 0 ? transitionEnd[key] : target[key];
        setAndResetVelocity(value, to4);
      }
    }
  });
  if (changedValueTypeKeys.length) {
    var scrollY_1 = changedValueTypeKeys.indexOf("height") >= 0 ? window.pageYOffset : null;
    var convertedTarget = convertChangedValueTypes(target, visualElement2, changedValueTypeKeys);
    if (removedTransformValues.length) {
      removedTransformValues.forEach(function(_a2) {
        var _b = __read(_a2, 2), key = _b[0], value = _b[1];
        visualElement2.getValue(key).set(value);
      });
    }
    visualElement2.syncRender();
    if (scrollY_1 !== null)
      window.scrollTo({ top: scrollY_1 });
    return { target: convertedTarget, transitionEnd };
  } else {
    return { target, transitionEnd };
  }
};
function unitConversion(visualElement2, target, origin2, transitionEnd) {
  return hasPositionalKey(target) ? checkAndConvertChangedValueTypes(visualElement2, target, origin2, transitionEnd) : { target, transitionEnd };
}

// node_modules/framer-motion/dist/es/render/dom/utils/parse-dom-variant.mjs
var parseDomVariant = function(visualElement2, target, origin2, transitionEnd) {
  var resolved = resolveCSSVariables(visualElement2, target, transitionEnd);
  target = resolved.target;
  transitionEnd = resolved.transitionEnd;
  return unitConversion(visualElement2, target, origin2, transitionEnd);
};

// node_modules/framer-motion/dist/es/render/html/visual-element.mjs
function getComputedStyle2(element) {
  return window.getComputedStyle(element);
}
var htmlConfig = {
  treeType: "dom",
  readValueFromInstance: function(domElement, key) {
    if (isTransformProp(key)) {
      var defaultType = getDefaultValueType(key);
      return defaultType ? defaultType.default || 0 : 0;
    } else {
      var computedStyle = getComputedStyle2(domElement);
      return (isCSSVariable(key) ? computedStyle.getPropertyValue(key) : computedStyle[key]) || 0;
    }
  },
  sortNodePosition: function(a3, b4) {
    return a3.compareDocumentPosition(b4) & 2 ? 1 : -1;
  },
  getBaseTarget: function(props, key) {
    var _a2;
    return (_a2 = props.style) === null || _a2 === void 0 ? void 0 : _a2[key];
  },
  measureViewportBox: function(element, _a2) {
    var transformPagePoint = _a2.transformPagePoint;
    return measureViewportBox(element, transformPagePoint);
  },
  /**
   * Reset the transform on the current Element. This is called as part
   * of a batched process across the entire layout tree. To remove this write
   * cycle it'd be interesting to see if it's possible to "undo" all the current
   * layout transforms up the tree in the same way this.getBoundingBoxWithoutTransforms
   * works
   */
  resetTransform: function(element, domElement, props) {
    var transformTemplate = props.transformTemplate;
    domElement.style.transform = transformTemplate ? transformTemplate({}, "") : "none";
    element.scheduleRender();
  },
  restoreTransform: function(instance, mutableState) {
    instance.style.transform = mutableState.style.transform;
  },
  removeValueFromRenderState: function(key, _a2) {
    var vars = _a2.vars, style2 = _a2.style;
    delete vars[key];
    delete style2[key];
  },
  /**
   * Ensure that HTML and Framer-specific value types like `px`->`%` and `Color`
   * can be animated by Motion.
   */
  makeTargetAnimatable: function(element, _a2, _b, isMounted) {
    var transformValues = _b.transformValues;
    if (isMounted === void 0) {
      isMounted = true;
    }
    var transition2 = _a2.transition, transitionEnd = _a2.transitionEnd, target = __rest(_a2, ["transition", "transitionEnd"]);
    var origin2 = getOrigin(target, transition2 || {}, element);
    if (transformValues) {
      if (transitionEnd)
        transitionEnd = transformValues(transitionEnd);
      if (target)
        target = transformValues(target);
      if (origin2)
        origin2 = transformValues(origin2);
    }
    if (isMounted) {
      checkTargetForNewValues(element, target, origin2);
      var parsed = parseDomVariant(element, target, origin2, transitionEnd);
      transitionEnd = parsed.transitionEnd;
      target = parsed.target;
    }
    return __assign({ transition: transition2, transitionEnd }, target);
  },
  scrapeMotionValuesFromProps,
  build: function(element, renderState, latestValues, options, props) {
    if (element.isVisible !== void 0) {
      renderState.style.visibility = element.isVisible ? "visible" : "hidden";
    }
    buildHTMLStyles(renderState, latestValues, options, props.transformTemplate);
  },
  render: renderHTML
};
var htmlVisualElement = visualElement(htmlConfig);

// node_modules/framer-motion/dist/es/render/svg/visual-element.mjs
init_tslib_es6();
var svgVisualElement = visualElement(__assign(__assign({}, htmlConfig), { getBaseTarget: function(props, key) {
  return props[key];
}, readValueFromInstance: function(domElement, key) {
  var _a2;
  if (isTransformProp(key)) {
    return ((_a2 = getDefaultValueType(key)) === null || _a2 === void 0 ? void 0 : _a2.default) || 0;
  }
  key = !camelCaseAttributes.has(key) ? camelToDash(key) : key;
  return domElement.getAttribute(key);
}, scrapeMotionValuesFromProps: scrapeMotionValuesFromProps2, build: function(_element, renderState, latestValues, options, props) {
  buildSVGAttrs(renderState, latestValues, options, props.transformTemplate);
}, render: renderSVG }));

// node_modules/framer-motion/dist/es/render/dom/create-visual-element.mjs
var createDomVisualElement = function(Component, options) {
  return isSVGComponent(Component) ? svgVisualElement(options, { enableHardwareAcceleration: false }) : htmlVisualElement(options, { enableHardwareAcceleration: true });
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
init_tslib_es6();
var import_react46 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/styles/scale-border-radius.mjs
function pixelsToPercent(pixels, axis) {
  if (axis.max === axis.min)
    return 0;
  return pixels / (axis.max - axis.min) * 100;
}
var correctBorderRadius = {
  correct: function(latest, node) {
    if (!node.target)
      return latest;
    if (typeof latest === "string") {
      if (px.test(latest)) {
        latest = parseFloat(latest);
      } else {
        return latest;
      }
    }
    var x2 = pixelsToPercent(latest, node.target.x);
    var y2 = pixelsToPercent(latest, node.target.y);
    return "".concat(x2, "% ").concat(y2, "%");
  }
};

// node_modules/framer-motion/dist/es/projection/styles/scale-box-shadow.mjs
var varToken = "_$css";
var correctBoxShadow = {
  correct: function(latest, _a2) {
    var treeScale = _a2.treeScale, projectionDelta = _a2.projectionDelta;
    var original = latest;
    var containsCSSVariables = latest.includes("var(");
    var cssVariables = [];
    if (containsCSSVariables) {
      latest = latest.replace(cssVariableRegex, function(match) {
        cssVariables.push(match);
        return varToken;
      });
    }
    var shadow = complex.parse(latest);
    if (shadow.length > 5)
      return original;
    var template = complex.createTransformer(latest);
    var offset = typeof shadow[0] !== "number" ? 1 : 0;
    var xScale = projectionDelta.x.scale * treeScale.x;
    var yScale = projectionDelta.y.scale * treeScale.y;
    shadow[0 + offset] /= xScale;
    shadow[1 + offset] /= yScale;
    var averageScale = mix(xScale, yScale, 0.5);
    if (typeof shadow[2 + offset] === "number")
      shadow[2 + offset] /= averageScale;
    if (typeof shadow[3 + offset] === "number")
      shadow[3 + offset] /= averageScale;
    var output = template(shadow);
    if (containsCSSVariables) {
      var i_1 = 0;
      output = output.replace(varToken, function() {
        var cssVariable = cssVariables[i_1];
        i_1++;
        return cssVariable;
      });
    }
    return output;
  }
};

// node_modules/framer-motion/dist/es/motion/features/layout/MeasureLayout.mjs
var MeasureLayoutWithContext = (
  /** @class */
  function(_super) {
    __extends(MeasureLayoutWithContext2, _super);
    function MeasureLayoutWithContext2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MeasureLayoutWithContext2.prototype.componentDidMount = function() {
      var _this = this;
      var _a2 = this.props, visualElement2 = _a2.visualElement, layoutGroup = _a2.layoutGroup, switchLayoutGroup = _a2.switchLayoutGroup, layoutId = _a2.layoutId;
      var projection = visualElement2.projection;
      addScaleCorrector(defaultScaleCorrectors);
      if (projection) {
        if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
          layoutGroup.group.add(projection);
        if ((switchLayoutGroup === null || switchLayoutGroup === void 0 ? void 0 : switchLayoutGroup.register) && layoutId) {
          switchLayoutGroup.register(projection);
        }
        projection.root.didUpdate();
        projection.addEventListener("animationComplete", function() {
          _this.safeToRemove();
        });
        projection.setOptions(__assign(__assign({}, projection.options), { onExitComplete: function() {
          return _this.safeToRemove();
        } }));
      }
      globalProjectionState.hasEverUpdated = true;
    };
    MeasureLayoutWithContext2.prototype.getSnapshotBeforeUpdate = function(prevProps) {
      var _this = this;
      var _a2 = this.props, layoutDependency = _a2.layoutDependency, visualElement2 = _a2.visualElement, drag2 = _a2.drag, isPresent2 = _a2.isPresent;
      var projection = visualElement2.projection;
      if (!projection)
        return null;
      projection.isPresent = isPresent2;
      if (drag2 || prevProps.layoutDependency !== layoutDependency || layoutDependency === void 0) {
        projection.willUpdate();
      } else {
        this.safeToRemove();
      }
      if (prevProps.isPresent !== isPresent2) {
        if (isPresent2) {
          projection.promote();
        } else if (!projection.relegate()) {
          es_default.postRender(function() {
            var _a3;
            if (!((_a3 = projection.getStack()) === null || _a3 === void 0 ? void 0 : _a3.members.length)) {
              _this.safeToRemove();
            }
          });
        }
      }
      return null;
    };
    MeasureLayoutWithContext2.prototype.componentDidUpdate = function() {
      var projection = this.props.visualElement.projection;
      if (projection) {
        projection.root.didUpdate();
        if (!projection.currentAnimation && projection.isLead()) {
          this.safeToRemove();
        }
      }
    };
    MeasureLayoutWithContext2.prototype.componentWillUnmount = function() {
      var _a2 = this.props, visualElement2 = _a2.visualElement, layoutGroup = _a2.layoutGroup, promoteContext = _a2.switchLayoutGroup;
      var projection = visualElement2.projection;
      if (projection) {
        projection.scheduleCheckAfterUnmount();
        if (layoutGroup === null || layoutGroup === void 0 ? void 0 : layoutGroup.group)
          layoutGroup.group.remove(projection);
        if (promoteContext === null || promoteContext === void 0 ? void 0 : promoteContext.deregister)
          promoteContext.deregister(projection);
      }
    };
    MeasureLayoutWithContext2.prototype.safeToRemove = function() {
      var safeToRemove = this.props.safeToRemove;
      safeToRemove === null || safeToRemove === void 0 ? void 0 : safeToRemove();
    };
    MeasureLayoutWithContext2.prototype.render = function() {
      return null;
    };
    return MeasureLayoutWithContext2;
  }(import_react46.default.Component)
);
function MeasureLayout(props) {
  var _a2 = __read(usePresence(), 2), isPresent2 = _a2[0], safeToRemove = _a2[1];
  var layoutGroup = (0, import_react46.useContext)(LayoutGroupContext);
  return import_react46.default.createElement(MeasureLayoutWithContext, __assign({}, props, { layoutGroup, switchLayoutGroup: (0, import_react46.useContext)(SwitchLayoutGroupContext), isPresent: isPresent2, safeToRemove }));
}
var defaultScaleCorrectors = {
  borderRadius: __assign(__assign({}, correctBorderRadius), { applyTo: [
    "borderTopLeftRadius",
    "borderTopRightRadius",
    "borderBottomLeftRadius",
    "borderBottomRightRadius"
  ] }),
  borderTopLeftRadius: correctBorderRadius,
  borderTopRightRadius: correctBorderRadius,
  borderBottomLeftRadius: correctBorderRadius,
  borderBottomRightRadius: correctBorderRadius,
  boxShadow: correctBoxShadow
};

// node_modules/framer-motion/dist/es/motion/features/layout/index.mjs
var layoutFeatures = {
  measureLayout: MeasureLayout
};

// node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/animation/animate.mjs
function animate2(from26, to4, transition2) {
  if (transition2 === void 0) {
    transition2 = {};
  }
  var value = isMotionValue(from26) ? from26 : motionValue(from26);
  startAnimation("", value, to4, transition2);
  return {
    stop: function() {
      return value.stop();
    },
    isAnimating: function() {
      return value.isAnimating();
    }
  };
}

// node_modules/framer-motion/dist/es/projection/animation/mix-values.mjs
var borders = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"];
var numBorders = borders.length;
var asNumber = function(value) {
  return typeof value === "string" ? parseFloat(value) : value;
};
var isPx = function(value) {
  return typeof value === "number" || px.test(value);
};
function mixValues(target, follow, lead, progress3, shouldCrossfadeOpacity, isOnlyMember) {
  var _a2, _b, _c2, _d;
  if (shouldCrossfadeOpacity) {
    target.opacity = mix(
      0,
      // (follow?.opacity as number) ?? 0,
      // TODO Reinstate this if only child
      (_a2 = lead.opacity) !== null && _a2 !== void 0 ? _a2 : 1,
      easeCrossfadeIn(progress3)
    );
    target.opacityExit = mix((_b = follow.opacity) !== null && _b !== void 0 ? _b : 1, 0, easeCrossfadeOut(progress3));
  } else if (isOnlyMember) {
    target.opacity = mix((_c2 = follow.opacity) !== null && _c2 !== void 0 ? _c2 : 1, (_d = lead.opacity) !== null && _d !== void 0 ? _d : 1, progress3);
  }
  for (var i2 = 0; i2 < numBorders; i2++) {
    var borderLabel = "border".concat(borders[i2], "Radius");
    var followRadius = getRadius(follow, borderLabel);
    var leadRadius = getRadius(lead, borderLabel);
    if (followRadius === void 0 && leadRadius === void 0)
      continue;
    followRadius || (followRadius = 0);
    leadRadius || (leadRadius = 0);
    var canMix = followRadius === 0 || leadRadius === 0 || isPx(followRadius) === isPx(leadRadius);
    if (canMix) {
      target[borderLabel] = Math.max(mix(asNumber(followRadius), asNumber(leadRadius), progress3), 0);
      if (percent.test(leadRadius) || percent.test(followRadius)) {
        target[borderLabel] += "%";
      }
    } else {
      target[borderLabel] = leadRadius;
    }
  }
  if (follow.rotate || lead.rotate) {
    target.rotate = mix(follow.rotate || 0, lead.rotate || 0, progress3);
  }
}
function getRadius(values, radiusName) {
  var _a2;
  return (_a2 = values[radiusName]) !== null && _a2 !== void 0 ? _a2 : values.borderRadius;
}
var easeCrossfadeIn = compress(0, 0.5, circOut);
var easeCrossfadeOut = compress(0.5, 0.95, linear);
function compress(min, max, easing) {
  return function(p2) {
    if (p2 < min)
      return 0;
    if (p2 > max)
      return 1;
    return easing(progress(min, max, p2));
  };
}

// node_modules/framer-motion/dist/es/projection/geometry/copy.mjs
function copyAxisInto(axis, originAxis) {
  axis.min = originAxis.min;
  axis.max = originAxis.max;
}
function copyBoxInto(box, originBox) {
  copyAxisInto(box.x, originBox.x);
  copyAxisInto(box.y, originBox.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/delta-remove.mjs
init_tslib_es6();
function removePointDelta(point, translate, scale2, originPoint, boxScale) {
  point -= translate;
  point = scalePoint(point, 1 / scale2, originPoint);
  if (boxScale !== void 0) {
    point = scalePoint(point, 1 / boxScale, originPoint);
  }
  return point;
}
function removeAxisDelta(axis, translate, scale2, origin2, boxScale, originAxis, sourceAxis) {
  if (translate === void 0) {
    translate = 0;
  }
  if (scale2 === void 0) {
    scale2 = 1;
  }
  if (origin2 === void 0) {
    origin2 = 0.5;
  }
  if (originAxis === void 0) {
    originAxis = axis;
  }
  if (sourceAxis === void 0) {
    sourceAxis = axis;
  }
  if (percent.test(translate)) {
    translate = parseFloat(translate);
    var relativeProgress = mix(sourceAxis.min, sourceAxis.max, translate / 100);
    translate = relativeProgress - sourceAxis.min;
  }
  if (typeof translate !== "number")
    return;
  var originPoint = mix(originAxis.min, originAxis.max, origin2);
  if (axis === originAxis)
    originPoint -= translate;
  axis.min = removePointDelta(axis.min, translate, scale2, originPoint, boxScale);
  axis.max = removePointDelta(axis.max, translate, scale2, originPoint, boxScale);
}
function removeAxisTransforms(axis, transforms2, _a2, origin2, sourceAxis) {
  var _b = __read(_a2, 3), key = _b[0], scaleKey = _b[1], originKey = _b[2];
  removeAxisDelta(axis, transforms2[key], transforms2[scaleKey], transforms2[originKey], transforms2.scale, origin2, sourceAxis);
}
var xKeys2 = ["x", "scaleX", "originX"];
var yKeys2 = ["y", "scaleY", "originY"];
function removeBoxTransforms(box, transforms2, originBox, sourceBox) {
  removeAxisTransforms(box.x, transforms2, xKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.x, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.x);
  removeAxisTransforms(box.y, transforms2, yKeys2, originBox === null || originBox === void 0 ? void 0 : originBox.y, sourceBox === null || sourceBox === void 0 ? void 0 : sourceBox.y);
}

// node_modules/framer-motion/dist/es/projection/geometry/utils.mjs
function isAxisDeltaZero(delta) {
  return delta.translate === 0 && delta.scale === 1;
}
function isDeltaZero(delta) {
  return isAxisDeltaZero(delta.x) && isAxisDeltaZero(delta.y);
}
function boxEquals(a3, b4) {
  return a3.x.min === b4.x.min && a3.x.max === b4.x.max && a3.y.min === b4.y.min && a3.y.max === b4.y.max;
}

// node_modules/framer-motion/dist/es/projection/shared/stack.mjs
var NodeStack = (
  /** @class */
  function() {
    function NodeStack2() {
      this.members = [];
    }
    NodeStack2.prototype.add = function(node) {
      addUniqueItem(this.members, node);
      node.scheduleRender();
    };
    NodeStack2.prototype.remove = function(node) {
      removeItem(this.members, node);
      if (node === this.prevLead) {
        this.prevLead = void 0;
      }
      if (node === this.lead) {
        var prevLead = this.members[this.members.length - 1];
        if (prevLead) {
          this.promote(prevLead);
        }
      }
    };
    NodeStack2.prototype.relegate = function(node) {
      var indexOfNode = this.members.findIndex(function(member2) {
        return node === member2;
      });
      if (indexOfNode === 0)
        return false;
      var prevLead;
      for (var i2 = indexOfNode; i2 >= 0; i2--) {
        var member = this.members[i2];
        if (member.isPresent !== false) {
          prevLead = member;
          break;
        }
      }
      if (prevLead) {
        this.promote(prevLead);
        return true;
      } else {
        return false;
      }
    };
    NodeStack2.prototype.promote = function(node, preserveFollowOpacity) {
      var _a2;
      var prevLead = this.lead;
      if (node === prevLead)
        return;
      this.prevLead = prevLead;
      this.lead = node;
      node.show();
      if (prevLead) {
        prevLead.instance && prevLead.scheduleRender();
        node.scheduleRender();
        node.resumeFrom = prevLead;
        if (preserveFollowOpacity) {
          node.resumeFrom.preserveOpacity = true;
        }
        if (prevLead.snapshot) {
          node.snapshot = prevLead.snapshot;
          node.snapshot.latestValues = prevLead.animationValues || prevLead.latestValues;
          node.snapshot.isShared = true;
        }
        if ((_a2 = node.root) === null || _a2 === void 0 ? void 0 : _a2.isUpdating) {
          node.isLayoutDirty = true;
        }
        var crossfade = node.options.crossfade;
        if (crossfade === false) {
          prevLead.hide();
        }
      }
    };
    NodeStack2.prototype.exitAnimationComplete = function() {
      this.members.forEach(function(node) {
        var _a2, _b, _c2, _d, _e2;
        (_b = (_a2 = node.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a2);
        (_e2 = (_c2 = node.resumingFrom) === null || _c2 === void 0 ? void 0 : (_d = _c2.options).onExitComplete) === null || _e2 === void 0 ? void 0 : _e2.call(_d);
      });
    };
    NodeStack2.prototype.scheduleRender = function() {
      this.members.forEach(function(node) {
        node.instance && node.scheduleRender(false);
      });
    };
    NodeStack2.prototype.removeLeadSnapshot = function() {
      if (this.lead && this.lead.snapshot) {
        this.lead.snapshot = void 0;
      }
    };
    return NodeStack2;
  }()
);

// node_modules/framer-motion/dist/es/projection/styles/transform.mjs
var identityProjection = "translate3d(0px, 0px, 0) scale(1, 1) scale(1, 1)";
function buildProjectionTransform(delta, treeScale, latestTransform) {
  var xTranslate = delta.x.translate / treeScale.x;
  var yTranslate = delta.y.translate / treeScale.y;
  var transform2 = "translate3d(".concat(xTranslate, "px, ").concat(yTranslate, "px, 0) ");
  transform2 += "scale(".concat(1 / treeScale.x, ", ").concat(1 / treeScale.y, ") ");
  if (latestTransform) {
    var rotate2 = latestTransform.rotate, rotateX = latestTransform.rotateX, rotateY = latestTransform.rotateY;
    if (rotate2)
      transform2 += "rotate(".concat(rotate2, "deg) ");
    if (rotateX)
      transform2 += "rotateX(".concat(rotateX, "deg) ");
    if (rotateY)
      transform2 += "rotateY(".concat(rotateY, "deg) ");
  }
  var elementScaleX = delta.x.scale * treeScale.x;
  var elementScaleY = delta.y.scale * treeScale.y;
  transform2 += "scale(".concat(elementScaleX, ", ").concat(elementScaleY, ")");
  return transform2 === identityProjection ? "none" : transform2;
}

// node_modules/framer-motion/dist/es/render/utils/compare-by-depth.mjs
var compareByDepth = function(a3, b4) {
  return a3.depth - b4.depth;
};

// node_modules/framer-motion/dist/es/render/utils/flat-tree.mjs
var FlatTree = (
  /** @class */
  function() {
    function FlatTree2() {
      this.children = [];
      this.isDirty = false;
    }
    FlatTree2.prototype.add = function(child) {
      addUniqueItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.remove = function(child) {
      removeItem(this.children, child);
      this.isDirty = true;
    };
    FlatTree2.prototype.forEach = function(callback) {
      this.isDirty && this.children.sort(compareByDepth);
      this.isDirty = false;
      this.children.forEach(callback);
    };
    return FlatTree2;
  }()
);

// node_modules/framer-motion/dist/es/projection/node/create-projection-node.mjs
var animationTarget = 1e3;
function createProjectionNode(_a2) {
  var attachResizeListener = _a2.attachResizeListener, defaultParent = _a2.defaultParent, measureScroll = _a2.measureScroll, checkIsScrollRoot = _a2.checkIsScrollRoot, resetTransform = _a2.resetTransform;
  return (
    /** @class */
    function() {
      function ProjectionNode(id3, latestValues, parent) {
        var _this = this;
        if (latestValues === void 0) {
          latestValues = {};
        }
        if (parent === void 0) {
          parent = defaultParent === null || defaultParent === void 0 ? void 0 : defaultParent();
        }
        this.children = /* @__PURE__ */ new Set();
        this.options = {};
        this.isTreeAnimating = false;
        this.isAnimationBlocked = false;
        this.isLayoutDirty = false;
        this.updateManuallyBlocked = false;
        this.updateBlockedByResize = false;
        this.isUpdating = false;
        this.isSVG = false;
        this.needsReset = false;
        this.shouldResetTransform = false;
        this.treeScale = { x: 1, y: 1 };
        this.eventHandlers = /* @__PURE__ */ new Map();
        this.potentialNodes = /* @__PURE__ */ new Map();
        this.checkUpdateFailed = function() {
          if (_this.isUpdating) {
            _this.isUpdating = false;
            _this.clearAllSnapshots();
          }
        };
        this.updateProjection = function() {
          _this.nodes.forEach(resolveTargetDelta);
          _this.nodes.forEach(calcProjection);
        };
        this.hasProjected = false;
        this.isVisible = true;
        this.animationProgress = 0;
        this.sharedNodes = /* @__PURE__ */ new Map();
        this.id = id3;
        this.latestValues = latestValues;
        this.root = parent ? parent.root || parent : this;
        this.path = parent ? __spreadArray(__spreadArray([], __read(parent.path), false), [parent], false) : [];
        this.parent = parent;
        this.depth = parent ? parent.depth + 1 : 0;
        id3 && this.root.registerPotentialNode(id3, this);
        for (var i2 = 0; i2 < this.path.length; i2++) {
          this.path[i2].shouldResetTransform = true;
        }
        if (this.root === this)
          this.nodes = new FlatTree();
      }
      ProjectionNode.prototype.addEventListener = function(name, handler) {
        if (!this.eventHandlers.has(name)) {
          this.eventHandlers.set(name, new SubscriptionManager());
        }
        return this.eventHandlers.get(name).add(handler);
      };
      ProjectionNode.prototype.notifyListeners = function(name) {
        var args = [];
        for (var _i2 = 1; _i2 < arguments.length; _i2++) {
          args[_i2 - 1] = arguments[_i2];
        }
        var subscriptionManager = this.eventHandlers.get(name);
        subscriptionManager === null || subscriptionManager === void 0 ? void 0 : subscriptionManager.notify.apply(subscriptionManager, __spreadArray([], __read(args), false));
      };
      ProjectionNode.prototype.hasListeners = function(name) {
        return this.eventHandlers.has(name);
      };
      ProjectionNode.prototype.registerPotentialNode = function(id3, node) {
        this.potentialNodes.set(id3, node);
      };
      ProjectionNode.prototype.mount = function(instance, isLayoutDirty) {
        var _this = this;
        var _a3;
        if (isLayoutDirty === void 0) {
          isLayoutDirty = false;
        }
        if (this.instance)
          return;
        this.isSVG = instance instanceof SVGElement && instance.tagName !== "svg";
        this.instance = instance;
        var _b = this.options, layoutId = _b.layoutId, layout = _b.layout, visualElement2 = _b.visualElement;
        if (visualElement2 && !visualElement2.getInstance()) {
          visualElement2.mount(instance);
        }
        this.root.nodes.add(this);
        (_a3 = this.parent) === null || _a3 === void 0 ? void 0 : _a3.children.add(this);
        this.id && this.root.potentialNodes.delete(this.id);
        if (isLayoutDirty && (layout || layoutId)) {
          this.isLayoutDirty = true;
        }
        if (attachResizeListener) {
          var unblockTimeout_1;
          var resizeUnblockUpdate_1 = function() {
            return _this.root.updateBlockedByResize = false;
          };
          attachResizeListener(instance, function() {
            _this.root.updateBlockedByResize = true;
            clearTimeout(unblockTimeout_1);
            unblockTimeout_1 = window.setTimeout(resizeUnblockUpdate_1, 250);
            if (globalProjectionState.hasAnimatedSinceResize) {
              globalProjectionState.hasAnimatedSinceResize = false;
              _this.nodes.forEach(finishAnimation);
            }
          });
        }
        if (layoutId) {
          this.root.registerSharedNode(layoutId, this);
        }
        if (this.options.animate !== false && visualElement2 && (layoutId || layout)) {
          this.addEventListener("didUpdate", function(_a4) {
            var _b2, _c2, _d, _e2, _f;
            var delta = _a4.delta, hasLayoutChanged = _a4.hasLayoutChanged, hasRelativeTargetChanged = _a4.hasRelativeTargetChanged, newLayout = _a4.layout;
            if (_this.isTreeAnimationBlocked()) {
              _this.target = void 0;
              _this.relativeTarget = void 0;
              return;
            }
            var layoutTransition = (_c2 = (_b2 = _this.options.transition) !== null && _b2 !== void 0 ? _b2 : visualElement2.getDefaultTransition()) !== null && _c2 !== void 0 ? _c2 : defaultLayoutTransition;
            var _g = visualElement2.getProps(), onLayoutAnimationStart = _g.onLayoutAnimationStart, onLayoutAnimationComplete = _g.onLayoutAnimationComplete;
            var targetChanged = !_this.targetLayout || !boxEquals(_this.targetLayout, newLayout) || hasRelativeTargetChanged;
            var hasOnlyRelativeTargetChanged = !hasLayoutChanged && hasRelativeTargetChanged;
            if (((_d = _this.resumeFrom) === null || _d === void 0 ? void 0 : _d.instance) || hasOnlyRelativeTargetChanged || hasLayoutChanged && (targetChanged || !_this.currentAnimation)) {
              if (_this.resumeFrom) {
                _this.resumingFrom = _this.resumeFrom;
                _this.resumingFrom.resumingFrom = void 0;
              }
              _this.setAnimationOrigin(delta, hasOnlyRelativeTargetChanged);
              var animationOptions = __assign(__assign({}, getValueTransition(layoutTransition, "layout")), { onPlay: onLayoutAnimationStart, onComplete: onLayoutAnimationComplete });
              if (visualElement2.shouldReduceMotion) {
                animationOptions.delay = 0;
                animationOptions.type = false;
              }
              _this.startAnimation(animationOptions);
            } else {
              if (!hasLayoutChanged && _this.animationProgress === 0) {
                _this.finishAnimation();
              }
              _this.isLead() && ((_f = (_e2 = _this.options).onExitComplete) === null || _f === void 0 ? void 0 : _f.call(_e2));
            }
            _this.targetLayout = newLayout;
          });
        }
      };
      ProjectionNode.prototype.unmount = function() {
        var _a3, _b;
        this.options.layoutId && this.willUpdate();
        this.root.nodes.remove(this);
        (_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.remove(this);
        (_b = this.parent) === null || _b === void 0 ? void 0 : _b.children.delete(this);
        this.instance = void 0;
        cancelSync.preRender(this.updateProjection);
      };
      ProjectionNode.prototype.blockUpdate = function() {
        this.updateManuallyBlocked = true;
      };
      ProjectionNode.prototype.unblockUpdate = function() {
        this.updateManuallyBlocked = false;
      };
      ProjectionNode.prototype.isUpdateBlocked = function() {
        return this.updateManuallyBlocked || this.updateBlockedByResize;
      };
      ProjectionNode.prototype.isTreeAnimationBlocked = function() {
        var _a3;
        return this.isAnimationBlocked || ((_a3 = this.parent) === null || _a3 === void 0 ? void 0 : _a3.isTreeAnimationBlocked()) || false;
      };
      ProjectionNode.prototype.startUpdate = function() {
        var _a3;
        if (this.isUpdateBlocked())
          return;
        this.isUpdating = true;
        (_a3 = this.nodes) === null || _a3 === void 0 ? void 0 : _a3.forEach(resetRotation);
      };
      ProjectionNode.prototype.willUpdate = function(shouldNotifyListeners) {
        var _a3, _b, _c2;
        if (shouldNotifyListeners === void 0) {
          shouldNotifyListeners = true;
        }
        if (this.root.isUpdateBlocked()) {
          (_b = (_a3 = this.options).onExitComplete) === null || _b === void 0 ? void 0 : _b.call(_a3);
          return;
        }
        !this.root.isUpdating && this.root.startUpdate();
        if (this.isLayoutDirty)
          return;
        this.isLayoutDirty = true;
        for (var i2 = 0; i2 < this.path.length; i2++) {
          var node = this.path[i2];
          node.shouldResetTransform = true;
          node.updateScroll();
        }
        var _d = this.options, layoutId = _d.layoutId, layout = _d.layout;
        if (layoutId === void 0 && !layout)
          return;
        var transformTemplate = (_c2 = this.options.visualElement) === null || _c2 === void 0 ? void 0 : _c2.getProps().transformTemplate;
        this.prevTransformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
        this.updateSnapshot();
        shouldNotifyListeners && this.notifyListeners("willUpdate");
      };
      ProjectionNode.prototype.didUpdate = function() {
        var updateWasBlocked = this.isUpdateBlocked();
        if (updateWasBlocked) {
          this.unblockUpdate();
          this.clearAllSnapshots();
          this.nodes.forEach(clearMeasurements);
          return;
        }
        if (!this.isUpdating)
          return;
        this.isUpdating = false;
        if (this.potentialNodes.size) {
          this.potentialNodes.forEach(mountNodeEarly);
          this.potentialNodes.clear();
        }
        this.nodes.forEach(resetTransformStyle);
        this.nodes.forEach(updateLayout);
        this.nodes.forEach(notifyLayoutUpdate);
        this.clearAllSnapshots();
        flushSync.update();
        flushSync.preRender();
        flushSync.render();
      };
      ProjectionNode.prototype.clearAllSnapshots = function() {
        this.nodes.forEach(clearSnapshot);
        this.sharedNodes.forEach(removeLeadSnapshots);
      };
      ProjectionNode.prototype.scheduleUpdateProjection = function() {
        es_default.preRender(this.updateProjection, false, true);
      };
      ProjectionNode.prototype.scheduleCheckAfterUnmount = function() {
        var _this = this;
        es_default.postRender(function() {
          if (_this.isLayoutDirty) {
            _this.root.didUpdate();
          } else {
            _this.root.checkUpdateFailed();
          }
        });
      };
      ProjectionNode.prototype.updateSnapshot = function() {
        if (this.snapshot || !this.instance)
          return;
        var measured = this.measure();
        var layout = this.removeTransform(this.removeElementScroll(measured));
        roundBox(layout);
        this.snapshot = {
          measured,
          layout,
          latestValues: {}
        };
      };
      ProjectionNode.prototype.updateLayout = function() {
        var _a3;
        if (!this.instance)
          return;
        this.updateScroll();
        if (!(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty) {
          return;
        }
        if (this.resumeFrom && !this.resumeFrom.instance) {
          for (var i2 = 0; i2 < this.path.length; i2++) {
            var node = this.path[i2];
            node.updateScroll();
          }
        }
        var measured = this.measure();
        roundBox(measured);
        var prevLayout = this.layout;
        this.layout = {
          measured,
          actual: this.removeElementScroll(measured)
        };
        this.layoutCorrected = createBox();
        this.isLayoutDirty = false;
        this.projectionDelta = void 0;
        this.notifyListeners("measure", this.layout.actual);
        (_a3 = this.options.visualElement) === null || _a3 === void 0 ? void 0 : _a3.notifyLayoutMeasure(this.layout.actual, prevLayout === null || prevLayout === void 0 ? void 0 : prevLayout.actual);
      };
      ProjectionNode.prototype.updateScroll = function() {
        if (this.options.layoutScroll && this.instance) {
          this.isScrollRoot = checkIsScrollRoot(this.instance);
          this.scroll = measureScroll(this.instance);
        }
      };
      ProjectionNode.prototype.resetTransform = function() {
        var _a3;
        if (!resetTransform)
          return;
        var isResetRequested = this.isLayoutDirty || this.shouldResetTransform;
        var hasProjection = this.projectionDelta && !isDeltaZero(this.projectionDelta);
        var transformTemplate = (_a3 = this.options.visualElement) === null || _a3 === void 0 ? void 0 : _a3.getProps().transformTemplate;
        var transformTemplateValue = transformTemplate === null || transformTemplate === void 0 ? void 0 : transformTemplate(this.latestValues, "");
        var transformTemplateHasChanged = transformTemplateValue !== this.prevTransformTemplateValue;
        if (isResetRequested && (hasProjection || hasTransform(this.latestValues) || transformTemplateHasChanged)) {
          resetTransform(this.instance, transformTemplateValue);
          this.shouldResetTransform = false;
          this.scheduleRender();
        }
      };
      ProjectionNode.prototype.measure = function() {
        var visualElement2 = this.options.visualElement;
        if (!visualElement2)
          return createBox();
        var box = visualElement2.measureViewportBox();
        var scroll3 = this.root.scroll;
        if (scroll3) {
          translateAxis(box.x, scroll3.x);
          translateAxis(box.y, scroll3.y);
        }
        return box;
      };
      ProjectionNode.prototype.removeElementScroll = function(box) {
        var boxWithoutScroll = createBox();
        copyBoxInto(boxWithoutScroll, box);
        for (var i2 = 0; i2 < this.path.length; i2++) {
          var node = this.path[i2];
          var scroll_1 = node.scroll, options = node.options, isScrollRoot = node.isScrollRoot;
          if (node !== this.root && scroll_1 && options.layoutScroll) {
            if (isScrollRoot) {
              copyBoxInto(boxWithoutScroll, box);
              var rootScroll = this.root.scroll;
              if (rootScroll) {
                translateAxis(boxWithoutScroll.x, -rootScroll.x);
                translateAxis(boxWithoutScroll.y, -rootScroll.y);
              }
            }
            translateAxis(boxWithoutScroll.x, scroll_1.x);
            translateAxis(boxWithoutScroll.y, scroll_1.y);
          }
        }
        return boxWithoutScroll;
      };
      ProjectionNode.prototype.applyTransform = function(box, transformOnly) {
        if (transformOnly === void 0) {
          transformOnly = false;
        }
        var withTransforms = createBox();
        copyBoxInto(withTransforms, box);
        for (var i2 = 0; i2 < this.path.length; i2++) {
          var node = this.path[i2];
          if (!transformOnly && node.options.layoutScroll && node.scroll && node !== node.root) {
            transformBox(withTransforms, {
              x: -node.scroll.x,
              y: -node.scroll.y
            });
          }
          if (!hasTransform(node.latestValues))
            continue;
          transformBox(withTransforms, node.latestValues);
        }
        if (hasTransform(this.latestValues)) {
          transformBox(withTransforms, this.latestValues);
        }
        return withTransforms;
      };
      ProjectionNode.prototype.removeTransform = function(box) {
        var _a3;
        var boxWithoutTransform = createBox();
        copyBoxInto(boxWithoutTransform, box);
        for (var i2 = 0; i2 < this.path.length; i2++) {
          var node = this.path[i2];
          if (!node.instance)
            continue;
          if (!hasTransform(node.latestValues))
            continue;
          hasScale(node.latestValues) && node.updateSnapshot();
          var sourceBox = createBox();
          var nodeBox = node.measure();
          copyBoxInto(sourceBox, nodeBox);
          removeBoxTransforms(boxWithoutTransform, node.latestValues, (_a3 = node.snapshot) === null || _a3 === void 0 ? void 0 : _a3.layout, sourceBox);
        }
        if (hasTransform(this.latestValues)) {
          removeBoxTransforms(boxWithoutTransform, this.latestValues);
        }
        return boxWithoutTransform;
      };
      ProjectionNode.prototype.setTargetDelta = function(delta) {
        this.targetDelta = delta;
        this.root.scheduleUpdateProjection();
      };
      ProjectionNode.prototype.setOptions = function(options) {
        var _a3;
        this.options = __assign(__assign(__assign({}, this.options), options), { crossfade: (_a3 = options.crossfade) !== null && _a3 !== void 0 ? _a3 : true });
      };
      ProjectionNode.prototype.clearMeasurements = function() {
        this.scroll = void 0;
        this.layout = void 0;
        this.snapshot = void 0;
        this.prevTransformTemplateValue = void 0;
        this.targetDelta = void 0;
        this.target = void 0;
        this.isLayoutDirty = false;
      };
      ProjectionNode.prototype.resolveTargetDelta = function() {
        var _a3;
        var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;
        if (!this.layout || !(layout || layoutId))
          return;
        if (!this.targetDelta && !this.relativeTarget) {
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && this.relativeParent.layout) {
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.layout.actual, this.relativeParent.layout.actual);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
        if (!this.relativeTarget && !this.targetDelta)
          return;
        if (!this.target) {
          this.target = createBox();
          this.targetWithTransforms = createBox();
        }
        if (this.relativeTarget && this.relativeTargetOrigin && ((_a3 = this.relativeParent) === null || _a3 === void 0 ? void 0 : _a3.target)) {
          calcRelativeBox(this.target, this.relativeTarget, this.relativeParent.target);
        } else if (this.targetDelta) {
          if (Boolean(this.resumingFrom)) {
            this.target = this.applyTransform(this.layout.actual);
          } else {
            copyBoxInto(this.target, this.layout.actual);
          }
          applyBoxDelta(this.target, this.targetDelta);
        } else {
          copyBoxInto(this.target, this.layout.actual);
        }
        if (this.attemptToResolveRelativeTarget) {
          this.attemptToResolveRelativeTarget = false;
          this.relativeParent = this.getClosestProjectingParent();
          if (this.relativeParent && Boolean(this.relativeParent.resumingFrom) === Boolean(this.resumingFrom) && !this.relativeParent.options.layoutScroll && this.relativeParent.target) {
            this.relativeTarget = createBox();
            this.relativeTargetOrigin = createBox();
            calcRelativePosition(this.relativeTargetOrigin, this.target, this.relativeParent.target);
            copyBoxInto(this.relativeTarget, this.relativeTargetOrigin);
          }
        }
      };
      ProjectionNode.prototype.getClosestProjectingParent = function() {
        if (!this.parent || hasTransform(this.parent.latestValues))
          return void 0;
        if ((this.parent.relativeTarget || this.parent.targetDelta) && this.parent.layout) {
          return this.parent;
        } else {
          return this.parent.getClosestProjectingParent();
        }
      };
      ProjectionNode.prototype.calcProjection = function() {
        var _a3;
        var _b = this.options, layout = _b.layout, layoutId = _b.layoutId;
        this.isTreeAnimating = Boolean(((_a3 = this.parent) === null || _a3 === void 0 ? void 0 : _a3.isTreeAnimating) || this.currentAnimation || this.pendingAnimation);
        if (!this.isTreeAnimating) {
          this.targetDelta = this.relativeTarget = void 0;
        }
        if (!this.layout || !(layout || layoutId))
          return;
        var lead = this.getLead();
        copyBoxInto(this.layoutCorrected, this.layout.actual);
        applyTreeDeltas(this.layoutCorrected, this.treeScale, this.path, Boolean(this.resumingFrom) || this !== lead);
        var target = lead.target;
        if (!target)
          return;
        if (!this.projectionDelta) {
          this.projectionDelta = createDelta();
          this.projectionDeltaWithTransform = createDelta();
        }
        var prevTreeScaleX = this.treeScale.x;
        var prevTreeScaleY = this.treeScale.y;
        var prevProjectionTransform = this.projectionTransform;
        calcBoxDelta(this.projectionDelta, this.layoutCorrected, target, this.latestValues);
        this.projectionTransform = buildProjectionTransform(this.projectionDelta, this.treeScale);
        if (this.projectionTransform !== prevProjectionTransform || this.treeScale.x !== prevTreeScaleX || this.treeScale.y !== prevTreeScaleY) {
          this.hasProjected = true;
          this.scheduleRender();
          this.notifyListeners("projectionUpdate", target);
        }
      };
      ProjectionNode.prototype.hide = function() {
        this.isVisible = false;
      };
      ProjectionNode.prototype.show = function() {
        this.isVisible = true;
      };
      ProjectionNode.prototype.scheduleRender = function(notifyAll) {
        var _a3, _b, _c2;
        if (notifyAll === void 0) {
          notifyAll = true;
        }
        (_b = (_a3 = this.options).scheduleRender) === null || _b === void 0 ? void 0 : _b.call(_a3);
        notifyAll && ((_c2 = this.getStack()) === null || _c2 === void 0 ? void 0 : _c2.scheduleRender());
        if (this.resumingFrom && !this.resumingFrom.instance) {
          this.resumingFrom = void 0;
        }
      };
      ProjectionNode.prototype.setAnimationOrigin = function(delta, hasOnlyRelativeTargetChanged) {
        var _this = this;
        var _a3;
        if (hasOnlyRelativeTargetChanged === void 0) {
          hasOnlyRelativeTargetChanged = false;
        }
        var snapshot2 = this.snapshot;
        var snapshotLatestValues = (snapshot2 === null || snapshot2 === void 0 ? void 0 : snapshot2.latestValues) || {};
        var mixedValues = __assign({}, this.latestValues);
        var targetDelta = createDelta();
        this.relativeTarget = this.relativeTargetOrigin = void 0;
        this.attemptToResolveRelativeTarget = !hasOnlyRelativeTargetChanged;
        var relativeLayout = createBox();
        var isSharedLayoutAnimation = snapshot2 === null || snapshot2 === void 0 ? void 0 : snapshot2.isShared;
        var isOnlyMember = (((_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.members.length) || 0) <= 1;
        var shouldCrossfadeOpacity = Boolean(isSharedLayoutAnimation && !isOnlyMember && this.options.crossfade === true && !this.path.some(hasOpacityCrossfade));
        this.animationProgress = 0;
        this.mixTargetDelta = function(latest) {
          var _a4;
          var progress3 = latest / 1e3;
          mixAxisDelta(targetDelta.x, delta.x, progress3);
          mixAxisDelta(targetDelta.y, delta.y, progress3);
          _this.setTargetDelta(targetDelta);
          if (_this.relativeTarget && _this.relativeTargetOrigin && _this.layout && ((_a4 = _this.relativeParent) === null || _a4 === void 0 ? void 0 : _a4.layout)) {
            calcRelativePosition(relativeLayout, _this.layout.actual, _this.relativeParent.layout.actual);
            mixBox(_this.relativeTarget, _this.relativeTargetOrigin, relativeLayout, progress3);
          }
          if (isSharedLayoutAnimation) {
            _this.animationValues = mixedValues;
            mixValues(mixedValues, snapshotLatestValues, _this.latestValues, progress3, shouldCrossfadeOpacity, isOnlyMember);
          }
          _this.root.scheduleUpdateProjection();
          _this.scheduleRender();
          _this.animationProgress = progress3;
        };
        this.mixTargetDelta(0);
      };
      ProjectionNode.prototype.startAnimation = function(options) {
        var _this = this;
        var _a3, _b;
        this.notifyListeners("animationStart");
        (_a3 = this.currentAnimation) === null || _a3 === void 0 ? void 0 : _a3.stop();
        if (this.resumingFrom) {
          (_b = this.resumingFrom.currentAnimation) === null || _b === void 0 ? void 0 : _b.stop();
        }
        if (this.pendingAnimation) {
          cancelSync.update(this.pendingAnimation);
          this.pendingAnimation = void 0;
        }
        this.pendingAnimation = es_default.update(function() {
          globalProjectionState.hasAnimatedSinceResize = true;
          _this.currentAnimation = animate2(0, animationTarget, __assign(__assign({}, options), { onUpdate: function(latest) {
            var _a4;
            _this.mixTargetDelta(latest);
            (_a4 = options.onUpdate) === null || _a4 === void 0 ? void 0 : _a4.call(options, latest);
          }, onComplete: function() {
            var _a4;
            (_a4 = options.onComplete) === null || _a4 === void 0 ? void 0 : _a4.call(options);
            _this.completeAnimation();
          } }));
          if (_this.resumingFrom) {
            _this.resumingFrom.currentAnimation = _this.currentAnimation;
          }
          _this.pendingAnimation = void 0;
        });
      };
      ProjectionNode.prototype.completeAnimation = function() {
        var _a3;
        if (this.resumingFrom) {
          this.resumingFrom.currentAnimation = void 0;
          this.resumingFrom.preserveOpacity = void 0;
        }
        (_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.exitAnimationComplete();
        this.resumingFrom = this.currentAnimation = this.animationValues = void 0;
        this.notifyListeners("animationComplete");
      };
      ProjectionNode.prototype.finishAnimation = function() {
        var _a3;
        if (this.currentAnimation) {
          (_a3 = this.mixTargetDelta) === null || _a3 === void 0 ? void 0 : _a3.call(this, animationTarget);
          this.currentAnimation.stop();
        }
        this.completeAnimation();
      };
      ProjectionNode.prototype.applyTransformsToTarget = function() {
        var _a3 = this.getLead(), targetWithTransforms = _a3.targetWithTransforms, target = _a3.target, layout = _a3.layout, latestValues = _a3.latestValues;
        if (!targetWithTransforms || !target || !layout)
          return;
        copyBoxInto(targetWithTransforms, target);
        transformBox(targetWithTransforms, latestValues);
        calcBoxDelta(this.projectionDeltaWithTransform, this.layoutCorrected, targetWithTransforms, latestValues);
      };
      ProjectionNode.prototype.registerSharedNode = function(layoutId, node) {
        var _a3, _b, _c2;
        if (!this.sharedNodes.has(layoutId)) {
          this.sharedNodes.set(layoutId, new NodeStack());
        }
        var stack = this.sharedNodes.get(layoutId);
        stack.add(node);
        node.promote({
          transition: (_a3 = node.options.initialPromotionConfig) === null || _a3 === void 0 ? void 0 : _a3.transition,
          preserveFollowOpacity: (_c2 = (_b = node.options.initialPromotionConfig) === null || _b === void 0 ? void 0 : _b.shouldPreserveFollowOpacity) === null || _c2 === void 0 ? void 0 : _c2.call(_b, node)
        });
      };
      ProjectionNode.prototype.isLead = function() {
        var stack = this.getStack();
        return stack ? stack.lead === this : true;
      };
      ProjectionNode.prototype.getLead = function() {
        var _a3;
        var layoutId = this.options.layoutId;
        return layoutId ? ((_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.lead) || this : this;
      };
      ProjectionNode.prototype.getPrevLead = function() {
        var _a3;
        var layoutId = this.options.layoutId;
        return layoutId ? (_a3 = this.getStack()) === null || _a3 === void 0 ? void 0 : _a3.prevLead : void 0;
      };
      ProjectionNode.prototype.getStack = function() {
        var layoutId = this.options.layoutId;
        if (layoutId)
          return this.root.sharedNodes.get(layoutId);
      };
      ProjectionNode.prototype.promote = function(_a3) {
        var _b = _a3 === void 0 ? {} : _a3, needsReset = _b.needsReset, transition2 = _b.transition, preserveFollowOpacity = _b.preserveFollowOpacity;
        var stack = this.getStack();
        if (stack)
          stack.promote(this, preserveFollowOpacity);
        if (needsReset) {
          this.projectionDelta = void 0;
          this.needsReset = true;
        }
        if (transition2)
          this.setOptions({ transition: transition2 });
      };
      ProjectionNode.prototype.relegate = function() {
        var stack = this.getStack();
        if (stack) {
          return stack.relegate(this);
        } else {
          return false;
        }
      };
      ProjectionNode.prototype.resetRotation = function() {
        var visualElement2 = this.options.visualElement;
        if (!visualElement2)
          return;
        var hasRotate = false;
        var resetValues = {};
        for (var i2 = 0; i2 < transformAxes.length; i2++) {
          var axis = transformAxes[i2];
          var key = "rotate" + axis;
          if (!visualElement2.getStaticValue(key)) {
            continue;
          }
          hasRotate = true;
          resetValues[key] = visualElement2.getStaticValue(key);
          visualElement2.setStaticValue(key, 0);
        }
        if (!hasRotate)
          return;
        visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.syncRender();
        for (var key in resetValues) {
          visualElement2.setStaticValue(key, resetValues[key]);
        }
        visualElement2.scheduleRender();
      };
      ProjectionNode.prototype.getProjectionStyles = function(styleProp) {
        var _a3, _b, _c2, _d, _e2, _f;
        if (styleProp === void 0) {
          styleProp = {};
        }
        var styles2 = {};
        if (!this.instance || this.isSVG)
          return styles2;
        if (!this.isVisible) {
          return { visibility: "hidden" };
        } else {
          styles2.visibility = "";
        }
        var transformTemplate = (_a3 = this.options.visualElement) === null || _a3 === void 0 ? void 0 : _a3.getProps().transformTemplate;
        if (this.needsReset) {
          this.needsReset = false;
          styles2.opacity = "";
          styles2.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
          styles2.transform = transformTemplate ? transformTemplate(this.latestValues, "") : "none";
          return styles2;
        }
        var lead = this.getLead();
        if (!this.projectionDelta || !this.layout || !lead.target) {
          var emptyStyles = {};
          if (this.options.layoutId) {
            emptyStyles.opacity = (_b = this.latestValues.opacity) !== null && _b !== void 0 ? _b : 1;
            emptyStyles.pointerEvents = resolveMotionValue(styleProp.pointerEvents) || "";
          }
          if (this.hasProjected && !hasTransform(this.latestValues)) {
            emptyStyles.transform = transformTemplate ? transformTemplate({}, "") : "none";
            this.hasProjected = false;
          }
          return emptyStyles;
        }
        var valuesToRender = lead.animationValues || lead.latestValues;
        this.applyTransformsToTarget();
        styles2.transform = buildProjectionTransform(this.projectionDeltaWithTransform, this.treeScale, valuesToRender);
        if (transformTemplate) {
          styles2.transform = transformTemplate(valuesToRender, styles2.transform);
        }
        var _g = this.projectionDelta, x2 = _g.x, y2 = _g.y;
        styles2.transformOrigin = "".concat(x2.origin * 100, "% ").concat(y2.origin * 100, "% 0");
        if (lead.animationValues) {
          styles2.opacity = lead === this ? (_d = (_c2 = valuesToRender.opacity) !== null && _c2 !== void 0 ? _c2 : this.latestValues.opacity) !== null && _d !== void 0 ? _d : 1 : this.preserveOpacity ? this.latestValues.opacity : valuesToRender.opacityExit;
        } else {
          styles2.opacity = lead === this ? (_e2 = valuesToRender.opacity) !== null && _e2 !== void 0 ? _e2 : "" : (_f = valuesToRender.opacityExit) !== null && _f !== void 0 ? _f : 0;
        }
        for (var key in scaleCorrectors) {
          if (valuesToRender[key] === void 0)
            continue;
          var _h = scaleCorrectors[key], correct = _h.correct, applyTo = _h.applyTo;
          var corrected = correct(valuesToRender[key], lead);
          if (applyTo) {
            var num = applyTo.length;
            for (var i2 = 0; i2 < num; i2++) {
              styles2[applyTo[i2]] = corrected;
            }
          } else {
            styles2[key] = corrected;
          }
        }
        if (this.options.layoutId) {
          styles2.pointerEvents = lead === this ? resolveMotionValue(styleProp.pointerEvents) || "" : "none";
        }
        return styles2;
      };
      ProjectionNode.prototype.clearSnapshot = function() {
        this.resumeFrom = this.snapshot = void 0;
      };
      ProjectionNode.prototype.resetTree = function() {
        this.root.nodes.forEach(function(node) {
          var _a3;
          return (_a3 = node.currentAnimation) === null || _a3 === void 0 ? void 0 : _a3.stop();
        });
        this.root.nodes.forEach(clearMeasurements);
        this.root.sharedNodes.clear();
      };
      return ProjectionNode;
    }()
  );
}
function updateLayout(node) {
  node.updateLayout();
}
function notifyLayoutUpdate(node) {
  var _a2, _b, _c2, _d;
  var snapshot2 = (_b = (_a2 = node.resumeFrom) === null || _a2 === void 0 ? void 0 : _a2.snapshot) !== null && _b !== void 0 ? _b : node.snapshot;
  if (node.isLead() && node.layout && snapshot2 && node.hasListeners("didUpdate")) {
    var _e2 = node.layout, layout_1 = _e2.actual, measuredLayout = _e2.measured;
    if (node.options.animationType === "size") {
      eachAxis(function(axis) {
        var axisSnapshot = snapshot2.isShared ? snapshot2.measured[axis] : snapshot2.layout[axis];
        var length2 = calcLength(axisSnapshot);
        axisSnapshot.min = layout_1[axis].min;
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    } else if (node.options.animationType === "position") {
      eachAxis(function(axis) {
        var axisSnapshot = snapshot2.isShared ? snapshot2.measured[axis] : snapshot2.layout[axis];
        var length2 = calcLength(layout_1[axis]);
        axisSnapshot.max = axisSnapshot.min + length2;
      });
    }
    var layoutDelta = createDelta();
    calcBoxDelta(layoutDelta, layout_1, snapshot2.layout);
    var visualDelta = createDelta();
    if (snapshot2.isShared) {
      calcBoxDelta(visualDelta, node.applyTransform(measuredLayout, true), snapshot2.measured);
    } else {
      calcBoxDelta(visualDelta, layout_1, snapshot2.layout);
    }
    var hasLayoutChanged = !isDeltaZero(layoutDelta);
    var hasRelativeTargetChanged = false;
    if (!node.resumeFrom) {
      node.relativeParent = node.getClosestProjectingParent();
      if (node.relativeParent && !node.relativeParent.resumeFrom) {
        var _f = node.relativeParent, parentSnapshot = _f.snapshot, parentLayout = _f.layout;
        if (parentSnapshot && parentLayout) {
          var relativeSnapshot = createBox();
          calcRelativePosition(relativeSnapshot, snapshot2.layout, parentSnapshot.layout);
          var relativeLayout = createBox();
          calcRelativePosition(relativeLayout, layout_1, parentLayout.actual);
          if (!boxEquals(relativeSnapshot, relativeLayout)) {
            hasRelativeTargetChanged = true;
          }
        }
      }
    }
    node.notifyListeners("didUpdate", {
      layout: layout_1,
      snapshot: snapshot2,
      delta: visualDelta,
      layoutDelta,
      hasLayoutChanged,
      hasRelativeTargetChanged
    });
  } else if (node.isLead()) {
    (_d = (_c2 = node.options).onExitComplete) === null || _d === void 0 ? void 0 : _d.call(_c2);
  }
  node.options.transition = void 0;
}
function clearSnapshot(node) {
  node.clearSnapshot();
}
function clearMeasurements(node) {
  node.clearMeasurements();
}
function resetTransformStyle(node) {
  var visualElement2 = node.options.visualElement;
  if (visualElement2 === null || visualElement2 === void 0 ? void 0 : visualElement2.getProps().onBeforeLayoutMeasure) {
    visualElement2.notifyBeforeLayoutMeasure();
  }
  node.resetTransform();
}
function finishAnimation(node) {
  node.finishAnimation();
  node.targetDelta = node.relativeTarget = node.target = void 0;
}
function resolveTargetDelta(node) {
  node.resolveTargetDelta();
}
function calcProjection(node) {
  node.calcProjection();
}
function resetRotation(node) {
  node.resetRotation();
}
function removeLeadSnapshots(stack) {
  stack.removeLeadSnapshot();
}
function mixAxisDelta(output, delta, p2) {
  output.translate = mix(delta.translate, 0, p2);
  output.scale = mix(delta.scale, 1, p2);
  output.origin = delta.origin;
  output.originPoint = delta.originPoint;
}
function mixAxis(output, from26, to4, p2) {
  output.min = mix(from26.min, to4.min, p2);
  output.max = mix(from26.max, to4.max, p2);
}
function mixBox(output, from26, to4, p2) {
  mixAxis(output.x, from26.x, to4.x, p2);
  mixAxis(output.y, from26.y, to4.y, p2);
}
function hasOpacityCrossfade(node) {
  return node.animationValues && node.animationValues.opacityExit !== void 0;
}
var defaultLayoutTransition = {
  duration: 0.45,
  ease: [0.4, 0, 0.1, 1]
};
function mountNodeEarly(node, id3) {
  var searchNode = node.root;
  for (var i2 = node.path.length - 1; i2 >= 0; i2--) {
    if (Boolean(node.path[i2].instance)) {
      searchNode = node.path[i2];
      break;
    }
  }
  var searchElement = searchNode && searchNode !== node.root ? searchNode.instance : document;
  var element = searchElement.querySelector('[data-projection-id="'.concat(id3, '"]'));
  if (element)
    node.mount(element, true);
}
function roundAxis(axis) {
  axis.min = Math.round(axis.min);
  axis.max = Math.round(axis.max);
}
function roundBox(box) {
  roundAxis(box.x);
  roundAxis(box.y);
}

// node_modules/framer-motion/dist/es/projection/node/DocumentProjectionNode.mjs
var DocumentProjectionNode = createProjectionNode({
  attachResizeListener: function(ref, notify) {
    return addDomEvent(ref, "resize", notify);
  },
  measureScroll: function() {
    return {
      x: document.documentElement.scrollLeft || document.body.scrollLeft,
      y: document.documentElement.scrollTop || document.body.scrollTop
    };
  },
  checkIsScrollRoot: function() {
    return true;
  }
});

// node_modules/framer-motion/dist/es/projection/node/HTMLProjectionNode.mjs
var rootProjectionNode = {
  current: void 0
};
var HTMLProjectionNode = createProjectionNode({
  measureScroll: function(instance) {
    return {
      x: instance.scrollLeft,
      y: instance.scrollTop
    };
  },
  defaultParent: function() {
    if (!rootProjectionNode.current) {
      var documentNode = new DocumentProjectionNode(0, {});
      documentNode.mount(window);
      documentNode.setOptions({ layoutScroll: true });
      rootProjectionNode.current = documentNode;
    }
    return rootProjectionNode.current;
  },
  resetTransform: function(instance, value) {
    instance.style.transform = value !== null && value !== void 0 ? value : "none";
  },
  checkIsScrollRoot: function(instance) {
    return Boolean(window.getComputedStyle(instance).position === "fixed");
  }
});

// node_modules/framer-motion/dist/es/render/dom/motion.mjs
var featureBundle = __assign(__assign(__assign(__assign({}, animations), gestureAnimations), drag), layoutFeatures);
var motion = createMotionProxy(function(Component, config) {
  return createDomMotionConfig(Component, config, featureBundle, createDomVisualElement, HTMLProjectionNode);
});

// node_modules/framer-motion/dist/es/render/dom/motion-minimal.mjs
var m = createMotionProxy(createDomMotionConfig);

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
init_tslib_es6();
var React4 = __toESM(require_react(), 1);
var import_react50 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-force-update.mjs
init_tslib_es6();
var import_react48 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-is-mounted.mjs
var import_react47 = __toESM(require_react(), 1);
function useIsMounted() {
  var isMounted = (0, import_react47.useRef)(false);
  useIsomorphicLayoutEffect(function() {
    isMounted.current = true;
    return function() {
      isMounted.current = false;
    };
  }, []);
  return isMounted;
}

// node_modules/framer-motion/dist/es/utils/use-force-update.mjs
function useForceUpdate() {
  var isMounted = useIsMounted();
  var _a2 = __read((0, import_react48.useState)(0), 2), forcedRenderCount = _a2[0], setForcedRenderCount = _a2[1];
  var forceRender = (0, import_react48.useCallback)(function() {
    isMounted.current && setForcedRenderCount(forcedRenderCount + 1);
  }, [forcedRenderCount]);
  var deferredForceRender = (0, import_react48.useCallback)(function() {
    return es_default.postRender(forceRender);
  }, [forceRender]);
  return [deferredForceRender, forcedRenderCount];
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/PresenceChild.mjs
init_tslib_es6();
var React3 = __toESM(require_react(), 1);
var import_react49 = __toESM(require_react(), 1);
var PresenceChild = function(_a2) {
  var children = _a2.children, initial = _a2.initial, isPresent2 = _a2.isPresent, onExitComplete = _a2.onExitComplete, custom2 = _a2.custom, presenceAffectsLayout = _a2.presenceAffectsLayout;
  var presenceChildren = useConstant(newChildrenMap);
  var id3 = useId();
  var context = (0, import_react49.useMemo)(
    function() {
      return {
        id: id3,
        initial,
        isPresent: isPresent2,
        custom: custom2,
        onExitComplete: function(childId) {
          var e_1, _a3;
          presenceChildren.set(childId, true);
          try {
            for (var _b = __values(presenceChildren.values()), _c2 = _b.next(); !_c2.done; _c2 = _b.next()) {
              var isComplete = _c2.value;
              if (!isComplete)
                return;
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (_c2 && !_c2.done && (_a3 = _b.return)) _a3.call(_b);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete();
        },
        register: function(childId) {
          presenceChildren.set(childId, false);
          return function() {
            return presenceChildren.delete(childId);
          };
        }
      };
    },
    /**
     * If the presence of a child affects the layout of the components around it,
     * we want to make a new context value to ensure they get re-rendered
     * so they can detect that layout change.
     */
    presenceAffectsLayout ? void 0 : [isPresent2]
  );
  (0, import_react49.useMemo)(function() {
    presenceChildren.forEach(function(_2, key) {
      return presenceChildren.set(key, false);
    });
  }, [isPresent2]);
  React3.useEffect(function() {
    !isPresent2 && !presenceChildren.size && (onExitComplete === null || onExitComplete === void 0 ? void 0 : onExitComplete());
  }, [isPresent2]);
  return React3.createElement(PresenceContext.Provider, { value: context }, children);
};
function newChildrenMap() {
  return /* @__PURE__ */ new Map();
}

// node_modules/framer-motion/dist/es/components/AnimatePresence/index.mjs
var getChildKey = function(child) {
  return child.key || "";
};
function updateChildLookup(children, allChildren) {
  children.forEach(function(child) {
    var key = getChildKey(child);
    allChildren.set(key, child);
  });
}
function onlyElements(children) {
  var filtered = [];
  import_react50.Children.forEach(children, function(child) {
    if ((0, import_react50.isValidElement)(child))
      filtered.push(child);
  });
  return filtered;
}
var AnimatePresence = function(_a2) {
  var children = _a2.children, custom2 = _a2.custom, _b = _a2.initial, initial = _b === void 0 ? true : _b, onExitComplete = _a2.onExitComplete, exitBeforeEnter = _a2.exitBeforeEnter, _c2 = _a2.presenceAffectsLayout, presenceAffectsLayout = _c2 === void 0 ? true : _c2;
  var _d = __read(useForceUpdate(), 1), forceRender = _d[0];
  var forceRenderLayoutGroup = (0, import_react50.useContext)(LayoutGroupContext).forceRender;
  if (forceRenderLayoutGroup)
    forceRender = forceRenderLayoutGroup;
  var isMounted = useIsMounted();
  var filteredChildren = onlyElements(children);
  var childrenToRender = filteredChildren;
  var exiting = /* @__PURE__ */ new Set();
  var presentChildren = (0, import_react50.useRef)(childrenToRender);
  var allChildren = (0, import_react50.useRef)(/* @__PURE__ */ new Map()).current;
  var isInitialRender = (0, import_react50.useRef)(true);
  useIsomorphicLayoutEffect(function() {
    isInitialRender.current = false;
    updateChildLookup(filteredChildren, allChildren);
    presentChildren.current = childrenToRender;
  });
  useUnmountEffect(function() {
    isInitialRender.current = true;
    allChildren.clear();
    exiting.clear();
  });
  if (isInitialRender.current) {
    return React4.createElement(React4.Fragment, null, childrenToRender.map(function(child) {
      return React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, initial: initial ? void 0 : false, presenceAffectsLayout }, child);
    }));
  }
  childrenToRender = __spreadArray([], __read(childrenToRender), false);
  var presentKeys = presentChildren.current.map(getChildKey);
  var targetKeys = filteredChildren.map(getChildKey);
  var numPresent = presentKeys.length;
  for (var i2 = 0; i2 < numPresent; i2++) {
    var key = presentKeys[i2];
    if (targetKeys.indexOf(key) === -1) {
      exiting.add(key);
    }
  }
  if (exitBeforeEnter && exiting.size) {
    childrenToRender = [];
  }
  exiting.forEach(function(key2) {
    if (targetKeys.indexOf(key2) !== -1)
      return;
    var child = allChildren.get(key2);
    if (!child)
      return;
    var insertionIndex = presentKeys.indexOf(key2);
    var onExit = function() {
      allChildren.delete(key2);
      exiting.delete(key2);
      var removeIndex = presentChildren.current.findIndex(function(presentChild) {
        return presentChild.key === key2;
      });
      presentChildren.current.splice(removeIndex, 1);
      if (!exiting.size) {
        presentChildren.current = filteredChildren;
        if (isMounted.current === false)
          return;
        forceRender();
        onExitComplete && onExitComplete();
      }
    };
    childrenToRender.splice(insertionIndex, 0, React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: false, onExitComplete: onExit, custom: custom2, presenceAffectsLayout }, child));
  });
  childrenToRender = childrenToRender.map(function(child) {
    var key2 = child.key;
    return exiting.has(key2) ? child : React4.createElement(PresenceChild, { key: getChildKey(child), isPresent: true, presenceAffectsLayout }, child);
  });
  if (env !== "production" && exitBeforeEnter && childrenToRender.length > 1) {
    console.warn("You're attempting to animate multiple children within AnimatePresence, but its exitBeforeEnter prop is set to true. This will lead to odd visual behaviour.");
  }
  return React4.createElement(React4.Fragment, null, exiting.size ? childrenToRender : childrenToRender.map(function(child) {
    return (0, import_react50.cloneElement)(child);
  }));
};

// node_modules/framer-motion/dist/es/components/AnimateSharedLayout.mjs
var React6 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/LayoutGroup/index.mjs
init_tslib_es6();
var React5 = __toESM(require_react(), 1);
var import_react52 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/DeprecatedLayoutGroupContext.mjs
var import_react51 = __toESM(require_react(), 1);
var DeprecatedLayoutGroupContext = (0, import_react51.createContext)(null);

// node_modules/framer-motion/dist/es/components/MotionConfig/index.mjs
init_tslib_es6();
var React7 = __toESM(require_react(), 1);
var import_react53 = __toESM(require_react(), 1);
function MotionConfig(_a2) {
  var children = _a2.children, isValidProp = _a2.isValidProp, config = __rest(_a2, ["children", "isValidProp"]);
  isValidProp && loadExternalIsValidProp(isValidProp);
  config = __assign(__assign({}, (0, import_react53.useContext)(MotionConfigContext)), config);
  config.isStatic = useConstant(function() {
    return config.isStatic;
  });
  var context = (0, import_react53.useMemo)(function() {
    return config;
  }, [JSON.stringify(config.transition), config.transformPagePoint, config.reducedMotion]);
  return React7.createElement(MotionConfigContext.Provider, { value: context }, children);
}

// node_modules/framer-motion/dist/es/components/LazyMotion/index.mjs
init_tslib_es6();
var React8 = __toESM(require_react(), 1);
var import_react54 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/components/Reorder/Group.mjs
init_tslib_es6();
var React9 = __toESM(require_react(), 1);
var import_react56 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/context/ReorderContext.mjs
var import_react55 = __toESM(require_react(), 1);
var ReorderContext = (0, import_react55.createContext)(null);

// node_modules/framer-motion/dist/es/components/Reorder/utils/check-reorder.mjs
function checkReorder(order3, value, offset, velocity) {
  if (!velocity)
    return order3;
  var index5 = order3.findIndex(function(item2) {
    return item2.value === value;
  });
  if (index5 === -1)
    return order3;
  var nextOffset = velocity > 0 ? 1 : -1;
  var nextItem = order3[index5 + nextOffset];
  if (!nextItem)
    return order3;
  var item = order3[index5];
  var nextLayout = nextItem.layout;
  var nextItemCenter = mix(nextLayout.min, nextLayout.max, 0.5);
  if (nextOffset === 1 && item.layout.max + offset > nextItemCenter || nextOffset === -1 && item.layout.min + offset < nextItemCenter) {
    return moveItem(order3, index5, index5 + nextOffset);
  }
  return order3;
}

// node_modules/framer-motion/dist/es/components/Reorder/Group.mjs
function ReorderGroup(_a2, externalRef) {
  var children = _a2.children, _b = _a2.as, as2 = _b === void 0 ? "ul" : _b, _c2 = _a2.axis, axis = _c2 === void 0 ? "y" : _c2, onReorder = _a2.onReorder, values = _a2.values, props = __rest(_a2, ["children", "as", "axis", "onReorder", "values"]);
  var Component = useConstant(function() {
    return motion(as2);
  });
  var order3 = [];
  var isReordering = (0, import_react56.useRef)(false);
  invariant(Boolean(values), "Reorder.Group must be provided a values prop");
  var context = {
    axis,
    registerItem: function(value, layout) {
      if (layout && order3.findIndex(function(entry) {
        return value === entry.value;
      }) === -1) {
        order3.push({ value, layout: layout[axis] });
        order3.sort(compareMin);
      }
    },
    updateOrder: function(id3, offset, velocity) {
      if (isReordering.current)
        return;
      var newOrder = checkReorder(order3, id3, offset, velocity);
      if (order3 !== newOrder) {
        isReordering.current = true;
        onReorder(newOrder.map(getValue).filter(function(value) {
          return values.indexOf(value) !== -1;
        }));
      }
    }
  };
  (0, import_react56.useEffect)(function() {
    isReordering.current = false;
  });
  return React9.createElement(
    Component,
    __assign({}, props, { ref: externalRef }),
    React9.createElement(ReorderContext.Provider, { value: context }, children)
  );
}
var Group = (0, import_react56.forwardRef)(ReorderGroup);
function getValue(item) {
  return item.value;
}
function compareMin(a3, b4) {
  return a3.layout.min - b4.layout.min;
}

// node_modules/framer-motion/dist/es/components/Reorder/Item.mjs
init_tslib_es6();
var React10 = __toESM(require_react(), 1);
var import_react58 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/value/use-motion-value.mjs
init_tslib_es6();
var import_react57 = __toESM(require_react(), 1);
function useMotionValue(initial) {
  var value = useConstant(function() {
    return motionValue(initial);
  });
  var isStatic = (0, import_react57.useContext)(MotionConfigContext).isStatic;
  if (isStatic) {
    var _a2 = __read((0, import_react57.useState)(initial), 2), setLatest_1 = _a2[1];
    (0, import_react57.useEffect)(function() {
      return value.onChange(setLatest_1);
    }, []);
  }
  return value;
}

// node_modules/framer-motion/dist/es/value/use-transform.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/utils/transform.mjs
init_tslib_es6();
var isCustomValueType = function(v2) {
  return typeof v2 === "object" && v2.mix;
};
var getMixer2 = function(v2) {
  return isCustomValueType(v2) ? v2.mix : void 0;
};
function transform() {
  var args = [];
  for (var _i2 = 0; _i2 < arguments.length; _i2++) {
    args[_i2] = arguments[_i2];
  }
  var useImmediate = !Array.isArray(args[0]);
  var argOffset = useImmediate ? 0 : -1;
  var inputValue = args[0 + argOffset];
  var inputRange = args[1 + argOffset];
  var outputRange = args[2 + argOffset];
  var options = args[3 + argOffset];
  var interpolator = interpolate(inputRange, outputRange, __assign({ mixer: getMixer2(outputRange[0]) }, options));
  return useImmediate ? interpolator(inputValue) : interpolator;
}

// node_modules/framer-motion/dist/es/value/use-on-change.mjs
function useMultiOnChange(values, handler) {
  useIsomorphicLayoutEffect(function() {
    var subscriptions = values.map(function(value) {
      return value.onChange(handler);
    });
    return function() {
      return subscriptions.forEach(function(unsubscribe) {
        return unsubscribe();
      });
    };
  });
}

// node_modules/framer-motion/dist/es/value/use-combine-values.mjs
function useCombineMotionValues(values, combineValues) {
  var value = useMotionValue(combineValues());
  var updateValue = function() {
    return value.set(combineValues());
  };
  updateValue();
  useMultiOnChange(values, function() {
    return es_default.update(updateValue, false, true);
  });
  return value;
}

// node_modules/framer-motion/dist/es/value/use-transform.mjs
function useTransform(input, inputRangeOrTransformer, outputRange, options) {
  var transformer = typeof inputRangeOrTransformer === "function" ? inputRangeOrTransformer : transform(inputRangeOrTransformer, outputRange, options);
  return Array.isArray(input) ? useListTransform(input, transformer) : useListTransform([input], function(_a2) {
    var _b = __read(_a2, 1), latest = _b[0];
    return transformer(latest);
  });
}
function useListTransform(values, transformer) {
  var latest = useConstant(function() {
    return [];
  });
  return useCombineMotionValues(values, function() {
    latest.length = 0;
    var numValues = values.length;
    for (var i2 = 0; i2 < numValues; i2++) {
      latest[i2] = values[i2].get();
    }
    return transformer(latest);
  });
}

// node_modules/framer-motion/dist/es/components/Reorder/Item.mjs
function useDefaultMotionValue(value, defaultValue) {
  if (defaultValue === void 0) {
    defaultValue = 0;
  }
  return isMotionValue(value) ? value : useMotionValue(defaultValue);
}
function ReorderItem(_a2, externalRef) {
  var children = _a2.children, style2 = _a2.style, value = _a2.value, _b = _a2.as, as2 = _b === void 0 ? "li" : _b, onDrag = _a2.onDrag, _c2 = _a2.layout, layout = _c2 === void 0 ? true : _c2, props = __rest(_a2, ["children", "style", "value", "as", "onDrag", "layout"]);
  var Component = useConstant(function() {
    return motion(as2);
  });
  var context = (0, import_react58.useContext)(ReorderContext);
  var point = {
    x: useDefaultMotionValue(style2 === null || style2 === void 0 ? void 0 : style2.x),
    y: useDefaultMotionValue(style2 === null || style2 === void 0 ? void 0 : style2.y)
  };
  var zIndex = useTransform([point.x, point.y], function(_a3) {
    var _b2 = __read(_a3, 2), latestX = _b2[0], latestY = _b2[1];
    return latestX || latestY ? 1 : "unset";
  });
  var measuredLayout = (0, import_react58.useRef)(null);
  invariant(Boolean(context), "Reorder.Item must be a child of Reorder.Group");
  var _d = context, axis = _d.axis, registerItem = _d.registerItem, updateOrder = _d.updateOrder;
  (0, import_react58.useEffect)(function() {
    registerItem(value, measuredLayout.current);
  }, [context]);
  return React10.createElement(Component, __assign({ drag: axis }, props, { dragSnapToOrigin: true, style: __assign(__assign({}, style2), { x: point.x, y: point.y, zIndex }), layout, onDrag: function(event, gesturePoint) {
    var velocity = gesturePoint.velocity;
    velocity[axis] && updateOrder(value, point[axis].get(), velocity[axis]);
    onDrag === null || onDrag === void 0 ? void 0 : onDrag(event, gesturePoint);
  }, onLayoutMeasure: function(measured) {
    measuredLayout.current = measured;
  }, ref: externalRef }), children);
}
var Item = (0, import_react58.forwardRef)(ReorderItem);

// node_modules/framer-motion/dist/es/render/dom/features-animation.mjs
init_tslib_es6();
var domAnimation = __assign(__assign({ renderer: createDomVisualElement }, animations), gestureAnimations);

// node_modules/framer-motion/dist/es/render/dom/features-max.mjs
init_tslib_es6();
var domMax = __assign(__assign(__assign(__assign({}, domAnimation), drag), layoutFeatures), { projectionNodeConstructor: HTMLProjectionNode });

// node_modules/framer-motion/dist/es/value/use-spring.mjs
init_tslib_es6();
var import_react59 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/value/use-velocity.mjs
var import_react60 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/value/use-scroll.mjs
init_tslib_es6();

// node_modules/@motionone/dom/dist/animate/utils/transforms.es.js
var axes = ["", "X", "Y", "Z"];
var order2 = ["translate", "scale", "rotate", "skew"];
var rotation = {
  syntax: "<angle>",
  initialValue: "0deg",
  toDefaultUnit: (v2) => v2 + "deg"
};
var baseTransformProperties = {
  translate: {
    syntax: "<length-percentage>",
    initialValue: "0px",
    toDefaultUnit: (v2) => v2 + "px"
  },
  rotate: rotation,
  scale: {
    syntax: "<number>",
    initialValue: 1,
    toDefaultUnit: noopReturn
  },
  skew: rotation
};
var transformDefinitions = /* @__PURE__ */ new Map();
var asTransformCssVar = (name) => `--motion-${name}`;
var transforms = ["x", "y", "z"];
order2.forEach((name) => {
  axes.forEach((axis) => {
    transforms.push(name + axis);
    transformDefinitions.set(asTransformCssVar(name + axis), baseTransformProperties[name]);
  });
});
var transformLookup = new Set(transforms);

// node_modules/@motionone/dom/dist/animate/utils/feature-detection.es.js
var testAnimation = (keyframes3) => document.createElement("div").animate(keyframes3, { duration: 1e-3 });
var featureTests = {
  cssRegisterProperty: () => typeof CSS !== "undefined" && Object.hasOwnProperty.call(CSS, "registerProperty"),
  waapi: () => Object.hasOwnProperty.call(Element.prototype, "animate"),
  partialKeyframes: () => {
    try {
      testAnimation({ opacity: [1] });
    } catch (e2) {
      return false;
    }
    return true;
  },
  finished: () => Boolean(testAnimation({ opacity: [0, 1] }).finished)
};
var results = {};
var supports = {};
for (const key in featureTests) {
  supports[key] = () => {
    if (results[key] === void 0)
      results[key] = featureTests[key]();
    return results[key];
  };
}

// node_modules/@motionone/dom/dist/utils/resolve-elements.es.js
function resolveElements(elements, selectorCache) {
  var _a2;
  if (typeof elements === "string") {
    if (selectorCache) {
      (_a2 = selectorCache[elements]) !== null && _a2 !== void 0 ? _a2 : selectorCache[elements] = document.querySelectorAll(elements);
      elements = selectorCache[elements];
    } else {
      elements = document.querySelectorAll(elements);
    }
  } else if (elements instanceof Element) {
    elements = [elements];
  }
  return Array.from(elements || []);
}

// node_modules/@motionone/dom/dist/timeline/index.es.js
init_tslib_es6();

// node_modules/@motionone/dom/dist/easing/create-generator-easing.es.js
function createGeneratorEasing(createGenerator) {
  const keyframesCache = /* @__PURE__ */ new WeakMap();
  return (options = {}) => {
    const generatorCache = /* @__PURE__ */ new Map();
    const getGenerator = (from26 = 0, to4 = 100, velocity = 0, isScale = false) => {
      const key = `${from26}-${to4}-${velocity}-${isScale}`;
      if (!generatorCache.has(key)) {
        generatorCache.set(key, createGenerator(Object.assign({
          from: from26,
          to: to4,
          velocity,
          restSpeed: isScale ? 0.05 : 2,
          restDistance: isScale ? 0.01 : 0.5
        }, options)));
      }
      return generatorCache.get(key);
    };
    const getKeyframes = (generator) => {
      if (!keyframesCache.has(generator)) {
        keyframesCache.set(generator, pregenerateKeyframes(generator));
      }
      return keyframesCache.get(generator);
    };
    return {
      createAnimation: (keyframes3, getOrigin2, canUseGenerator, name, motionValue2) => {
        var _a2, _b;
        let settings;
        const numKeyframes = keyframes3.length;
        let shouldUseGenerator = canUseGenerator && numKeyframes <= 2 && keyframes3.every(isNumberOrNull);
        if (shouldUseGenerator) {
          const target = keyframes3[numKeyframes - 1];
          const unresolvedOrigin = numKeyframes === 1 ? null : keyframes3[0];
          let velocity = 0;
          let origin2 = 0;
          const prevGenerator = motionValue2 === null || motionValue2 === void 0 ? void 0 : motionValue2.generator;
          if (prevGenerator) {
            const { animation, generatorStartTime } = motionValue2;
            const startTime = (animation === null || animation === void 0 ? void 0 : animation.startTime) || generatorStartTime || 0;
            const currentTime = (animation === null || animation === void 0 ? void 0 : animation.currentTime) || performance.now() - startTime;
            const prevGeneratorCurrent = prevGenerator(currentTime).current;
            origin2 = (_a2 = unresolvedOrigin) !== null && _a2 !== void 0 ? _a2 : prevGeneratorCurrent;
            if (numKeyframes === 1 || numKeyframes === 2 && keyframes3[0] === null) {
              velocity = calcGeneratorVelocity((t2) => prevGenerator(t2).current, currentTime, prevGeneratorCurrent);
            }
          } else {
            origin2 = (_b = unresolvedOrigin) !== null && _b !== void 0 ? _b : parseFloat(getOrigin2());
          }
          const generator = getGenerator(origin2, target, velocity, name === null || name === void 0 ? void 0 : name.includes("scale"));
          const keyframesMetadata = getKeyframes(generator);
          settings = Object.assign(Object.assign({}, keyframesMetadata), { easing: "linear" });
          if (motionValue2) {
            motionValue2.generator = generator;
            motionValue2.generatorStartTime = performance.now();
          }
        } else {
          const keyframesMetadata = getKeyframes(getGenerator(0, 100));
          settings = {
            easing: "ease",
            duration: keyframesMetadata.overshootDuration
          };
        }
        return settings;
      }
    };
  };
}
var isNumberOrNull = (value) => typeof value !== "string";

// node_modules/@motionone/dom/dist/easing/spring/index.es.js
var spring3 = createGeneratorEasing(spring);

// node_modules/@motionone/dom/dist/easing/glide/index.es.js
var glide2 = createGeneratorEasing(glide);

// node_modules/@motionone/dom/dist/gestures/in-view.es.js
var thresholds = {
  any: 0,
  all: 1
};
function inView(elementOrSelector, onStart, { root: root2, margin: rootMargin, amount = "any" } = {}) {
  if (typeof IntersectionObserver === "undefined") {
    return () => {
    };
  }
  const elements = resolveElements(elementOrSelector);
  const activeIntersections = /* @__PURE__ */ new WeakMap();
  const onIntersectionChange = (entries) => {
    entries.forEach((entry) => {
      const onEnd = activeIntersections.get(entry.target);
      if (entry.isIntersecting === Boolean(onEnd))
        return;
      if (entry.isIntersecting) {
        const newOnEnd = onStart(entry);
        if (typeof newOnEnd === "function") {
          activeIntersections.set(entry.target, newOnEnd);
        } else {
          observer.unobserve(entry.target);
        }
      } else if (onEnd) {
        onEnd(entry);
        activeIntersections.delete(entry.target);
      }
    });
  };
  const observer = new IntersectionObserver(onIntersectionChange, {
    root: root2,
    rootMargin,
    threshold: typeof amount === "number" ? amount : thresholds[amount]
  });
  elements.forEach((element) => observer.observe(element));
  return () => observer.disconnect();
}

// node_modules/@motionone/dom/dist/gestures/scroll/index.es.js
init_tslib_es6();

// node_modules/@motionone/dom/dist/state/index.es.js
init_tslib_es6();

// node_modules/@motionone/dom/dist/state/gestures/in-view.es.js
init_tslib_es6();

// node_modules/@motionone/dom/dist/state/utils/events.es.js
function dispatchPointerEvent(element, name, event) {
  element.dispatchEvent(new CustomEvent(name, { detail: { originalEvent: event } }));
}
function dispatchViewEvent(element, name, entry) {
  element.dispatchEvent(new CustomEvent(name, { detail: { originalEntry: entry } }));
}

// node_modules/@motionone/dom/dist/state/gestures/in-view.es.js
var inView2 = {
  isActive: (options) => Boolean(options.inView),
  subscribe: (element, { enable, disable }, { inViewOptions = {} }) => {
    const { once } = inViewOptions, viewOptions = __rest(inViewOptions, ["once"]);
    return inView(element, (enterEntry) => {
      enable();
      dispatchViewEvent(element, "viewenter", enterEntry);
      if (!once) {
        return (leaveEntry) => {
          disable();
          dispatchViewEvent(element, "viewleave", leaveEntry);
        };
      }
    }, viewOptions);
  }
};

// node_modules/@motionone/dom/dist/state/gestures/hover.es.js
var mouseEvent = (element, name, action) => (event) => {
  if (event.pointerType && event.pointerType !== "mouse")
    return;
  action();
  dispatchPointerEvent(element, name, event);
};
var hover = {
  isActive: (options) => Boolean(options.hover),
  subscribe: (element, { enable, disable }) => {
    const onEnter = mouseEvent(element, "hoverstart", enable);
    const onLeave = mouseEvent(element, "hoverend", disable);
    element.addEventListener("pointerenter", onEnter);
    element.addEventListener("pointerleave", onLeave);
    return () => {
      element.removeEventListener("pointerenter", onEnter);
      element.removeEventListener("pointerleave", onLeave);
    };
  }
};

// node_modules/@motionone/dom/dist/state/gestures/press.es.js
var press = {
  isActive: (options) => Boolean(options.press),
  subscribe: (element, { enable, disable }) => {
    const onPointerUp = (event) => {
      disable();
      dispatchPointerEvent(element, "pressend", event);
      window.removeEventListener("pointerup", onPointerUp);
    };
    const onPointerDown = (event) => {
      enable();
      dispatchPointerEvent(element, "pressstart", event);
      window.addEventListener("pointerup", onPointerUp);
    };
    element.addEventListener("pointerdown", onPointerDown);
    return () => {
      element.removeEventListener("pointerdown", onPointerDown);
      window.removeEventListener("pointerup", onPointerUp);
    };
  }
};

// node_modules/@motionone/dom/dist/state/index.es.js
var gestures = { inView: inView2, hover, press };
var stateTypes = ["initial", "animate", ...Object.keys(gestures), "exit"];

// node_modules/framer-motion/dist/es/utils/use-animation-frame.mjs
var import_react61 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/animation/animation-controls.mjs
init_tslib_es6();

// node_modules/framer-motion/dist/es/animation/use-animation.mjs
var import_react62 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-cycle.mjs
init_tslib_es6();
var import_react63 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/utils/use-in-view.mjs
init_tslib_es6();
var import_react64 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/gestures/drag/use-drag-controls.mjs
var DragControls = (
  /** @class */
  function() {
    function DragControls2() {
      this.componentControls = /* @__PURE__ */ new Set();
    }
    DragControls2.prototype.subscribe = function(controls) {
      var _this = this;
      this.componentControls.add(controls);
      return function() {
        return _this.componentControls.delete(controls);
      };
    };
    DragControls2.prototype.start = function(event, options) {
      this.componentControls.forEach(function(controls) {
        controls.start(event.nativeEvent || event, options);
      });
    };
    return DragControls2;
  }()
);

// node_modules/framer-motion/dist/es/utils/use-instant-transition.mjs
init_tslib_es6();
var import_react65 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/projection/use-reset-projection.mjs
var React11 = __toESM(require_react(), 1);

// node_modules/framer-motion/dist/es/animation/use-animated-state.mjs
init_tslib_es6();
var import_react66 = __toESM(require_react(), 1);
var createObject = function() {
  return {};
};
var stateVisualElement = visualElement({
  build: function() {
  },
  measureViewportBox: createBox,
  resetTransform: function() {
  },
  restoreTransform: function() {
  },
  removeValueFromRenderState: function() {
  },
  render: function() {
  },
  scrapeMotionValuesFromProps: createObject,
  readValueFromInstance: function(_state, key, options) {
    return options.initialState[key] || 0;
  },
  makeTargetAnimatable: function(element, _a2) {
    var transition2 = _a2.transition, transitionEnd = _a2.transitionEnd, target = __rest(_a2, ["transition", "transitionEnd"]);
    var origin2 = getOrigin(target, transition2 || {}, element);
    checkTargetForNewValues(element, target, origin2);
    return __assign({ transition: transition2, transitionEnd }, target);
  }
});
var useVisualState = makeUseVisualState({
  scrapeMotionValuesFromProps: createObject,
  createRenderState: createObject
});

// node_modules/styled-components/dist/styled-components.browser.esm.js
var import_react_is = __toESM(require_react_is());
var import_react67 = __toESM(require_react());
var import_shallowequal = __toESM(require_shallowequal());

// node_modules/@emotion/stylis/dist/stylis.browser.esm.js
function stylis_min(W3) {
  function M3(d2, c3, e2, h, a3) {
    for (var m3 = 0, b4 = 0, v2 = 0, n2 = 0, q3, g3, x2 = 0, K2 = 0, k4, u3 = k4 = q3 = 0, l3 = 0, r2 = 0, I3 = 0, t2 = 0, B3 = e2.length, J2 = B3 - 1, y2, f3 = "", p2 = "", F3 = "", G3 = "", C2; l3 < B3; ) {
      g3 = e2.charCodeAt(l3);
      l3 === J2 && 0 !== b4 + n2 + v2 + m3 && (0 !== b4 && (g3 = 47 === b4 ? 10 : 47), n2 = v2 = m3 = 0, B3++, J2++);
      if (0 === b4 + n2 + v2 + m3) {
        if (l3 === J2 && (0 < r2 && (f3 = f3.replace(N2, "")), 0 < f3.trim().length)) {
          switch (g3) {
            case 32:
            case 9:
            case 59:
            case 13:
            case 10:
              break;
            default:
              f3 += e2.charAt(l3);
          }
          g3 = 59;
        }
        switch (g3) {
          case 123:
            f3 = f3.trim();
            q3 = f3.charCodeAt(0);
            k4 = 1;
            for (t2 = ++l3; l3 < B3; ) {
              switch (g3 = e2.charCodeAt(l3)) {
                case 123:
                  k4++;
                  break;
                case 125:
                  k4--;
                  break;
                case 47:
                  switch (g3 = e2.charCodeAt(l3 + 1)) {
                    case 42:
                    case 47:
                      a: {
                        for (u3 = l3 + 1; u3 < J2; ++u3) {
                          switch (e2.charCodeAt(u3)) {
                            case 47:
                              if (42 === g3 && 42 === e2.charCodeAt(u3 - 1) && l3 + 2 !== u3) {
                                l3 = u3 + 1;
                                break a;
                              }
                              break;
                            case 10:
                              if (47 === g3) {
                                l3 = u3 + 1;
                                break a;
                              }
                          }
                        }
                        l3 = u3;
                      }
                  }
                  break;
                case 91:
                  g3++;
                case 40:
                  g3++;
                case 34:
                case 39:
                  for (; l3++ < J2 && e2.charCodeAt(l3) !== g3; ) {
                  }
              }
              if (0 === k4) break;
              l3++;
            }
            k4 = e2.substring(t2, l3);
            0 === q3 && (q3 = (f3 = f3.replace(ca3, "").trim()).charCodeAt(0));
            switch (q3) {
              case 64:
                0 < r2 && (f3 = f3.replace(N2, ""));
                g3 = f3.charCodeAt(1);
                switch (g3) {
                  case 100:
                  case 109:
                  case 115:
                  case 45:
                    r2 = c3;
                    break;
                  default:
                    r2 = O2;
                }
                k4 = M3(c3, r2, k4, g3, a3 + 1);
                t2 = k4.length;
                0 < A && (r2 = X4(O2, f3, I3), C2 = H3(3, k4, r2, c3, D3, z3, t2, g3, a3, h), f3 = r2.join(""), void 0 !== C2 && 0 === (t2 = (k4 = C2.trim()).length) && (g3 = 0, k4 = ""));
                if (0 < t2) switch (g3) {
                  case 115:
                    f3 = f3.replace(da2, ea2);
                  case 100:
                  case 109:
                  case 45:
                    k4 = f3 + "{" + k4 + "}";
                    break;
                  case 107:
                    f3 = f3.replace(fa2, "$1 $2");
                    k4 = f3 + "{" + k4 + "}";
                    k4 = 1 === w2 || 2 === w2 && L2("@" + k4, 3) ? "@-webkit-" + k4 + "@" + k4 : "@" + k4;
                    break;
                  default:
                    k4 = f3 + k4, 112 === h && (k4 = (p2 += k4, ""));
                }
                else k4 = "";
                break;
              default:
                k4 = M3(c3, X4(c3, f3, I3), k4, h, a3 + 1);
            }
            F3 += k4;
            k4 = I3 = r2 = u3 = q3 = 0;
            f3 = "";
            g3 = e2.charCodeAt(++l3);
            break;
          case 125:
          case 59:
            f3 = (0 < r2 ? f3.replace(N2, "") : f3).trim();
            if (1 < (t2 = f3.length)) switch (0 === u3 && (q3 = f3.charCodeAt(0), 45 === q3 || 96 < q3 && 123 > q3) && (t2 = (f3 = f3.replace(" ", ":")).length), 0 < A && void 0 !== (C2 = H3(1, f3, c3, d2, D3, z3, p2.length, h, a3, h)) && 0 === (t2 = (f3 = C2.trim()).length) && (f3 = "\0\0"), q3 = f3.charCodeAt(0), g3 = f3.charCodeAt(1), q3) {
              case 0:
                break;
              case 64:
                if (105 === g3 || 99 === g3) {
                  G3 += f3 + e2.charAt(l3);
                  break;
                }
              default:
                58 !== f3.charCodeAt(t2 - 1) && (p2 += P(f3, q3, g3, f3.charCodeAt(2)));
            }
            I3 = r2 = u3 = q3 = 0;
            f3 = "";
            g3 = e2.charCodeAt(++l3);
        }
      }
      switch (g3) {
        case 13:
        case 10:
          47 === b4 ? b4 = 0 : 0 === 1 + q3 && 107 !== h && 0 < f3.length && (r2 = 1, f3 += "\0");
          0 < A * Y2 && H3(0, f3, c3, d2, D3, z3, p2.length, h, a3, h);
          z3 = 1;
          D3++;
          break;
        case 59:
        case 125:
          if (0 === b4 + n2 + v2 + m3) {
            z3++;
            break;
          }
        default:
          z3++;
          y2 = e2.charAt(l3);
          switch (g3) {
            case 9:
            case 32:
              if (0 === n2 + m3 + b4) switch (x2) {
                case 44:
                case 58:
                case 9:
                case 32:
                  y2 = "";
                  break;
                default:
                  32 !== g3 && (y2 = " ");
              }
              break;
            case 0:
              y2 = "\\0";
              break;
            case 12:
              y2 = "\\f";
              break;
            case 11:
              y2 = "\\v";
              break;
            case 38:
              0 === n2 + b4 + m3 && (r2 = I3 = 1, y2 = "\f" + y2);
              break;
            case 108:
              if (0 === n2 + b4 + m3 + E3 && 0 < u3) switch (l3 - u3) {
                case 2:
                  112 === x2 && 58 === e2.charCodeAt(l3 - 3) && (E3 = x2);
                case 8:
                  111 === K2 && (E3 = K2);
              }
              break;
            case 58:
              0 === n2 + b4 + m3 && (u3 = l3);
              break;
            case 44:
              0 === b4 + v2 + n2 + m3 && (r2 = 1, y2 += "\r");
              break;
            case 34:
            case 39:
              0 === b4 && (n2 = n2 === g3 ? 0 : 0 === n2 ? g3 : n2);
              break;
            case 91:
              0 === n2 + b4 + v2 && m3++;
              break;
            case 93:
              0 === n2 + b4 + v2 && m3--;
              break;
            case 41:
              0 === n2 + b4 + m3 && v2--;
              break;
            case 40:
              if (0 === n2 + b4 + m3) {
                if (0 === q3) switch (2 * x2 + 3 * K2) {
                  case 533:
                    break;
                  default:
                    q3 = 1;
                }
                v2++;
              }
              break;
            case 64:
              0 === b4 + v2 + n2 + m3 + u3 + k4 && (k4 = 1);
              break;
            case 42:
            case 47:
              if (!(0 < n2 + m3 + v2)) switch (b4) {
                case 0:
                  switch (2 * g3 + 3 * e2.charCodeAt(l3 + 1)) {
                    case 235:
                      b4 = 47;
                      break;
                    case 220:
                      t2 = l3, b4 = 42;
                  }
                  break;
                case 42:
                  47 === g3 && 42 === x2 && t2 + 2 !== l3 && (33 === e2.charCodeAt(t2 + 2) && (p2 += e2.substring(t2, l3 + 1)), y2 = "", b4 = 0);
              }
          }
          0 === b4 && (f3 += y2);
      }
      K2 = x2;
      x2 = g3;
      l3++;
    }
    t2 = p2.length;
    if (0 < t2) {
      r2 = c3;
      if (0 < A && (C2 = H3(2, p2, r2, d2, D3, z3, t2, h, a3, h), void 0 !== C2 && 0 === (p2 = C2).length)) return G3 + p2 + F3;
      p2 = r2.join(",") + "{" + p2 + "}";
      if (0 !== w2 * E3) {
        2 !== w2 || L2(p2, 2) || (E3 = 0);
        switch (E3) {
          case 111:
            p2 = p2.replace(ha2, ":-moz-$1") + p2;
            break;
          case 112:
            p2 = p2.replace(Q2, "::-webkit-input-$1") + p2.replace(Q2, "::-moz-$1") + p2.replace(Q2, ":-ms-input-$1") + p2;
        }
        E3 = 0;
      }
    }
    return G3 + p2 + F3;
  }
  function X4(d2, c3, e2) {
    var h = c3.trim().split(ia2);
    c3 = h;
    var a3 = h.length, m3 = d2.length;
    switch (m3) {
      case 0:
      case 1:
        var b4 = 0;
        for (d2 = 0 === m3 ? "" : d2[0] + " "; b4 < a3; ++b4) {
          c3[b4] = Z2(d2, c3[b4], e2).trim();
        }
        break;
      default:
        var v2 = b4 = 0;
        for (c3 = []; b4 < a3; ++b4) {
          for (var n2 = 0; n2 < m3; ++n2) {
            c3[v2++] = Z2(d2[n2] + " ", h[b4], e2).trim();
          }
        }
    }
    return c3;
  }
  function Z2(d2, c3, e2) {
    var h = c3.charCodeAt(0);
    33 > h && (h = (c3 = c3.trim()).charCodeAt(0));
    switch (h) {
      case 38:
        return c3.replace(F2, "$1" + d2.trim());
      case 58:
        return d2.trim() + c3.replace(F2, "$1" + d2.trim());
      default:
        if (0 < 1 * e2 && 0 < c3.indexOf("\f")) return c3.replace(F2, (58 === d2.charCodeAt(0) ? "" : "$1") + d2.trim());
    }
    return d2 + c3;
  }
  function P(d2, c3, e2, h) {
    var a3 = d2 + ";", m3 = 2 * c3 + 3 * e2 + 4 * h;
    if (944 === m3) {
      d2 = a3.indexOf(":", 9) + 1;
      var b4 = a3.substring(d2, a3.length - 1).trim();
      b4 = a3.substring(0, d2).trim() + b4 + ";";
      return 1 === w2 || 2 === w2 && L2(b4, 1) ? "-webkit-" + b4 + b4 : b4;
    }
    if (0 === w2 || 2 === w2 && !L2(a3, 1)) return a3;
    switch (m3) {
      case 1015:
        return 97 === a3.charCodeAt(10) ? "-webkit-" + a3 + a3 : a3;
      case 951:
        return 116 === a3.charCodeAt(3) ? "-webkit-" + a3 + a3 : a3;
      case 963:
        return 110 === a3.charCodeAt(5) ? "-webkit-" + a3 + a3 : a3;
      case 1009:
        if (100 !== a3.charCodeAt(4)) break;
      case 969:
      case 942:
        return "-webkit-" + a3 + a3;
      case 978:
        return "-webkit-" + a3 + "-moz-" + a3 + a3;
      case 1019:
      case 983:
        return "-webkit-" + a3 + "-moz-" + a3 + "-ms-" + a3 + a3;
      case 883:
        if (45 === a3.charCodeAt(8)) return "-webkit-" + a3 + a3;
        if (0 < a3.indexOf("image-set(", 11)) return a3.replace(ja2, "$1-webkit-$2") + a3;
        break;
      case 932:
        if (45 === a3.charCodeAt(4)) switch (a3.charCodeAt(5)) {
          case 103:
            return "-webkit-box-" + a3.replace("-grow", "") + "-webkit-" + a3 + "-ms-" + a3.replace("grow", "positive") + a3;
          case 115:
            return "-webkit-" + a3 + "-ms-" + a3.replace("shrink", "negative") + a3;
          case 98:
            return "-webkit-" + a3 + "-ms-" + a3.replace("basis", "preferred-size") + a3;
        }
        return "-webkit-" + a3 + "-ms-" + a3 + a3;
      case 964:
        return "-webkit-" + a3 + "-ms-flex-" + a3 + a3;
      case 1023:
        if (99 !== a3.charCodeAt(8)) break;
        b4 = a3.substring(a3.indexOf(":", 15)).replace("flex-", "").replace("space-between", "justify");
        return "-webkit-box-pack" + b4 + "-webkit-" + a3 + "-ms-flex-pack" + b4 + a3;
      case 1005:
        return ka2.test(a3) ? a3.replace(aa2, ":-webkit-") + a3.replace(aa2, ":-moz-") + a3 : a3;
      case 1e3:
        b4 = a3.substring(13).trim();
        c3 = b4.indexOf("-") + 1;
        switch (b4.charCodeAt(0) + b4.charCodeAt(c3)) {
          case 226:
            b4 = a3.replace(G2, "tb");
            break;
          case 232:
            b4 = a3.replace(G2, "tb-rl");
            break;
          case 220:
            b4 = a3.replace(G2, "lr");
            break;
          default:
            return a3;
        }
        return "-webkit-" + a3 + "-ms-" + b4 + a3;
      case 1017:
        if (-1 === a3.indexOf("sticky", 9)) break;
      case 975:
        c3 = (a3 = d2).length - 10;
        b4 = (33 === a3.charCodeAt(c3) ? a3.substring(0, c3) : a3).substring(d2.indexOf(":", 7) + 1).trim();
        switch (m3 = b4.charCodeAt(0) + (b4.charCodeAt(7) | 0)) {
          case 203:
            if (111 > b4.charCodeAt(8)) break;
          case 115:
            a3 = a3.replace(b4, "-webkit-" + b4) + ";" + a3;
            break;
          case 207:
          case 102:
            a3 = a3.replace(b4, "-webkit-" + (102 < m3 ? "inline-" : "") + "box") + ";" + a3.replace(b4, "-webkit-" + b4) + ";" + a3.replace(b4, "-ms-" + b4 + "box") + ";" + a3;
        }
        return a3 + ";";
      case 938:
        if (45 === a3.charCodeAt(5)) switch (a3.charCodeAt(6)) {
          case 105:
            return b4 = a3.replace("-items", ""), "-webkit-" + a3 + "-webkit-box-" + b4 + "-ms-flex-" + b4 + a3;
          case 115:
            return "-webkit-" + a3 + "-ms-flex-item-" + a3.replace(ba2, "") + a3;
          default:
            return "-webkit-" + a3 + "-ms-flex-line-pack" + a3.replace("align-content", "").replace(ba2, "") + a3;
        }
        break;
      case 973:
      case 989:
        if (45 !== a3.charCodeAt(3) || 122 === a3.charCodeAt(4)) break;
      case 931:
      case 953:
        if (true === la2.test(d2)) return 115 === (b4 = d2.substring(d2.indexOf(":") + 1)).charCodeAt(0) ? P(d2.replace("stretch", "fill-available"), c3, e2, h).replace(":fill-available", ":stretch") : a3.replace(b4, "-webkit-" + b4) + a3.replace(b4, "-moz-" + b4.replace("fill-", "")) + a3;
        break;
      case 962:
        if (a3 = "-webkit-" + a3 + (102 === a3.charCodeAt(5) ? "-ms-" + a3 : "") + a3, 211 === e2 + h && 105 === a3.charCodeAt(13) && 0 < a3.indexOf("transform", 10)) return a3.substring(0, a3.indexOf(";", 27) + 1).replace(ma2, "$1-webkit-$2") + a3;
    }
    return a3;
  }
  function L2(d2, c3) {
    var e2 = d2.indexOf(1 === c3 ? ":" : "{"), h = d2.substring(0, 3 !== c3 ? e2 : 10);
    e2 = d2.substring(e2 + 1, d2.length - 1);
    return R2(2 !== c3 ? h : h.replace(na2, "$1"), e2, c3);
  }
  function ea2(d2, c3) {
    var e2 = P(c3, c3.charCodeAt(0), c3.charCodeAt(1), c3.charCodeAt(2));
    return e2 !== c3 + ";" ? e2.replace(oa2, " or ($1)").substring(4) : "(" + c3 + ")";
  }
  function H3(d2, c3, e2, h, a3, m3, b4, v2, n2, q3) {
    for (var g3 = 0, x2 = c3, w3; g3 < A; ++g3) {
      switch (w3 = S2[g3].call(B2, d2, x2, e2, h, a3, m3, b4, v2, n2, q3)) {
        case void 0:
        case false:
        case true:
        case null:
          break;
        default:
          x2 = w3;
      }
    }
    if (x2 !== c3) return x2;
  }
  function T4(d2) {
    switch (d2) {
      case void 0:
      case null:
        A = S2.length = 0;
        break;
      default:
        if ("function" === typeof d2) S2[A++] = d2;
        else if ("object" === typeof d2) for (var c3 = 0, e2 = d2.length; c3 < e2; ++c3) {
          T4(d2[c3]);
        }
        else Y2 = !!d2 | 0;
    }
    return T4;
  }
  function U2(d2) {
    d2 = d2.prefix;
    void 0 !== d2 && (R2 = null, d2 ? "function" !== typeof d2 ? w2 = 1 : (w2 = 2, R2 = d2) : w2 = 0);
    return U2;
  }
  function B2(d2, c3) {
    var e2 = d2;
    33 > e2.charCodeAt(0) && (e2 = e2.trim());
    V2 = e2;
    e2 = [V2];
    if (0 < A) {
      var h = H3(-1, c3, e2, e2, D3, z3, 0, 0, 0, 0);
      void 0 !== h && "string" === typeof h && (c3 = h);
    }
    var a3 = M3(O2, e2, c3, 0, 0);
    0 < A && (h = H3(-2, a3, e2, e2, D3, z3, a3.length, 0, 0, 0), void 0 !== h && (a3 = h));
    V2 = "";
    E3 = 0;
    z3 = D3 = 1;
    return a3;
  }
  var ca3 = /^\0+/g, N2 = /[\0\r\f]/g, aa2 = /: */g, ka2 = /zoo|gra/, ma2 = /([,: ])(transform)/g, ia2 = /,\r+?/g, F2 = /([\t\r\n ])*\f?&/g, fa2 = /@(k\w+)\s*(\S*)\s*/, Q2 = /::(place)/g, ha2 = /:(read-only)/g, G2 = /[svh]\w+-[tblr]{2}/, da2 = /\(\s*(.*)\s*\)/g, oa2 = /([\s\S]*?);/g, ba2 = /-self|flex-/g, na2 = /[^]*?(:[rp][el]a[\w-]+)[^]*/, la2 = /stretch|:\s*\w+\-(?:conte|avail)/, ja2 = /([^-])(image-set\()/, z3 = 1, D3 = 1, E3 = 0, w2 = 1, O2 = [], S2 = [], A = 0, R2 = null, Y2 = 0, V2 = "";
  B2.use = T4;
  B2.set = U2;
  void 0 !== W3 && U2(W3);
  return B2;
}
var stylis_browser_esm_default = stylis_min;

// node_modules/@emotion/unitless/dist/unitless.browser.esm.js
var unitlessKeys = {
  animationIterationCount: 1,
  borderImageOutset: 1,
  borderImageSlice: 1,
  borderImageWidth: 1,
  boxFlex: 1,
  boxFlexGroup: 1,
  boxOrdinalGroup: 1,
  columnCount: 1,
  columns: 1,
  flex: 1,
  flexGrow: 1,
  flexPositive: 1,
  flexShrink: 1,
  flexNegative: 1,
  flexOrder: 1,
  gridRow: 1,
  gridRowEnd: 1,
  gridRowSpan: 1,
  gridRowStart: 1,
  gridColumn: 1,
  gridColumnEnd: 1,
  gridColumnSpan: 1,
  gridColumnStart: 1,
  msGridRow: 1,
  msGridRowSpan: 1,
  msGridColumn: 1,
  msGridColumnSpan: 1,
  fontWeight: 1,
  lineHeight: 1,
  opacity: 1,
  order: 1,
  orphans: 1,
  tabSize: 1,
  widows: 1,
  zIndex: 1,
  zoom: 1,
  WebkitLineClamp: 1,
  // SVG-related properties
  fillOpacity: 1,
  floodOpacity: 1,
  stopOpacity: 1,
  strokeDasharray: 1,
  strokeDashoffset: 1,
  strokeMiterlimit: 1,
  strokeOpacity: 1,
  strokeWidth: 1
};
var unitless_browser_esm_default = unitlessKeys;

// node_modules/styled-components/node_modules/@emotion/memoize/dist/emotion-memoize.esm.js
function memoize2(fn2) {
  var cache = /* @__PURE__ */ Object.create(null);
  return function(arg) {
    if (cache[arg] === void 0) cache[arg] = fn2(arg);
    return cache[arg];
  };
}

// node_modules/styled-components/node_modules/@emotion/is-prop-valid/dist/emotion-is-prop-valid.esm.js
var reactPropsRegex2 = /^((children|dangerouslySetInnerHTML|key|ref|autoFocus|defaultValue|defaultChecked|innerHTML|suppressContentEditableWarning|suppressHydrationWarning|valueLink|abbr|accept|acceptCharset|accessKey|action|allow|allowUserMedia|allowPaymentRequest|allowFullScreen|allowTransparency|alt|async|autoComplete|autoPlay|capture|cellPadding|cellSpacing|challenge|charSet|checked|cite|classID|className|cols|colSpan|content|contentEditable|contextMenu|controls|controlsList|coords|crossOrigin|data|dateTime|decoding|default|defer|dir|disabled|disablePictureInPicture|disableRemotePlayback|download|draggable|encType|enterKeyHint|fetchpriority|fetchPriority|form|formAction|formEncType|formMethod|formNoValidate|formTarget|frameBorder|headers|height|hidden|high|href|hrefLang|htmlFor|httpEquiv|id|inputMode|integrity|is|keyParams|keyType|kind|label|lang|list|loading|loop|low|marginHeight|marginWidth|max|maxLength|media|mediaGroup|method|min|minLength|multiple|muted|name|nonce|noValidate|open|optimum|pattern|placeholder|playsInline|poster|preload|profile|radioGroup|readOnly|referrerPolicy|rel|required|reversed|role|rows|rowSpan|sandbox|scope|scoped|scrolling|seamless|selected|shape|size|sizes|slot|span|spellCheck|src|srcDoc|srcLang|srcSet|start|step|style|summary|tabIndex|target|title|translate|type|useMap|value|width|wmode|wrap|about|datatype|inlist|prefix|property|resource|typeof|vocab|autoCapitalize|autoCorrect|autoSave|color|incremental|fallback|inert|itemProp|itemScope|itemType|itemID|itemRef|on|option|results|security|unselectable|accentHeight|accumulate|additive|alignmentBaseline|allowReorder|alphabetic|amplitude|arabicForm|ascent|attributeName|attributeType|autoReverse|azimuth|baseFrequency|baselineShift|baseProfile|bbox|begin|bias|by|calcMode|capHeight|clip|clipPathUnits|clipPath|clipRule|colorInterpolation|colorInterpolationFilters|colorProfile|colorRendering|contentScriptType|contentStyleType|cursor|cx|cy|d|decelerate|descent|diffuseConstant|direction|display|divisor|dominantBaseline|dur|dx|dy|edgeMode|elevation|enableBackground|end|exponent|externalResourcesRequired|fill|fillOpacity|fillRule|filter|filterRes|filterUnits|floodColor|floodOpacity|focusable|fontFamily|fontSize|fontSizeAdjust|fontStretch|fontStyle|fontVariant|fontWeight|format|from|fr|fx|fy|g1|g2|glyphName|glyphOrientationHorizontal|glyphOrientationVertical|glyphRef|gradientTransform|gradientUnits|hanging|horizAdvX|horizOriginX|ideographic|imageRendering|in|in2|intercept|k|k1|k2|k3|k4|kernelMatrix|kernelUnitLength|kerning|keyPoints|keySplines|keyTimes|lengthAdjust|letterSpacing|lightingColor|limitingConeAngle|local|markerEnd|markerMid|markerStart|markerHeight|markerUnits|markerWidth|mask|maskContentUnits|maskUnits|mathematical|mode|numOctaves|offset|opacity|operator|order|orient|orientation|origin|overflow|overlinePosition|overlineThickness|panose1|paintOrder|pathLength|patternContentUnits|patternTransform|patternUnits|pointerEvents|points|pointsAtX|pointsAtY|pointsAtZ|preserveAlpha|preserveAspectRatio|primitiveUnits|r|radius|refX|refY|renderingIntent|repeatCount|repeatDur|requiredExtensions|requiredFeatures|restart|result|rotate|rx|ry|scale|seed|shapeRendering|slope|spacing|specularConstant|specularExponent|speed|spreadMethod|startOffset|stdDeviation|stemh|stemv|stitchTiles|stopColor|stopOpacity|strikethroughPosition|strikethroughThickness|string|stroke|strokeDasharray|strokeDashoffset|strokeLinecap|strokeLinejoin|strokeMiterlimit|strokeOpacity|strokeWidth|surfaceScale|systemLanguage|tableValues|targetX|targetY|textAnchor|textDecoration|textRendering|textLength|to|transform|u1|u2|underlinePosition|underlineThickness|unicode|unicodeBidi|unicodeRange|unitsPerEm|vAlphabetic|vHanging|vIdeographic|vMathematical|values|vectorEffect|version|vertAdvY|vertOriginX|vertOriginY|viewBox|viewTarget|visibility|widths|wordSpacing|writingMode|x|xHeight|x1|x2|xChannelSelector|xlinkActuate|xlinkArcrole|xlinkHref|xlinkRole|xlinkShow|xlinkTitle|xlinkType|xmlBase|xmlns|xmlnsXlink|xmlLang|xmlSpace|y|y1|y2|yChannelSelector|z|zoomAndPan|for|class|autofocus)|(([Dd][Aa][Tt][Aa]|[Aa][Rr][Ii][Aa]|x)-.*))$/;
var isPropValid = memoize2(
  function(prop) {
    return reactPropsRegex2.test(prop) || prop.charCodeAt(0) === 111 && prop.charCodeAt(1) === 110 && prop.charCodeAt(2) < 91;
  }
  /* Z+1 */
);

// node_modules/styled-components/dist/styled-components.browser.esm.js
var import_hoist_non_react_statics = __toESM(require_hoist_non_react_statics_cjs());
function y() {
  return (y = Object.assign || function(e2) {
    for (var t2 = 1; t2 < arguments.length; t2++) {
      var n2 = arguments[t2];
      for (var r2 in n2) Object.prototype.hasOwnProperty.call(n2, r2) && (e2[r2] = n2[r2]);
    }
    return e2;
  }).apply(this, arguments);
}
var v = function(e2, t2) {
  for (var n2 = [e2[0]], r2 = 0, o2 = t2.length; r2 < o2; r2 += 1) n2.push(t2[r2], e2[r2 + 1]);
  return n2;
};
var g = function(t2) {
  return null !== t2 && "object" == typeof t2 && "[object Object]" === (t2.toString ? t2.toString() : Object.prototype.toString.call(t2)) && !(0, import_react_is.typeOf)(t2);
};
var S = Object.freeze([]);
var w = Object.freeze({});
function E(e2) {
  return "function" == typeof e2;
}
function b2(e2) {
  return "string" == typeof e2 && e2 || e2.displayName || e2.name || "Component";
}
function _(e2) {
  return e2 && "string" == typeof e2.styledComponentId;
}
var N = "undefined" != typeof process && void 0 !== process.env && (process.env.REACT_APP_SC_ATTR || process.env.SC_ATTR) || "data-styled";
var C = "undefined" != typeof window && "HTMLElement" in window;
var I = Boolean("boolean" == typeof SC_DISABLE_SPEEDY ? SC_DISABLE_SPEEDY : "undefined" != typeof process && void 0 !== process.env && (void 0 !== process.env.REACT_APP_SC_DISABLE_SPEEDY && "" !== process.env.REACT_APP_SC_DISABLE_SPEEDY ? "false" !== process.env.REACT_APP_SC_DISABLE_SPEEDY && process.env.REACT_APP_SC_DISABLE_SPEEDY : void 0 !== process.env.SC_DISABLE_SPEEDY && "" !== process.env.SC_DISABLE_SPEEDY ? "false" !== process.env.SC_DISABLE_SPEEDY && process.env.SC_DISABLE_SPEEDY : true));
var O = true ? { 1: "Cannot create styled-component for component: %s.\n\n", 2: "Can't collect styles once you've consumed a `ServerStyleSheet`'s styles! `ServerStyleSheet` is a one off instance for each server-side render cycle.\n\n- Are you trying to reuse it across renders?\n- Are you accidentally calling collectStyles twice?\n\n", 3: "Streaming SSR is only supported in a Node.js environment; Please do not try to call this method in the browser.\n\n", 4: "The `StyleSheetManager` expects a valid target or sheet prop!\n\n- Does this error occur on the client and is your target falsy?\n- Does this error occur on the server and is the sheet falsy?\n\n", 5: "The clone method cannot be used on the client!\n\n- Are you running in a client-like environment on the server?\n- Are you trying to run SSR on the client?\n\n", 6: "Trying to insert a new style tag, but the given Node is unmounted!\n\n- Are you using a custom target that isn't mounted?\n- Does your document not have a valid head element?\n- Have you accidentally removed a style tag manually?\n\n", 7: 'ThemeProvider: Please return an object from your "theme" prop function, e.g.\n\n```js\ntheme={() => ({})}\n```\n\n', 8: 'ThemeProvider: Please make your "theme" prop an object.\n\n', 9: "Missing document `<head>`\n\n", 10: "Cannot find a StyleSheet instance. Usually this happens if there are multiple copies of styled-components loaded at once. Check out this issue for how to troubleshoot and fix the common cases where this situation can happen: https://github.com/styled-components/styled-components/issues/1941#issuecomment-417862021\n\n", 11: "_This error was replaced with a dev-time warning, it will be deleted for v4 final._ [createGlobalStyle] received children which will not be rendered. Please use the component without passing children elements.\n\n", 12: "It seems you are interpolating a keyframe declaration (%s) into an untagged string. This was supported in styled-components v3, but is not longer supported in v4 as keyframes are now injected on-demand. Please wrap your string in the css\\`\\` helper which ensures the styles are injected correctly. See https://www.styled-components.com/docs/api#css\n\n", 13: "%s is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details.\n\n", 14: 'ThemeProvider: "theme" prop is required.\n\n', 15: "A stylis plugin has been supplied that is not named. We need a name for each plugin to be able to prevent styling collisions between different stylis configurations within the same app. Before you pass your plugin to `<StyleSheetManager stylisPlugins={[]}>`, please make sure each plugin is uniquely-named, e.g.\n\n```js\nObject.defineProperty(importedPlugin, 'name', { value: 'some-unique-name' });\n```\n\n", 16: "Reached the limit of how many styled components may be created at group %s.\nYou may only create up to 1,073,741,824 components. If you're creating components dynamically,\nas for instance in your render method then you may be running into this limitation.\n\n", 17: "CSSStyleSheet could not be found on HTMLStyleElement.\nHas styled-components' style tag been unmounted or altered by another script?\n" } : {};
function R() {
  for (var e2 = arguments.length <= 0 ? void 0 : arguments[0], t2 = [], n2 = 1, r2 = arguments.length; n2 < r2; n2 += 1) t2.push(n2 < 0 || arguments.length <= n2 ? void 0 : arguments[n2]);
  return t2.forEach(function(t3) {
    e2 = e2.replace(/%[a-z]/, t3);
  }), e2;
}
function D(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++) n2[r2 - 1] = arguments[r2];
  throw false ? new Error("An error occurred. See https://git.io/JUIaE#" + e2 + " for more information." + (n2.length > 0 ? " Args: " + n2.join(", ") : "")) : new Error(R.apply(void 0, [O[e2]].concat(n2)).trim());
}
var j = function() {
  function e2(e3) {
    this.groupSizes = new Uint32Array(512), this.length = 512, this.tag = e3;
  }
  var t2 = e2.prototype;
  return t2.indexOfGroup = function(e3) {
    for (var t3 = 0, n2 = 0; n2 < e3; n2++) t3 += this.groupSizes[n2];
    return t3;
  }, t2.insertRules = function(e3, t3) {
    if (e3 >= this.groupSizes.length) {
      for (var n2 = this.groupSizes, r2 = n2.length, o2 = r2; e3 >= o2; ) (o2 <<= 1) < 0 && D(16, "" + e3);
      this.groupSizes = new Uint32Array(o2), this.groupSizes.set(n2), this.length = o2;
      for (var s2 = r2; s2 < o2; s2++) this.groupSizes[s2] = 0;
    }
    for (var i2 = this.indexOfGroup(e3 + 1), a3 = 0, c3 = t3.length; a3 < c3; a3++) this.tag.insertRule(i2, t3[a3]) && (this.groupSizes[e3]++, i2++);
  }, t2.clearGroup = function(e3) {
    if (e3 < this.length) {
      var t3 = this.groupSizes[e3], n2 = this.indexOfGroup(e3), r2 = n2 + t3;
      this.groupSizes[e3] = 0;
      for (var o2 = n2; o2 < r2; o2++) this.tag.deleteRule(n2);
    }
  }, t2.getGroup = function(e3) {
    var t3 = "";
    if (e3 >= this.length || 0 === this.groupSizes[e3]) return t3;
    for (var n2 = this.groupSizes[e3], r2 = this.indexOfGroup(e3), o2 = r2 + n2, s2 = r2; s2 < o2; s2++) t3 += this.tag.getRule(s2) + "/*!sc*/\n";
    return t3;
  }, e2;
}();
var T = /* @__PURE__ */ new Map();
var x = /* @__PURE__ */ new Map();
var k = 1;
var V = function(e2) {
  if (T.has(e2)) return T.get(e2);
  for (; x.has(k); ) k++;
  var t2 = k++;
  return ((0 | t2) < 0 || t2 > 1 << 30) && D(16, "" + t2), T.set(e2, t2), x.set(t2, e2), t2;
};
var B = function(e2) {
  return x.get(e2);
};
var z = function(e2, t2) {
  t2 >= k && (k = t2 + 1), T.set(e2, t2), x.set(t2, e2);
};
var M = "style[" + N + '][data-styled-version="5.3.11"]';
var G = new RegExp("^" + N + '\\.g(\\d+)\\[id="([\\w\\d-]+)"\\].*?"([^"]*)');
var L = function(e2, t2, n2) {
  for (var r2, o2 = n2.split(","), s2 = 0, i2 = o2.length; s2 < i2; s2++) (r2 = o2[s2]) && e2.registerName(t2, r2);
};
var F = function(e2, t2) {
  for (var n2 = (t2.textContent || "").split("/*!sc*/\n"), r2 = [], o2 = 0, s2 = n2.length; o2 < s2; o2++) {
    var i2 = n2[o2].trim();
    if (i2) {
      var a3 = i2.match(G);
      if (a3) {
        var c3 = 0 | parseInt(a3[1], 10), u3 = a3[2];
        0 !== c3 && (z(u3, c3), L(e2, u3, a3[3]), e2.getTag().insertRules(c3, r2)), r2.length = 0;
      } else r2.push(i2);
    }
  }
};
var Y = function() {
  return "undefined" != typeof __webpack_nonce__ ? __webpack_nonce__ : null;
};
var q = function(e2) {
  var t2 = document.head, n2 = e2 || t2, r2 = document.createElement("style"), o2 = function(e3) {
    for (var t3 = e3.childNodes, n3 = t3.length; n3 >= 0; n3--) {
      var r3 = t3[n3];
      if (r3 && 1 === r3.nodeType && r3.hasAttribute(N)) return r3;
    }
  }(n2), s2 = void 0 !== o2 ? o2.nextSibling : null;
  r2.setAttribute(N, "active"), r2.setAttribute("data-styled-version", "5.3.11");
  var i2 = Y();
  return i2 && r2.setAttribute("nonce", i2), n2.insertBefore(r2, s2), r2;
};
var H = function() {
  function e2(e3) {
    var t3 = this.element = q(e3);
    t3.appendChild(document.createTextNode("")), this.sheet = function(e4) {
      if (e4.sheet) return e4.sheet;
      for (var t4 = document.styleSheets, n2 = 0, r2 = t4.length; n2 < r2; n2++) {
        var o2 = t4[n2];
        if (o2.ownerNode === e4) return o2;
      }
      D(17);
    }(t3), this.length = 0;
  }
  var t2 = e2.prototype;
  return t2.insertRule = function(e3, t3) {
    try {
      return this.sheet.insertRule(t3, e3), this.length++, true;
    } catch (e4) {
      return false;
    }
  }, t2.deleteRule = function(e3) {
    this.sheet.deleteRule(e3), this.length--;
  }, t2.getRule = function(e3) {
    var t3 = this.sheet.cssRules[e3];
    return void 0 !== t3 && "string" == typeof t3.cssText ? t3.cssText : "";
  }, e2;
}();
var $ = function() {
  function e2(e3) {
    var t3 = this.element = q(e3);
    this.nodes = t3.childNodes, this.length = 0;
  }
  var t2 = e2.prototype;
  return t2.insertRule = function(e3, t3) {
    if (e3 <= this.length && e3 >= 0) {
      var n2 = document.createTextNode(t3), r2 = this.nodes[e3];
      return this.element.insertBefore(n2, r2 || null), this.length++, true;
    }
    return false;
  }, t2.deleteRule = function(e3) {
    this.element.removeChild(this.nodes[e3]), this.length--;
  }, t2.getRule = function(e3) {
    return e3 < this.length ? this.nodes[e3].textContent : "";
  }, e2;
}();
var W = function() {
  function e2(e3) {
    this.rules = [], this.length = 0;
  }
  var t2 = e2.prototype;
  return t2.insertRule = function(e3, t3) {
    return e3 <= this.length && (this.rules.splice(e3, 0, t3), this.length++, true);
  }, t2.deleteRule = function(e3) {
    this.rules.splice(e3, 1), this.length--;
  }, t2.getRule = function(e3) {
    return e3 < this.length ? this.rules[e3] : "";
  }, e2;
}();
var U = C;
var J = { isServer: !C, useCSSOMInjection: !I };
var X = function() {
  function e2(e3, t3, n2) {
    void 0 === e3 && (e3 = w), void 0 === t3 && (t3 = {}), this.options = y({}, J, {}, e3), this.gs = t3, this.names = new Map(n2), this.server = !!e3.isServer, !this.server && C && U && (U = false, function(e4) {
      for (var t4 = document.querySelectorAll(M), n3 = 0, r2 = t4.length; n3 < r2; n3++) {
        var o2 = t4[n3];
        o2 && "active" !== o2.getAttribute(N) && (F(e4, o2), o2.parentNode && o2.parentNode.removeChild(o2));
      }
    }(this));
  }
  e2.registerId = function(e3) {
    return V(e3);
  };
  var t2 = e2.prototype;
  return t2.reconstructWithOptions = function(t3, n2) {
    return void 0 === n2 && (n2 = true), new e2(y({}, this.options, {}, t3), this.gs, n2 && this.names || void 0);
  }, t2.allocateGSInstance = function(e3) {
    return this.gs[e3] = (this.gs[e3] || 0) + 1;
  }, t2.getTag = function() {
    return this.tag || (this.tag = (n2 = (t3 = this.options).isServer, r2 = t3.useCSSOMInjection, o2 = t3.target, e3 = n2 ? new W(o2) : r2 ? new H(o2) : new $(o2), new j(e3)));
    var e3, t3, n2, r2, o2;
  }, t2.hasNameForId = function(e3, t3) {
    return this.names.has(e3) && this.names.get(e3).has(t3);
  }, t2.registerName = function(e3, t3) {
    if (V(e3), this.names.has(e3)) this.names.get(e3).add(t3);
    else {
      var n2 = /* @__PURE__ */ new Set();
      n2.add(t3), this.names.set(e3, n2);
    }
  }, t2.insertRules = function(e3, t3, n2) {
    this.registerName(e3, t3), this.getTag().insertRules(V(e3), n2);
  }, t2.clearNames = function(e3) {
    this.names.has(e3) && this.names.get(e3).clear();
  }, t2.clearRules = function(e3) {
    this.getTag().clearGroup(V(e3)), this.clearNames(e3);
  }, t2.clearTag = function() {
    this.tag = void 0;
  }, t2.toString = function() {
    return function(e3) {
      for (var t3 = e3.getTag(), n2 = t3.length, r2 = "", o2 = 0; o2 < n2; o2++) {
        var s2 = B(o2);
        if (void 0 !== s2) {
          var i2 = e3.names.get(s2), a3 = t3.getGroup(o2);
          if (i2 && a3 && i2.size) {
            var c3 = N + ".g" + o2 + '[id="' + s2 + '"]', u3 = "";
            void 0 !== i2 && i2.forEach(function(e4) {
              e4.length > 0 && (u3 += e4 + ",");
            }), r2 += "" + a3 + c3 + '{content:"' + u3 + '"}/*!sc*/\n';
          }
        }
      }
      return r2;
    }(this);
  }, e2;
}();
var Z = /(a)(d)/gi;
var K = function(e2) {
  return String.fromCharCode(e2 + (e2 > 25 ? 39 : 97));
};
function Q(e2) {
  var t2, n2 = "";
  for (t2 = Math.abs(e2); t2 > 52; t2 = t2 / 52 | 0) n2 = K(t2 % 52) + n2;
  return (K(t2 % 52) + n2).replace(Z, "$1-$2");
}
var ee = function(e2, t2) {
  for (var n2 = t2.length; n2; ) e2 = 33 * e2 ^ t2.charCodeAt(--n2);
  return e2;
};
var te = function(e2) {
  return ee(5381, e2);
};
function ne(e2) {
  for (var t2 = 0; t2 < e2.length; t2 += 1) {
    var n2 = e2[t2];
    if (E(n2) && !_(n2)) return false;
  }
  return true;
}
var re = te("5.3.11");
var oe = function() {
  function e2(e3, t2, n2) {
    this.rules = e3, this.staticRulesId = "", this.isStatic = false, this.componentId = t2, this.baseHash = ee(re, t2), this.baseStyle = n2, X.registerId(t2);
  }
  return e2.prototype.generateAndInjectStyles = function(e3, t2, n2) {
    var r2 = this.componentId, o2 = [];
    if (this.baseStyle && o2.push(this.baseStyle.generateAndInjectStyles(e3, t2, n2)), this.isStatic && !n2.hash) if (this.staticRulesId && t2.hasNameForId(r2, this.staticRulesId)) o2.push(this.staticRulesId);
    else {
      var s2 = _e(this.rules, e3, t2, n2).join(""), i2 = Q(ee(this.baseHash, s2) >>> 0);
      if (!t2.hasNameForId(r2, i2)) {
        var a3 = n2(s2, "." + i2, void 0, r2);
        t2.insertRules(r2, i2, a3);
      }
      o2.push(i2), this.staticRulesId = i2;
    }
    else {
      for (var c3 = this.rules.length, u3 = ee(this.baseHash, n2.hash), l3 = "", d2 = 0; d2 < c3; d2++) {
        var h = this.rules[d2];
        if ("string" == typeof h) l3 += h, u3 = ee(u3, h + d2);
        else if (h) {
          var p2 = _e(h, e3, t2, n2), f3 = Array.isArray(p2) ? p2.join("") : p2;
          u3 = ee(u3, f3 + d2), l3 += f3;
        }
      }
      if (l3) {
        var m3 = Q(u3 >>> 0);
        if (!t2.hasNameForId(r2, m3)) {
          var y2 = n2(l3, "." + m3, void 0, r2);
          t2.insertRules(r2, m3, y2);
        }
        o2.push(m3);
      }
    }
    return o2.join(" ");
  }, e2;
}();
var se = /^\s*\/\/.*$/gm;
var ie = [":", "[", ".", "#"];
function ae(e2) {
  var t2, n2, r2, o2, s2 = void 0 === e2 ? w : e2, i2 = s2.options, a3 = void 0 === i2 ? w : i2, c3 = s2.plugins, u3 = void 0 === c3 ? S : c3, l3 = new stylis_browser_esm_default(a3), d2 = [], p2 = /* @__PURE__ */ function(e3) {
    function t3(t4) {
      if (t4) try {
        e3(t4 + "}");
      } catch (e4) {
      }
    }
    return function(n3, r3, o3, s3, i3, a4, c4, u4, l4, d3) {
      switch (n3) {
        case 1:
          if (0 === l4 && 64 === r3.charCodeAt(0)) return e3(r3 + ";"), "";
          break;
        case 2:
          if (0 === u4) return r3 + "/*|*/";
          break;
        case 3:
          switch (u4) {
            case 102:
            case 112:
              return e3(o3[0] + r3), "";
            default:
              return r3 + (0 === d3 ? "/*|*/" : "");
          }
        case -2:
          r3.split("/*|*/}").forEach(t3);
      }
    };
  }(function(e3) {
    d2.push(e3);
  }), f3 = function(e3, r3, s3) {
    return 0 === r3 && -1 !== ie.indexOf(s3[n2.length]) || s3.match(o2) ? e3 : "." + t2;
  };
  function m3(e3, s3, i3, a4) {
    void 0 === a4 && (a4 = "&");
    var c4 = e3.replace(se, ""), u4 = s3 && i3 ? i3 + " " + s3 + " { " + c4 + " }" : c4;
    return t2 = a4, n2 = s3, r2 = new RegExp("\\" + n2 + "\\b", "g"), o2 = new RegExp("(\\" + n2 + "\\b){2,}"), l3(i3 || !s3 ? "" : s3, u4);
  }
  return l3.use([].concat(u3, [function(e3, t3, o3) {
    2 === e3 && o3.length && o3[0].lastIndexOf(n2) > 0 && (o3[0] = o3[0].replace(r2, f3));
  }, p2, function(e3) {
    if (-2 === e3) {
      var t3 = d2;
      return d2 = [], t3;
    }
  }])), m3.hash = u3.length ? u3.reduce(function(e3, t3) {
    return t3.name || D(15), ee(e3, t3.name);
  }, 5381).toString() : "", m3;
}
var ce = import_react67.default.createContext();
var ue = ce.Consumer;
var le = import_react67.default.createContext();
var de = (le.Consumer, new X());
var he = ae();
function pe() {
  return (0, import_react67.useContext)(ce) || de;
}
function fe() {
  return (0, import_react67.useContext)(le) || he;
}
function me(e2) {
  var t2 = (0, import_react67.useState)(e2.stylisPlugins), n2 = t2[0], s2 = t2[1], c3 = pe(), u3 = (0, import_react67.useMemo)(function() {
    var t3 = c3;
    return e2.sheet ? t3 = e2.sheet : e2.target && (t3 = t3.reconstructWithOptions({ target: e2.target }, false)), e2.disableCSSOMInjection && (t3 = t3.reconstructWithOptions({ useCSSOMInjection: false })), t3;
  }, [e2.disableCSSOMInjection, e2.sheet, e2.target]), l3 = (0, import_react67.useMemo)(function() {
    return ae({ options: { prefix: !e2.disableVendorPrefixes }, plugins: n2 });
  }, [e2.disableVendorPrefixes, n2]);
  return (0, import_react67.useEffect)(function() {
    (0, import_shallowequal.default)(n2, e2.stylisPlugins) || s2(e2.stylisPlugins);
  }, [e2.stylisPlugins]), import_react67.default.createElement(ce.Provider, { value: u3 }, import_react67.default.createElement(le.Provider, { value: l3 }, true ? import_react67.default.Children.only(e2.children) : e2.children));
}
var ye = function() {
  function e2(e3, t2) {
    var n2 = this;
    this.inject = function(e4, t3) {
      void 0 === t3 && (t3 = he);
      var r2 = n2.name + t3.hash;
      e4.hasNameForId(n2.id, r2) || e4.insertRules(n2.id, r2, t3(n2.rules, r2, "@keyframes"));
    }, this.toString = function() {
      return D(12, String(n2.name));
    }, this.name = e3, this.id = "sc-keyframes-" + e3, this.rules = t2;
  }
  return e2.prototype.getName = function(e3) {
    return void 0 === e3 && (e3 = he), this.name + e3.hash;
  }, e2;
}();
var ve = /([A-Z])/;
var ge = /([A-Z])/g;
var Se = /^ms-/;
var we = function(e2) {
  return "-" + e2.toLowerCase();
};
function Ee(e2) {
  return ve.test(e2) ? e2.replace(ge, we).replace(Se, "-ms-") : e2;
}
var be = function(e2) {
  return null == e2 || false === e2 || "" === e2;
};
function _e(e2, n2, r2, o2) {
  if (Array.isArray(e2)) {
    for (var s2, i2 = [], a3 = 0, c3 = e2.length; a3 < c3; a3 += 1) "" !== (s2 = _e(e2[a3], n2, r2, o2)) && (Array.isArray(s2) ? i2.push.apply(i2, s2) : i2.push(s2));
    return i2;
  }
  if (be(e2)) return "";
  if (_(e2)) return "." + e2.styledComponentId;
  if (E(e2)) {
    if ("function" != typeof (l3 = e2) || l3.prototype && l3.prototype.isReactComponent || !n2) return e2;
    var u3 = e2(n2);
    return (0, import_react_is.isElement)(u3) && console.warn(b2(e2) + " is not a styled component and cannot be referred to via component selector. See https://www.styled-components.com/docs/advanced#referring-to-other-components for more details."), _e(u3, n2, r2, o2);
  }
  var l3;
  return e2 instanceof ye ? r2 ? (e2.inject(r2, o2), e2.getName(o2)) : e2 : g(e2) ? function e3(t2, n3) {
    var r3, o3, s3 = [];
    for (var i3 in t2) t2.hasOwnProperty(i3) && !be(t2[i3]) && (Array.isArray(t2[i3]) && t2[i3].isCss || E(t2[i3]) ? s3.push(Ee(i3) + ":", t2[i3], ";") : g(t2[i3]) ? s3.push.apply(s3, e3(t2[i3], i3)) : s3.push(Ee(i3) + ": " + (r3 = i3, null == (o3 = t2[i3]) || "boolean" == typeof o3 || "" === o3 ? "" : "number" != typeof o3 || 0 === o3 || r3 in unitless_browser_esm_default || r3.startsWith("--") ? String(o3).trim() : o3 + "px") + ";"));
    return n3 ? [n3 + " {"].concat(s3, ["}"]) : s3;
  }(e2) : e2.toString();
}
var Ne = function(e2) {
  return Array.isArray(e2) && (e2.isCss = true), e2;
};
function Ae(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++) n2[r2 - 1] = arguments[r2];
  return E(e2) || g(e2) ? Ne(_e(v(S, [e2].concat(n2)))) : 0 === n2.length && 1 === e2.length && "string" == typeof e2[0] ? e2 : Ne(_e(v(e2, n2)));
}
var Ce = /invalid hook call/i;
var Ie = /* @__PURE__ */ new Set();
var Pe = function(e2, t2) {
  if (true) {
    var n2 = "The component " + e2 + (t2 ? ' with the id of "' + t2 + '"' : "") + " has been created dynamically.\nYou may see this warning because you've called styled inside another component.\nTo resolve this only create new StyledComponents outside of any render method and function component.", r2 = console.error;
    try {
      var o2 = true;
      console.error = function(e3) {
        if (Ce.test(e3)) o2 = false, Ie.delete(n2);
        else {
          for (var t3 = arguments.length, s2 = new Array(t3 > 1 ? t3 - 1 : 0), i2 = 1; i2 < t3; i2++) s2[i2 - 1] = arguments[i2];
          r2.apply(void 0, [e3].concat(s2));
        }
      }, (0, import_react67.useRef)(), o2 && !Ie.has(n2) && (console.warn(n2), Ie.add(n2));
    } catch (e3) {
      Ce.test(e3.message) && Ie.delete(n2);
    } finally {
      console.error = r2;
    }
  }
};
var Oe = function(e2, t2, n2) {
  return void 0 === n2 && (n2 = w), e2.theme !== n2.theme && e2.theme || t2 || n2.theme;
};
var Re = /[!"#$%&'()*+,./:;<=>?@[\\\]^`{|}~-]+/g;
var De = /(^-|-$)/g;
function je(e2) {
  return e2.replace(Re, "-").replace(De, "");
}
var Te = function(e2) {
  return Q(te(e2) >>> 0);
};
function xe(e2) {
  return "string" == typeof e2 && e2.charAt(0) === e2.charAt(0).toLowerCase();
}
var ke = function(e2) {
  return "function" == typeof e2 || "object" == typeof e2 && null !== e2 && !Array.isArray(e2);
};
var Ve = function(e2) {
  return "__proto__" !== e2 && "constructor" !== e2 && "prototype" !== e2;
};
function Be(e2, t2, n2) {
  var r2 = e2[n2];
  ke(t2) && ke(r2) ? ze(r2, t2) : e2[n2] = t2;
}
function ze(e2) {
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++) n2[r2 - 1] = arguments[r2];
  for (var o2 = 0, s2 = n2; o2 < s2.length; o2++) {
    var i2 = s2[o2];
    if (ke(i2)) for (var a3 in i2) Ve(a3) && Be(e2, i2[a3], a3);
  }
  return e2;
}
var Me = import_react67.default.createContext();
var Ge = Me.Consumer;
function Le(e2) {
  var t2 = (0, import_react67.useContext)(Me), n2 = (0, import_react67.useMemo)(function() {
    return function(e3, t3) {
      if (!e3) return D(14);
      if (E(e3)) {
        var n3 = e3(t3);
        return null !== n3 && !Array.isArray(n3) && "object" == typeof n3 ? n3 : D(7);
      }
      return Array.isArray(e3) || "object" != typeof e3 ? D(8) : t3 ? y({}, t3, {}, e3) : e3;
    }(e2.theme, t2);
  }, [e2.theme, t2]);
  return e2.children ? import_react67.default.createElement(Me.Provider, { value: n2 }, e2.children) : null;
}
var Fe = {};
function Ye(e2, t2, n2) {
  var o2 = _(e2), i2 = !xe(e2), a3 = t2.attrs, c3 = void 0 === a3 ? S : a3, l3 = t2.componentId, d2 = void 0 === l3 ? function(e3, t3) {
    var n3 = "string" != typeof e3 ? "sc" : je(e3);
    Fe[n3] = (Fe[n3] || 0) + 1;
    var r2 = n3 + "-" + Te("5.3.11" + n3 + Fe[n3]);
    return t3 ? t3 + "-" + r2 : r2;
  }(t2.displayName, t2.parentComponentId) : l3, h = t2.displayName, p2 = void 0 === h ? function(e3) {
    return xe(e3) ? "styled." + e3 : "Styled(" + b2(e3) + ")";
  }(e2) : h, v2 = t2.displayName && t2.componentId ? je(t2.displayName) + "-" + t2.componentId : t2.componentId || d2, g3 = o2 && e2.attrs ? Array.prototype.concat(e2.attrs, c3).filter(Boolean) : c3, N2 = t2.shouldForwardProp;
  o2 && e2.shouldForwardProp && (N2 = t2.shouldForwardProp ? function(n3, r2, o3) {
    return e2.shouldForwardProp(n3, r2, o3) && t2.shouldForwardProp(n3, r2, o3);
  } : e2.shouldForwardProp);
  var A, C2 = new oe(n2, v2, o2 ? e2.componentStyle : void 0), I3 = C2.isStatic && 0 === c3.length, P = function(e3, t3) {
    return function(e4, t4, n3, r2) {
      var o3 = e4.attrs, i3 = e4.componentStyle, a4 = e4.defaultProps, c4 = e4.foldedComponentIds, l4 = e4.shouldForwardProp, d3 = e4.styledComponentId, h2 = e4.target, p3 = function(e5, t5, n4) {
        void 0 === e5 && (e5 = w);
        var r3 = y({}, t5, { theme: e5 }), o4 = {};
        return n4.forEach(function(e6) {
          var t6, n5, s2, i4 = e6;
          for (t6 in E(i4) && (i4 = i4(r3)), i4) r3[t6] = o4[t6] = "className" === t6 ? (n5 = o4[t6], s2 = i4[t6], n5 && s2 ? n5 + " " + s2 : n5 || s2) : i4[t6];
        }), [r3, o4];
      }(Oe(t4, (0, import_react67.useContext)(Me), a4) || w, t4, o3), m3 = p3[0], v3 = p3[1], g4 = function(e5, t5, n4, r3) {
        var o4 = pe(), s2 = fe(), i4 = t5 ? e5.generateAndInjectStyles(w, o4, s2) : e5.generateAndInjectStyles(n4, o4, s2);
        return !t5 && r3 && r3(i4), i4;
      }(i3, r2, m3, true ? e4.warnTooManyClasses : void 0), S2 = n3, b4 = v3.$as || t4.$as || v3.as || t4.as || h2, _2 = xe(b4), N3 = v3 !== t4 ? y({}, t4, {}, v3) : t4, A2 = {};
      for (var C3 in N3) "$" !== C3[0] && "as" !== C3 && ("forwardedAs" === C3 ? A2.as = N3[C3] : (l4 ? l4(C3, isPropValid, b4) : !_2 || isPropValid(C3)) && (A2[C3] = N3[C3]));
      return t4.style && v3.style !== t4.style && (A2.style = y({}, t4.style, {}, v3.style)), A2.className = Array.prototype.concat(c4, d3, g4 !== d3 ? g4 : null, t4.className, v3.className).filter(Boolean).join(" "), A2.ref = S2, (0, import_react67.createElement)(b4, A2);
    }(A, e3, t3, I3);
  };
  return P.displayName = p2, (A = import_react67.default.forwardRef(P)).attrs = g3, A.componentStyle = C2, A.displayName = p2, A.shouldForwardProp = N2, A.foldedComponentIds = o2 ? Array.prototype.concat(e2.foldedComponentIds, e2.styledComponentId) : S, A.styledComponentId = v2, A.target = o2 ? e2.target : e2, A.withComponent = function(e3) {
    var r2 = t2.componentId, o3 = function(e4, t3) {
      if (null == e4) return {};
      var n3, r3, o4 = {}, s3 = Object.keys(e4);
      for (r3 = 0; r3 < s3.length; r3++) n3 = s3[r3], t3.indexOf(n3) >= 0 || (o4[n3] = e4[n3]);
      return o4;
    }(t2, ["componentId"]), s2 = r2 && r2 + "-" + (xe(e3) ? e3 : je(b2(e3)));
    return Ye(e3, y({}, o3, { attrs: g3, componentId: s2 }), n2);
  }, Object.defineProperty(A, "defaultProps", { get: function() {
    return this._foldedDefaultProps;
  }, set: function(t3) {
    this._foldedDefaultProps = o2 ? ze({}, e2.defaultProps, t3) : t3;
  } }), Pe(p2, v2), A.warnTooManyClasses = /* @__PURE__ */ function(e3, t3) {
    var n3 = {}, r2 = false;
    return function(o3) {
      if (!r2 && (n3[o3] = true, Object.keys(n3).length >= 200)) {
        var s2 = t3 ? ' with the id of "' + t3 + '"' : "";
        console.warn("Over 200 classes were generated for component " + e3 + s2 + ".\nConsider using the attrs method, together with a style object for frequently changed styles.\nExample:\n  const Component = styled.div.attrs(props => ({\n    style: {\n      background: props.background,\n    },\n  }))`width: 100%;`\n\n  <Component />"), r2 = true, n3 = {};
      }
    };
  }(p2, v2), Object.defineProperty(A, "toString", { value: function() {
    return "." + A.styledComponentId;
  } }), i2 && (0, import_hoist_non_react_statics.default)(A, e2, { attrs: true, componentStyle: true, displayName: true, foldedComponentIds: true, shouldForwardProp: true, styledComponentId: true, target: true, withComponent: true }), A;
}
var qe = function(e2) {
  return function e3(t2, r2, o2) {
    if (void 0 === o2 && (o2 = w), !(0, import_react_is.isValidElementType)(r2)) return D(1, String(r2));
    var s2 = function() {
      return t2(r2, o2, Ae.apply(void 0, arguments));
    };
    return s2.withConfig = function(n2) {
      return e3(t2, r2, y({}, o2, {}, n2));
    }, s2.attrs = function(n2) {
      return e3(t2, r2, y({}, o2, { attrs: Array.prototype.concat(o2.attrs, n2).filter(Boolean) }));
    }, s2;
  }(Ye, e2);
};
["a", "abbr", "address", "area", "article", "aside", "audio", "b", "base", "bdi", "bdo", "big", "blockquote", "body", "br", "button", "canvas", "caption", "cite", "code", "col", "colgroup", "data", "datalist", "dd", "del", "details", "dfn", "dialog", "div", "dl", "dt", "em", "embed", "fieldset", "figcaption", "figure", "footer", "form", "h1", "h2", "h3", "h4", "h5", "h6", "head", "header", "hgroup", "hr", "html", "i", "iframe", "img", "input", "ins", "kbd", "keygen", "label", "legend", "li", "link", "main", "map", "mark", "marquee", "menu", "menuitem", "meta", "meter", "nav", "noscript", "object", "ol", "optgroup", "option", "output", "p", "param", "picture", "pre", "progress", "q", "rp", "rt", "ruby", "s", "samp", "script", "section", "select", "small", "source", "span", "strong", "style", "sub", "summary", "sup", "table", "tbody", "td", "textarea", "tfoot", "th", "thead", "time", "title", "tr", "track", "u", "ul", "var", "video", "wbr", "circle", "clipPath", "defs", "ellipse", "foreignObject", "g", "image", "line", "linearGradient", "marker", "mask", "path", "pattern", "polygon", "polyline", "radialGradient", "rect", "stop", "svg", "text", "textPath", "tspan"].forEach(function(e2) {
  qe[e2] = qe(e2);
});
var He = function() {
  function e2(e3, t3) {
    this.rules = e3, this.componentId = t3, this.isStatic = ne(e3), X.registerId(this.componentId + 1);
  }
  var t2 = e2.prototype;
  return t2.createStyles = function(e3, t3, n2, r2) {
    var o2 = r2(_e(this.rules, t3, n2, r2).join(""), ""), s2 = this.componentId + e3;
    n2.insertRules(s2, s2, o2);
  }, t2.removeStyles = function(e3, t3) {
    t3.clearRules(this.componentId + e3);
  }, t2.renderStyles = function(e3, t3, n2, r2) {
    e3 > 2 && X.registerId(this.componentId + e3), this.removeStyles(e3, n2), this.createStyles(e3, t3, n2, r2);
  }, e2;
}();
function We(e2) {
  "undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("`keyframes` cannot be used on ReactNative, only on the web. To do animation in ReactNative please use Animated.");
  for (var t2 = arguments.length, n2 = new Array(t2 > 1 ? t2 - 1 : 0), r2 = 1; r2 < t2; r2++) n2[r2 - 1] = arguments[r2];
  var o2 = Ae.apply(void 0, [e2].concat(n2)).join(""), s2 = Te(o2);
  return new ye(s2, o2);
}
var Ue = function() {
  function e2() {
    var e3 = this;
    this._emitSheetCSS = function() {
      var t3 = e3.instance.toString();
      if (!t3) return "";
      var n2 = Y();
      return "<style " + [n2 && 'nonce="' + n2 + '"', N + '="true"', 'data-styled-version="5.3.11"'].filter(Boolean).join(" ") + ">" + t3 + "</style>";
    }, this.getStyleTags = function() {
      return e3.sealed ? D(2) : e3._emitSheetCSS();
    }, this.getStyleElement = function() {
      var t3;
      if (e3.sealed) return D(2);
      var n2 = ((t3 = {})[N] = "", t3["data-styled-version"] = "5.3.11", t3.dangerouslySetInnerHTML = { __html: e3.instance.toString() }, t3), o2 = Y();
      return o2 && (n2.nonce = o2), [import_react67.default.createElement("style", y({}, n2, { key: "sc-0-0" }))];
    }, this.seal = function() {
      e3.sealed = true;
    }, this.instance = new X({ isServer: true }), this.sealed = false;
  }
  var t2 = e2.prototype;
  return t2.collectStyles = function(e3) {
    return this.sealed ? D(2) : import_react67.default.createElement(me, { sheet: this.instance }, e3);
  }, t2.interleaveWithNodeStream = function(e3) {
    return D(3);
  }, e2;
}();
"undefined" != typeof navigator && "ReactNative" === navigator.product && console.warn("It looks like you've imported 'styled-components' on React Native.\nPerhaps you're looking to import 'styled-components/native'?\nRead more about this at https://www.styled-components.com/docs/basics#react-native"), "undefined" != typeof window && (window["__styled-components-init__"] = window["__styled-components-init__"] || 0, 1 === window["__styled-components-init__"] && console.warn("It looks like there are several instances of 'styled-components' initialized in this application. This may cause dynamic styles to not render properly, errors during the rehydration process, a missing theme prop, and makes your application bigger without good reason.\n\nSee https://s-c.sh/2BAXzed for more info."), window["__styled-components-init__"] += 1);
var styled_components_browser_esm_default = qe;

// node_modules/connectkit/build/index.es.js
var import_react_dom = __toESM(require_react_dom());

// node_modules/ox/_esm/core/Ens.js
var Ens_exports = {};
__export(Ens_exports, {
  labelhash: () => labelhash,
  namehash: () => namehash,
  normalize: () => normalize3
});

// node_modules/@adraffy/ens-normalize/dist/index.mjs
var COMPRESSED$1 = "AEkU4AngDVgB0QKRAQYBOwDqATEAnwDbAIUApABsAOAAbwCRAEYAiQBPAHYAPgA+ACsANwAlAGMAHwAvACsAJQAWAC8AGwAiACIALwAUACsAEQAiAAsAGwARABcAGAA6ACkALAAsADUAFgAsABEAHQAhAA8AGwAdABUAFgAZAA0ADQAXABAAGQAUABIEqgYJAR4UFjfDBdMAsQCuPwFnAKUBA10jAK5/Ly8vLwE/pwUJ6/0HPwbkMQVXBVgAPSs5APa2EQbIwQuUCkEDyJ4zAsUKLwKOoQKG2D+Ob4kCxcsCg/IBH98JAPKtAUECLY0KP48A4wDiChUAF9S5yAwLPZ0EG3cA/QI5GL0P6wkGKekFBIFnDRsHLQCrAGmR76WcfwBbBpMjBukAGwA7DJMAWxVbqfu75wzbIM8IuykDsRQ7APcta6MAoX0YABcEJdcWAR0AuRnNBPoJIEw3CZcJiB4bVllM44NCABMADAAVAA5rVAAhAA4AR+4V2D3zOVjKleYuChAdX01YPewAEwAMABUADmsgXECXAMPrABsAOQzFABsVW6n7Adq4HB0FWwXiAtCfAsSwCkwcpGUUcxptTPUAuw1nAuEACy00iRfJkQKBewETGwC9DWcC4QALLQFIUCWRTAoDLfsFMgnXaRetAddDAEkrEncCMRYhAusnuTdrADnhAfUlAMcOy7UBG2OBALEFAAUAitNJBRvDHwcXAKgn0QGhKy0DmwBnAQoZPu03dAQYFwCqAccCIQDTKxJzOvNQsAWQOncnNUgF+icFWQVYr7gFaTtdQhI6WEGXe5NmX6H4CxMDxQcl8XcjBKNLAlNTAnUbqycBj6OlNVsDRRcEg2EJANEGqz8vIwcpAjldAGsBYR9xAIMdGQCVAUm3ACdpFwGvxQM3LSFDUwFvWQZlAmUA8UkXAykBBQBJQQCrAF0AcwArtQYH8+8ZjX8ACSEAKQCzG0cB0QHbBwsxl3iB6AAKABEANAA9ADgzd3nTwBBfEFwBTQlMbDoVCwKsD6YL5REVDNEqy9PYADSpB+sDUwfrA1MDUwfrB+sDUwfrA1MDUwNTA1McCvAa08AQXw9IBG0FjgWLBNYIgyZJEYEHKAjSVA10HhxHA0UA/CMlSRw7kzMLJUJMDE0DB/w2QmynfTgDRzGrVPWQogPLMk85bAEecRKgACoPcxw1tU5+ekdxoApLT661f0liTmcCvjqoP/gKIQmTb7t3TgY9EBcnoRDzDC8BsQE3DelL1ATtBjcExR95GRUPyZWYCKEt2QzpJt8unYBWI/EqfwXpS/A82QtJUWQPVQthCd86X4FKAx0BCSKHCtkNNQhpEO8KxWcN4RFBBzUD0UmWAKEG/QsNHTEVsSYMYqgLBTlzBvca8guLJqsTJXr4Bc8aHQZJASUa+wDLLuOFrFotXBhPWwX/CyEjwxSkUBwNIUCzeEQaFwcRJaUCjUNsSoNRMh6PIfI8OQ1iLg9ReAfxPAEZSwt9PJpGp0UKEc4+iT1EIkVMKAQxeywrJ4cJyw+BDLV8bgFVCR0JrQxtEy0REzfBCDUHFSmXICcRCB1GkWCWBPObA+8TzQMHBTsJPQcPA7EcKRMqFSUFCYEg0wLvNtEurwKLVnwBEwXHDyEf2xBMR9wO5QiXAmEDfyXnACkVHQATIpcIP18AW4/UUwEuxwjDamgjcANjFONdEW8HjQ5TB6McLxW7HN1wxF4HhgQon6sJVwFxCZUBWwTfCAU1V4ycID1nT4tUGJcgXUE7XfgCLQxhFZtEuYd0AocPZxIXATEBbwc1DP0CcxHpEWcQkQjnhgA1sTP0OiEESyF/IA0KIwNLbMoLIyb1DPRlAZ8SXgMINDl36menYLIgF/kHFTLBQVwh7QuOT8kMmBq9GD5UKhngB7sD7xrvJ+ZBUwX7A58POkkz6gS5C2UIhwk7AEUOnxMH0xhmCm2MzAEthwGzlQNTjX8Ca4sGMwcHAGMHgwV14QAZAqMInwABAMsDUwA1AqkHmQAVAIE9ATkDIysBHeECiwOPCC3HAZErAe8lBBe/DBEA8zNuRgLDrQKAZmaeBdlUAooCRTEBSSEEAUpDTQOrbd0A1wBHBg/bQwERp0bHFt8/AdtrJwDDAPcAATEHAT0ByQHvaQCzAVsLLQmer7EBSeUlAH8AEWcB0wKFANkAMQB77QFPAEkFVfUFzwJLRQENLRQnU10BtwMbAS8BCQB1BseJocUDGwRpB88CEBcV3QLvKgexAyLbE8lCwQK92lEAMhIKNAq1CrQfX/NcLwItbj1MAAofpD7DP0oFTTtPO1Q7TztUO087VDtPO1Q7TztUA5O73rveCmhfQWHnDKIN0ETEOkUT12BNYC4TxC2zFL0VyiVSGTkauCcBJeBVBQ8ALc9mLAgoNHEXuAA7KWSDPWOCHiwKRxzjU41U9C0XAK1LnjOrDagbEUQ8BUN16WImFgoKHgJkfQJiPldJq1c3HAKh8wJolAJmBQKfgDgXBwJmNwJmIgRqBHsDfw8Dfo45AjlzEzl+Oh8fAmwZAjIyOAYCbcMCbarrhi9jQScBYwDaAN0ARgEHlAyJAPoHvgAJsQJ3KwJ2njsCeUc/Ani2GVjXRapG0wJ8OwJ6xAJ9BQJ87AVVBRxH/Eh5XyAAJxFJVEpXERNKyALQ/QLQyEsjA4hLA4fiRMGRLgLynVz/AwOqS8pMKSHLTUhNqwKLOwKK1L0XAxk/YwGzAo4zAo5YPJN9Ao7VAo5YdFGwUzEGUtBUgQKT9wKTCADlABhVGlWrVcwCLBcpkYIy3XhiRTc1ApebAu+uWB2kAFUhApaLApZ4mAClWahaBX1JADcClrEClkpcQFzNApnHAplgXMZdAxUCnJc5vjqZApwSAp+XAp60hgAZCy0mCwKd7QKejgCxOWEwYesCns8CoGoBpQKemxsCnkqhY8RkIyEnAierAiZ6AqD3AqBIAqLZAqHAAqYrAqXKAqf7AHkCp+5oeGit/0VqGGrNAqzfAqyqAq1jAqz+AlcZAlXYArHd0wMfSmyTArK5CQKy5BNs3G1fbURbAyXJArZYNztujAMpQQK4WgK5QxECuSZzcDJw3QK9FQK71nCSAzINAr6Ecf4DM20CvhZzHnNLAsPHAsMAc350RzFBdNwDPKMDPJYDPbsCxXgCxkMCxgyFAshlTQLIQALJSwLJKgJkmQLdznh1XXiqeSFLzAMYn2b+AmHwGe+VIHsHXo5etw0Cz2cCz2grR0/O7w+bAMKpAs9vASXmA04OfkcBAtwjAtuGAtJLA1JYA1NbAP0DVYiAhTvHEulcQYIYgs+CyoOJAtrDAtnahAyERac4A4ahACsDZAqGbVX1AFEC32EC3rRvcwLiK+0QAfMsIwH0lwHyzoMC6+8C6Wx1Aur1AurgAPVDAbUC7oUC65iWppb/Au47A4XcmHVw3HGdAvL/AGUDjhKZjwL3DwORagOSgwL3lAL51QL4YpoYmqe3M5saA51/Av72ARcANZ8Yn68DBYkDpmYDptUAzcEDBmahhKIBBQMMRQELARsHaQZdtWMBALcEZ7sNhx6vCQATcTUAHwMvEkkDhXsBXyMdAIzrAB0A5p8Dm40IswYbn8EApwURu+kdPT4WeAVoNz5AK0IhQrRfcRFfvACWxQUyAJBMGZu5OyZgMhG6zw4vGMYYicn2BVcFWAVXBVgFYwVYBVcFWAVXBVgFVwVYBVcFWEYVCNeFZwICAgpkXukrBMkDsQYvu7sAuwSnuwDnQCkWsgVGPmk+cEI/QrZfdTdf6ABYETOrAIz+zGvL/KbnRno9JiMEKxYnNjV+bd9qwfEZwixpAWvXbjAXBV8FasnBybgIz0lbAAAACnxefYu+ADM/gQADFtEG5a0jBQCMwwsDAQ0A5WUdPSQfSkKxQrxBOCNfJ2A2JzgjCcE9CkQ/Qz54PoE+cD5xAolCvElCO1/LTk9qTQosa1QvagtuH1/gMzobCWebCmIjKzwdJkKrQrwrzAHL/F/JDh8uCQgJIn6d32o6LUoXyavJrAllwcvMCmBBXw/lEKMRAJONHUVCJRupbTnOOAozP0M+cEI/HAcKHUxHbFssLVrhvBIKfe0dK0I/HF0ISgkOM1RDQjcEO0OcLAqBGy1CPxv1CFMiIxgwMQAFj2HwXgpxZMlgC2AtI25DYBk5AhseYLMGAmsQZU5gTREBZOdgFWCVYH1gs2BLYJFoFhcGtQ7cVam8WgtDFqsBuyvNwQIfFQAcAx4BeQJsLzCVUoABigq4RxoA5CN0jgrKDaZN6gGbAoecTwVAXwD39wkANBZXDAulDCQfuq9HAE8MNAAVE58rggh6AtILS2URGwDYTgZ1BAoeWgAxALa4AZonCxZvqyQ4nxkBWwGGCfwD2e0PBqoGSga5AB3LValaCbthE4kLLT8OuwG7ASICR1ooKCggHh8hLBImBiEMjQBUAm5XkEmVAW4fD3FHAdN1D85RIBmpsE3qBxEFTF8A9/cKAHoGJGwKKwulODAtx69WDQsAX7wLAGNAlQh6AOpN7yIbvwAxALa4AZonLTsOzgKQGHtQu1jIdHKO16WbDvWZFT0b7AEpEFwSBg8bAccJOhCTBRArDDYLABEAs84BAgCkAOEAmIIABWtXLwAUAFsbxi5sdioNwRACOyQz0+EcHgsbfQJ7Ls6hHATBCqrxbAA3OS0Opge7CQAQOi7OERkAfavaHA+7GkcczaF3HgE9Kl8cAuugCAHCAULz5B9lAb4Jtwz6CDwKPgAFwAs9AksNuwi8DTwKvC7OoSoJPA67BZgBG2sKD4sa4QHDARELuxY7AKALOxC7BBige9wAO2sMPAACpgm8BRvQ9QUBvgH6bsoGewAHuwG7D00RErwBAQDqAQAAdBVbBhbLFPxvF7sYOwAuuwLrDlaouwAeuwJVICp/AAG7AALjAAg7FTwVuwAbuwG9KOClWw6/xAD0AGj7L7ZtvgNIo7vIqDsDAbuVJ0sAAlsACrsEAOfdGbsIGnsIoQUK/3AA37unuxjbGruji3lyBvupm4MAErsGGwsBvAAAhgBtuwYAC7unOwEaO7oIoZzKAbsL7QfAqTsA4XsBvwAA5QAVuwAG+wAJuwBpiwAauwAOuwIYu45pFfsAAVsADmsALkseAAa7ABe7CCEADUoBwgC3ryYBwAAAtAAOmwG+J+QAsloAHBsBv/7hCqEABcYLFRXbAAebAEK7AQIAabsAC3sAHbsACLsJoQAFygBunxnVAJEIIQAFygABOwAH2wAdmwghAAaaAAl7ABsrAG0bAOa7gAAIWwAUuwkhAAbKAOOLAAk7C6EOxPtfAAc7AG6cQEgARwADOwAJrQM3AAcbABl7Abv/Aab7AAobAAo7AAn7p+sGuwAJGwADCwAQOwAAFDsAEWsAD4sADesADbsAGQsGFhsAFTsAbpsWswG7ALoAEzsDAGkrCgDhSwACOwAEUgAXewUbAAbQABi7AAv7AF+7AGv7AOSLAbsAF3YBvAABcguhAAVKHgF7KFIAOUUA/gcNDHIAKCpwAaQFCF4BvF4jDAkHb0tsXyqJHzwUYi02A6EKtAHYABYC0QNuAXZyR1IUIQNPAhU+ASwGA3NGvHtSekAAKQAxAfsAUwrbAHuQLAErAHblDREyRgFKAFcFAAFQAQeKzAB4OwQgpQBaANYVAJVoNx+LAM1rsQDP1BYIwnVzGxhWHQnRAYiQqyJTU01IEjzCifkAfxw3QCkr4BGXTwByASksMClCGQ8DMFUE98XuAEtl3ABqAnECPxF6Osd4LjXVBgUAEBsdCggMKgQfHSlOU04IuboAChLNACYAARoAhgCJAI41AO4AtADgAJ08ALsAqwCmAKEA8gCfANMAnADrAQwBBwDAAHkAWgDLAM0BBwDXAOsAiACiATUA4wDYANUDAQcqM9TU1NS2wNzN0M5DMhcBTQFXL0cBVQFkAWMBVgFHS0NFaA0BThUHCAMyNgwHACINJCYpLDg6Oj09PT4/DkAeUVFRUVNTUlMpVFVXVlYcXWFhYGJhI2ZocG9ycnJycnJ0dHR0dHR0dHR0dHZ2d3Z1WwBA7ABFAJYAdAAuAGLyAIoAUwBTADMCc+kAh//y8gBgAI/sAJsASwBeAGD5+aoAgQCBAGUAUgCtAB4AsgB/AjwCPwD4AOMA+gD6AOQA+wDlAOUA5ADiACkCdwFNATwBOgFQAToBOgE6ATUBNAE0ATQBGAFUDwArCAAATRcKFgMVFg4AigCSAKIASwBkGAItAHAAaQCRAxIDJCoDHkE+RykAiwJLAMMCUwKgALoCkgKSApICkgKSApIChwKSApICkgKSApICkgKRApEClAKcApMCkgKSApACkAKQApACjgKRAnEB0AKTApsCkgKSApEWeQsA+gUDpwJdAjYXAVAQNQLeEQorEwFKNxNNkQF3pDwBZVkA/wM9RwEAAJMpHhiPagApYABpAC4AiQOUzIvwroRaBborDsIRAZ3VdCoLBCMxbAEzWmwBsgDdfoB/foB+gYKCfoOGhH6FiIaAh4KIgol+in6LfoyKjX6Ofo+CkH6RfpJ+k36Ug5WIloKXftoC2WzhAtdsAIJsJGygAINsbARCBD8EQQREBEIESARFBEAERgRIBEcEQwRFBEgAlmZsAKMDh2wAtGYBBWwAyVFsbADPbAIMbAD2WmwA9gEZAPYA9AD0APUA9AN8XmzUhCNlvwD2APQA9AD1APQcbGwAiVpsAPYAiQEZAPYAiQLsAPYAiQN8XmzUhCNlvxxsAPdabAEZAPYA9gD0APQA9QD0APcA9AD0APUA9AN8XmzUhCNlvxxsbACJWmwBGQD2AIkA9gCJAuwA9gCJA3xebNSEI2W/HGwCQwE2bAJKATlsAkvBbGwCV2xsA54C7AOeA54DnwOfA58DnwN8XmzUhCNlvxxsbACJWmwBGQOeAIkDngCJAuwDngCJA3xebNSEI2W/HGwEN2wAiQQ4AIkGjTFtIC9s1m4DJmwA/QDGWgJsbABVWv4UMgJsbACJAmwAVAEAuV5sAmxebGwAiV5sAmxebD3YAEls1gJsbEZFNiJ9FGVAe8xvEZKvxVfKZszAVTBzYBH2d1iyUXEHH7twNw7eZF5JJRHI5EgaRr5D20/3dfONrFLSq5qSrrgd2CEUq722WBQ/LzpA+bx1oREI5xy4BDSZNun0ZWORUJqInZSyMaioyvfSI0l5uFDzbWaQ28/zdB0hwR4OQZ0/jn9ALSLNikjFYGfqR389qtFlhD3a6KdIh97rhZYpywuLc7o8ql5/X8KCbPU3L/QlmCowhRXhsGDvg6wUNprA9bM/49uxlAj7ZVy3ouEY/BgFXBNyK0TLrSjZWeJm/T4nz6QGLT3cJNtWRZVZTvIdtaxMMJRHgig9+S11LjBh7Inr06ykoch1U097Rw0hvgmOrydQyaWcEQDg0RavuMuT0zYabUZl1e33HNSK1oNUCS03eh+9C2EvF3fq9h+XBaAMFuoWeZf+mfZgL4HzyiKDIUtfNU4oFu0aE9qt3VA3U4D3fOSrAcYVnjG3cSkp1vhXZnp3JQm4JknKdBitO2NVnGCYQwU3YMWHWB87NEd+4AHuOKI8BSIH92reW0pfs+kWCTJxDCbRjFv8Cfc4/DSBYJScJYTeAEgg9wTEvcwd/QuHRHqGzAQ4fXf5FUI1lPrO+fvEcPl4JInM1z9AtBT2bL4QYEREe7KiSnnxTwtmAFjn8lqT3mND8qTktX2F16Ae9cakqJ6/pEQsHURqyqWlRMCzKXRKfCHT7sYHWx9/T/ugYTFY6iVN3Btm58ATJR5alYZybKMWojwOw3HbFn23NFyeLl7+Er82RchyYuBoGQ3j7SAWNxiYvp5U+Fq/DEzB9cG5DlJWsqkosRze92OVlCtQEYo1S1lF72Z8xWc4ld/+fFcfTEDTFb9d8tJGQ75dpJEvcWyGmGBiTbiWDdGOcw93Dmxq5ISUrmasygONfHLvhgo83HQZenbdBtSzBkvYrCEQ/xEDMhMZsN6gqplx5jGG9mSQLhM81UEdEeJ59sdNJDAFy/gPyJoKlwPZgB/MkC/kICLiCB8va+nCdO2ry4aDfkmPFpF/H/SGQ3LJ6aAv9dtJ8DniHtLOckZix0BVb0iR5V3LAp521LBSIi6AtV7r2ZB/hQEvAw54EFNOQcFnl1xGUIc67tqK1INNwD2n/RbwgzO9h45LM6VMuN8V1ZNIQ6t+Xy3lTqyVCD5kqLy/t3/b8MLbgDg8JIWDkSZ+LrGhhr+gYpH+pr1TnCUnZPjpUdw6bSL6MWVXoDDciQDWECwU2e6VEpfrcOBbrSOijqGkEIoJPbpmeJLkcwbvA0yWIixQVjo0HnYh7fji+Dfdq1mtV1lG2Zz9R7eFMHS+FK7nybutu2fwzDpFldO2pZBshsHJWaltn3PWOoGJpCT2jE8EHOuC6FkejNWcfsWCqNqMLP9xTwcWArj2EiiI7D+EaDi7/2cqHL1gPiF6C/J7aUo7RQqogPZ11WqbyP97nsoMxPOC78wZMF7B1Y0g7JNXJV/nN1m4xx8hbqWz07KSaqr5hE4icB326DMR/vUKX9LoNjle/ZWtbUhrTAcsdgrLlG5Ne8aiR0bS/2ZhpNOVVxavWIZsEM/rd68EB4vjbbD13NkMK1qvMk74vGbSkL7ULO0sZ9R6APSCo6KH+Xn98wEdw1bCPAnDTaBsD6sidAGN58uiH4a3ovG1KyZAu2XtyGgF/vgWKGxw9R1lfAVcfuYE71DHuxtTzfGZnHaDpDGWmfEq0N4GawE7yIkaoz8jcmVmzJe1ydM8q0p08YIxFcY1YcqQc1djWBEoNETDFcgk5waRftEJasPREkrV++N/TOKkERF1fCLrXS8DFGYGRBeECMQRNEs0ES3FzUtXCcNxpYEM3Uei6XodZruXUIRnn+UXf2b/r7n1vQutoi6WoIbW7svDNWBbUWcDUc7F9SJK3bvSy9KIqhgyJHoW2Kpvv0J4ob14HFXGWWVsYXJzjwxS+SADShTgCRjhoDgjAYRGxwJ1Vonw+cpnCKhz8NQPrb0SFxHIRbmG95Q2hlC4mDxvPBRbkFa60cvWakd7f0kVBxxktzZ9agPJEWyA63RSHYVqt8cPrs2uFJ3rS3k9ETGKn5+A6F9IOrdZHfT1biEyUJKEvwzuscwshGCBJvd16TrefW03xVnJf4xvs72PdxrMidjJO8EiWyN/VWyB3fv9kc34YIuZTFtXGo9DuG3H1Uka5FgBMwDPEvRcSabi3WakNQkXFecJlFk6buLVk5YHpuKWTw6oF632FPPSVIVl5hgUAeHhj0t/sw/PEEvThLQDDFE34eCg/rLOyXT3r+L98oRKrlTO0MdALYQ3rRQqC7d822dJPGxF1K4J2TtfPSMFaCAg0n0NGk9yiaKKOJD1v2aBX9HUOIawjjfvwCmjHZJTR62R9c9x33JnBjWrN4QYEOmehy0oZMP9XM9Zyi6TYoe07PaLceRXcCWZiY/imRUWW6+mci7+wMxSdwMdbXckXtvhJH8sc4iQcTwm7yp+3f7CaesTTQB2qkgeXh+wFiSMXfMlH7Yil0OoZ2QTtRLTip2O0cLZ4SstqWHZ6H+8A2kZXhpm0kPbL9dUanTOvziqIUh6Ambwa3WrCb2eWbuCN3L1hgWUmjRC3JoL3dBhR3imSQI8xuCMfsszlji7cSShNSYdqCXPxEVwbqO9i5B6hf93YI7aeyI8jxgcVXK0I/klbvhSXjkjOIwZgPdVwmsFW7HGPLUAvDRuKm+itybRg7c8+Yqqjg824Qf+/NxsBSUNAK9KCoJpauFqK0XQULrWYj4FnxeKDuvr54iokpi+D57e6Y1zxRJJdsHnDR3JyraCUufHBRTKODWBVzthjm4k3/Hv+Q990XDVR+KW+TcJX045LW86EKhz/97aqj89A8ZvTk1//tczosU90loIPVaHuWegJU3wP//7XHcO7c0yQM2jM/IhQKrf8hiObHWiWDZManF8Uf/HzbmDfC2wT//aiZ4hGTv/xzgKwdb1sD6cGEkceow0s3b89/zg+3plyRm0HlZi886j5wUwFhdHiDTaBidZRo5cx/tMeLyguOATbzq17ydhzbrpxunuHx6lbFGiO97gsd4dk//7iCIo+Ew+hG2so5kvv+ITG4c1fzHPtu1Xn5QfUnqY3/uByVmB7gmnE/E+5zdm+6nDmoews5fr+NzThdSHzK4bBQOL9c4O8OI0xLSqjJ4lbniLJg1aFpQRLwaSMZmpkC9e/j6FOVrTQ6a/a4alGgfrl2ZL1sbHUQ3DOI7ntq9diHFfm3t1mul3rdJEJCHnlW/hlQntipMrpeMs7fUr6wK370D7VbXH0DUHzdYfRg/6Z11Ult1sffJS+heHbco15Sxy3+rDnPesqH1lajk0yu02hPUvEUqvcUXWXL7Ad0wNGMx5gOle4XJxq/r/YY0xdco2wRSEGwcT7YADlBrHc9ZbvzOL0QwyWCWWChB9Obg800v7tyBWaNvdwz+fL7Ph9i2irEeJkRgOzeEDw+JiD/V93vH9FgMEoFIJMoIuogmicZohf94SBuPn6hXaV9jP4VVVA/bu+Wg8S88GLtmEPSNRLdtlXx2XL/nuM8nKkhnlnjaropiKKLIH94pLIASci0pDBfj9Hi5BfaTSXQg5+PMjQX91Ktk4MOqK1K99l4BRPv5+vNovGZ3IxQv8ICvjV4/diThpoaM8uvd3D9d/DE477w3yAbW3IDm2i73pZ9aEj38JqS6h/s8/xgmUIVcuq2JTgefAyuoafzQxAuRASeg3NtG3ach/JEkyuX+JDt2PnDZTShUhyHHG3ttBg/6lhAchGjLJBtopj4e01MlCp2yqQRTr4sBBXru+lKaoanwYX8y2aWCJiR3KnhCOkYVFSvsO0oDRujUFOEptiNDTYrJoUbvOyvl4AhC9h3wORiTXK1MrpMfnvdnndnR/HRVSusMBgIxwrLdn3vq1VcncPiD0SquTx/kNmxeFyCT4uXVUd9AL+rSGmuq7OOCzDKeVPjiNWVaoP5KOFqYq5Xcuf/xW9S+u9eIq9GAtZWtQlgkRecjRtvG1NR4WXXpn+pwsTBTIy079Ikg8rSef1aVapIFcXCd6C2wHVjLXR+N0tw4Taw6x6H90BFRgNrtlq2up6hHKuV3inM5RJaQWZHd84e6RsKkk9po3dk9by54tpPw7cBkFas/G+GbHwuG+AwP55BZyXILTHCIVrPpXHEaUPYfL6nphJP1Rc10xG4UaCeY4IHCwuur8xmSQDgY4aVwhzWhjbtSHG8JO6P2i2nC9/0Bfx0zk6dYQq3aw7k5vIObD7SEKrxhz0fQ0+YTOfHW23CBNeZci1qNsUDhoeqmfyP6PvjoEjHk8QbrFyQVZPHVWijnb8YCM65iYNoEbvnchStZ/9cKg5Vd45j8KnB6UjzXl/bkyZx7VoD47ocUUi117WwgySSb4rXgLJ52Mv5XJbp3I+uBP81BUvOjy4Cacgi+GWWlC/8dwgqwiojjUBDnEOxyRyowwLQfytFra1OZS4XvRYr4uoamAfG3I/p2bA7G90yqKThH8Ke00Tqd+3l3dmJpaCZelBMYjGqNLVa3SM4+LQeL56gY6Bymy2LQPVOxjWfj5tq4o74swcxhyGJPynkS5xAjOXZP1/FAYcBT3u6qLoIkEfErwo4gozmyI1YCvM0oyI3ghjGPQSsof2sKUhq91WsKy9cYWN+4A2v4pG/Mxpdc6w6kI/HX7Xb0TuihmsiOy2wQIsrZbUmr3OBSUo6oDJNgQp+YqYkgTgYcWZDgawJw3DFfdzT//PhVUidgB2qa8uw/j9ToHBAS33iT8YLhhAfyXG0bQUFp7QmH7oQ3i6Flf4OTZLvJdh8pfuflmWu2ohm5pTiSg1pl3vq9uluTJwqXfh1hqy8e2iHoD+Y35gCIViTo6VOtK5dD8HYClucJucXASzwe2kPj4S4eYQtmkYHagXhAzp/F541xE8YFYqSPszDuz3soWzHy0p3E2jwZNQaIcGU9FNQwQxeDw0ZlK9dxXrj9IUHGUPTOyib8CqXmbZ7Ex54bn1rLx3qqAavu/gh6XjV0GmN1p+yyMK9HN5uYEvxgbAk43tsheREhyI+Q5WLIneKTGPmYiM/lxOp8fvqHy8YgXK0TlMiX0tliLI2JtfmWZP8eVV732sdYm+pcWzDzEmKLJZyeelyaZKkjPnnUO9keDwtgiLnmd5+t+Sr5y8brRnlvxcWEWfCqIALQYHvaXx6jTg4dAlye469uGwwOZVZCILLfGjaMg4LUCNMTtMSp1aC2y/3wR2t1v3w/iNBRQ+bNbtDqL2NAr7K4rUcyqbSpNrXZgAWXvjxBBtfYLK1uRYt3q2pfXJOAL0HtWcEwJLddOSJKV1SwvcvEuzg/4MPnA8MIUJOLqm3qI6wFyN99Ck6zYaV/zGSAzF/PGsaNa4vPLe5QnyuqVUnVQ6xELA6gbe53aGgeke+R/ycb2LJVyc7BhuzI90zA+c6wUDTb7NH//gdDSl2u/aW7lRJm8m1fLtPxcNuEM5JbkOCZKPM88HUsLRoC1pmKKlvWyeAXuxILbu0snpSxf8N+RgtLUSe5n2gdjOjoSTaN7mMZ7bF+cWk/MS8mFD4pcyl5UN7CbpFZH2a+Pm1VAnUTVfbw8qrmz1G9m5aKmRzY1SMhhPrlCn2t4uNUXNA3IFe6NOjSC1DEaAFZAfDlEkQCsbNhsZPj6NQPDSB3tLiTo0ZYoEbIeEIaKtU3Wk60rEszawTFuyHVd365LA/c/uarABN5M5rGq/dqTG3Ilye/5EKiYisisuzqNaZjmWv0z9TORc0CKbaTea214oNM9u2sXUZub/eqM3Pi/PjRSyQiOSwPWif2asTgu6hS6fb5UGosCWxdedMqdViIUUSSdIJx+qQ4KShfTT39VAWZbi+mB+iKICNwpt6cflY57Rcbs6d1kA26Iru73cuxYVlSvuJdcR5VfDYZRk8X0AXePROyw3Le6LaUdmTLzYsoNhhgQpd67xVNiHgk3pakmndeIAtTC4DCXy9oS6eU4CWxDdVmY53pKNbdAKmQsP37lrJZC6iDXMELGKcHjNuuZgcDyY8W/yv6ha3DX7OWm/35fpvhw55oitf4V+GULlcPWYyGGuVBdro19c8u0RDddDun40W7G5cSIzHLh/qZxb59R+EPY+wZ2XerkUim92hhXpKyW6WtAh6zQS97DrPyjCvKi3pCw96LeKynOpyjtsMQc2RmI/20zFOZcSa2AK++PoRcT6zeJyxlBZ7kk5mhqXGkLlM2hFKc+/T544xXP0Ua38Q6xdPTLTeG1PHnLMaOvksUQMrEFTB/lizCirmFQL8zYVU+OTeYQEFaITsBSMMYexS9HkajO2gGIf2micvntCZJsZQEwIH3/4JGJQGflBuH5rNXmnRRYXDQs3ZoEQoMtYDr1kFKUS/siiQSUxcTH9XYeBZiKDDFQoExREO9dddKQLO3BwMHvymCSTFyY+vxn3D27NDx6OlU092D5EDUwilttqVHpjJQDUceJYCLsK2swfXeNUVrBJT/w/sk+7si8rPtiMFis+oxvGdGQxirMBID700T39mULuNHzOyN+xBfcFACZcyngF1aSpv0JPkNUrAZTqfplv509cGXFUiEEm5dZb+OsP/blizqdK45/dSsIrufYTrCPY2lgJD6k6QljTfXVlHfYKSq+MsagyUcaMintyr95bD8kdTAeYNLNsMmo/Wdd8a2nStBP49ARIjqqpUHWY4q4mvO5Cq/CgCP+4/B+5zutGwX5pssgVLr1+fIM7WWLfiUQDk4c6ZdHZOWv5hG3g2dgQ5NXnpIY+BWwJpaouf25bXnjDzbHnQNofH/c6m+dEAS9Gs2h7pFRPKOBDnqswZ8KZjhId1ytHUTs533KwBoSiImoxKQUgZ7z6pA9QB3sZ8Cq0vwutJTTkfbX8AzCpm2cFXx/P22niUMHauU8IGc+78R6TsutoonoqFuoNA3l80t387YHMoL5KGAT1JO4zmx+vJ0LbLHlicHraSVYvJjnO9p++qnWgKw9OwFVVUagvZuf9qfiuum+hIicxP1q4zDnzkHsCNriLxBpxY9N+UOmqzdY1MunLMDgkMyi3uvnN3UBXJeZ8YLs5xr8QrOhimYoKuGBebZHAiBIkViv3DG8k2oNpp5OIgX6ulqaRN8V62QUPjn5tl1kPXhT9bcd8qIm8gi4or/FGbvQ6pgGSHmnayrugmf5E0upGxPRf/3xOtitGMaHLKJVm5zhglmVfI91o0yxhJZVS/5wQ8zfxK8Ylw0WmHXoGfRkoBRx9Hsnl/6sgTjAVwpmNuSeZtBwlX4qB8Bh8lxjqBDIuFGJ4I1wxN0XRlAAslzqMKwQfyA7OkuivCXfv+i+3XmhcBFM2n4jdT+NyUmBnQJPV3F2sZfKvJhUlXzSosFR4VevVVcOkFnnjdiRWc0TeSYxj41sJGYMbZTeLI3GvyZ8/gAAudQ1+4oFX+enX5V49MczGCYVBuoC4kHjp7ZVxj+clBwPr9k+v05SsezQK3enxLs1Nt/N7c7AImVUysjGou4iOohHo83Zs9/MI/OWB+OyXzOBD93NbApGHXrv8CVRHp2bwH+xB55cfNrdqFD35HSMx4iVmtzYAmSCIV8kXsHoq3DIb93riTWbubnjxbBW5zConVtbxLRStXHkIyAByaozME952Gc9aAdAbBpZSVCH88Uwb/4bPTVOVl+WoMYD7JIvK8VcMrJ8zHV4bbG0Dg7Kx17A4ej/ZcZ2Z5pVuVLUH1E/AccUTKm81SE+LQ6STTUDscUk0x2OWIbEORhg69tdoTGNkA1RfkGIRZHr5mCXOpLC55WWzCZoGPFUVtZRHwh0nq039CDdjEPo+JyaxSQAvDgR6Iqvxy0frrtEG1A385N81l05SSzN+IDm9bypF9m92EUqblnauZ5sjc37wRykOdl7w4o8WMgQsjii3EE/aJYDfHs1cH6DNBEujjcCc8qAefYFyIAURDcDnzun5UmkbBQsU4eu/W8I9nBE0qJKTdg2hwjq0+XV7a3TJ7R+alvJZCRia9lJ+grNB9dbrOmWEvUotMjvDhq4wV/kq4fvIBkzUGpDeYH74rne8uU3dgoNZdR9pUL6q9YDNRfOiF6Dyk+SYXQIghTjm9qR4tBHh0gnmF/9q3Qv22EzaLhSvDlDOxMrrCNRmLCl1jApzLrBCPn2mjn5zqK7OYK7VxOfQ5GfBfoPdyQwqFEgCVHkJ9oTnagRM3R0+rsuN5jQv9icCav/p1WqiEXSzCdLd/WEA6z6dDP7tPqPbeDYKAkVcz1lLGbFOC9b7cBd3MV0Ve8dZ89oR7OnxGS7uVpSry8banVZwpJg+nkH1jRBYa2BvBMY2xITH9ERXCjHzdZxs+ipdXP2DY7X+eWiBhtT2L0RRGTLPeazn5tpl4tu8iE2rWig731iuJDRbCHHy+g/Mb9+miAyVqfIpXT/iZeOxOxODO0hEpLM78I1+G2Z45yi3lS1K3m4WMQ559Lp4UML5vZUjYGJuxl+OPpUH5klpyBujkjprhei0TmUik10gjvNUp8mDkWlNKikmYspaVTqewbnOzJrmz8FLIpsT67EJLHIIfeDcWEfiP+DJrZ1jfxpoAb2abeMqLx+9RuZGzQoYtYVGgAWwEM9Kek2vPIeBNAKD6ao7nw6sgvfeLZPoXkbYO/tStHJdKzk+WFSFEU2NcALJAEP6S8pcnqqBBt57dwTrzQNCIdk2SocK4dLRbD/pu/VryKnm65ZYXiJCfHJk3mx9MRSl+nSK6OqEBSoGjz0/LADddwF/HqcfK3K3O+6YUGQcmj8pZL4PhZ6KrGkb8B38FmDvvLd3XQXbvS/FQmrXFTvJNkaN/FGo83KuS43BK1UfVnIqigGkCoP5fBda2MwAGTGNKX9K9t4Bx83pMFc5KSORmWKv+8VoVggWxoaBz3/9IBh6RwLd1tebwy89xvE5z6EEpXpDfrXWfRsMs6+ekUHH6idVosno55+xQ8Zqzelh0bxtJTgCcH3Z3/Cxlx9eNIS4JIFKOAVrDqbrXRszmY55a5+niJGHtkO3b6mnIDxLa1WXc7BAe33mt2KyM4Fbc3R6/WVTQN8QhlqAtave2WsQTqzWeSlKuGUVIJRqtObpv294rS0kDN1RKzdstZTXJebR2HlzsQ4P3NbMHUqFZMZw+/IKXnh4t+lY8qocp/B1oMszR03EFs3bPeND8QkItMvllObeCz3SZAjqZrobmLcrpFyQV7mwBjg3C3C8/bc5goQhv8j/IXMLGnt4mF7tybRDG5G0polxoUScQkPvmnga2/K+aapKeqSL0BTmo1Cm5g+booNOtdyKva2KoefRURaBk7113QKo3y+WTuFKtgETIK8HRluYS9DvlcciCDvnG8UaJRfZE2siZsiTHvRmN80xkUIInHeRZl5Re/+ATL6VhKFi8CZ/n/jbFV6T5pZ+Uoppvsi3qjacVFOJgWWfdlwVHKPW/TJO3na9hRM9bS2yo2rEsC6IBzRReVO6IesJU7PItzOamr+ROFfwGZmZ7ue8HNxAgLJKb7P3p8dMqk6Be5PJaT/5Rdc1deYVihWH9cjVKc9uz5EnfHqxLUkOO8iJUENBNVf5LyNy8zjLu/78k5WNTywiPfYeX3CPk7yc6CI3lum/CEZwfUaNpcI3KsPqfn2lmz3kd/acQjKA1ebkJaiuLD+epQ/Fc1llHXXMzofWzz/Kd29SNmOhcjMWw1jq1g3YfrXZ9rzXDYW4ZttfgfMi6oCUtBs0PkMVuxmq5lxEoCaSXPSqCJJ7MlKdRDidVt0AFlxk5cTdX++sBF2+E35mjwfm8ERVxH0FvuAQtsfA4V2G0TKTUxeyRGVjd/u6F1SvuAiU2/WaQjcNCU4Ep7VunXCYSbZj3U3wzu/LWM5MPlYuyQ3FOOCD/zt7K295hY2JhwF+ODDIZ676vGQFKveEQYkWj7lkK7rVmD7MhU0Y/tF8EcTTpo4/yqOufbd/zWIpMajnbDuWK2vn6OPPtz2rc9MIBNlPd8tt+yf+7SC4wqEPbozKMCwY5Bygx4JmoIEDsixWRDcdHd6S3/dZMHXOJAAv7+NIstl00crgSqHZKAEe4g3G4dzIV51EeZB01r7p8GNlfUnG/GjZgNGsqXZdYMBVtAtFNv3hJWPve4GvqZ2XxuiNkHTz5kxWgr0PjQdJlVywJ9Zf2ZvqeeTbolKtvK54re2Lq5BoyzfsRtvDfyao3kmyFzDQ88nM+qx83w74RDlkngtYiArI05Epre3GgBeSlMig0pE6RGQaFznKkGeb0SozLCyiOtxh7hgwZlbKbClzUUfC8ntMiHUOZE375RhTy9c4DA+oMLkUDkztSybZbdmP1xpaIbjUpPAHBq3cIq+CBFzbMlMMCCkUQ6d9LGV6GYCsYiEWZIy3nBnuxOYXeU4YTGDSin9e4/pCjPtQSHlg5LMEvIlF0ElthqrF129iK2RPBEWd3XWOl3SWV5uz5VUyZYp5kEFmz7QfP/B1W1BBzQ2iTGbSVT79lUHzcGXz3PJceSgz4uknETUwo0xffpr2KUvZF0i/r2sL3IFIClYx8CbIZE6Qt7MDJbOPB3xMScwaOcWG66IJfCnDkb0D2Mb+PHzX+oiCbxeTIogtyN+s2NJirNACk/OACSOTtV6vscwbzW4M168xqaI+RzR47S1nlV/rOoZnid87n/Ima2XYa3un3BuGAisNjb8eLMT9OnMtazQROFCuO1HiZXaOc0oUDbNC4eKLToOx8DzVhMgGA8XIAQ2x3b6I0uEyLssQjJX3QphcUMx4KsMgJ+72km4N2aqkBF2coKmUEt1eqIMGn+5txMT4kYVGd3ALO+y9Z4PP3d3l48JQK8s9ZZ/Qx/+NBKgBEJFlQ32psoJiihGO7FSYM5L81q72kaAYcilEFMG+ZK1BcMqELkflyCV7v8JEXLO4Rf/oZYNZHZVjJhfL6fnpP9Tio3Euue5uS7FMkfGOeRCTrBZ06Caev7tgufeTrX34Ur/Vvc+b8ksiIShNJtuF9WmYxOZ4xg8y6zTdy3KAB2y5kYkcRnXsptWwAFyKZ2I/QGySNeoQLkINUMloC+5L3WuMMx297Q1xUYLKqZ9XHavaobo6QQv4auMm+i84IhxRpPt9nUmcav9NcjCcP+TcMmxsQZ/F3mgeoA0fQgwvTsyXuuTaM3Sqtv2jaaajmaFQpK9W6uIbeqwvSDo34ZrY6elDUHwSCjHRRmlwmyy+eOra64Ssq0XSXYljMHtKY+FShcMkHsEUY/4Bw63dJ6KpwDaxmthlDdbdE+TvYF3v33cGSKqO+1H1pKYhJMvZD5ckQcHyNF8zrtiR5b0ko6NPGoRexUZTYP6VbUdn3zzxGBOi8Z0OqHjGqYxRXwN3mYi0GYEEZYq+Q3QvdKcEHILLLj8S+VFepSfErtmfZCdvxbfIifFSpEzKi+7VJsLMT+zEFeyp1OdwRC1VZrfTLIyR7xTPUcZFYPD9qI7D70uTb4hdpqPXsJIRNYbZtNwch1OI3trh3u2ScoQyM9POnInsUa+OovcwkUP1UfIzPb95n4BaF2ev57NHAej0+BVMF9/Cj9663HN2/JN3SQgslL914bKfiTTDFAz9PlQEL/dSv1H8xl3mtWxh1McFO9EJXlRDaKQDsyKO4vOJW90NFE6yw2tjbc2GeF95sbs0I9enAa6QwQVf/kJQhAD2BzUDKggOyjy1TEhED6sfk+418lQy3c/uj8aw8UEzZ6hIMCd8RohAkumMtIj9m73l2yPWoGHVTPaywkC7Yj9tBM1NxMgcrDwRtk4RO2WHT7Ql5kQCKdJj6kNuOTeyEBYBjLMhGz+O5/YGa84HEiTYEpZ6fFzy26GG2hWtTyteuYrhSyG56BjsT/wQeLRytpTY3D7sIMqZnJ9z1FDrfyjFlGl2TNw9BQysbaxOuwYYZs/7I6BANgkqCknWZC7/BBXvaeKwAmC959I+G39BUE9bExkNlbRoFRyEtNzv+NJ91FuisG3JCS6uYBeRnfv8AkAfKTeg9EYamqnsGfAV7d0f9DghHEQ5IsPGDIUhgoSj7obM4Bu5uhQ3/CYEDTHc92AsFvDK4XGrwUeGBWBHPlS+f4x+CxmmHz2sAGmSFNt65kwZC64mnaoWlu2310laYn8r62AqsR5dfjyK18MEdurdagldzfJtjFXlZs7St4QhdPiye6TPh2/ZAQLU/Fip5s7TDEM16KtRWrK9hmxnQ7bmfa/+7pa10Z8WDPK3NuJ+NN/RAbQ5vHx2uX0Lm7/w7cAEH/hvZA+mt7J7zGw7YtQYwnNN6dpgwkGjjrS3yQoeoYt1EnczmtmJfQZWzUlP3Hlg9Wzlr9IH23q3thGth+QNEANFettxKfskkGOlLk8AqoKJwDqOxAa6UzAx07plSSyNBJSGco9zjnC5gGbDoKvsMDuBR6bGRlGzJ+hFsGa/Izt78aI+WZ6dJlZKp4pGISuv9rV0sAS0MWEwCmfauO7oQZMiakHU35LBxiyJoOMddhUWgcZuC8r4Ksvn75TTcQXLJ7kWtYhGuGqPd9dZuFjBWQHNwosXY5snbHFQq72CvHXhIg+shQxycuLOuWYErwCLZeF24b7F78pO7xw4X6lIAR02hUOf5087Rl0nOaeb6CK4i/KA/EZv76ftOWZtjwxslNr0E/u8rWUmnf3amfg6UZmBAluuoj3Dd7UV+9IAJ6iYcDfSJlgmIImohjfIUMJ27z+opj50Ak9af2LCNrWrBJvMovA1OeNO+MF/MwZvnaCxTgG7Cw4QfSPF6AYCGFt21M8PySZFeV3t2Rqqs5JMzMYzGRgq4o+UaKRgBf9GHi/9X9HXA3wxkCsd/UhnHSh2zUVDiraio/6nP4y3XJqs8ABfALAtCYU7DHPMPRjgcM6Ad/HiSXDAbOdSMkvGZPAkHs8wuQTy6X2Ov/JFvcPuKfV3/r9Q28";
var FENCED = /* @__PURE__ */ new Map([[8217, "apostrophe"], [8260, "fraction slash"], [12539, "middle dot"]]);
var NSM_MAX = 4;
function decode_arithmetic(bytes) {
  let pos = 0;
  function u16() {
    return bytes[pos++] << 8 | bytes[pos++];
  }
  let symbol_count = u16();
  let total = 1;
  let acc = [0, 1];
  for (let i2 = 1; i2 < symbol_count; i2++) {
    acc.push(total += u16());
  }
  let skip = u16();
  let pos_payload = pos;
  pos += skip;
  let read_width = 0;
  let read_buffer = 0;
  function read_bit() {
    if (read_width == 0) {
      read_buffer = read_buffer << 8 | bytes[pos++];
      read_width = 8;
    }
    return read_buffer >> --read_width & 1;
  }
  const N2 = 31;
  const FULL = 2 ** N2;
  const HALF = FULL >>> 1;
  const QRTR = HALF >> 1;
  const MASK = FULL - 1;
  let register = 0;
  for (let i2 = 0; i2 < N2; i2++) register = register << 1 | read_bit();
  let symbols = [];
  let low = 0;
  let range = FULL;
  while (true) {
    let value = Math.floor(((register - low + 1) * total - 1) / range);
    let start = 0;
    let end = symbol_count;
    while (end - start > 1) {
      let mid = start + end >>> 1;
      if (value < acc[mid]) {
        end = mid;
      } else {
        start = mid;
      }
    }
    if (start == 0) break;
    symbols.push(start);
    let a3 = low + Math.floor(range * acc[start] / total);
    let b4 = low + Math.floor(range * acc[start + 1] / total) - 1;
    while (((a3 ^ b4) & HALF) == 0) {
      register = register << 1 & MASK | read_bit();
      a3 = a3 << 1 & MASK;
      b4 = b4 << 1 & MASK | 1;
    }
    while (a3 & ~b4 & QRTR) {
      register = register & HALF | register << 1 & MASK >>> 1 | read_bit();
      a3 = a3 << 1 ^ HALF;
      b4 = (b4 ^ HALF) << 1 | HALF | 1;
    }
    low = a3;
    range = 1 + b4 - a3;
  }
  let offset = symbol_count - 4;
  return symbols.map((x2) => {
    switch (x2 - offset) {
      case 3:
        return offset + 65792 + (bytes[pos_payload++] << 16 | bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 2:
        return offset + 256 + (bytes[pos_payload++] << 8 | bytes[pos_payload++]);
      case 1:
        return offset + bytes[pos_payload++];
      default:
        return x2 - 1;
    }
  });
}
function read_payload(v2) {
  let pos = 0;
  return () => v2[pos++];
}
function read_compressed_payload(s2) {
  return read_payload(decode_arithmetic(unsafe_atob(s2)));
}
function unsafe_atob(s2) {
  let lookup = [];
  [..."ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"].forEach((c3, i2) => lookup[c3.charCodeAt(0)] = i2);
  let n2 = s2.length;
  let ret = new Uint8Array(6 * n2 >> 3);
  for (let i2 = 0, pos = 0, width = 0, carry = 0; i2 < n2; i2++) {
    carry = carry << 6 | lookup[s2.charCodeAt(i2)];
    width += 6;
    if (width >= 8) {
      ret[pos++] = carry >> (width -= 8);
    }
  }
  return ret;
}
function signed(i2) {
  return i2 & 1 ? ~i2 >> 1 : i2 >> 1;
}
function read_deltas(n2, next) {
  let v2 = Array(n2);
  for (let i2 = 0, x2 = 0; i2 < n2; i2++) v2[i2] = x2 += signed(next());
  return v2;
}
function read_sorted(next, prev = 0) {
  let ret = [];
  while (true) {
    let x2 = next();
    let n2 = next();
    if (!n2) break;
    prev += x2;
    for (let i2 = 0; i2 < n2; i2++) {
      ret.push(prev + i2);
    }
    prev += n2 + 1;
  }
  return ret;
}
function read_sorted_arrays(next) {
  return read_array_while(() => {
    let v2 = read_sorted(next);
    if (v2.length) return v2;
  });
}
function read_mapped(next) {
  let ret = [];
  while (true) {
    let w2 = next();
    if (w2 == 0) break;
    ret.push(read_linear_table(w2, next));
  }
  while (true) {
    let w2 = next() - 1;
    if (w2 < 0) break;
    ret.push(read_replacement_table(w2, next));
  }
  return ret.flat();
}
function read_array_while(next) {
  let v2 = [];
  while (true) {
    let x2 = next(v2.length);
    if (!x2) break;
    v2.push(x2);
  }
  return v2;
}
function read_transposed(n2, w2, next) {
  let m3 = Array(n2).fill().map(() => []);
  for (let i2 = 0; i2 < w2; i2++) {
    read_deltas(n2, next).forEach((x2, j3) => m3[j3].push(x2));
  }
  return m3;
}
function read_linear_table(w2, next) {
  let dx = 1 + next();
  let dy = next();
  let vN = read_array_while(next);
  let m3 = read_transposed(vN.length, 1 + w2, next);
  return m3.flatMap((v2, i2) => {
    let [x2, ...ys2] = v2;
    return Array(vN[i2]).fill().map((_2, j3) => {
      let j_dy = j3 * dy;
      return [x2 + j3 * dx, ys2.map((y2) => y2 + j_dy)];
    });
  });
}
function read_replacement_table(w2, next) {
  let n2 = 1 + next();
  let m3 = read_transposed(n2, 1 + w2, next);
  return m3.map((v2) => [v2[0], v2.slice(1)]);
}
function read_trie(next) {
  let ret = [];
  let sorted = read_sorted(next);
  expand(decode4([]), []);
  return ret;
  function decode4(Q2) {
    let S2 = next();
    let B2 = read_array_while(() => {
      let cps = read_sorted(next).map((i2) => sorted[i2]);
      if (cps.length) return decode4(cps);
    });
    return { S: S2, B: B2, Q: Q2 };
  }
  function expand({ S: S2, B: B2 }, cps, saved) {
    if (S2 & 4 && saved === cps[cps.length - 1]) return;
    if (S2 & 2) saved = cps[cps.length - 1];
    if (S2 & 1) ret.push(cps);
    for (let br2 of B2) {
      for (let cp of br2.Q) {
        expand(br2, [...cps, cp], saved);
      }
    }
  }
}
function hex_cp(cp) {
  return cp.toString(16).toUpperCase().padStart(2, "0");
}
function quote_cp(cp) {
  return `{${hex_cp(cp)}}`;
}
function explode_cp(s2) {
  let cps = [];
  for (let pos = 0, len = s2.length; pos < len; ) {
    let cp = s2.codePointAt(pos);
    pos += cp < 65536 ? 1 : 2;
    cps.push(cp);
  }
  return cps;
}
function str_from_cps(cps) {
  const chunk = 4096;
  let len = cps.length;
  if (len < chunk) return String.fromCodePoint(...cps);
  let buf = [];
  for (let i2 = 0; i2 < len; ) {
    buf.push(String.fromCodePoint(...cps.slice(i2, i2 += chunk)));
  }
  return buf.join("");
}
function compare_arrays(a3, b4) {
  let n2 = a3.length;
  let c3 = n2 - b4.length;
  for (let i2 = 0; c3 == 0 && i2 < n2; i2++) c3 = a3[i2] - b4[i2];
  return c3;
}
var COMPRESSED = "AEUDVgHLCGMATwDUADIAdAAhADQAFAAtABQAIQAPACcADQASAAoAGAAJABIACQARAAUACwAFAAwABQAQAAMABwAEAAoABQAJAAIACgABAAQAFAALAAIACwABAAIAAQAHAAMAAwAEAAsADAAMAAwACwANAA0AAwAKAAkABAAdAAYAZwDTAeYDMwCxCl8B8xhZAqfoC190UGcThgBurwf7PT09Pb09AjgJum8OjDllxHYUKXAPxzq6tABAxgK8ysUvWAgMPT09PT09PSs6LT2HcgWXWwFLoSMEEEl5RFVMKvO0XQ8ExDdJMnIgPi89uj00MsvBXxEPAGPCDwBnQKoEbwRwBHEEcgRzBHQEdQR2BHcEeAR6BHsEfAR+BIAEgfndBQoBYgULAWIFDAFiBNcE2ATZBRAFEQUvBdALFAsVDPcNBw13DYcOMA4xDjMB4BllHI0B2grbAMDpHLkQ7QHVAPRNQQFnGRUEg0yEB2uaJF8AJpIBpob5AERSMAKNoAXqaQLUBMCzEiC+AZ4EWRJJFbEu7QDQLARtEbgECxDwAb/RyAk1AV4nD2cEQQKTAzsAGpobWgAahAGPCrysdy0OAKwAfFIcBAQFUmoA/PtZADkBIadVj2UMUgx5Il4ANQC9vAITAdQZWxDzALN9AhsZVwIcGSkCBAgXOhG7AqMZ4M7+1M0UAPDNAWsC+mcJDe8AAQA99zkEXLICyQozAo6lAobcP5JvjQLFzwKD9gU/OD8FEQCtEQL6bW+nAKUEvzjDHsuRyUvOFHcacUz5AqIFRSE2kzsBEQCuaQL5DQTlcgO6twSpTiUgCwIFCAUXBHQEqQV6swAVxUlmTmsCwjqsP/wKJQmXb793UgZBEBsnpRD3DDMBtQE7De1L2ATxBjsEyR99GRkPzZWcCKUt3QztJuMuoYBaI/UqgwXtS/Q83QtNUWgPWQtlCeM6Y4FOAyEBDSKLCt0NOQhtEPMKyWsN5RFFBzkD1UmaAKUHAQsRHTUVtSYQYqwLCTl3Bvsa9guPJq8TKXr8BdMaIQZNASka/wDPLueFsFoxXBxPXwYDCyUjxxSoUCANJUC3eEgaGwcVJakCkUNwSodRNh6TIfY8PQ1mLhNRfAf1PAUZTwuBPJ5Gq0UOEdI+jT1IIklMLAQ1fywvJ4sJzw+FDLl8cgFZCSEJsQxxEzERFzfFCDkHGS2XJCcVCCFGlWCaBPefA/MT0QMLBT8JQQcTA7UcLRMuFSkFDYEk1wLzNtUuswKPVoABFwXLDyUf3xBQR+AO6QibAmUDgyXrAC0VIQAXIpsIQ2MAX4/YUwUuywjHamwjdANnFOdhEXMHkQ5XB6ccMxW/HOFwyF4Lhggoo68JWwF1CZkBXwTjCAk1W4ygIEFnU4tYGJsgYUE/XfwCMQxlFZ9EvYd4AosPaxIbATUBcwc5DQECdxHtEWsQlQjrhgQ1tTP4OiUETyGDIBEKJwNPbM4LJyb5DPhpAaMSYgMMND137merYLYkF/0HGTLFQWAh8QuST80MnBrBGEJULhnkB78D8xrzJ+pBVwX/A6MDEzpNM+4EvQtpCIsJPwBJDqMXB9cYagpxjNABMYsBt5kDV5GDAm+PBjcHCwBnC4cFeeUAHQKnCKMABQDPA1cAOQKtB50AGQCFQQE9AycvASHlAo8DkwgxywGVLwHzKQQbwwwVAPc3bkoCw7ECgGpmogXdWAKOAkk1AU0lBAVOR1EDr3HhANsASwYT30cBFatKyxrjQwHfbysAxwD7AAU1BwVBAc0B820AtwFfCzEJorO1AU3pKQCDABVrAdcCiQDdADUAf/EBUwBNBVn5BdMCT0kBETEYK1dhAbsDHwEzAQ0AeQbLjaXJBx8EbQfTAhAbFeEC7y4HtQEDIt8TzULFAr3eVaFgAmSBAmJCW02vWzcgAqH3AmiYAmYJAp+EOBsLAmY7AmYmBG4EfwN/EwN+kjkGOXcXOYI6IyMCbB0CMjY4CgJtxwJtru+KM2dFKwFnAN4A4QBKBQeYDI0A/gvCAA21AncvAnaiPwJ5S0MCeLodXNtFrkbXAnw/AnrIAn0JAnzwBVkFIEgASH1jJAKBbQKAAAKABQJ/rklYSlsVF0rMAtEBAtDMSycDiE8Dh+ZExZEyAvKhXQMDA65LzkwtJQPPTUxNrwKLPwKK2MEbBx1DZwW3Ao43Ao5cQJeBAo7ZAo5ceFG0UzUKUtRUhQKT+wKTDADpABxVHlWvVdAGLBsplYYy4XhmRTs5ApefAu+yWCGoAFklApaPApZ8nACpWaxaCYFNADsClrUClk5cRFzRApnLAplkXMpdBxkCnJs5wjqdApwWAp+bAp64igAdDzEqDwKd8QKekgC1PWE0Ye8CntMCoG4BqQKenx8Cnk6lY8hkJyUrAievAiZ+AqD7AqBMAqLdAqHEAqYvAqXOAqf/AH0Cp/JofGixAANJahxq0QKs4wKsrgKtZwKtAgJXHQJV3AKx4dcDH05slwKyvQ0CsugXbOBtY21IXwMlzQK2XDs/bpADKUUCuF4CuUcVArkqd3A2cOECvRkCu9pwlgMyEQK+iHICAzNxAr4acyJzTwLDywLDBHOCdEs1RXTgAzynAzyaAz2/AsV8AsZHAsYQiQLIaVECyEQCyU8CyS4CZJ0C3dJ4eWF4rnklS9ADGKNnAgJh9BnzlSR7C16SXrsRAs9rAs9sL0tT0vMTnwDGrQLPcwEp6gNOEn5LBQLcJwLbigLSTwNSXANTXwEBA1WMgIk/AMsW7WBFghyC04LOg40C2scC2d6EEIRJpzwDhqUALwNkDoZxWfkAVQLfZQLeuHN3AuIv7RQB8zAnAfSbAfLShwLr8wLpcHkC6vkC6uQA+UcBuQLuiQLrnJaqlwMC7j8DheCYeXDgcaEC8wMAaQOOFpmTAvcTA5FuA5KHAveYAvnZAvhmmhyaq7s3mx4DnYMC/voBGwA5nxyfswMFjQOmagOm2QDRxQMGaqGIogUJAwxJAtQAPwMA4UEXUwER8wNrB5dnBQCTLSu3r73bAYmZFH8RBDkB+ykFIQ6dCZ8Akv0TtRQrxQL3LScApQC3BbmOkRc/xqdtQS4UJo0uAUMBgPwBtSYAdQMOBG0ALAIWDKEAAAoCPQJqA90DfgSRASBFBSF8CgAFAEQAEwA2EgJ3AQAF1QNr7wrFAgD3Cp8nv7G35QGRIUFCAekUfxE0wIkABAAbAFoCRQKEiwAGOlM6lI1tALg6jzrQAI04wTrcAKUA6ADLATqBOjs5/Dn5O3aJOls7nok6bzkYAVYBMwFsBS81XTWeNa01ZjV1NbY1xTWCNZE10jXhNZ41rTXuNf01sjXBNgI2ETXGNdU2FjYnNd417TYuNj02LjUtITY6Nj02PDbJNwgEkDxXNjg23TcgNw82yiA3iTcwCgSwPGc2JDcZN2w6jTchQtRDB0LgQwscDw8JmyhtKFFVBgDpfwDpsAD+mxQ91wLpNSMArQC9BbeOkRdLxptzBL8MDAMMAQgDAAkKCwsLCQoGBAVVBI/DvwDz9b29kaUCb0QtsRTNLt4eGBcSHAMZFhYZEhYEARAEBUEcQRxBHEEcQRxBHEEaQRxBHEFCSTxBPElISUhBNkM2QTYbNklISVmBVIgELgEaJZkC7aMAoQCjBcGOmxdNxrsBvwGJAaQcEZ0ePCklMAAhMvAIMAL54gC7Bm8EescjzQMpARQpKgDUHqSvAj5Gqwr7YrMUACT9AN3rlr3JG9m8w9lIAXltp/v8kfWaIaaR9OwpAES/I3ZVamDXSgB/UsOgAG6D0tq+5CIqE15FiAhV3yA2VhCQ7tj+m6xXaF53FIfGi/IAZIskMGAi2MU7MDVJNCbMzERyHZi+osdPtnFVbvq653O8rwaCy4IAf9OOok65AqJUtUriUfYsGPPVbe6jm0s9lbKlPCUKjdkHsFsEhvX4kT39ZCtAAbwQdn/h4TpO5hTByWAmr5n+Wuwhdegv6bmvX4LyOes3z2+cuHv2JFYwVMNuq2gzn8YHTjlUQd39osyWei4NKl3LAdfxlO876hh5ENp/cOvpuI9bF55guEthLLPOXjD4dktTH04P5TvZrWTM0e4+BHJxj7MLApXIFOs0sWKhNkG8iwuM5wR83my6V3wW06abhDzTXYfOr/ZpFXgXzmv4d12FFyP00/dPGbIVGV5ao8UufGzUwp/IHx6v/wDWJr9iaoCulhWwlZ7A8q/NMoD12+mBdNRgJYnThRLtMx1Bgwttn8/4Qn2CDfOSup9GVXEvA21ILgp0owHYxNOkpwLWz0G7K+WREIDjIzUzSn8I99CuJSmSpPyH0Ke6/NERYiNx+3dncSebPnOUnnWD61AhJ1n/tSLZmU5wYO5GfgzyAYJm6VL91LxZ8hL1lfximQxIDMRhIecQZBmeE5R0XlrpvwplVrJwpa8BBCdp93GPP9lyBeZ2zkRr920CR3cYbKpKHfogvm0nV7XdDz6EbjzlxADCMjSLXuXpIpyuizy39yY+I+H9rmpoIF3YwEjlH9MgGgWcCNTjHEWMqAbprn2Ox7rOHupaVE3lNyg3nt5XaZID6Y+uml5Ja+aOPu+BI+DZbiJVfaspUadakWUX6TA4dETkIqdJJHYnU4Z4yKpt5y8rVIahoMUf8A8kWtAQNCTbjp71gx3/zVdqNz1Sutkw0gFIMVm2BF4Xdv/0olw+NaDIR9Bb3DPweZA2K/cw+/b+AwyWl9ZOP67A9nexmeTNjfdzPGf9J6E6BMPKa5lJh+qNsdUz3HBUevU71eQFCqOcxiIYhacAhh/8PX0J5DdSViZ6WazDDx7cukJNpMfEkYLJ5Ao4vLoVd3d25Pg4qaVa2p2D2L3WvYPJ5Yf/A/MSxptjlgXL/KJtP2U0cRv2I09ATAiWCJYuRwiapeKFsqmi18yMMulDp3HdcIldq+7jkwsJUOHLHCzzzBw5XFvL0CAmo1ub456z7zb7shk3KPGCLZzr47oT1k/j06XNnJvG3Udv6XrP+wsqTBlZ5MaNPt9FOs/4Bt/ja/vbVhTNpBFl9Gq7MqINvGlWKOAwQzwOZy+EzSdjAqKJVV2YcskTuM94aIK+kc/AZaXiZLPREUDpkXIV947IFfj+85TrqPqLfkGcxgboMQjosf+az+odLNXdyp1mDNGsqSdK/pJ2Ca04mt/4d6s1X+lncOEYaGBBeW4pApGcjf7/XJCFbj3N3mFb+BtlIcw8ZiDKoClFX9Rf0bxCqtLpicObKJzBVVHr/6u4siH2hK75RNv7w9GfTbhJOQBYiFUZAByY4rn37tZBHT//kqKsNi3ryL9AqXJRzqiMIJMhILjoi/i8LVEsbu+Ih9bsyW16sgQqjYLO0qda6KaCPKj3DQcu6CfV5lKtjS3ZCdqLAZkOey9MR+QutJBGiz/r15GVD6rCVwJR4UUKC4GNJkfDf00OMW8aQtLSAGLXV8MIi9mbbl/qQEpxCm2L5hutFX4ekeLH4QgBWUFKs/2VVMKy46WtFE6AbwgmYm/Z0yHk5veDIrcl2HpVqb/rSE0PC9EbDzJEWqeaPhh7vF369Umq2kSiB3s5rBI6c/7N9bkRu4h2n+/h5nSwy+7n+/I+6oXQVANo2Jb5zDwtiBPf1ySCzHdT6yJShMzqSRZfnykX49CaFaxhoVF4PBhEuECJ1PrFYSpmHuyYsl14DTAV9ZxRms1XiR/kBrjhZjidOt0UNe+GSml7XNgpVw8YsUTmZXLTK+6iYnyW/wYR1W4UXwOi14xpFROHb6HcZzksgF5DbL2AFXzKNwHU2adjdAY+KCyM/cwRTBkkq/a227NI0q6DR2MkMCRu620t79bGcYUmACtqN3mk/0uNwd3JSXHqE1kzf6Yyj0W2083JNDRnIXDlgBxJ6uf58NN1f6FQiRCWB4egF8QDx74AixV8oTyw7PluIjr3/rj/WzgwPSq4xPojaF7V0xqG2u5ti2L1h6yYHv73Isrukr0kURDIEjClBsBx7kdcXUxaYMS0syT3ymLzDzslNDWQOT1Tao1YNmJHARUenhCkmV9tqCPGI5GqZaRpkiPxyjoncWjyOHYGqvbvRX+Bn1pn7EhRNXa1lqJPmoeN5VqdqIDPhEVhFsyG0d4iQEIYX0wZUbY2XbZWYlpZ/l66IrDDY0q1C1YzBDpHC4h05YqHQLqS9anyl22JQ6lEvjvdBwMHfE7z0luCXD34/rFeDa2TmSeEAykSpYO5j1G/nsgpR3qn0qaQEmLjnnLfcz+veoYqPnRqmRGwCJ6FJ3Gm/Z1/aVX5PSb03MMnjAf41ww54sD5k8FrkfBP+K0b1MrYpapWjtpZfve2HVf4ickX3LKSOhu7qI1Vd4c1kNrn2ajy1t4y93JhV4fnWCKq7OmFpcr7FjdJCXPTql0Drr14Ho3Z87+GPQ4Z/DcTiGqtvZxlRYi8cNuhXABveZIwNl/BX1huhVLaFax5OqypUrQRyb9OE3SSkPlDdy5uo5XGg2EIGEjLY1MO5cr1ibfiFWV7zspcTgkBKkwo5jPyAin04LqizZXb2tDRgwKJjGx4cVk3ngAQixwcxjYAg2Q7vmUR/hpwInMdw7OhC2qyf41vTPkudQAORS0DdLtOGQxb4fH2VYGsvJCkeWPeUwtf1/tuIhzXEThoCZzzSJqqjUtbaPI3ntHm3T5uf849hGUA0zU8ni5W+EEn3/0Y6oUhQFw9z0aGjkljBbAlFXc0y82G2wkd7VdgWa5KTgJJNjNwZMfmdnUIUn1JU5LiWX5UZEZbVlKSN76mlmjUR2ku+fucTNlO4IAAahnLjBhlvQNR9pe9swGBgq0YR7P3VCyI/seYwQ4QBzy9X+HPePgoF8WfKaJ4MBOhLCGHae6Z8xkNXwni9QAKvTNtVA56x8YJflZ/VvONRSlsSLmiSyNMnTjTaE1ko81zkzGEnVwEhjCzlwIqpxmpDAqwsEmtpdr3xpc7i/ZX3f2TzT3M0FdxIEQvO1jgmmiN+D1YpMduAzEhBtj2OBkMN/rv6p7Th4pSH6f5aH3aTvwFTl7EOSgGASI7ttyMehzpm4AVyK+bFEaFg9gnZsSUPpsbAe/0RFhrH+EXZ12Z7thf4dzN1+Sn+G8QrDA1VKaN4IFxD1rQz9Xq9Coii9S9/hPbTGjyBwFH3H1UdQuz5KsgPDEHua4/kPg2Gp/IIItsaLWBqiT9XH45MiQxSosGJ56H/0F2cjcCFd72l1665RNHURdC3lspI77esfJsl+rXXabkAy7vxDXG/XGGcKpwiKDPFfvMEgjkAHil4Za1F36RnyxxvdIAzvgfH8knukYDck07tc++DP4TdWeI7HXuq5Yl6VVFrUQtf64/dkXewlKZSHQo6YvCSpREB0GDrz+Ys2GfO8nw2SwrYwaf88AifzlPvP17bf1mI3AuccJvAjZIpBmqvharKFAebEjVKfGAwpQjWoXlm9LROsq9bCk1UeQ3CJxJqprzssS/Q04JeS1ReCCubL3J7sx86spkP4eNpp95UF+8K748icIs8vdILFklk9skQqi1So6cx3X906pvy1vz+KipTJ8fiVJxsV5MmT0XwA";
var S0 = 44032;
var L0 = 4352;
var V0 = 4449;
var T0 = 4519;
var L_COUNT = 19;
var V_COUNT = 21;
var T_COUNT = 28;
var N_COUNT = V_COUNT * T_COUNT;
var S_COUNT = L_COUNT * N_COUNT;
var S1 = S0 + S_COUNT;
var L1 = L0 + L_COUNT;
var V1 = V0 + V_COUNT;
var T1 = T0 + T_COUNT;
function unpack_cc(packed) {
  return packed >> 24 & 255;
}
function unpack_cp(packed) {
  return packed & 16777215;
}
var SHIFTED_RANK;
var EXCLUSIONS;
var DECOMP;
var RECOMP;
function init$1() {
  let r2 = read_compressed_payload(COMPRESSED);
  SHIFTED_RANK = new Map(read_sorted_arrays(r2).flatMap((v2, i2) => v2.map((x2) => [x2, i2 + 1 << 24])));
  EXCLUSIONS = new Set(read_sorted(r2));
  DECOMP = /* @__PURE__ */ new Map();
  RECOMP = /* @__PURE__ */ new Map();
  for (let [cp, cps] of read_mapped(r2)) {
    if (!EXCLUSIONS.has(cp) && cps.length == 2) {
      let [a3, b4] = cps;
      let bucket = RECOMP.get(a3);
      if (!bucket) {
        bucket = /* @__PURE__ */ new Map();
        RECOMP.set(a3, bucket);
      }
      bucket.set(b4, cp);
    }
    DECOMP.set(cp, cps.reverse());
  }
}
function is_hangul(cp) {
  return cp >= S0 && cp < S1;
}
function compose_pair(a3, b4) {
  if (a3 >= L0 && a3 < L1 && b4 >= V0 && b4 < V1) {
    return S0 + (a3 - L0) * N_COUNT + (b4 - V0) * T_COUNT;
  } else if (is_hangul(a3) && b4 > T0 && b4 < T1 && (a3 - S0) % T_COUNT == 0) {
    return a3 + (b4 - T0);
  } else {
    let recomp = RECOMP.get(a3);
    if (recomp) {
      recomp = recomp.get(b4);
      if (recomp) {
        return recomp;
      }
    }
    return -1;
  }
}
function decomposed(cps) {
  if (!SHIFTED_RANK) init$1();
  let ret = [];
  let buf = [];
  let check_order = false;
  function add4(cp) {
    let cc3 = SHIFTED_RANK.get(cp);
    if (cc3) {
      check_order = true;
      cp |= cc3;
    }
    ret.push(cp);
  }
  for (let cp of cps) {
    while (true) {
      if (cp < 128) {
        ret.push(cp);
      } else if (is_hangul(cp)) {
        let s_index = cp - S0;
        let l_index = s_index / N_COUNT | 0;
        let v_index = s_index % N_COUNT / T_COUNT | 0;
        let t_index = s_index % T_COUNT;
        add4(L0 + l_index);
        add4(V0 + v_index);
        if (t_index > 0) add4(T0 + t_index);
      } else {
        let mapped = DECOMP.get(cp);
        if (mapped) {
          buf.push(...mapped);
        } else {
          add4(cp);
        }
      }
      if (!buf.length) break;
      cp = buf.pop();
    }
  }
  if (check_order && ret.length > 1) {
    let prev_cc = unpack_cc(ret[0]);
    for (let i2 = 1; i2 < ret.length; i2++) {
      let cc3 = unpack_cc(ret[i2]);
      if (cc3 == 0 || prev_cc <= cc3) {
        prev_cc = cc3;
        continue;
      }
      let j3 = i2 - 1;
      while (true) {
        let tmp = ret[j3 + 1];
        ret[j3 + 1] = ret[j3];
        ret[j3] = tmp;
        if (!j3) break;
        prev_cc = unpack_cc(ret[--j3]);
        if (prev_cc <= cc3) break;
      }
      prev_cc = unpack_cc(ret[i2]);
    }
  }
  return ret;
}
function composed_from_decomposed(v2) {
  let ret = [];
  let stack = [];
  let prev_cp = -1;
  let prev_cc = 0;
  for (let packed of v2) {
    let cc3 = unpack_cc(packed);
    let cp = unpack_cp(packed);
    if (prev_cp == -1) {
      if (cc3 == 0) {
        prev_cp = cp;
      } else {
        ret.push(cp);
      }
    } else if (prev_cc > 0 && prev_cc >= cc3) {
      if (cc3 == 0) {
        ret.push(prev_cp, ...stack);
        stack.length = 0;
        prev_cp = cp;
      } else {
        stack.push(cp);
      }
      prev_cc = cc3;
    } else {
      let composed = compose_pair(prev_cp, cp);
      if (composed >= 0) {
        prev_cp = composed;
      } else if (prev_cc == 0 && cc3 == 0) {
        ret.push(prev_cp);
        prev_cp = cp;
      } else {
        stack.push(cp);
        prev_cc = cc3;
      }
    }
  }
  if (prev_cp >= 0) {
    ret.push(prev_cp, ...stack);
  }
  return ret;
}
function nfd(cps) {
  return decomposed(cps).map(unpack_cp);
}
function nfc(cps) {
  return composed_from_decomposed(decomposed(cps));
}
var HYPHEN = 45;
var STOP_CH = ".";
var FE0F = 65039;
var UNIQUE_PH = 1;
var Array_from = (x2) => Array.from(x2);
function group_has_cp(g3, cp) {
  return g3.P.has(cp) || g3.Q.has(cp);
}
var Emoji = class extends Array {
  get is_emoji() {
    return true;
  }
  // free tagging system
};
var MAPPED;
var IGNORED;
var CM;
var NSM;
var ESCAPE;
var NFC_CHECK;
var GROUPS;
var WHOLE_VALID;
var WHOLE_MAP;
var VALID;
var EMOJI_LIST;
var EMOJI_ROOT;
function init() {
  if (MAPPED) return;
  let r2 = read_compressed_payload(COMPRESSED$1);
  const read_sorted_array = () => read_sorted(r2);
  const read_sorted_set = () => new Set(read_sorted_array());
  const set_add_many = (set, v2) => v2.forEach((x2) => set.add(x2));
  MAPPED = new Map(read_mapped(r2));
  IGNORED = read_sorted_set();
  CM = read_sorted_array();
  NSM = new Set(read_sorted_array().map((i2) => CM[i2]));
  CM = new Set(CM);
  ESCAPE = read_sorted_set();
  NFC_CHECK = read_sorted_set();
  let chunks = read_sorted_arrays(r2);
  let unrestricted = r2();
  const read_chunked = () => {
    let set = /* @__PURE__ */ new Set();
    read_sorted_array().forEach((i2) => set_add_many(set, chunks[i2]));
    set_add_many(set, read_sorted_array());
    return set;
  };
  GROUPS = read_array_while((i2) => {
    let N2 = read_array_while(r2).map((x2) => x2 + 96);
    if (N2.length) {
      let R2 = i2 >= unrestricted;
      N2[0] -= 32;
      N2 = str_from_cps(N2);
      if (R2) N2 = `Restricted[${N2}]`;
      let P = read_chunked();
      let Q2 = read_chunked();
      let M3 = !r2();
      return { N: N2, P, Q: Q2, M: M3, R: R2 };
    }
  });
  WHOLE_VALID = read_sorted_set();
  WHOLE_MAP = /* @__PURE__ */ new Map();
  let wholes = read_sorted_array().concat(Array_from(WHOLE_VALID)).sort((a3, b4) => a3 - b4);
  wholes.forEach((cp, i2) => {
    let d2 = r2();
    let w2 = wholes[i2] = d2 ? wholes[i2 - d2] : { V: [], M: /* @__PURE__ */ new Map() };
    w2.V.push(cp);
    if (!WHOLE_VALID.has(cp)) {
      WHOLE_MAP.set(cp, w2);
    }
  });
  for (let { V: V2, M: M3 } of new Set(WHOLE_MAP.values())) {
    let recs = [];
    for (let cp of V2) {
      let gs2 = GROUPS.filter((g3) => group_has_cp(g3, cp));
      let rec = recs.find(({ G: G2 }) => gs2.some((g3) => G2.has(g3)));
      if (!rec) {
        rec = { G: /* @__PURE__ */ new Set(), V: [] };
        recs.push(rec);
      }
      rec.V.push(cp);
      set_add_many(rec.G, gs2);
    }
    let union = recs.flatMap((x2) => Array_from(x2.G));
    for (let { G: G2, V: V3 } of recs) {
      let complement = new Set(union.filter((g3) => !G2.has(g3)));
      for (let cp of V3) {
        M3.set(cp, complement);
      }
    }
  }
  VALID = /* @__PURE__ */ new Set();
  let multi = /* @__PURE__ */ new Set();
  const add_to_union = (cp) => VALID.has(cp) ? multi.add(cp) : VALID.add(cp);
  for (let g3 of GROUPS) {
    for (let cp of g3.P) add_to_union(cp);
    for (let cp of g3.Q) add_to_union(cp);
  }
  for (let cp of VALID) {
    if (!WHOLE_MAP.has(cp) && !multi.has(cp)) {
      WHOLE_MAP.set(cp, UNIQUE_PH);
    }
  }
  set_add_many(VALID, nfd(VALID));
  EMOJI_LIST = read_trie(r2).map((v2) => Emoji.from(v2)).sort(compare_arrays);
  EMOJI_ROOT = /* @__PURE__ */ new Map();
  for (let cps of EMOJI_LIST) {
    let prev = [EMOJI_ROOT];
    for (let cp of cps) {
      let next = prev.map((node) => {
        let child = node.get(cp);
        if (!child) {
          child = /* @__PURE__ */ new Map();
          node.set(cp, child);
        }
        return child;
      });
      if (cp === FE0F) {
        prev.push(...next);
      } else {
        prev = next;
      }
    }
    for (let x2 of prev) {
      x2.V = cps;
    }
  }
}
function quoted_cp(cp) {
  return (should_escape(cp) ? "" : `${bidi_qq(safe_str_from_cps([cp]))} `) + quote_cp(cp);
}
function bidi_qq(s2) {
  return `"${s2}"`;
}
function check_label_extension(cps) {
  if (cps.length >= 4 && cps[2] == HYPHEN && cps[3] == HYPHEN) {
    throw new Error(`invalid label extension: "${str_from_cps(cps.slice(0, 4))}"`);
  }
}
function check_leading_underscore(cps) {
  const UNDERSCORE = 95;
  for (let i2 = cps.lastIndexOf(UNDERSCORE); i2 > 0; ) {
    if (cps[--i2] !== UNDERSCORE) {
      throw new Error("underscore allowed only at start");
    }
  }
}
function check_fenced(cps) {
  let cp = cps[0];
  let prev = FENCED.get(cp);
  if (prev) throw error_placement(`leading ${prev}`);
  let n2 = cps.length;
  let last = -1;
  for (let i2 = 1; i2 < n2; i2++) {
    cp = cps[i2];
    let match = FENCED.get(cp);
    if (match) {
      if (last == i2) throw error_placement(`${prev} + ${match}`);
      last = i2 + 1;
      prev = match;
    }
  }
  if (last == n2) throw error_placement(`trailing ${prev}`);
}
function safe_str_from_cps(cps, max = Infinity, quoter = quote_cp) {
  let buf = [];
  if (is_combining_mark(cps[0])) buf.push("");
  if (cps.length > max) {
    max >>= 1;
    cps = [...cps.slice(0, max), 8230, ...cps.slice(-max)];
  }
  let prev = 0;
  let n2 = cps.length;
  for (let i2 = 0; i2 < n2; i2++) {
    let cp = cps[i2];
    if (should_escape(cp)) {
      buf.push(str_from_cps(cps.slice(prev, i2)));
      buf.push(quoter(cp));
      prev = i2 + 1;
    }
  }
  buf.push(str_from_cps(cps.slice(prev, n2)));
  return buf.join("");
}
function is_combining_mark(cp, only_nsm) {
  init();
  return only_nsm ? NSM.has(cp) : CM.has(cp);
}
function should_escape(cp) {
  init();
  return ESCAPE.has(cp);
}
function ens_normalize(name) {
  return flatten(split(name, nfc, filter_fe0f));
}
function split(name, nf, ef) {
  if (!name) return [];
  init();
  let offset = 0;
  return name.split(STOP_CH).map((label) => {
    let input = explode_cp(label);
    let info = {
      input,
      offset
      // codepoint, not substring!
    };
    offset += input.length + 1;
    try {
      let tokens = info.tokens = tokens_from_str(input, nf, ef);
      let token_count = tokens.length;
      let type6;
      if (!token_count) {
        throw new Error(`empty label`);
      }
      let norm = info.output = tokens.flat();
      check_leading_underscore(norm);
      let emoji = info.emoji = token_count > 1 || tokens[0].is_emoji;
      if (!emoji && norm.every((cp) => cp < 128)) {
        check_label_extension(norm);
        type6 = "ASCII";
      } else {
        let chars = tokens.flatMap((x2) => x2.is_emoji ? [] : x2);
        if (!chars.length) {
          type6 = "Emoji";
        } else {
          if (CM.has(norm[0])) throw error_placement("leading combining mark");
          for (let i2 = 1; i2 < token_count; i2++) {
            let cps = tokens[i2];
            if (!cps.is_emoji && CM.has(cps[0])) {
              throw error_placement(`emoji + combining mark: "${str_from_cps(tokens[i2 - 1])} + ${safe_str_from_cps([cps[0]])}"`);
            }
          }
          check_fenced(norm);
          let unique2 = Array_from(new Set(chars));
          let [g3] = determine_group(unique2);
          check_group(g3, chars);
          check_whole(g3, unique2);
          type6 = g3.N;
        }
      }
      info.type = type6;
    } catch (err) {
      info.error = err;
    }
    return info;
  });
}
function check_whole(group, unique2) {
  let maker;
  let shared = [];
  for (let cp of unique2) {
    let whole = WHOLE_MAP.get(cp);
    if (whole === UNIQUE_PH) return;
    if (whole) {
      let set = whole.M.get(cp);
      maker = maker ? maker.filter((g3) => set.has(g3)) : Array_from(set);
      if (!maker.length) return;
    } else {
      shared.push(cp);
    }
  }
  if (maker) {
    for (let g3 of maker) {
      if (shared.every((cp) => group_has_cp(g3, cp))) {
        throw new Error(`whole-script confusable: ${group.N}/${g3.N}`);
      }
    }
  }
}
function determine_group(unique2) {
  let groups = GROUPS;
  for (let cp of unique2) {
    let gs2 = groups.filter((g3) => group_has_cp(g3, cp));
    if (!gs2.length) {
      if (!GROUPS.some((g3) => group_has_cp(g3, cp))) {
        throw error_disallowed(cp);
      } else {
        throw error_group_member(groups[0], cp);
      }
    }
    groups = gs2;
    if (gs2.length == 1) break;
  }
  return groups;
}
function flatten(split4) {
  return split4.map(({ input, error, output }) => {
    if (error) {
      let msg = error.message;
      throw new Error(split4.length == 1 ? msg : `Invalid label ${bidi_qq(safe_str_from_cps(input, 63))}: ${msg}`);
    }
    return str_from_cps(output);
  }).join(STOP_CH);
}
function error_disallowed(cp) {
  return new Error(`disallowed character: ${quoted_cp(cp)}`);
}
function error_group_member(g3, cp) {
  let quoted = quoted_cp(cp);
  let gg = GROUPS.find((g4) => g4.P.has(cp));
  if (gg) {
    quoted = `${gg.N} ${quoted}`;
  }
  return new Error(`illegal mixture: ${g3.N} + ${quoted}`);
}
function error_placement(where) {
  return new Error(`illegal placement: ${where}`);
}
function check_group(g3, cps) {
  for (let cp of cps) {
    if (!group_has_cp(g3, cp)) {
      throw error_group_member(g3, cp);
    }
  }
  if (g3.M) {
    let decomposed2 = nfd(cps);
    for (let i2 = 1, e2 = decomposed2.length; i2 < e2; i2++) {
      if (NSM.has(decomposed2[i2])) {
        let j3 = i2 + 1;
        for (let cp; j3 < e2 && NSM.has(cp = decomposed2[j3]); j3++) {
          for (let k4 = i2; k4 < j3; k4++) {
            if (decomposed2[k4] == cp) {
              throw new Error(`duplicate non-spacing marks: ${quoted_cp(cp)}`);
            }
          }
        }
        if (j3 - i2 > NSM_MAX) {
          throw new Error(`excessive non-spacing marks: ${bidi_qq(safe_str_from_cps(decomposed2.slice(i2 - 1, j3)))} (${j3 - i2}/${NSM_MAX})`);
        }
        i2 = j3;
      }
    }
  }
}
function tokens_from_str(input, nf, ef) {
  let ret = [];
  let chars = [];
  input = input.slice().reverse();
  while (input.length) {
    let emoji = consume_emoji_reversed(input);
    if (emoji) {
      if (chars.length) {
        ret.push(nf(chars));
        chars = [];
      }
      ret.push(ef(emoji));
    } else {
      let cp = input.pop();
      if (VALID.has(cp)) {
        chars.push(cp);
      } else {
        let cps = MAPPED.get(cp);
        if (cps) {
          chars.push(...cps);
        } else if (!IGNORED.has(cp)) {
          throw error_disallowed(cp);
        }
      }
    }
  }
  if (chars.length) {
    ret.push(nf(chars));
  }
  return ret;
}
function filter_fe0f(cps) {
  return cps.filter((cp) => cp != FE0F);
}
function consume_emoji_reversed(cps, eaten) {
  let node = EMOJI_ROOT;
  let emoji;
  let pos = cps.length;
  while (pos) {
    node = node.get(cps[--pos]);
    if (!node) break;
    let { V: V2 } = node;
    if (V2) {
      emoji = V2;
      if (eaten) eaten.push(...cps.slice(pos).reverse());
      cps.length = pos;
    }
  }
  return emoji;
}

// node_modules/ox/_esm/core/Abi.js
var Abi_exports = {};
__export(Abi_exports, {
  format: () => format2,
  from: () => from6
});

// node_modules/ox/_esm/core/internal/abi.js
function isSignatures(value) {
  for (const item of value) {
    if (typeof item !== "string")
      return false;
  }
  return true;
}

// node_modules/ox/_esm/core/Abi.js
function format2(abi) {
  return formatAbi(abi);
}
function from6(abi) {
  if (isSignatures(abi))
    return parseAbi(abi);
  return abi;
}

// node_modules/ox/_esm/core/AbiError.js
var AbiError_exports = {};
__export(AbiError_exports, {
  decode: () => decode2,
  encode: () => encode2,
  format: () => format3,
  from: () => from7,
  fromAbi: () => fromAbi2,
  getSelector: () => getSelector2,
  panicReasons: () => panicReasons,
  solidityError: () => solidityError,
  solidityErrorSelector: () => solidityErrorSelector,
  solidityPanic: () => solidityPanic,
  solidityPanicSelector: () => solidityPanicSelector
});
function decode2(abiError, data, options = {}) {
  if (size2(data) < 4)
    throw new InvalidSelectorSizeError({ data });
  if (abiError.inputs.length === 0)
    return void 0;
  const values = decode(abiError.inputs, slice2(data, 4), options);
  if (values && Object.keys(values).length === 1) {
    if (Array.isArray(values))
      return values[0];
    return Object.values(values)[0];
  }
  return values;
}
function encode2(abiError, ...args) {
  const selector = getSelector2(abiError);
  const data = args.length > 0 ? encode(abiError.inputs, args[0]) : void 0;
  return data ? concat2(selector, data) : selector;
}
function format3(abiError) {
  return formatAbiItem(abiError);
}
function from7(abiError, options = {}) {
  return from5(abiError, options);
}
function fromAbi2(abi, name, options) {
  if (name === "Error")
    return solidityError;
  if (name === "Panic")
    return solidityPanic;
  if (validate2(name, { strict: false })) {
    const selector = slice2(name, 0, 4);
    if (selector === solidityErrorSelector)
      return solidityError;
    if (selector === solidityPanicSelector)
      return solidityPanic;
  }
  const item = fromAbi(abi, name, options);
  if (item.type !== "error")
    throw new NotFoundError({ name, type: "error" });
  return item;
}
function getSelector2(abiItem) {
  return getSelector(abiItem);
}
var panicReasons = {
  1: "An `assert` condition failed.",
  17: "Arithmetic operation resulted in underflow or overflow.",
  18: "Division or modulo by zero (e.g. `5 / 0` or `23 % 0`).",
  33: "Attempted to convert to an invalid type.",
  34: "Attempted to access a storage byte array that is incorrectly encoded.",
  49: "Performed `.pop()` on an empty array",
  50: "Array index is out of bounds.",
  65: "Allocated too much memory or created an array which is too large.",
  81: "Attempted to call a zero-initialized variable of internal function type."
};
var solidityError = from7({
  inputs: [
    {
      name: "message",
      type: "string"
    }
  ],
  name: "Error",
  type: "error"
});
var solidityErrorSelector = "0x08c379a0";
var solidityPanic = from7({
  inputs: [
    {
      name: "reason",
      type: "uint8"
    }
  ],
  name: "Panic",
  type: "error"
});
var solidityPanicSelector = "0x4e487b71";

// node_modules/ox/_esm/core/AbiEvent.js
var AbiEvent_exports = {};
__export(AbiEvent_exports, {
  ArgsMismatchError: () => ArgsMismatchError,
  DataMismatchError: () => DataMismatchError,
  FilterTypeNotSupportedError: () => FilterTypeNotSupportedError,
  InputNotFoundError: () => InputNotFoundError,
  SelectorTopicMismatchError: () => SelectorTopicMismatchError,
  TopicsMismatchError: () => TopicsMismatchError,
  assertArgs: () => assertArgs,
  decode: () => decode3,
  encode: () => encode3,
  format: () => format4,
  from: () => from8,
  fromAbi: () => fromAbi3,
  getSelector: () => getSelector3
});
function assertArgs(abiEvent, args, matchArgs) {
  if (!args || !matchArgs)
    throw new ArgsMismatchError({
      abiEvent,
      expected: args,
      given: matchArgs
    });
  function isEqual3(input, value, arg) {
    if (input.type === "address")
      return isEqual2(value, arg);
    if (input.type === "string")
      return keccak2562(fromString(value)) === arg;
    if (input.type === "bytes")
      return keccak2562(value) === arg;
    return value === arg;
  }
  if (Array.isArray(args) && Array.isArray(matchArgs)) {
    for (const [index5, value] of matchArgs.entries()) {
      if (value === null || value === void 0)
        continue;
      const input = abiEvent.inputs[index5];
      if (!input)
        throw new InputNotFoundError({
          abiEvent,
          name: `${index5}`
        });
      const value_ = Array.isArray(value) ? value : [value];
      let equal = false;
      for (const value2 of value_) {
        if (isEqual3(input, value2, args[index5]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args,
          given: matchArgs
        });
    }
  }
  if (typeof args === "object" && !Array.isArray(args) && typeof matchArgs === "object" && !Array.isArray(matchArgs))
    for (const [key, value] of Object.entries(matchArgs)) {
      if (value === null || value === void 0)
        continue;
      const input = abiEvent.inputs.find((input2) => input2.name === key);
      if (!input)
        throw new InputNotFoundError({ abiEvent, name: key });
      const value_ = Array.isArray(value) ? value : [value];
      let equal = false;
      for (const value2 of value_) {
        if (isEqual3(input, value2, args[key]))
          equal = true;
      }
      if (!equal)
        throw new ArgsMismatchError({
          abiEvent,
          expected: args,
          given: matchArgs
        });
    }
}
function decode3(abiEvent, log) {
  const { data, topics } = log;
  const [selector_, ...argTopics] = topics;
  const selector = getSelector3(abiEvent);
  if (selector_ !== selector)
    throw new SelectorTopicMismatchError({
      abiEvent,
      actual: selector_,
      expected: selector
    });
  const { inputs } = abiEvent;
  const isUnnamed = inputs == null ? void 0 : inputs.every((x2) => !("name" in x2 && x2.name));
  let args = isUnnamed ? [] : {};
  const indexedInputs = inputs.filter((x2) => "indexed" in x2 && x2.indexed);
  for (let i2 = 0; i2 < indexedInputs.length; i2++) {
    const param = indexedInputs[i2];
    const topic = argTopics[i2];
    if (!topic)
      throw new TopicsMismatchError({
        abiEvent,
        param
      });
    args[isUnnamed ? i2 : param.name || i2] = (() => {
      if (param.type === "string" || param.type === "bytes" || param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
        return topic;
      const decoded = decode([param], topic) || [];
      return decoded[0];
    })();
  }
  const nonIndexedInputs = inputs.filter((x2) => !("indexed" in x2 && x2.indexed));
  if (nonIndexedInputs.length > 0) {
    if (data && data !== "0x") {
      try {
        const decodedData = decode(nonIndexedInputs, data);
        if (decodedData) {
          if (isUnnamed)
            args = [...args, ...decodedData];
          else {
            for (let i2 = 0; i2 < nonIndexedInputs.length; i2++) {
              const index5 = inputs.indexOf(nonIndexedInputs[i2]);
              args[nonIndexedInputs[i2].name || index5] = decodedData[i2];
            }
          }
        }
      } catch (err) {
        if (err instanceof DataSizeTooSmallError || err instanceof PositionOutOfBoundsError)
          throw new DataMismatchError({
            abiEvent,
            data,
            parameters: nonIndexedInputs,
            size: size2(data)
          });
        throw err;
      }
    } else {
      throw new DataMismatchError({
        abiEvent,
        data: "0x",
        parameters: nonIndexedInputs,
        size: 0
      });
    }
  }
  return Object.values(args).length > 0 ? args : void 0;
}
function encode3(abiEvent, ...[args]) {
  let topics = [];
  if (args && abiEvent.inputs) {
    const indexedInputs = abiEvent.inputs.filter((param) => "indexed" in param && param.indexed);
    const args_ = Array.isArray(args) ? args : Object.values(args).length > 0 ? (indexedInputs == null ? void 0 : indexedInputs.map((x2, i2) => args[x2.name ?? i2])) ?? [] : [];
    if (args_.length > 0) {
      const encode9 = (param, value) => {
        if (param.type === "string")
          return keccak2562(fromString2(value));
        if (param.type === "bytes")
          return keccak2562(value);
        if (param.type === "tuple" || param.type.match(/^(.*)\[(\d+)?\]$/))
          throw new FilterTypeNotSupportedError(param.type);
        return encode([param], [value]);
      };
      topics = (indexedInputs == null ? void 0 : indexedInputs.map((param, i2) => {
        if (Array.isArray(args_[i2]))
          return args_[i2].map((_2, j3) => encode9(param, args_[i2][j3]));
        return typeof args_[i2] !== "undefined" && args_[i2] !== null ? encode9(param, args_[i2]) : null;
      })) ?? [];
    }
  }
  const selector = (() => {
    if (abiEvent.hash)
      return abiEvent.hash;
    return getSelector3(abiEvent);
  })();
  return { topics: [selector, ...topics] };
}
function format4(abiEvent) {
  return formatAbiItem(abiEvent);
}
function from8(abiEvent, options = {}) {
  return from5(abiEvent, options);
}
function fromAbi3(abi, name, options) {
  const item = fromAbi(abi, name, options);
  if (item.type !== "event")
    throw new NotFoundError({ name, type: "event" });
  return item;
}
function getSelector3(abiItem) {
  return getSignatureHash(abiItem);
}
var ArgsMismatchError = class extends BaseError2 {
  constructor({ abiEvent, expected, given }) {
    super("Given arguments do not match the expected arguments.", {
      metaMessages: [
        `Event: ${format4(abiEvent)}`,
        `Expected Arguments: ${!expected ? "None" : ""}`,
        expected ? prettyPrint(expected) : void 0,
        `Given Arguments: ${!given ? "None" : ""}`,
        given ? prettyPrint(given) : void 0
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.ArgsMismatchError"
    });
  }
};
var InputNotFoundError = class extends BaseError2 {
  constructor({ abiEvent, name }) {
    super(`Parameter "${name}" not found on \`${format4(abiEvent)}\`.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.InputNotFoundError"
    });
  }
};
var DataMismatchError = class extends BaseError2 {
  constructor({ abiEvent, data, parameters, size: size5 }) {
    super([
      `Data size of ${size5} bytes is too small for non-indexed event parameters.`
    ].join("\n"), {
      metaMessages: [
        `Non-indexed Parameters: (${format(parameters)})`,
        `Data:   ${data} (${size5} bytes)`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.DataMismatchError"
    });
    Object.defineProperty(this, "abiEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "parameters", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "size", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiEvent = abiEvent;
    this.data = data;
    this.parameters = parameters;
    this.size = size5;
  }
};
var TopicsMismatchError = class extends BaseError2 {
  constructor({ abiEvent, param }) {
    super([
      `Expected a topic for indexed event parameter${param.name ? ` "${param.name}"` : ""} for "${format4(abiEvent)}".`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.TopicsMismatchError"
    });
    Object.defineProperty(this, "abiEvent", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.abiEvent = abiEvent;
  }
};
var SelectorTopicMismatchError = class extends BaseError2 {
  constructor({ abiEvent, actual, expected }) {
    super(`topics[0]="${actual}" does not match the expected topics[0]="${expected}".`, {
      metaMessages: [`Event: ${format4(abiEvent)}`, `Selector: ${expected}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.SelectorTopicMismatchError"
    });
  }
};
var FilterTypeNotSupportedError = class extends BaseError2 {
  constructor(type6) {
    super(`Filter type "${type6}" is not supported.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AbiEvent.FilterTypeNotSupportedError"
    });
  }
};

// node_modules/ox/_esm/core/AccessList.js
var AccessList_exports = {};
__export(AccessList_exports, {
  InvalidStorageKeySizeError: () => InvalidStorageKeySizeError,
  fromTupleList: () => fromTupleList,
  toTupleList: () => toTupleList
});
function fromTupleList(accessList) {
  const list = [];
  for (let i2 = 0; i2 < accessList.length; i2++) {
    const [address, storageKeys] = accessList[i2];
    if (address)
      assert(address, { strict: false });
    list.push({
      address,
      storageKeys: storageKeys.map((key) => validate3(key) ? key : trimLeft(key))
    });
  }
  return list;
}
function toTupleList(accessList) {
  if (!accessList || accessList.length === 0)
    return [];
  const tuple = [];
  for (const { address, storageKeys } of accessList) {
    for (let j3 = 0; j3 < storageKeys.length; j3++)
      if (size2(storageKeys[j3]) !== 32)
        throw new InvalidStorageKeySizeError({
          storageKey: storageKeys[j3]
        });
    if (address)
      assert(address, { strict: false });
    tuple.push([address, storageKeys]);
  }
  return tuple;
}
var InvalidStorageKeySizeError = class extends BaseError2 {
  constructor({ storageKey }) {
    super(`Size for storage key "${storageKey}" is invalid. Expected 32 bytes. Got ${size2(storageKey)} bytes.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "AccessList.InvalidStorageKeySizeError"
    });
  }
};

// node_modules/ox/_esm/core/AccountProof.js
var AccountProof_exports = {};

// node_modules/ox/_esm/core/AesGcm.js
var AesGcm_exports = {};
__export(AesGcm_exports, {
  decrypt: () => decrypt,
  encrypt: () => encrypt,
  getKey: () => getKey,
  ivLength: () => ivLength,
  randomSalt: () => randomSalt
});
var ivLength = 16;
async function decrypt(value, key, options = {}) {
  const { as: as2 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const encrypted = from(value);
  const iv = encrypted.slice(0, ivLength);
  const data = encrypted.slice(ivLength);
  const decrypted = await globalThis.crypto.subtle.decrypt({
    name: "AES-GCM",
    iv
  }, key, from(data));
  const result = new Uint8Array(decrypted);
  if (as2 === "Bytes")
    return result;
  return from2(result);
}
async function encrypt(value, key, options = {}) {
  const { as: as2 = typeof value === "string" ? "Hex" : "Bytes" } = options;
  const iv = random(ivLength);
  const encrypted = await globalThis.crypto.subtle.encrypt({
    name: "AES-GCM",
    iv
  }, key, from(value));
  const result = concat(iv, new Uint8Array(encrypted));
  if (as2 === "Bytes")
    return result;
  return from2(result);
}
async function getKey(options) {
  const { iterations = 9e5, password, salt = randomSalt(32) } = options;
  const baseKey = await globalThis.crypto.subtle.importKey("raw", fromString(password), { name: "PBKDF2" }, false, ["deriveBits", "deriveKey"]);
  const key = await globalThis.crypto.subtle.deriveKey({
    name: "PBKDF2",
    salt,
    iterations,
    hash: "SHA-256"
  }, baseKey, { name: "AES-GCM", length: 256 }, false, ["encrypt", "decrypt"]);
  return key;
}
function randomSalt(size5 = 32) {
  return random(size5);
}

// node_modules/ox/_esm/core/Authorization.js
var Authorization_exports = {};
__export(Authorization_exports, {
  from: () => from11,
  fromRpc: () => fromRpc3,
  fromRpcList: () => fromRpcList,
  fromTuple: () => fromTuple2,
  fromTupleList: () => fromTupleList2,
  getSignPayload: () => getSignPayload,
  hash: () => hash,
  toRpc: () => toRpc3,
  toRpcList: () => toRpcList,
  toTuple: () => toTuple2,
  toTupleList: () => toTupleList2
});

// node_modules/ox/_esm/core/Rlp.js
var Rlp_exports = {};
__export(Rlp_exports, {
  decodeRlpCursor: () => decodeRlpCursor,
  from: () => from9,
  fromBytes: () => fromBytes2,
  fromHex: () => fromHex3,
  readLength: () => readLength,
  readList: () => readList,
  to: () => to,
  toBytes: () => toBytes5,
  toHex: () => toHex4
});
function toBytes5(value) {
  return to(value, "Bytes");
}
function toHex4(value) {
  return to(value, "Hex");
}
function to(value, to4) {
  const to_ = to4 ?? (typeof value === "string" ? "Hex" : "Bytes");
  const bytes = (() => {
    if (typeof value === "string") {
      if (value.length > 3 && value.length % 2 !== 0)
        throw new InvalidLengthError(value);
      return fromHex2(value);
    }
    return value;
  })();
  const cursor = create(bytes, {
    recursiveReadLimit: Number.POSITIVE_INFINITY
  });
  const result = decodeRlpCursor(cursor, to_);
  return result;
}
function decodeRlpCursor(cursor, to4 = "Hex") {
  if (cursor.bytes.length === 0)
    return to4 === "Hex" ? fromBytes(cursor.bytes) : cursor.bytes;
  const prefix = cursor.readByte();
  if (prefix < 128)
    cursor.decrementPosition(1);
  if (prefix < 192) {
    const length3 = readLength(cursor, prefix, 128);
    const bytes = cursor.readBytes(length3);
    return to4 === "Hex" ? fromBytes(bytes) : bytes;
  }
  const length2 = readLength(cursor, prefix, 192);
  return readList(cursor, length2, to4);
}
function readLength(cursor, prefix, offset) {
  if (offset === 128 && prefix < 128)
    return 1;
  if (prefix <= offset + 55)
    return prefix - offset;
  if (prefix === offset + 55 + 1)
    return cursor.readUint8();
  if (prefix === offset + 55 + 2)
    return cursor.readUint16();
  if (prefix === offset + 55 + 3)
    return cursor.readUint24();
  if (prefix === offset + 55 + 4)
    return cursor.readUint32();
  throw new BaseError2("Invalid RLP prefix");
}
function readList(cursor, length2, to4) {
  const position = cursor.position;
  const value = [];
  while (cursor.position - position < length2)
    value.push(decodeRlpCursor(cursor, to4));
  return value;
}
function from9(value, options) {
  const { as: as2 } = options;
  const encodable = getEncodable(value);
  const cursor = create(new Uint8Array(encodable.length));
  encodable.encode(cursor);
  if (as2 === "Hex")
    return fromBytes(cursor.bytes);
  return cursor.bytes;
}
function fromBytes2(bytes, options = {}) {
  const { as: as2 = "Bytes" } = options;
  return from9(bytes, { as: as2 });
}
function fromHex3(hex3, options = {}) {
  const { as: as2 = "Hex" } = options;
  return from9(hex3, { as: as2 });
}
function getEncodable(bytes) {
  if (Array.isArray(bytes))
    return getEncodableList(bytes.map((x2) => getEncodable(x2)));
  return getEncodableBytes(bytes);
}
function getEncodableList(list) {
  const bodyLength = list.reduce((acc, x2) => acc + x2.length, 0);
  const sizeOfBodyLength = getSizeOfLength(bodyLength);
  const length2 = (() => {
    if (bodyLength <= 55)
      return 1 + bodyLength;
    return 1 + sizeOfBodyLength + bodyLength;
  })();
  return {
    length: length2,
    encode(cursor) {
      if (bodyLength <= 55) {
        cursor.pushByte(192 + bodyLength);
      } else {
        cursor.pushByte(192 + 55 + sizeOfBodyLength);
        if (sizeOfBodyLength === 1)
          cursor.pushUint8(bodyLength);
        else if (sizeOfBodyLength === 2)
          cursor.pushUint16(bodyLength);
        else if (sizeOfBodyLength === 3)
          cursor.pushUint24(bodyLength);
        else
          cursor.pushUint32(bodyLength);
      }
      for (const { encode: encode9 } of list) {
        encode9(cursor);
      }
    }
  };
}
function getEncodableBytes(bytesOrHex) {
  const bytes = typeof bytesOrHex === "string" ? fromHex2(bytesOrHex) : bytesOrHex;
  const sizeOfBytesLength = getSizeOfLength(bytes.length);
  const length2 = (() => {
    if (bytes.length === 1 && bytes[0] < 128)
      return 1;
    if (bytes.length <= 55)
      return 1 + bytes.length;
    return 1 + sizeOfBytesLength + bytes.length;
  })();
  return {
    length: length2,
    encode(cursor) {
      if (bytes.length === 1 && bytes[0] < 128) {
        cursor.pushBytes(bytes);
      } else if (bytes.length <= 55) {
        cursor.pushByte(128 + bytes.length);
        cursor.pushBytes(bytes);
      } else {
        cursor.pushByte(128 + 55 + sizeOfBytesLength);
        if (sizeOfBytesLength === 1)
          cursor.pushUint8(bytes.length);
        else if (sizeOfBytesLength === 2)
          cursor.pushUint16(bytes.length);
        else if (sizeOfBytesLength === 3)
          cursor.pushUint24(bytes.length);
        else
          cursor.pushUint32(bytes.length);
        cursor.pushBytes(bytes);
      }
    }
  };
}
function getSizeOfLength(length2) {
  if (length2 < 2 ** 8)
    return 1;
  if (length2 < 2 ** 16)
    return 2;
  if (length2 < 2 ** 24)
    return 3;
  if (length2 < 2 ** 32)
    return 4;
  throw new BaseError2("Length is too large.");
}

// node_modules/ox/_esm/core/Signature.js
var Signature_exports = {};
__export(Signature_exports, {
  InvalidRError: () => InvalidRError,
  InvalidSError: () => InvalidSError,
  InvalidSerializedSizeError: () => InvalidSerializedSizeError,
  InvalidVError: () => InvalidVError,
  InvalidYParityError: () => InvalidYParityError,
  MissingPropertiesError: () => MissingPropertiesError,
  assert: () => assert2,
  extract: () => extract2,
  from: () => from10,
  fromBytes: () => fromBytes3,
  fromDerBytes: () => fromDerBytes,
  fromDerHex: () => fromDerHex,
  fromHex: () => fromHex4,
  fromLegacy: () => fromLegacy,
  fromRpc: () => fromRpc2,
  fromTuple: () => fromTuple,
  toBytes: () => toBytes6,
  toDerBytes: () => toDerBytes,
  toDerHex: () => toDerHex,
  toHex: () => toHex5,
  toLegacy: () => toLegacy,
  toRpc: () => toRpc2,
  toTuple: () => toTuple,
  vToYParity: () => vToYParity,
  validate: () => validate5,
  yParityToV: () => yParityToV
});
function assert2(signature, options = {}) {
  const { recovered } = options;
  if (typeof signature.r === "undefined")
    throw new MissingPropertiesError({ signature });
  if (typeof signature.s === "undefined")
    throw new MissingPropertiesError({ signature });
  if (recovered && typeof signature.yParity === "undefined")
    throw new MissingPropertiesError({ signature });
  if (signature.r < 0n || signature.r > maxUint2562)
    throw new InvalidRError({ value: signature.r });
  if (signature.s < 0n || signature.s > maxUint2562)
    throw new InvalidSError({ value: signature.s });
  if (typeof signature.yParity === "number" && signature.yParity !== 0 && signature.yParity !== 1)
    throw new InvalidYParityError({ value: signature.yParity });
}
function fromBytes3(signature) {
  return fromHex4(fromBytes(signature));
}
function fromHex4(signature) {
  if (signature.length !== 130 && signature.length !== 132)
    throw new InvalidSerializedSizeError({ signature });
  const r2 = BigInt(slice2(signature, 0, 32));
  const s2 = BigInt(slice2(signature, 32, 64));
  const yParity = (() => {
    const yParity2 = Number(`0x${signature.slice(130)}`);
    if (Number.isNaN(yParity2))
      return void 0;
    try {
      return vToYParity(yParity2);
    } catch {
      throw new InvalidYParityError({ value: yParity2 });
    }
  })();
  if (typeof yParity === "undefined")
    return {
      r: r2,
      s: s2
    };
  return {
    r: r2,
    s: s2,
    yParity
  };
}
function extract2(value) {
  if (typeof value.r === "undefined")
    return void 0;
  if (typeof value.s === "undefined")
    return void 0;
  return from10(value);
}
function from10(signature) {
  const signature_ = (() => {
    if (typeof signature === "string")
      return fromHex4(signature);
    if (signature instanceof Uint8Array)
      return fromBytes3(signature);
    if (typeof signature.r === "string")
      return fromRpc2(signature);
    if (signature.v)
      return fromLegacy(signature);
    return {
      r: signature.r,
      s: signature.s,
      ...typeof signature.yParity !== "undefined" ? { yParity: signature.yParity } : {}
    };
  })();
  assert2(signature_);
  return signature_;
}
function fromDerBytes(signature) {
  return fromDerHex(fromBytes(signature));
}
function fromDerHex(signature) {
  const { r: r2, s: s2 } = secp256k1.Signature.fromDER(from2(signature).slice(2));
  return { r: r2, s: s2 };
}
function fromLegacy(signature) {
  return {
    r: signature.r,
    s: signature.s,
    yParity: vToYParity(signature.v)
  };
}
function fromRpc2(signature) {
  const yParity = (() => {
    const v2 = signature.v ? Number(signature.v) : void 0;
    let yParity2 = signature.yParity ? Number(signature.yParity) : void 0;
    if (typeof v2 === "number" && typeof yParity2 !== "number")
      yParity2 = vToYParity(v2);
    if (typeof yParity2 !== "number")
      throw new InvalidYParityError({ value: signature.yParity });
    return yParity2;
  })();
  return {
    r: BigInt(signature.r),
    s: BigInt(signature.s),
    yParity
  };
}
function fromTuple(tuple) {
  const [yParity, r2, s2] = tuple;
  return from10({
    r: r2 === "0x" ? 0n : BigInt(r2),
    s: s2 === "0x" ? 0n : BigInt(s2),
    yParity: yParity === "0x" ? 0 : Number(yParity)
  });
}
function toBytes6(signature) {
  return fromHex2(toHex5(signature));
}
function toHex5(signature) {
  assert2(signature);
  const r2 = signature.r;
  const s2 = signature.s;
  const signature_ = concat2(
    fromNumber2(r2, { size: 32 }),
    fromNumber2(s2, { size: 32 }),
    // If the signature is recovered, add the recovery byte to the signature.
    typeof signature.yParity === "number" ? fromNumber2(yParityToV(signature.yParity), { size: 1 }) : "0x"
  );
  return signature_;
}
function toDerBytes(signature) {
  const sig = new secp256k1.Signature(signature.r, signature.s);
  return sig.toDERRawBytes();
}
function toDerHex(signature) {
  const sig = new secp256k1.Signature(signature.r, signature.s);
  return `0x${sig.toDERHex()}`;
}
function toLegacy(signature) {
  return {
    r: signature.r,
    s: signature.s,
    v: yParityToV(signature.yParity)
  };
}
function toRpc2(signature) {
  const { r: r2, s: s2, yParity } = signature;
  return {
    r: fromNumber2(r2, { size: 32 }),
    s: fromNumber2(s2, { size: 32 }),
    yParity: yParity === 0 ? "0x0" : "0x1"
  };
}
function toTuple(signature) {
  const { r: r2, s: s2, yParity } = signature;
  return [
    yParity ? "0x01" : "0x",
    r2 === 0n ? "0x" : trimLeft(fromNumber2(r2)),
    s2 === 0n ? "0x" : trimLeft(fromNumber2(s2))
  ];
}
function validate5(signature, options = {}) {
  try {
    assert2(signature, options);
    return true;
  } catch {
    return false;
  }
}
function vToYParity(v2) {
  if (v2 === 0 || v2 === 27)
    return 0;
  if (v2 === 1 || v2 === 28)
    return 1;
  if (v2 >= 35)
    return v2 % 2 === 0 ? 1 : 0;
  throw new InvalidVError({ value: v2 });
}
function yParityToV(yParity) {
  if (yParity === 0)
    return 27;
  if (yParity === 1)
    return 28;
  throw new InvalidYParityError({ value: yParity });
}
var InvalidSerializedSizeError = class extends BaseError2 {
  constructor({ signature }) {
    super(`Value \`${signature}\` is an invalid signature size.`, {
      metaMessages: [
        "Expected: 64 bytes or 65 bytes.",
        `Received ${size2(from2(signature))} bytes.`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidSerializedSizeError"
    });
  }
};
var MissingPropertiesError = class extends BaseError2 {
  constructor({ signature }) {
    super(`Signature \`${stringify(signature)}\` is missing either an \`r\`, \`s\`, or \`yParity\` property.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.MissingPropertiesError"
    });
  }
};
var InvalidRError = class extends BaseError2 {
  constructor({ value }) {
    super(`Value \`${value}\` is an invalid r value. r must be a positive integer less than 2^256.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidRError"
    });
  }
};
var InvalidSError = class extends BaseError2 {
  constructor({ value }) {
    super(`Value \`${value}\` is an invalid s value. s must be a positive integer less than 2^256.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidSError"
    });
  }
};
var InvalidYParityError = class extends BaseError2 {
  constructor({ value }) {
    super(`Value \`${value}\` is an invalid y-parity value. Y-parity must be 0 or 1.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidYParityError"
    });
  }
};
var InvalidVError = class extends BaseError2 {
  constructor({ value }) {
    super(`Value \`${value}\` is an invalid v value. v must be 27, 28 or >=35.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Signature.InvalidVError"
    });
  }
};

// node_modules/ox/_esm/core/Authorization.js
function from11(authorization, options = {}) {
  if (typeof authorization.chainId === "string")
    return fromRpc3(authorization);
  return { ...authorization, ...options.signature };
}
function fromRpc3(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = extract2(authorization);
  return {
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    ...signature
  };
}
function fromRpcList(authorizationList) {
  return authorizationList.map(fromRpc3);
}
function fromTuple2(tuple) {
  const [chainId, address, nonce, yParity, r2, s2] = tuple;
  const signature = yParity && r2 && s2 ? fromTuple([yParity, r2, s2]) : void 0;
  return from11({
    address,
    chainId: Number(chainId),
    nonce: BigInt(nonce),
    ...signature
  });
}
function fromTupleList2(tupleList) {
  const list = [];
  for (const tuple of tupleList)
    list.push(fromTuple2(tuple));
  return list;
}
function getSignPayload(authorization) {
  return hash(authorization);
}
function hash(authorization) {
  return keccak2562(concat2("0x05", fromHex3(toTuple2(authorization))));
}
function toRpc3(authorization) {
  const { address, chainId, nonce, ...signature } = authorization;
  return {
    address,
    chainId: fromNumber2(chainId),
    nonce: fromNumber2(nonce),
    ...toRpc2(signature)
  };
}
function toRpcList(authorizationList) {
  return authorizationList.map(toRpc3);
}
function toTuple2(authorization) {
  const { address, chainId, nonce } = authorization;
  const signature = extract2(authorization);
  return [
    chainId ? fromNumber2(chainId) : "0x",
    address,
    nonce ? fromNumber2(nonce) : "0x",
    ...signature ? toTuple(signature) : []
  ];
}
function toTupleList2(list) {
  if (!list || list.length === 0)
    return [];
  const tupleList = [];
  for (const authorization of list)
    tupleList.push(toTuple2(authorization));
  return tupleList;
}

// node_modules/ox/_esm/core/Base58.js
var Base58_exports = {};
__export(Base58_exports, {
  fromBytes: () => fromBytes4,
  fromHex: () => fromHex5,
  fromString: () => fromString3,
  toBytes: () => toBytes7,
  toHex: () => toHex6,
  toString: () => toString3
});

// node_modules/ox/_esm/core/internal/base58.js
var integerToAlphabet = "123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz";
var alphabetToInteger = (
  /* __PURE__ */
  Object.freeze({
    1: 0n,
    2: 1n,
    3: 2n,
    4: 3n,
    5: 4n,
    6: 5n,
    7: 6n,
    8: 7n,
    9: 8n,
    A: 9n,
    B: 10n,
    C: 11n,
    D: 12n,
    E: 13n,
    F: 14n,
    G: 15n,
    H: 16n,
    J: 17n,
    K: 18n,
    L: 19n,
    M: 20n,
    N: 21n,
    P: 22n,
    Q: 23n,
    R: 24n,
    S: 25n,
    T: 26n,
    U: 27n,
    V: 28n,
    W: 29n,
    X: 30n,
    Y: 31n,
    Z: 32n,
    a: 33n,
    b: 34n,
    c: 35n,
    d: 36n,
    e: 37n,
    f: 38n,
    g: 39n,
    h: 40n,
    i: 41n,
    j: 42n,
    k: 43n,
    m: 44n,
    n: 45n,
    o: 46n,
    p: 47n,
    q: 48n,
    r: 49n,
    s: 50n,
    t: 51n,
    u: 52n,
    v: 53n,
    w: 54n,
    x: 55n,
    y: 56n,
    z: 57n
  })
);
function from12(value) {
  let bytes = from(value);
  let integer = (() => {
    let hex3 = value;
    if (value instanceof Uint8Array)
      hex3 = fromBytes(bytes);
    return BigInt(hex3);
  })();
  let result = "";
  while (integer > 0n) {
    const remainder = Number(integer % 58n);
    integer = integer / 58n;
    result = integerToAlphabet[remainder] + result;
  }
  while (bytes.length > 1 && bytes[0] === 0) {
    result = "1" + result;
    bytes = bytes.slice(1);
  }
  return result;
}

// node_modules/ox/_esm/core/Base58.js
function fromBytes4(value) {
  return from12(value);
}
function fromHex5(value) {
  return from12(value);
}
function fromString3(value) {
  return from12(fromString(value));
}
function toBytes7(value) {
  return fromHex2(toHex6(value));
}
function toHex6(value) {
  let integer = BigInt(0);
  let pad2 = 0;
  let checkPad = true;
  for (let i2 = 0; i2 < value.length; i2++) {
    const char = value[i2];
    if (checkPad && char === "1")
      pad2++;
    else
      checkPad = false;
    if (typeof alphabetToInteger[char] !== "bigint")
      throw new Error("invalid base58 character: " + char);
    integer = integer * 58n;
    integer = integer + alphabetToInteger[char];
  }
  if (!pad2)
    return `0x${integer.toString(16)}`;
  return `0x${"0".repeat(pad2 * 2)}${integer.toString(16)}`;
}
function toString3(value) {
  return toString2(toHex6(value));
}

// node_modules/ox/_esm/core/Base64.js
var Base64_exports = {};
__export(Base64_exports, {
  fromBytes: () => fromBytes5,
  fromHex: () => fromHex6,
  fromString: () => fromString4,
  toBytes: () => toBytes8,
  toHex: () => toHex7,
  toString: () => toString4
});
var encoder = new TextEncoder();
var decoder = new TextDecoder();
var integerToCharacter = Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a3, i2) => [i2, a3.charCodeAt(0)]));
var characterToInteger = {
  ...Object.fromEntries(Array.from("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/").map((a3, i2) => [a3.charCodeAt(0), i2])),
  ["=".charCodeAt(0)]: 0,
  ["-".charCodeAt(0)]: 62,
  ["_".charCodeAt(0)]: 63
};
function fromBytes5(value, options = {}) {
  const { pad: pad2 = true, url = false } = options;
  const encoded = new Uint8Array(Math.ceil(value.length / 3) * 4);
  for (let i2 = 0, j3 = 0; j3 < value.length; i2 += 4, j3 += 3) {
    const y2 = (value[j3] << 16) + (value[j3 + 1] << 8) + (value[j3 + 2] | 0);
    encoded[i2] = integerToCharacter[y2 >> 18];
    encoded[i2 + 1] = integerToCharacter[y2 >> 12 & 63];
    encoded[i2 + 2] = integerToCharacter[y2 >> 6 & 63];
    encoded[i2 + 3] = integerToCharacter[y2 & 63];
  }
  const k4 = value.length % 3;
  const end = Math.floor(value.length / 3) * 4 + (k4 && k4 + 1);
  let base642 = decoder.decode(new Uint8Array(encoded.buffer, 0, end));
  if (pad2 && k4 === 1)
    base642 += "==";
  if (pad2 && k4 === 2)
    base642 += "=";
  if (url)
    base642 = base642.replaceAll("+", "-").replaceAll("/", "_");
  return base642;
}
function fromHex6(value, options = {}) {
  return fromBytes5(fromHex2(value), options);
}
function fromString4(value, options = {}) {
  return fromBytes5(fromString(value), options);
}
function toBytes8(value) {
  const base642 = value.replace(/=+$/, "");
  const size5 = base642.length;
  const decoded = new Uint8Array(size5 + 3);
  encoder.encodeInto(base642 + "===", decoded);
  for (let i2 = 0, j3 = 0; i2 < base642.length; i2 += 4, j3 += 3) {
    const x2 = (characterToInteger[decoded[i2]] << 18) + (characterToInteger[decoded[i2 + 1]] << 12) + (characterToInteger[decoded[i2 + 2]] << 6) + characterToInteger[decoded[i2 + 3]];
    decoded[j3] = x2 >> 16;
    decoded[j3 + 1] = x2 >> 8 & 255;
    decoded[j3 + 2] = x2 & 255;
  }
  const decodedSize = (size5 >> 2) * 3 + (size5 % 4 && size5 % 4 - 1);
  return new Uint8Array(decoded.buffer, 0, decodedSize);
}
function toHex7(value) {
  return fromBytes(toBytes8(value));
}
function toString4(value) {
  return toString(toBytes8(value));
}

// node_modules/ox/_esm/core/BinaryStateTree.js
var BinaryStateTree_exports = {};
__export(BinaryStateTree_exports, {
  create: () => create2,
  insert: () => insert,
  merkelize: () => merkelize
});

// node_modules/@noble/hashes/esm/_blake.js
var BSIGMA = Uint8Array.from([
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9,
  12,
  5,
  1,
  15,
  14,
  13,
  4,
  10,
  0,
  7,
  6,
  3,
  9,
  2,
  8,
  11,
  13,
  11,
  7,
  14,
  12,
  1,
  3,
  9,
  5,
  0,
  15,
  4,
  8,
  6,
  2,
  10,
  6,
  15,
  14,
  9,
  11,
  3,
  0,
  8,
  12,
  2,
  13,
  7,
  1,
  4,
  10,
  5,
  10,
  2,
  8,
  4,
  7,
  6,
  1,
  5,
  15,
  11,
  9,
  14,
  3,
  12,
  13,
  0,
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7,
  8,
  9,
  10,
  11,
  12,
  13,
  14,
  15,
  14,
  10,
  4,
  8,
  9,
  15,
  13,
  6,
  1,
  12,
  0,
  2,
  11,
  7,
  5,
  3,
  // Blake1, unused in others
  11,
  8,
  12,
  0,
  5,
  2,
  15,
  13,
  10,
  14,
  3,
  6,
  7,
  1,
  9,
  4,
  7,
  9,
  3,
  1,
  13,
  12,
  11,
  14,
  2,
  6,
  5,
  10,
  4,
  0,
  15,
  8,
  9,
  0,
  5,
  7,
  2,
  4,
  10,
  15,
  14,
  1,
  11,
  12,
  6,
  8,
  3,
  13,
  2,
  12,
  6,
  10,
  0,
  11,
  8,
  3,
  4,
  13,
  7,
  5,
  15,
  14,
  1,
  9
]);
function G1s(a3, b4, c3, d2, x2) {
  a3 = a3 + b4 + x2 | 0;
  d2 = rotr(d2 ^ a3, 16);
  c3 = c3 + d2 | 0;
  b4 = rotr(b4 ^ c3, 12);
  return { a: a3, b: b4, c: c3, d: d2 };
}
function G2s(a3, b4, c3, d2, x2) {
  a3 = a3 + b4 + x2 | 0;
  d2 = rotr(d2 ^ a3, 8);
  c3 = c3 + d2 | 0;
  b4 = rotr(b4 ^ c3, 7);
  return { a: a3, b: b4, c: c3, d: d2 };
}

// node_modules/@noble/hashes/esm/blake2.js
var B2B_IV = Uint32Array.from([
  4089235720,
  1779033703,
  2227873595,
  3144134277,
  4271175723,
  1013904242,
  1595750129,
  2773480762,
  2917565137,
  1359893119,
  725511199,
  2600822924,
  4215389547,
  528734635,
  327033209,
  1541459225
]);
var BBUF = new Uint32Array(32);
function G1b(a3, b4, c3, d2, msg, x2) {
  const Xl2 = msg[x2], Xh = msg[x2 + 1];
  let Al2 = BBUF[2 * a3], Ah = BBUF[2 * a3 + 1];
  let Bl2 = BBUF[2 * b4], Bh = BBUF[2 * b4 + 1];
  let Cl2 = BBUF[2 * c3], Ch = BBUF[2 * c3 + 1];
  let Dl2 = BBUF[2 * d2], Dh = BBUF[2 * d2 + 1];
  let ll2 = add3L(Al2, Bl2, Xl2);
  Ah = add3H(ll2, Ah, Bh, Xh);
  Al2 = ll2 | 0;
  ({ Dh, Dl: Dl2 } = { Dh: Dh ^ Ah, Dl: Dl2 ^ Al2 });
  ({ Dh, Dl: Dl2 } = { Dh: rotr32H(Dh, Dl2), Dl: rotr32L(Dh, Dl2) });
  ({ h: Ch, l: Cl2 } = add(Ch, Cl2, Dh, Dl2));
  ({ Bh, Bl: Bl2 } = { Bh: Bh ^ Ch, Bl: Bl2 ^ Cl2 });
  ({ Bh, Bl: Bl2 } = { Bh: rotrSH(Bh, Bl2, 24), Bl: rotrSL(Bh, Bl2, 24) });
  BBUF[2 * a3] = Al2, BBUF[2 * a3 + 1] = Ah;
  BBUF[2 * b4] = Bl2, BBUF[2 * b4 + 1] = Bh;
  BBUF[2 * c3] = Cl2, BBUF[2 * c3 + 1] = Ch;
  BBUF[2 * d2] = Dl2, BBUF[2 * d2 + 1] = Dh;
}
function G2b(a3, b4, c3, d2, msg, x2) {
  const Xl2 = msg[x2], Xh = msg[x2 + 1];
  let Al2 = BBUF[2 * a3], Ah = BBUF[2 * a3 + 1];
  let Bl2 = BBUF[2 * b4], Bh = BBUF[2 * b4 + 1];
  let Cl2 = BBUF[2 * c3], Ch = BBUF[2 * c3 + 1];
  let Dl2 = BBUF[2 * d2], Dh = BBUF[2 * d2 + 1];
  let ll2 = add3L(Al2, Bl2, Xl2);
  Ah = add3H(ll2, Ah, Bh, Xh);
  Al2 = ll2 | 0;
  ({ Dh, Dl: Dl2 } = { Dh: Dh ^ Ah, Dl: Dl2 ^ Al2 });
  ({ Dh, Dl: Dl2 } = { Dh: rotrSH(Dh, Dl2, 16), Dl: rotrSL(Dh, Dl2, 16) });
  ({ h: Ch, l: Cl2 } = add(Ch, Cl2, Dh, Dl2));
  ({ Bh, Bl: Bl2 } = { Bh: Bh ^ Ch, Bl: Bl2 ^ Cl2 });
  ({ Bh, Bl: Bl2 } = { Bh: rotrBH(Bh, Bl2, 63), Bl: rotrBL(Bh, Bl2, 63) });
  BBUF[2 * a3] = Al2, BBUF[2 * a3 + 1] = Ah;
  BBUF[2 * b4] = Bl2, BBUF[2 * b4 + 1] = Bh;
  BBUF[2 * c3] = Cl2, BBUF[2 * c3 + 1] = Ch;
  BBUF[2 * d2] = Dl2, BBUF[2 * d2 + 1] = Dh;
}
function checkBlake2Opts(outputLen, opts = {}, keyLen, saltLen, persLen) {
  anumber(keyLen);
  if (outputLen < 0 || outputLen > keyLen)
    throw new Error("outputLen bigger than keyLen");
  const { key, salt, personalization } = opts;
  if (key !== void 0 && (key.length < 1 || key.length > keyLen))
    throw new Error("key length must be undefined or 1.." + keyLen);
  if (salt !== void 0 && salt.length !== saltLen)
    throw new Error("salt must be undefined or " + saltLen);
  if (personalization !== void 0 && personalization.length !== persLen)
    throw new Error("personalization must be undefined or " + persLen);
}
var BLAKE2 = class extends Hash {
  constructor(blockLen, outputLen) {
    super();
    this.finished = false;
    this.destroyed = false;
    this.length = 0;
    this.pos = 0;
    anumber(blockLen);
    anumber(outputLen);
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.buffer = new Uint8Array(blockLen);
    this.buffer32 = u32(this.buffer);
  }
  update(data) {
    aexists(this);
    data = toBytes3(data);
    abytes(data);
    const { blockLen, buffer: buffer3, buffer32 } = this;
    const len = data.length;
    const offset = data.byteOffset;
    const buf = data.buffer;
    for (let pos = 0; pos < len; ) {
      if (this.pos === blockLen) {
        swap32IfBE(buffer32);
        this.compress(buffer32, 0, false);
        swap32IfBE(buffer32);
        this.pos = 0;
      }
      const take = Math.min(blockLen - this.pos, len - pos);
      const dataOffset = offset + pos;
      if (take === blockLen && !(dataOffset % 4) && pos + take < len) {
        const data32 = new Uint32Array(buf, dataOffset, Math.floor((len - pos) / 4));
        swap32IfBE(data32);
        for (let pos32 = 0; pos + blockLen < len; pos32 += buffer32.length, pos += blockLen) {
          this.length += blockLen;
          this.compress(data32, pos32, false);
        }
        swap32IfBE(data32);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      this.length += take;
      pos += take;
    }
    return this;
  }
  digestInto(out) {
    aexists(this);
    aoutput(out, this);
    const { pos, buffer32 } = this;
    this.finished = true;
    clean(this.buffer.subarray(pos));
    swap32IfBE(buffer32);
    this.compress(buffer32, 0, true);
    swap32IfBE(buffer32);
    const out32 = u32(out);
    this.get().forEach((v2, i2) => out32[i2] = swap8IfBE(v2));
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to4) {
    const { buffer: buffer3, length: length2, finished, destroyed, outputLen, pos } = this;
    to4 || (to4 = new this.constructor({ dkLen: outputLen }));
    to4.set(...this.get());
    to4.buffer.set(buffer3);
    to4.destroyed = destroyed;
    to4.finished = finished;
    to4.length = length2;
    to4.pos = pos;
    to4.outputLen = outputLen;
    return to4;
  }
  clone() {
    return this._cloneInto();
  }
};
var BLAKE2b = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 64 : opts.dkLen;
    super(128, olen);
    this.v0l = B2B_IV[0] | 0;
    this.v0h = B2B_IV[1] | 0;
    this.v1l = B2B_IV[2] | 0;
    this.v1h = B2B_IV[3] | 0;
    this.v2l = B2B_IV[4] | 0;
    this.v2h = B2B_IV[5] | 0;
    this.v3l = B2B_IV[6] | 0;
    this.v3h = B2B_IV[7] | 0;
    this.v4l = B2B_IV[8] | 0;
    this.v4h = B2B_IV[9] | 0;
    this.v5l = B2B_IV[10] | 0;
    this.v5h = B2B_IV[11] | 0;
    this.v6l = B2B_IV[12] | 0;
    this.v6h = B2B_IV[13] | 0;
    this.v7l = B2B_IV[14] | 0;
    this.v7h = B2B_IV[15] | 0;
    checkBlake2Opts(olen, opts, 64, 16, 16);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes3(key);
      keyLength = key.length;
    }
    this.v0l ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes3(salt);
      const slt = u32(salt);
      this.v4l ^= swap8IfBE(slt[0]);
      this.v4h ^= swap8IfBE(slt[1]);
      this.v5l ^= swap8IfBE(slt[2]);
      this.v5h ^= swap8IfBE(slt[3]);
    }
    if (personalization !== void 0) {
      personalization = toBytes3(personalization);
      const pers = u32(personalization);
      this.v6l ^= swap8IfBE(pers[0]);
      this.v6h ^= swap8IfBE(pers[1]);
      this.v7l ^= swap8IfBE(pers[2]);
      this.v7h ^= swap8IfBE(pers[3]);
    }
    if (key !== void 0) {
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  // prettier-ignore
  get() {
    let { v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h } = this;
    return [v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h];
  }
  // prettier-ignore
  set(v0l, v0h, v1l, v1h, v2l, v2h, v3l, v3h, v4l, v4h, v5l, v5h, v6l, v6h, v7l, v7h) {
    this.v0l = v0l | 0;
    this.v0h = v0h | 0;
    this.v1l = v1l | 0;
    this.v1h = v1h | 0;
    this.v2l = v2l | 0;
    this.v2h = v2h | 0;
    this.v3l = v3l | 0;
    this.v3h = v3h | 0;
    this.v4l = v4l | 0;
    this.v4h = v4h | 0;
    this.v5l = v5l | 0;
    this.v5h = v5h | 0;
    this.v6l = v6l | 0;
    this.v6h = v6h | 0;
    this.v7l = v7l | 0;
    this.v7h = v7h | 0;
  }
  compress(msg, offset, isLast) {
    this.get().forEach((v2, i2) => BBUF[i2] = v2);
    BBUF.set(B2B_IV, 16);
    let { h, l: l3 } = fromBig(BigInt(this.length));
    BBUF[24] = B2B_IV[8] ^ l3;
    BBUF[25] = B2B_IV[9] ^ h;
    if (isLast) {
      BBUF[28] = ~BBUF[28];
      BBUF[29] = ~BBUF[29];
    }
    let j3 = 0;
    const s2 = BSIGMA;
    for (let i2 = 0; i2 < 12; i2++) {
      G1b(0, 4, 8, 12, msg, offset + 2 * s2[j3++]);
      G2b(0, 4, 8, 12, msg, offset + 2 * s2[j3++]);
      G1b(1, 5, 9, 13, msg, offset + 2 * s2[j3++]);
      G2b(1, 5, 9, 13, msg, offset + 2 * s2[j3++]);
      G1b(2, 6, 10, 14, msg, offset + 2 * s2[j3++]);
      G2b(2, 6, 10, 14, msg, offset + 2 * s2[j3++]);
      G1b(3, 7, 11, 15, msg, offset + 2 * s2[j3++]);
      G2b(3, 7, 11, 15, msg, offset + 2 * s2[j3++]);
      G1b(0, 5, 10, 15, msg, offset + 2 * s2[j3++]);
      G2b(0, 5, 10, 15, msg, offset + 2 * s2[j3++]);
      G1b(1, 6, 11, 12, msg, offset + 2 * s2[j3++]);
      G2b(1, 6, 11, 12, msg, offset + 2 * s2[j3++]);
      G1b(2, 7, 8, 13, msg, offset + 2 * s2[j3++]);
      G2b(2, 7, 8, 13, msg, offset + 2 * s2[j3++]);
      G1b(3, 4, 9, 14, msg, offset + 2 * s2[j3++]);
      G2b(3, 4, 9, 14, msg, offset + 2 * s2[j3++]);
    }
    this.v0l ^= BBUF[0] ^ BBUF[16];
    this.v0h ^= BBUF[1] ^ BBUF[17];
    this.v1l ^= BBUF[2] ^ BBUF[18];
    this.v1h ^= BBUF[3] ^ BBUF[19];
    this.v2l ^= BBUF[4] ^ BBUF[20];
    this.v2h ^= BBUF[5] ^ BBUF[21];
    this.v3l ^= BBUF[6] ^ BBUF[22];
    this.v3h ^= BBUF[7] ^ BBUF[23];
    this.v4l ^= BBUF[8] ^ BBUF[24];
    this.v4h ^= BBUF[9] ^ BBUF[25];
    this.v5l ^= BBUF[10] ^ BBUF[26];
    this.v5h ^= BBUF[11] ^ BBUF[27];
    this.v6l ^= BBUF[12] ^ BBUF[28];
    this.v6h ^= BBUF[13] ^ BBUF[29];
    this.v7l ^= BBUF[14] ^ BBUF[30];
    this.v7h ^= BBUF[15] ^ BBUF[31];
    clean(BBUF);
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2b = createOptHasher((opts) => new BLAKE2b(opts));
function compress2(s2, offset, msg, rounds, v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15) {
  let j3 = 0;
  for (let i2 = 0; i2 < rounds; i2++) {
    ({ a: v0, b: v4, c: v8, d: v12 } = G1s(v0, v4, v8, v12, msg[offset + s2[j3++]]));
    ({ a: v0, b: v4, c: v8, d: v12 } = G2s(v0, v4, v8, v12, msg[offset + s2[j3++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G1s(v1, v5, v9, v13, msg[offset + s2[j3++]]));
    ({ a: v1, b: v5, c: v9, d: v13 } = G2s(v1, v5, v9, v13, msg[offset + s2[j3++]]));
    ({ a: v2, b: v6, c: v10, d: v14 } = G1s(v2, v6, v10, v14, msg[offset + s2[j3++]]));
    ({ a: v2, b: v6, c: v10, d: v14 } = G2s(v2, v6, v10, v14, msg[offset + s2[j3++]]));
    ({ a: v3, b: v7, c: v11, d: v15 } = G1s(v3, v7, v11, v15, msg[offset + s2[j3++]]));
    ({ a: v3, b: v7, c: v11, d: v15 } = G2s(v3, v7, v11, v15, msg[offset + s2[j3++]]));
    ({ a: v0, b: v5, c: v10, d: v15 } = G1s(v0, v5, v10, v15, msg[offset + s2[j3++]]));
    ({ a: v0, b: v5, c: v10, d: v15 } = G2s(v0, v5, v10, v15, msg[offset + s2[j3++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G1s(v1, v6, v11, v12, msg[offset + s2[j3++]]));
    ({ a: v1, b: v6, c: v11, d: v12 } = G2s(v1, v6, v11, v12, msg[offset + s2[j3++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G1s(v2, v7, v8, v13, msg[offset + s2[j3++]]));
    ({ a: v2, b: v7, c: v8, d: v13 } = G2s(v2, v7, v8, v13, msg[offset + s2[j3++]]));
    ({ a: v3, b: v4, c: v9, d: v14 } = G1s(v3, v4, v9, v14, msg[offset + s2[j3++]]));
    ({ a: v3, b: v4, c: v9, d: v14 } = G2s(v3, v4, v9, v14, msg[offset + s2[j3++]]));
  }
  return { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 };
}
var B2S_IV = SHA256_IV;
var BLAKE2s = class extends BLAKE2 {
  constructor(opts = {}) {
    const olen = opts.dkLen === void 0 ? 32 : opts.dkLen;
    super(64, olen);
    this.v0 = B2S_IV[0] | 0;
    this.v1 = B2S_IV[1] | 0;
    this.v2 = B2S_IV[2] | 0;
    this.v3 = B2S_IV[3] | 0;
    this.v4 = B2S_IV[4] | 0;
    this.v5 = B2S_IV[5] | 0;
    this.v6 = B2S_IV[6] | 0;
    this.v7 = B2S_IV[7] | 0;
    checkBlake2Opts(olen, opts, 32, 8, 8);
    let { key, personalization, salt } = opts;
    let keyLength = 0;
    if (key !== void 0) {
      key = toBytes3(key);
      keyLength = key.length;
    }
    this.v0 ^= this.outputLen | keyLength << 8 | 1 << 16 | 1 << 24;
    if (salt !== void 0) {
      salt = toBytes3(salt);
      const slt = u32(salt);
      this.v4 ^= swap8IfBE(slt[0]);
      this.v5 ^= swap8IfBE(slt[1]);
    }
    if (personalization !== void 0) {
      personalization = toBytes3(personalization);
      const pers = u32(personalization);
      this.v6 ^= swap8IfBE(pers[0]);
      this.v7 ^= swap8IfBE(pers[1]);
    }
    if (key !== void 0) {
      abytes(key);
      const tmp = new Uint8Array(this.blockLen);
      tmp.set(key);
      this.update(tmp);
    }
  }
  get() {
    const { v0, v1, v2, v3, v4, v5, v6, v7 } = this;
    return [v0, v1, v2, v3, v4, v5, v6, v7];
  }
  // prettier-ignore
  set(v0, v1, v2, v3, v4, v5, v6, v7) {
    this.v0 = v0 | 0;
    this.v1 = v1 | 0;
    this.v2 = v2 | 0;
    this.v3 = v3 | 0;
    this.v4 = v4 | 0;
    this.v5 = v5 | 0;
    this.v6 = v6 | 0;
    this.v7 = v7 | 0;
  }
  compress(msg, offset, isLast) {
    const { h, l: l3 } = fromBig(BigInt(this.length));
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress2(BSIGMA, offset, msg, 10, this.v0, this.v1, this.v2, this.v3, this.v4, this.v5, this.v6, this.v7, B2S_IV[0], B2S_IV[1], B2S_IV[2], B2S_IV[3], l3 ^ B2S_IV[4], h ^ B2S_IV[5], isLast ? ~B2S_IV[6] : B2S_IV[6], B2S_IV[7]);
    this.v0 ^= v0 ^ v8;
    this.v1 ^= v1 ^ v9;
    this.v2 ^= v2 ^ v10;
    this.v3 ^= v3 ^ v11;
    this.v4 ^= v4 ^ v12;
    this.v5 ^= v5 ^ v13;
    this.v6 ^= v6 ^ v14;
    this.v7 ^= v7 ^ v15;
  }
  destroy() {
    this.destroyed = true;
    clean(this.buffer32);
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var blake2s = createOptHasher((opts) => new BLAKE2s(opts));

// node_modules/@noble/hashes/esm/blake3.js
var B3_Flags = {
  CHUNK_START: 1,
  CHUNK_END: 2,
  PARENT: 4,
  ROOT: 8,
  KEYED_HASH: 16,
  DERIVE_KEY_CONTEXT: 32,
  DERIVE_KEY_MATERIAL: 64
};
var B3_IV = SHA256_IV.slice();
var B3_SIGMA = (() => {
  const Id3 = Array.from({ length: 16 }, (_2, i2) => i2);
  const permute = (arr) => [2, 6, 3, 10, 7, 0, 4, 13, 1, 11, 12, 5, 9, 14, 15, 8].map((i2) => arr[i2]);
  const res = [];
  for (let i2 = 0, v2 = Id3; i2 < 7; i2++, v2 = permute(v2))
    res.push(...v2);
  return Uint8Array.from(res);
})();
var BLAKE3 = class _BLAKE3 extends BLAKE2 {
  constructor(opts = {}, flags = 0) {
    super(64, opts.dkLen === void 0 ? 32 : opts.dkLen);
    this.chunkPos = 0;
    this.chunksDone = 0;
    this.flags = 0 | 0;
    this.stack = [];
    this.posOut = 0;
    this.bufferOut32 = new Uint32Array(16);
    this.chunkOut = 0;
    this.enableXOF = true;
    const { key, context } = opts;
    const hasContext = context !== void 0;
    if (key !== void 0) {
      if (hasContext)
        throw new Error('Only "key" or "context" can be specified at same time');
      const k4 = toBytes3(key).slice();
      abytes(k4, 32);
      this.IV = u32(k4);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.KEYED_HASH;
    } else if (hasContext) {
      const ctx = toBytes3(context);
      const contextKey = new _BLAKE3({ dkLen: 32 }, B3_Flags.DERIVE_KEY_CONTEXT).update(ctx).digest();
      this.IV = u32(contextKey);
      swap32IfBE(this.IV);
      this.flags = flags | B3_Flags.DERIVE_KEY_MATERIAL;
    } else {
      this.IV = B3_IV.slice();
      this.flags = flags;
    }
    this.state = this.IV.slice();
    this.bufferOut = u8(this.bufferOut32);
  }
  // Unused
  get() {
    return [];
  }
  set() {
  }
  b2Compress(counter2, flags, buf, bufPos = 0) {
    const { state: s2, pos } = this;
    const { h, l: l3 } = fromBig(BigInt(counter2), true);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress2(B3_SIGMA, bufPos, buf, 7, s2[0], s2[1], s2[2], s2[3], s2[4], s2[5], s2[6], s2[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], h, l3, pos, flags);
    s2[0] = v0 ^ v8;
    s2[1] = v1 ^ v9;
    s2[2] = v2 ^ v10;
    s2[3] = v3 ^ v11;
    s2[4] = v4 ^ v12;
    s2[5] = v5 ^ v13;
    s2[6] = v6 ^ v14;
    s2[7] = v7 ^ v15;
  }
  compress(buf, bufPos = 0, isLast = false) {
    let flags = this.flags;
    if (!this.chunkPos)
      flags |= B3_Flags.CHUNK_START;
    if (this.chunkPos === 15 || isLast)
      flags |= B3_Flags.CHUNK_END;
    if (!isLast)
      this.pos = this.blockLen;
    this.b2Compress(this.chunksDone, flags, buf, bufPos);
    this.chunkPos += 1;
    if (this.chunkPos === 16 || isLast) {
      let chunk = this.state;
      this.state = this.IV.slice();
      for (let last, chunks = this.chunksDone + 1; isLast || !(chunks & 1); chunks >>= 1) {
        if (!(last = this.stack.pop()))
          break;
        this.buffer32.set(last, 0);
        this.buffer32.set(chunk, 8);
        this.pos = this.blockLen;
        this.b2Compress(0, this.flags | B3_Flags.PARENT, this.buffer32, 0);
        chunk = this.state;
        this.state = this.IV.slice();
      }
      this.chunksDone++;
      this.chunkPos = 0;
      this.stack.push(chunk);
    }
    this.pos = 0;
  }
  _cloneInto(to4) {
    to4 = super._cloneInto(to4);
    const { IV, flags, state, chunkPos, posOut, chunkOut, stack, chunksDone } = this;
    to4.state.set(state.slice());
    to4.stack = stack.map((i2) => Uint32Array.from(i2));
    to4.IV.set(IV);
    to4.flags = flags;
    to4.chunkPos = chunkPos;
    to4.chunksDone = chunksDone;
    to4.posOut = posOut;
    to4.chunkOut = chunkOut;
    to4.enableXOF = this.enableXOF;
    to4.bufferOut32.set(this.bufferOut32);
    return to4;
  }
  destroy() {
    this.destroyed = true;
    clean(this.state, this.buffer32, this.IV, this.bufferOut32);
    clean(...this.stack);
  }
  // Same as b2Compress, but doesn't modify state and returns 16 u32 array (instead of 8)
  b2CompressOut() {
    const { state: s2, pos, flags, buffer32, bufferOut32: out32 } = this;
    const { h, l: l3 } = fromBig(BigInt(this.chunkOut++));
    swap32IfBE(buffer32);
    const { v0, v1, v2, v3, v4, v5, v6, v7, v8, v9, v10, v11, v12, v13, v14, v15 } = compress2(B3_SIGMA, 0, buffer32, 7, s2[0], s2[1], s2[2], s2[3], s2[4], s2[5], s2[6], s2[7], B3_IV[0], B3_IV[1], B3_IV[2], B3_IV[3], l3, h, pos, flags);
    out32[0] = v0 ^ v8;
    out32[1] = v1 ^ v9;
    out32[2] = v2 ^ v10;
    out32[3] = v3 ^ v11;
    out32[4] = v4 ^ v12;
    out32[5] = v5 ^ v13;
    out32[6] = v6 ^ v14;
    out32[7] = v7 ^ v15;
    out32[8] = s2[0] ^ v8;
    out32[9] = s2[1] ^ v9;
    out32[10] = s2[2] ^ v10;
    out32[11] = s2[3] ^ v11;
    out32[12] = s2[4] ^ v12;
    out32[13] = s2[5] ^ v13;
    out32[14] = s2[6] ^ v14;
    out32[15] = s2[7] ^ v15;
    swap32IfBE(buffer32);
    swap32IfBE(out32);
    this.posOut = 0;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    clean(this.buffer.subarray(this.pos));
    let flags = this.flags | B3_Flags.ROOT;
    if (this.stack.length) {
      flags |= B3_Flags.PARENT;
      swap32IfBE(this.buffer32);
      this.compress(this.buffer32, 0, true);
      swap32IfBE(this.buffer32);
      this.chunksDone = 0;
      this.pos = this.blockLen;
    } else {
      flags |= (!this.chunkPos ? B3_Flags.CHUNK_START : 0) | B3_Flags.CHUNK_END;
    }
    this.flags = flags;
    this.b2CompressOut();
  }
  writeInto(out) {
    aexists(this, false);
    abytes(out);
    this.finish();
    const { blockLen, bufferOut } = this;
    for (let pos = 0, len = out.length; pos < len; ) {
      if (this.posOut >= blockLen)
        this.b2CompressOut();
      const take = Math.min(blockLen - this.posOut, len - pos);
      out.set(bufferOut.subarray(this.posOut, this.posOut + take), pos);
      this.posOut += take;
      pos += take;
    }
    return out;
  }
  xofInto(out) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible after digest call");
    return this.writeInto(out);
  }
  xof(bytes) {
    anumber(bytes);
    return this.xofInto(new Uint8Array(bytes));
  }
  digestInto(out) {
    aoutput(out, this);
    if (this.finished)
      throw new Error("digest() was already called");
    this.enableXOF = false;
    this.writeInto(out);
    this.destroy();
    return out;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
};
var blake3 = createXOFer((opts) => new BLAKE3(opts));

// node_modules/ox/_esm/core/BinaryStateTree.js
function create2() {
  return {
    root: emptyNode()
  };
}
function insert(tree, key, value) {
  const stem = slice(key, 0, 31);
  const subIndex = slice(key, 31)[0];
  if (tree.root.type === "empty") {
    tree.root = stemNode(stem);
    tree.root.values[subIndex] = value;
    return;
  }
  function inner(node_, stem2, subIndex2, value2, depth) {
    let node = node_;
    if (node.type === "empty") {
      node = stemNode(stem2);
      node.values[subIndex2] = value2;
      return node;
    }
    const stemBits = bytesToBits(stem2);
    if (node.type === "stem") {
      if (isEqual(node.stem, stem2)) {
        node.values[subIndex2] = value2;
        return node;
      }
      const existingStemBits = bytesToBits(node.stem);
      return splitLeaf(node, stemBits, existingStemBits, subIndex2, value2, depth);
    }
    if (node.type === "internal") {
      const bit = stemBits[depth];
      if (bit === 0) {
        node.left = inner(node.left, stem2, subIndex2, value2, depth + 1);
      } else {
        node.right = inner(node.right, stem2, subIndex2, value2, depth + 1);
      }
      return node;
    }
    return emptyNode();
  }
  tree.root = inner(tree.root, stem, subIndex, value, 0);
}
function merkelize(tree) {
  function inner(node) {
    if (node.type === "empty")
      return new Uint8Array(32).fill(0);
    if (node.type === "internal") {
      const hash_left = inner(node.left);
      const hash_right = inner(node.right);
      return hash2(concat(hash_left, hash_right));
    }
    let level = node.values.map(hash2);
    while (level.length > 1) {
      const level_ = [];
      for (let i2 = 0; i2 < level.length; i2 += 2)
        level_.push(hash2(concat(level[i2], level[i2 + 1])));
      level = level_;
    }
    return hash2(concat(node.stem, new Uint8Array(1).fill(0), level[0]));
  }
  return inner(tree.root);
}
function splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth) {
  if (stemBits[depth] === existingStemBits[depth]) {
    const internal2 = internalNode();
    const bit2 = stemBits[depth];
    if (bit2 === 0) {
      internal2.left = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth + 1);
    } else {
      internal2.right = splitLeaf(leaf, stemBits, existingStemBits, subIndex, value, depth + 1);
    }
    return internal2;
  }
  const internal = internalNode();
  const bit = stemBits[depth];
  const stem = bitsToBytes(stemBits);
  if (bit === 0) {
    internal.left = stemNode(stem);
    internal.left.values[subIndex] = value;
    internal.right = leaf;
  } else {
    internal.right = stemNode(stem);
    internal.right.values[subIndex] = value;
    internal.left = leaf;
  }
  return internal;
}
function emptyNode() {
  return {
    type: "empty"
  };
}
function internalNode() {
  return {
    left: emptyNode(),
    right: emptyNode(),
    type: "internal"
  };
}
function stemNode(stem) {
  return {
    stem,
    values: Array.from({ length: 256 }, () => void 0),
    type: "stem"
  };
}
function bytesToBits(bytes) {
  const bits = [];
  for (const byte of bytes)
    for (let i2 = 0; i2 < 8; i2++)
      bits.push(byte >> 7 - i2 & 1);
  return bits;
}
function bitsToBytes(bits) {
  const byte_data = new Uint8Array(bits.length / 8);
  for (let i2 = 0; i2 < bits.length; i2 += 8) {
    let byte = 0;
    for (let j3 = 0; j3 < 8; j3++)
      byte |= bits[i2 + j3] << 7 - j3;
    byte_data[i2 / 8] = byte;
  }
  return byte_data;
}
function hash2(bytes) {
  if (!bytes)
    return new Uint8Array(32).fill(0);
  if (!bytes.some((byte) => byte !== 0))
    return new Uint8Array(32).fill(0);
  return blake3(bytes);
}

// node_modules/ox/_esm/core/Blobs.js
var Blobs_exports = {};
__export(Blobs_exports, {
  BlobSizeTooLargeError: () => BlobSizeTooLargeError,
  EmptyBlobError: () => EmptyBlobError,
  EmptyBlobVersionedHashesError: () => EmptyBlobVersionedHashesError,
  InvalidVersionedHashSizeError: () => InvalidVersionedHashSizeError,
  InvalidVersionedHashVersionError: () => InvalidVersionedHashVersionError,
  bytesPerBlob: () => bytesPerBlob,
  bytesPerFieldElement: () => bytesPerFieldElement,
  commitmentToVersionedHash: () => commitmentToVersionedHash,
  commitmentsToVersionedHashes: () => commitmentsToVersionedHashes,
  fieldElementsPerBlob: () => fieldElementsPerBlob,
  from: () => from14,
  maxBytesPerTransaction: () => maxBytesPerTransaction,
  sidecarsToVersionedHashes: () => sidecarsToVersionedHashes,
  to: () => to2,
  toBytes: () => toBytes9,
  toCommitments: () => toCommitments,
  toHex: () => toHex8,
  toProofs: () => toProofs,
  toSidecars: () => toSidecars,
  toVersionedHashes: () => toVersionedHashes
});

// node_modules/ox/_esm/core/Kzg.js
var Kzg_exports = {};
__export(Kzg_exports, {
  from: () => from13,
  versionedHashVersion: () => versionedHashVersion
});
var versionedHashVersion = 1;
function from13(value) {
  const { blobToKzgCommitment, computeBlobKzgProof } = value;
  return {
    blobToKzgCommitment,
    computeBlobKzgProof
  };
}

// node_modules/ox/_esm/core/Blobs.js
var blobsPerTransaction = 6;
var bytesPerFieldElement = 32;
var fieldElementsPerBlob = 4096;
var bytesPerBlob = bytesPerFieldElement * fieldElementsPerBlob;
var maxBytesPerTransaction = bytesPerBlob * blobsPerTransaction - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * fieldElementsPerBlob * blobsPerTransaction;
function commitmentsToVersionedHashes(commitments, options = {}) {
  const { version: version7 } = options;
  const as2 = options.as ?? (typeof commitments[0] === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const commitment of commitments) {
    hashes.push(commitmentToVersionedHash(commitment, {
      as: as2,
      version: version7
    }));
  }
  return hashes;
}
function commitmentToVersionedHash(commitment, options = {}) {
  const { version: version7 = 1 } = options;
  const as2 = options.as ?? (typeof commitment === "string" ? "Hex" : "Bytes");
  const versionedHash = sha2563(commitment, { as: "Bytes" });
  versionedHash.set([version7], 0);
  return as2 === "Bytes" ? versionedHash : fromBytes(versionedHash);
}
function from14(data, options = {}) {
  const as2 = options.as ?? (typeof data === "string" ? "Hex" : "Bytes");
  const data_ = typeof data === "string" ? fromHex2(data) : data;
  const size_ = size(data_);
  if (!size_)
    throw new EmptyBlobError();
  if (size_ > maxBytesPerTransaction)
    throw new BlobSizeTooLargeError({
      maxSize: maxBytesPerTransaction,
      size: size_
    });
  const blobs = [];
  let active = true;
  let position = 0;
  while (active) {
    const blob = create(new Uint8Array(bytesPerBlob));
    let size5 = 0;
    while (size5 < fieldElementsPerBlob) {
      const bytes = data_.slice(position, position + (bytesPerFieldElement - 1));
      blob.pushByte(0);
      blob.pushBytes(bytes);
      if (bytes.length < 31) {
        blob.pushByte(128);
        active = false;
        break;
      }
      size5++;
      position += 31;
    }
    blobs.push(blob);
  }
  return as2 === "Bytes" ? blobs.map((x2) => x2.bytes) : blobs.map((x2) => fromBytes(x2.bytes));
}
function sidecarsToVersionedHashes(sidecars, options = {}) {
  const { version: version7 } = options;
  const as2 = options.as ?? (typeof sidecars[0].blob === "string" ? "Hex" : "Bytes");
  const hashes = [];
  for (const { commitment } of sidecars) {
    hashes.push(commitmentToVersionedHash(commitment, {
      as: as2,
      version: version7
    }));
  }
  return hashes;
}
function to2(blobs, to4) {
  const to_ = to4 ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x2) => fromHex2(x2)) : blobs;
  const length2 = blobs_.reduce((length3, blob) => length3 + blob.length, 0);
  const data = create(new Uint8Array(length2));
  let active = true;
  for (const blob of blobs_) {
    const cursor = create(blob);
    while (active && cursor.position < blob.length) {
      cursor.incrementPosition(1);
      let consume = 31;
      if (blob.length - cursor.position < 31)
        consume = blob.length - cursor.position;
      for (const _2 in Array.from({ length: consume })) {
        const byte = cursor.readByte();
        const isTerminator = byte === 128 && !cursor.inspectBytes(cursor.remaining).includes(128);
        if (isTerminator) {
          active = false;
          break;
        }
        data.pushByte(byte);
      }
    }
  }
  const trimmedData = data.bytes.slice(0, data.position);
  return to_ === "Hex" ? fromBytes(trimmedData) : trimmedData;
}
function toHex8(blobs) {
  return to2(blobs, "Hex");
}
function toBytes9(blobs) {
  return to2(blobs, "Bytes");
}
function toCommitments(blobs, options) {
  const { kzg } = options;
  const as2 = options.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x2) => fromHex2(x2)) : blobs;
  const commitments = [];
  for (const blob of blobs_)
    commitments.push(Uint8Array.from(kzg.blobToKzgCommitment(blob)));
  return as2 === "Bytes" ? commitments : commitments.map((x2) => fromBytes(x2));
}
function toProofs(blobs, options) {
  const { kzg } = options;
  const as2 = options.as ?? (typeof blobs[0] === "string" ? "Hex" : "Bytes");
  const blobs_ = typeof blobs[0] === "string" ? blobs.map((x2) => fromHex2(x2)) : blobs;
  const commitments = typeof options.commitments[0] === "string" ? options.commitments.map((x2) => fromHex2(x2)) : options.commitments;
  const proofs = [];
  for (let i2 = 0; i2 < blobs_.length; i2++) {
    const blob = blobs_[i2];
    const commitment = commitments[i2];
    proofs.push(Uint8Array.from(kzg.computeBlobKzgProof(blob, commitment)));
  }
  return as2 === "Bytes" ? proofs : proofs.map((x2) => fromBytes(x2));
}
function toSidecars(blobs, options) {
  const { kzg } = options;
  const commitments = options.commitments ?? toCommitments(blobs, { kzg });
  const proofs = options.proofs ?? toProofs(blobs, { commitments, kzg });
  const sidecars = [];
  for (let i2 = 0; i2 < blobs.length; i2++)
    sidecars.push({
      blob: blobs[i2],
      commitment: commitments[i2],
      proof: proofs[i2]
    });
  return sidecars;
}
function toVersionedHashes(blobs, options) {
  const commitments = toCommitments(blobs, options);
  return commitmentsToVersionedHashes(commitments, options);
}
var BlobSizeTooLargeError = class extends BaseError2 {
  constructor({ maxSize, size: size5 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${maxSize} bytes`, `Given: ${size5} bytes`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.BlobSizeTooLargeError"
    });
  }
};
var EmptyBlobError = class extends BaseError2 {
  constructor() {
    super("Blob data must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.EmptyBlobError"
    });
  }
};
var EmptyBlobVersionedHashesError = class extends BaseError2 {
  constructor() {
    super("Blob versioned hashes must not be empty.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.EmptyBlobVersionedHashesError"
    });
  }
};
var InvalidVersionedHashSizeError = class extends BaseError2 {
  constructor({ hash: hash8, size: size5 }) {
    super(`Versioned hash "${hash8}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${size5}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.InvalidVersionedHashSizeError"
    });
  }
};
var InvalidVersionedHashVersionError = class extends BaseError2 {
  constructor({ hash: hash8, version: version7 }) {
    super(`Versioned hash "${hash8}" version is invalid.`, {
      metaMessages: [
        `Expected: ${versionedHashVersion}`,
        `Received: ${version7}`
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Blobs.InvalidVersionedHashVersionError"
    });
  }
};

// node_modules/ox/_esm/core/Block.js
var Block_exports = {};
__export(Block_exports, {
  fromRpc: () => fromRpc5,
  toRpc: () => toRpc5
});

// node_modules/ox/_esm/core/Transaction.js
var Transaction_exports = {};
__export(Transaction_exports, {
  fromRpc: () => fromRpc4,
  fromRpcType: () => fromRpcType,
  toRpc: () => toRpc4,
  toRpcType: () => toRpcType
});
var toRpcType = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
var fromRpcType = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function fromRpc4(transaction, _options = {}) {
  if (!transaction)
    return null;
  const signature = extract2(transaction);
  const transaction_ = {
    ...transaction,
    ...signature
  };
  transaction_.blockNumber = transaction.blockNumber ? BigInt(transaction.blockNumber) : null;
  transaction_.data = transaction.input;
  transaction_.gas = BigInt(transaction.gas ?? 0n);
  transaction_.nonce = BigInt(transaction.nonce ?? 0n);
  transaction_.transactionIndex = transaction.transactionIndex ? Number(transaction.transactionIndex) : null;
  transaction_.value = BigInt(transaction.value ?? 0n);
  if (transaction.authorizationList)
    transaction_.authorizationList = fromRpcList(transaction.authorizationList);
  if (transaction.chainId)
    transaction_.chainId = Number(transaction.chainId);
  if (transaction.gasPrice)
    transaction_.gasPrice = BigInt(transaction.gasPrice);
  if (transaction.maxFeePerBlobGas)
    transaction_.maxFeePerBlobGas = BigInt(transaction.maxFeePerBlobGas);
  if (transaction.maxFeePerGas)
    transaction_.maxFeePerGas = BigInt(transaction.maxFeePerGas);
  if (transaction.maxPriorityFeePerGas)
    transaction_.maxPriorityFeePerGas = BigInt(transaction.maxPriorityFeePerGas);
  if (transaction.type)
    transaction_.type = fromRpcType[transaction.type] ?? transaction.type;
  if (signature)
    transaction_.v = yParityToV(signature.yParity);
  return transaction_;
}
function toRpc4(transaction, _options) {
  const rpc2 = {};
  rpc2.blockHash = transaction.blockHash;
  rpc2.blockNumber = typeof transaction.blockNumber === "bigint" ? fromNumber2(transaction.blockNumber) : null;
  rpc2.from = transaction.from;
  rpc2.gas = fromNumber2(transaction.gas ?? 0n);
  rpc2.hash = transaction.hash;
  rpc2.input = transaction.input;
  rpc2.nonce = fromNumber2(transaction.nonce ?? 0n);
  rpc2.to = transaction.to;
  rpc2.transactionIndex = transaction.transactionIndex ? fromNumber2(transaction.transactionIndex) : null;
  rpc2.type = toRpcType[transaction.type] ?? transaction.type;
  rpc2.value = fromNumber2(transaction.value ?? 0n);
  if (transaction.accessList)
    rpc2.accessList = transaction.accessList;
  if (transaction.authorizationList)
    rpc2.authorizationList = toRpcList(transaction.authorizationList);
  if (transaction.blobVersionedHashes)
    rpc2.blobVersionedHashes = transaction.blobVersionedHashes;
  if (transaction.chainId)
    rpc2.chainId = fromNumber2(transaction.chainId);
  if (typeof transaction.gasPrice === "bigint")
    rpc2.gasPrice = fromNumber2(transaction.gasPrice);
  if (typeof transaction.maxFeePerBlobGas === "bigint")
    rpc2.maxFeePerBlobGas = fromNumber2(transaction.maxFeePerBlobGas);
  if (typeof transaction.maxFeePerGas === "bigint")
    rpc2.maxFeePerGas = fromNumber2(transaction.maxFeePerGas);
  if (typeof transaction.maxPriorityFeePerGas === "bigint")
    rpc2.maxPriorityFeePerGas = fromNumber2(transaction.maxPriorityFeePerGas);
  if (typeof transaction.r === "bigint")
    rpc2.r = fromNumber2(transaction.r, { size: 32 });
  if (typeof transaction.s === "bigint")
    rpc2.s = fromNumber2(transaction.s, { size: 32 });
  if (typeof transaction.v === "number")
    rpc2.v = fromNumber2(transaction.v, { size: 1 });
  if (typeof transaction.yParity === "number")
    rpc2.yParity = transaction.yParity === 0 ? "0x0" : "0x1";
  return rpc2;
}

// node_modules/ox/_esm/core/Block.js
function toRpc5(block, _options = {}) {
  var _a2;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return toRpc4(transaction);
  });
  return {
    baseFeePerGas: typeof block.baseFeePerGas === "bigint" ? fromNumber2(block.baseFeePerGas) : void 0,
    blobGasUsed: typeof block.blobGasUsed === "bigint" ? fromNumber2(block.blobGasUsed) : void 0,
    excessBlobGas: typeof block.excessBlobGas === "bigint" ? fromNumber2(block.excessBlobGas) : void 0,
    extraData: block.extraData,
    difficulty: typeof block.difficulty === "bigint" ? fromNumber2(block.difficulty) : void 0,
    gasLimit: fromNumber2(block.gasLimit),
    gasUsed: fromNumber2(block.gasUsed),
    hash: block.hash,
    logsBloom: block.logsBloom,
    miner: block.miner,
    mixHash: block.mixHash,
    nonce: block.nonce,
    number: typeof block.number === "bigint" ? fromNumber2(block.number) : null,
    parentBeaconBlockRoot: block.parentBeaconBlockRoot,
    parentHash: block.parentHash,
    receiptsRoot: block.receiptsRoot,
    sealFields: block.sealFields,
    sha3Uncles: block.sha3Uncles,
    size: fromNumber2(block.size),
    stateRoot: block.stateRoot,
    timestamp: fromNumber2(block.timestamp),
    totalDifficulty: typeof block.totalDifficulty === "bigint" ? fromNumber2(block.totalDifficulty) : void 0,
    transactions,
    transactionsRoot: block.transactionsRoot,
    uncles: block.uncles,
    withdrawals: (_a2 = block.withdrawals) == null ? void 0 : _a2.map(toRpc),
    withdrawalsRoot: block.withdrawalsRoot
  };
}
function fromRpc5(block, _options = {}) {
  var _a2;
  if (!block)
    return null;
  const transactions = block.transactions.map((transaction) => {
    if (typeof transaction === "string")
      return transaction;
    return fromRpc4(transaction);
  });
  return {
    ...block,
    baseFeePerGas: block.baseFeePerGas ? BigInt(block.baseFeePerGas) : void 0,
    blobGasUsed: block.blobGasUsed ? BigInt(block.blobGasUsed) : void 0,
    difficulty: block.difficulty ? BigInt(block.difficulty) : void 0,
    excessBlobGas: block.excessBlobGas ? BigInt(block.excessBlobGas) : void 0,
    gasLimit: BigInt(block.gasLimit ?? 0n),
    gasUsed: BigInt(block.gasUsed ?? 0n),
    number: block.number ? BigInt(block.number) : null,
    size: BigInt(block.size ?? 0n),
    stateRoot: block.stateRoot,
    timestamp: BigInt(block.timestamp ?? 0n),
    totalDifficulty: BigInt(block.totalDifficulty ?? 0n),
    transactions,
    withdrawals: (_a2 = block.withdrawals) == null ? void 0 : _a2.map(fromRpc)
  };
}

// node_modules/ox/_esm/core/Bloom.js
var Bloom_exports = {};
__export(Bloom_exports, {
  contains: () => contains,
  validate: () => validate6
});
function contains(bloom, input) {
  const filter3 = fromHex2(bloom);
  const hash8 = keccak2562(input, { as: "Bytes" });
  for (const i2 of [0, 2, 4]) {
    const bit = hash8[i2 + 1] + (hash8[i2] << 8) & 2047;
    if ((filter3[256 - 1 - Math.floor(bit / 8)] & 1 << bit % 8) === 0)
      return false;
  }
  return true;
}
function validate6(value) {
  return validate2(value) && size2(value) === 256;
}

// node_modules/ox/_esm/core/Bls.js
var Bls_exports = {};
__export(Bls_exports, {
  aggregate: () => aggregate,
  getPublicKey: () => getPublicKey,
  noble: () => noble,
  randomPrivateKey: () => randomPrivateKey,
  sign: () => sign,
  verify: () => verify
});

// node_modules/@noble/curves/esm/abstract/bls.js
var _0n = BigInt(0);
var _1n = BigInt(1);
var _2n = BigInt(2);
var _3n = BigInt(3);
function NAfDecomposition(a3) {
  const res = [];
  for (; a3 > _1n; a3 >>= _1n) {
    if ((a3 & _1n) === _0n)
      res.unshift(0);
    else if ((a3 & _3n) === _3n) {
      res.unshift(-1);
      a3 += _1n;
    } else
      res.unshift(1);
  }
  return res;
}
function bls(CURVE) {
  const { Fp: Fp3, Fr: Fr2, Fp2: Fp22, Fp6: Fp62, Fp12: Fp122 } = CURVE.fields;
  const BLS_X_IS_NEGATIVE = CURVE.params.xNegative;
  const TWIST = CURVE.params.twistType;
  const G1_ = weierstrassPoints({ n: Fr2.ORDER, ...CURVE.G1 });
  const G1 = Object.assign(G1_, createHasher(G1_.ProjectivePoint, CURVE.G1.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G1.htfDefaults
  }));
  const G2_ = weierstrassPoints({ n: Fr2.ORDER, ...CURVE.G2 });
  const G2 = Object.assign(G2_, createHasher(G2_.ProjectivePoint, CURVE.G2.mapToCurve, {
    ...CURVE.htfDefaults,
    ...CURVE.G2.htfDefaults
  }));
  let lineFunction;
  if (TWIST === "multiplicative") {
    lineFunction = (c0, c1, c22, f3, Px, Py) => Fp122.mul014(f3, c0, Fp22.mul(c1, Px), Fp22.mul(c22, Py));
  } else if (TWIST === "divisive") {
    lineFunction = (c0, c1, c22, f3, Px, Py) => Fp122.mul034(f3, Fp22.mul(c22, Py), Fp22.mul(c1, Px), c0);
  } else
    throw new Error("bls: unknown twist type");
  const Fp2div2 = Fp22.div(Fp22.ONE, Fp22.mul(Fp22.ONE, _2n));
  function pointDouble(ell, Rx, Ry, Rz) {
    const t0 = Fp22.sqr(Ry);
    const t1 = Fp22.sqr(Rz);
    const t2 = Fp22.mulByB(Fp22.mul(t1, _3n));
    const t3 = Fp22.mul(t2, _3n);
    const t4 = Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(Ry, Rz)), t1), t0);
    const c0 = Fp22.sub(t2, t0);
    const c1 = Fp22.mul(Fp22.sqr(Rx), _3n);
    const c22 = Fp22.neg(t4);
    ell.push([c0, c1, c22]);
    Rx = Fp22.mul(Fp22.mul(Fp22.mul(Fp22.sub(t0, t3), Rx), Ry), Fp2div2);
    Ry = Fp22.sub(Fp22.sqr(Fp22.mul(Fp22.add(t0, t3), Fp2div2)), Fp22.mul(Fp22.sqr(t2), _3n));
    Rz = Fp22.mul(t0, t4);
    return { Rx, Ry, Rz };
  }
  function pointAdd(ell, Rx, Ry, Rz, Qx, Qy) {
    const t0 = Fp22.sub(Ry, Fp22.mul(Qy, Rz));
    const t1 = Fp22.sub(Rx, Fp22.mul(Qx, Rz));
    const c0 = Fp22.sub(Fp22.mul(t0, Qx), Fp22.mul(t1, Qy));
    const c1 = Fp22.neg(t0);
    const c22 = t1;
    ell.push([c0, c1, c22]);
    const t2 = Fp22.sqr(t1);
    const t3 = Fp22.mul(t2, t1);
    const t4 = Fp22.mul(t2, Rx);
    const t5 = Fp22.add(Fp22.sub(t3, Fp22.mul(t4, _2n)), Fp22.mul(Fp22.sqr(t0), Rz));
    Rx = Fp22.mul(t1, t5);
    Ry = Fp22.sub(Fp22.mul(Fp22.sub(t4, t5), t0), Fp22.mul(t3, Ry));
    Rz = Fp22.mul(Rz, t3);
    return { Rx, Ry, Rz };
  }
  const ATE_NAF = NAfDecomposition(CURVE.params.ateLoopSize);
  const calcPairingPrecomputes = memoized((point) => {
    const p2 = point;
    const { x: x2, y: y2 } = p2.toAffine();
    const Qx = x2, Qy = y2, negQy = Fp22.neg(y2);
    let Rx = Qx, Ry = Qy, Rz = Fp22.ONE;
    const ell = [];
    for (const bit of ATE_NAF) {
      const cur = [];
      ({ Rx, Ry, Rz } = pointDouble(cur, Rx, Ry, Rz));
      if (bit)
        ({ Rx, Ry, Rz } = pointAdd(cur, Rx, Ry, Rz, Qx, bit === -1 ? negQy : Qy));
      ell.push(cur);
    }
    if (CURVE.postPrecompute) {
      const last = ell[ell.length - 1];
      CURVE.postPrecompute(Rx, Ry, Rz, Qx, Qy, pointAdd.bind(null, last));
    }
    return ell;
  });
  function millerLoopBatch(pairs, withFinalExponent = false) {
    let f12 = Fp122.ONE;
    if (pairs.length) {
      const ellLen = pairs[0][0].length;
      for (let i2 = 0; i2 < ellLen; i2++) {
        f12 = Fp122.sqr(f12);
        for (const [ell, Px, Py] of pairs) {
          for (const [c0, c1, c22] of ell[i2])
            f12 = lineFunction(c0, c1, c22, f12, Px, Py);
        }
      }
    }
    if (BLS_X_IS_NEGATIVE)
      f12 = Fp122.conjugate(f12);
    return withFinalExponent ? Fp122.finalExponentiate(f12) : f12;
  }
  function pairingBatch(pairs, withFinalExponent = true) {
    const res = [];
    G1.ProjectivePoint.normalizeZ(pairs.map(({ g1 }) => g1));
    G2.ProjectivePoint.normalizeZ(pairs.map(({ g2: g22 }) => g22));
    for (const { g1, g2: g22 } of pairs) {
      if (g1.equals(G1.ProjectivePoint.ZERO) || g22.equals(G2.ProjectivePoint.ZERO))
        throw new Error("pairing is not available for ZERO point");
      g1.assertValidity();
      g22.assertValidity();
      const Qa2 = g1.toAffine();
      res.push([calcPairingPrecomputes(g22), Qa2.x, Qa2.y]);
    }
    return millerLoopBatch(res, withFinalExponent);
  }
  function pairing(Q2, P, withFinalExponent = true) {
    return pairingBatch([{ g1: Q2, g2: P }], withFinalExponent);
  }
  const utils2 = {
    randomPrivateKey: () => {
      const length2 = getMinHashLength(Fr2.ORDER);
      return mapHashToField(CURVE.randomBytes(length2), Fr2.ORDER);
    },
    calcPairingPrecomputes
  };
  const { ShortSignature } = CURVE.G1;
  const { Signature } = CURVE.G2;
  function normP1(point) {
    return point instanceof G1.ProjectivePoint ? point : G1.ProjectivePoint.fromHex(point);
  }
  function normP1Hash(point, htfOpts) {
    return point instanceof G1.ProjectivePoint ? point : G1.hashToCurve(ensureBytes("point", point), htfOpts);
  }
  function normP2(point) {
    return point instanceof G2.ProjectivePoint ? point : Signature.fromHex(point);
  }
  function normP2Hash(point, htfOpts) {
    return point instanceof G2.ProjectivePoint ? point : G2.hashToCurve(ensureBytes("point", point), htfOpts);
  }
  function getPublicKey4(privateKey) {
    return G1.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
  }
  function getPublicKeyForShortSignatures(privateKey) {
    return G2.ProjectivePoint.fromPrivateKey(privateKey).toRawBytes(true);
  }
  function sign6(message, privateKey, htfOpts) {
    const msgPoint = normP2Hash(message, htfOpts);
    msgPoint.assertValidity();
    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
    if (message instanceof G2.ProjectivePoint)
      return sigPoint;
    return Signature.toRawBytes(sigPoint);
  }
  function signShortSignature(message, privateKey, htfOpts) {
    const msgPoint = normP1Hash(message, htfOpts);
    msgPoint.assertValidity();
    const sigPoint = msgPoint.multiply(G1.normPrivateKeyToScalar(privateKey));
    if (message instanceof G1.ProjectivePoint)
      return sigPoint;
    return ShortSignature.toRawBytes(sigPoint);
  }
  function verify6(signature, message, publicKey, htfOpts) {
    const P = normP1(publicKey);
    const Hm = normP2Hash(message, htfOpts);
    const G3 = G1.ProjectivePoint.BASE;
    const S2 = normP2(signature);
    const exp = pairingBatch([
      { g1: P.negate(), g2: Hm },
      // ePHM = pairing(P.negate(), Hm, false);
      { g1: G3, g2: S2 }
      // eGS = pairing(G, S, false);
    ]);
    return Fp122.eql(exp, Fp122.ONE);
  }
  function verifyShortSignature(signature, message, publicKey, htfOpts) {
    const P = normP2(publicKey);
    const Hm = normP1Hash(message, htfOpts);
    const G3 = G2.ProjectivePoint.BASE;
    const S2 = normP1(signature);
    const exp = pairingBatch([
      { g1: Hm, g2: P },
      // eHmP = pairing(Hm, P, false);
      { g1: S2, g2: G3.negate() }
      // eSG = pairing(S, G.negate(), false);
    ]);
    return Fp122.eql(exp, Fp122.ONE);
  }
  function aNonEmpty(arr) {
    if (!Array.isArray(arr) || arr.length === 0)
      throw new Error("expected non-empty array");
  }
  function aggregatePublicKeys(publicKeys) {
    aNonEmpty(publicKeys);
    const agg = publicKeys.map(normP1).reduce((sum, p2) => sum.add(p2), G1.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (publicKeys[0] instanceof G1.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return aggAffine.toRawBytes(true);
  }
  function aggregateSignatures(signatures) {
    aNonEmpty(signatures);
    const agg = signatures.map(normP2).reduce((sum, s2) => sum.add(s2), G2.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (signatures[0] instanceof G2.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return Signature.toRawBytes(aggAffine);
  }
  function aggregateShortSignatures(signatures) {
    aNonEmpty(signatures);
    const agg = signatures.map(normP1).reduce((sum, s2) => sum.add(s2), G1.ProjectivePoint.ZERO);
    const aggAffine = agg;
    if (signatures[0] instanceof G1.ProjectivePoint) {
      aggAffine.assertValidity();
      return aggAffine;
    }
    return ShortSignature.toRawBytes(aggAffine);
  }
  function verifyBatch(signature, messages, publicKeys, htfOpts) {
    aNonEmpty(messages);
    if (publicKeys.length !== messages.length)
      throw new Error("amount of public keys and messages should be equal");
    const sig = normP2(signature);
    const nMessages = messages.map((i2) => normP2Hash(i2, htfOpts));
    const nPublicKeys = publicKeys.map(normP1);
    const messagePubKeyMap = /* @__PURE__ */ new Map();
    for (let i2 = 0; i2 < nPublicKeys.length; i2++) {
      const pub = nPublicKeys[i2];
      const msg = nMessages[i2];
      let keys = messagePubKeyMap.get(msg);
      if (keys === void 0) {
        keys = [];
        messagePubKeyMap.set(msg, keys);
      }
      keys.push(pub);
    }
    const paired = [];
    try {
      for (const [msg, keys] of messagePubKeyMap) {
        const groupPublicKey = keys.reduce((acc, msg2) => acc.add(msg2));
        paired.push({ g1: groupPublicKey, g2: msg });
      }
      paired.push({ g1: G1.ProjectivePoint.BASE.negate(), g2: sig });
      return Fp122.eql(pairingBatch(paired), Fp122.ONE);
    } catch {
      return false;
    }
  }
  G1.ProjectivePoint.BASE._setWindowSize(4);
  return {
    getPublicKey: getPublicKey4,
    getPublicKeyForShortSignatures,
    sign: sign6,
    signShortSignature,
    verify: verify6,
    verifyBatch,
    verifyShortSignature,
    aggregatePublicKeys,
    aggregateSignatures,
    aggregateShortSignatures,
    millerLoopBatch,
    pairing,
    pairingBatch,
    G1,
    G2,
    Signature,
    ShortSignature,
    fields: {
      Fr: Fr2,
      Fp: Fp3,
      Fp2: Fp22,
      Fp6: Fp62,
      Fp12: Fp122
    },
    params: {
      ateLoopSize: CURVE.params.ateLoopSize,
      r: CURVE.params.r,
      G1b: CURVE.G1.b,
      G2b: CURVE.G2.b
    },
    utils: utils2
  };
}

// node_modules/@noble/curves/esm/abstract/tower.js
var _0n2 = BigInt(0);
var _1n2 = BigInt(1);
var _2n2 = BigInt(2);
var _3n2 = BigInt(3);
function calcFrobeniusCoefficients(Fp3, nonResidue, modulus, degree, num = 1, divisor) {
  const _divisor = BigInt(divisor === void 0 ? degree : divisor);
  const towerModulus = modulus ** BigInt(degree);
  const res = [];
  for (let i2 = 0; i2 < num; i2++) {
    const a3 = BigInt(i2 + 1);
    const powers2 = [];
    for (let j3 = 0, qPower = _1n2; j3 < degree; j3++) {
      const power = (a3 * qPower - a3) / _divisor % towerModulus;
      powers2.push(Fp3.pow(nonResidue, power));
      qPower *= modulus;
    }
    res.push(powers2);
  }
  return res;
}
function psiFrobenius(Fp3, Fp22, base3) {
  const PSI_X = Fp22.pow(base3, (Fp3.ORDER - _1n2) / _3n2);
  const PSI_Y = Fp22.pow(base3, (Fp3.ORDER - _1n2) / _2n2);
  function psi(x2, y2) {
    const x22 = Fp22.mul(Fp22.frobeniusMap(x2, 1), PSI_X);
    const y22 = Fp22.mul(Fp22.frobeniusMap(y2, 1), PSI_Y);
    return [x22, y22];
  }
  const PSI2_X = Fp22.pow(base3, (Fp3.ORDER ** _2n2 - _1n2) / _3n2);
  const PSI2_Y = Fp22.pow(base3, (Fp3.ORDER ** _2n2 - _1n2) / _2n2);
  if (!Fp22.eql(PSI2_Y, Fp22.neg(Fp22.ONE)))
    throw new Error("psiFrobenius: PSI2_Y!==-1");
  function psi2(x2, y2) {
    return [Fp22.mul(x2, PSI2_X), Fp22.neg(y2)];
  }
  const mapAffine = (fn2) => (c3, P) => {
    const affine = P.toAffine();
    const p2 = fn2(affine.x, affine.y);
    return c3.fromAffine({ x: p2[0], y: p2[1] });
  };
  const G2psi3 = mapAffine(psi);
  const G2psi22 = mapAffine(psi2);
  return { psi, psi2, G2psi: G2psi3, G2psi2: G2psi22, PSI_X, PSI_Y, PSI2_X, PSI2_Y };
}
function tower12(opts) {
  const { ORDER } = opts;
  const Fp3 = Field(ORDER);
  const FpNONRESIDUE = Fp3.create(opts.NONRESIDUE || BigInt(-1));
  const FpLegendre2 = FpLegendre(ORDER);
  const Fpdiv2 = Fp3.div(Fp3.ONE, _2n2);
  const FP2_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp3, FpNONRESIDUE, Fp3.ORDER, 2)[0];
  const Fp2Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp3.add(c0, r0),
    c1: Fp3.add(c1, r1)
  });
  const Fp2Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp3.sub(c0, r0),
    c1: Fp3.sub(c1, r1)
  });
  const Fp2Multiply = ({ c0, c1 }, rhs) => {
    if (typeof rhs === "bigint")
      return { c0: Fp3.mul(c0, rhs), c1: Fp3.mul(c1, rhs) };
    const { c0: r0, c1: r1 } = rhs;
    let t1 = Fp3.mul(c0, r0);
    let t2 = Fp3.mul(c1, r1);
    const o0 = Fp3.sub(t1, t2);
    const o1 = Fp3.sub(Fp3.mul(Fp3.add(c0, c1), Fp3.add(r0, r1)), Fp3.add(t1, t2));
    return { c0: o0, c1: o1 };
  };
  const Fp2Square = ({ c0, c1 }) => {
    const a3 = Fp3.add(c0, c1);
    const b4 = Fp3.sub(c0, c1);
    const c3 = Fp3.add(c0, c0);
    return { c0: Fp3.mul(a3, b4), c1: Fp3.mul(c3, c1) };
  };
  const Fp2fromBigTuple = (tuple) => {
    if (tuple.length !== 2)
      throw new Error("invalid tuple");
    const fps = tuple.map((n2) => Fp3.create(n2));
    return { c0: fps[0], c1: fps[1] };
  };
  const FP2_ORDER = ORDER * ORDER;
  const Fp2Nonresidue = Fp2fromBigTuple(opts.FP2_NONRESIDUE);
  const Fp22 = {
    ORDER: FP2_ORDER,
    isLE: Fp3.isLE,
    NONRESIDUE: Fp2Nonresidue,
    BITS: bitLen(FP2_ORDER),
    BYTES: Math.ceil(bitLen(FP2_ORDER) / 8),
    MASK: bitMask(bitLen(FP2_ORDER)),
    ZERO: { c0: Fp3.ZERO, c1: Fp3.ZERO },
    ONE: { c0: Fp3.ONE, c1: Fp3.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1 }) => typeof c0 === "bigint" && typeof c1 === "bigint",
    is0: ({ c0, c1 }) => Fp3.is0(c0) && Fp3.is0(c1),
    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp3.eql(c0, r0) && Fp3.eql(c1, r1),
    neg: ({ c0, c1 }) => ({ c0: Fp3.neg(c0), c1: Fp3.neg(c1) }),
    pow: (num, power) => FpPow(Fp22, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp22, nums),
    // Normalized
    add: Fp2Add,
    sub: Fp2Subtract,
    mul: Fp2Multiply,
    sqr: Fp2Square,
    // NonNormalized stuff
    addN: Fp2Add,
    subN: Fp2Subtract,
    mulN: Fp2Multiply,
    sqrN: Fp2Square,
    // Why inversion for bigint inside Fp instead of Fp2? it is even used in that context?
    div: (lhs, rhs) => Fp22.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp22.inv(rhs)),
    inv: ({ c0: a3, c1: b4 }) => {
      const factor = Fp3.inv(Fp3.create(a3 * a3 + b4 * b4));
      return { c0: Fp3.mul(factor, Fp3.create(a3)), c1: Fp3.mul(factor, Fp3.create(-b4)) };
    },
    sqrt: (num) => {
      if (opts.Fp2sqrt)
        return opts.Fp2sqrt(num);
      const { c0, c1 } = num;
      if (Fp3.is0(c1)) {
        if (Fp3.eql(FpLegendre2(Fp3, c0), Fp3.ONE))
          return Fp22.create({ c0: Fp3.sqrt(c0), c1: Fp3.ZERO });
        else
          return Fp22.create({ c0: Fp3.ZERO, c1: Fp3.sqrt(Fp3.div(c0, FpNONRESIDUE)) });
      }
      const a3 = Fp3.sqrt(Fp3.sub(Fp3.sqr(c0), Fp3.mul(Fp3.sqr(c1), FpNONRESIDUE)));
      let d2 = Fp3.mul(Fp3.add(a3, c0), Fpdiv2);
      const legendre = FpLegendre2(Fp3, d2);
      if (!Fp3.is0(legendre) && !Fp3.eql(legendre, Fp3.ONE))
        d2 = Fp3.sub(d2, a3);
      const a0 = Fp3.sqrt(d2);
      const candidateSqrt = Fp22.create({ c0: a0, c1: Fp3.div(Fp3.mul(c1, Fpdiv2), a0) });
      if (!Fp22.eql(Fp22.sqr(candidateSqrt), num))
        throw new Error("Cannot find square root");
      const x1 = candidateSqrt;
      const x2 = Fp22.neg(x1);
      const { re: re1, im: im1 } = Fp22.reim(x1);
      const { re: re2, im: im2 } = Fp22.reim(x2);
      if (im1 > im2 || im1 === im2 && re1 > re2)
        return x1;
      return x2;
    },
    // Same as sgn0_m_eq_2 in RFC 9380
    isOdd: (x2) => {
      const { re: x0, im: x1 } = Fp22.reim(x2);
      const sign_0 = x0 % _2n2;
      const zero_0 = x0 === _0n2;
      const sign_1 = x1 % _2n2;
      return BigInt(sign_0 || zero_0 && sign_1) == _1n2;
    },
    // Bytes util
    fromBytes(b4) {
      if (b4.length !== Fp22.BYTES)
        throw new Error("fromBytes invalid length=" + b4.length);
      return { c0: Fp3.fromBytes(b4.subarray(0, Fp3.BYTES)), c1: Fp3.fromBytes(b4.subarray(Fp3.BYTES)) };
    },
    toBytes: ({ c0, c1 }) => concatBytes(Fp3.toBytes(c0), Fp3.toBytes(c1)),
    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c3) => ({
      c0: Fp3.cmov(c0, r0, c3),
      c1: Fp3.cmov(c1, r1, c3)
    }),
    reim: ({ c0, c1 }) => ({ re: c0, im: c1 }),
    // multiply by u + 1
    mulByNonresidue: ({ c0, c1 }) => Fp22.mul({ c0, c1 }, Fp2Nonresidue),
    mulByB: opts.Fp2mulByB,
    fromBigTuple: Fp2fromBigTuple,
    frobeniusMap: ({ c0, c1 }, power) => ({
      c0,
      c1: Fp3.mul(c1, FP2_FROBENIUS_COEFFICIENTS[power % 2])
    })
  };
  const Fp6Add = ({ c0, c1, c2: c22 }, { c0: r0, c1: r1, c2: r2 }) => ({
    c0: Fp22.add(c0, r0),
    c1: Fp22.add(c1, r1),
    c2: Fp22.add(c22, r2)
  });
  const Fp6Subtract = ({ c0, c1, c2: c22 }, { c0: r0, c1: r1, c2: r2 }) => ({
    c0: Fp22.sub(c0, r0),
    c1: Fp22.sub(c1, r1),
    c2: Fp22.sub(c22, r2)
  });
  const Fp6Multiply = ({ c0, c1, c2: c22 }, rhs) => {
    if (typeof rhs === "bigint") {
      return {
        c0: Fp22.mul(c0, rhs),
        c1: Fp22.mul(c1, rhs),
        c2: Fp22.mul(c22, rhs)
      };
    }
    const { c0: r0, c1: r1, c2: r2 } = rhs;
    const t0 = Fp22.mul(c0, r0);
    const t1 = Fp22.mul(c1, r1);
    const t2 = Fp22.mul(c22, r2);
    return {
      // t0 + (c1 + c2) * (r1 * r2) - (T1 + T2) * (u + 1)
      c0: Fp22.add(t0, Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c22), Fp22.add(r1, r2)), Fp22.add(t1, t2)))),
      // (c0 + c1) * (r0 + r1) - (T0 + T1) + T2 * (u + 1)
      c1: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c1), Fp22.add(r0, r1)), Fp22.add(t0, t1)), Fp22.mulByNonresidue(t2)),
      // T1 + (c0 + c2) * (r0 + r2) - T0 + T2
      c2: Fp22.sub(Fp22.add(t1, Fp22.mul(Fp22.add(c0, c22), Fp22.add(r0, r2))), Fp22.add(t0, t2))
    };
  };
  const Fp6Square = ({ c0, c1, c2: c22 }) => {
    let t0 = Fp22.sqr(c0);
    let t1 = Fp22.mul(Fp22.mul(c0, c1), _2n2);
    let t3 = Fp22.mul(Fp22.mul(c1, c22), _2n2);
    let t4 = Fp22.sqr(c22);
    return {
      c0: Fp22.add(Fp22.mulByNonresidue(t3), t0),
      // T3 * (u + 1) + T0
      c1: Fp22.add(Fp22.mulByNonresidue(t4), t1),
      // T4 * (u + 1) + T1
      // T1 + (c0 - c1 + c2) + T3 - T0 - T4
      c2: Fp22.sub(Fp22.sub(Fp22.add(Fp22.add(t1, Fp22.sqr(Fp22.add(Fp22.sub(c0, c1), c22))), t3), t0), t4)
    };
  };
  const [FP6_FROBENIUS_COEFFICIENTS_1, FP6_FROBENIUS_COEFFICIENTS_2] = calcFrobeniusCoefficients(Fp22, Fp2Nonresidue, Fp3.ORDER, 6, 2, 3);
  const Fp62 = {
    ORDER: Fp22.ORDER,
    // TODO: unused, but need to verify
    isLE: Fp22.isLE,
    BITS: 3 * Fp22.BITS,
    BYTES: 3 * Fp22.BYTES,
    MASK: bitMask(3 * Fp22.BITS),
    ZERO: { c0: Fp22.ZERO, c1: Fp22.ZERO, c2: Fp22.ZERO },
    ONE: { c0: Fp22.ONE, c1: Fp22.ZERO, c2: Fp22.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1, c2: c22 }) => Fp22.isValid(c0) && Fp22.isValid(c1) && Fp22.isValid(c22),
    is0: ({ c0, c1, c2: c22 }) => Fp22.is0(c0) && Fp22.is0(c1) && Fp22.is0(c22),
    neg: ({ c0, c1, c2: c22 }) => ({ c0: Fp22.neg(c0), c1: Fp22.neg(c1), c2: Fp22.neg(c22) }),
    eql: ({ c0, c1, c2: c22 }, { c0: r0, c1: r1, c2: r2 }) => Fp22.eql(c0, r0) && Fp22.eql(c1, r1) && Fp22.eql(c22, r2),
    sqrt: notImplemented,
    // Do we need division by bigint at all? Should be done via order:
    div: (lhs, rhs) => Fp62.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp62.inv(rhs)),
    pow: (num, power) => FpPow(Fp62, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp62, nums),
    // Normalized
    add: Fp6Add,
    sub: Fp6Subtract,
    mul: Fp6Multiply,
    sqr: Fp6Square,
    // NonNormalized stuff
    addN: Fp6Add,
    subN: Fp6Subtract,
    mulN: Fp6Multiply,
    sqrN: Fp6Square,
    inv: ({ c0, c1, c2: c22 }) => {
      let t0 = Fp22.sub(Fp22.sqr(c0), Fp22.mulByNonresidue(Fp22.mul(c22, c1)));
      let t1 = Fp22.sub(Fp22.mulByNonresidue(Fp22.sqr(c22)), Fp22.mul(c0, c1));
      let t2 = Fp22.sub(Fp22.sqr(c1), Fp22.mul(c0, c22));
      let t4 = Fp22.inv(Fp22.add(Fp22.mulByNonresidue(Fp22.add(Fp22.mul(c22, t1), Fp22.mul(c1, t2))), Fp22.mul(c0, t0)));
      return { c0: Fp22.mul(t4, t0), c1: Fp22.mul(t4, t1), c2: Fp22.mul(t4, t2) };
    },
    // Bytes utils
    fromBytes: (b4) => {
      if (b4.length !== Fp62.BYTES)
        throw new Error("fromBytes invalid length=" + b4.length);
      return {
        c0: Fp22.fromBytes(b4.subarray(0, Fp22.BYTES)),
        c1: Fp22.fromBytes(b4.subarray(Fp22.BYTES, 2 * Fp22.BYTES)),
        c2: Fp22.fromBytes(b4.subarray(2 * Fp22.BYTES))
      };
    },
    toBytes: ({ c0, c1, c2: c22 }) => concatBytes(Fp22.toBytes(c0), Fp22.toBytes(c1), Fp22.toBytes(c22)),
    cmov: ({ c0, c1, c2: c22 }, { c0: r0, c1: r1, c2: r2 }, c3) => ({
      c0: Fp22.cmov(c0, r0, c3),
      c1: Fp22.cmov(c1, r1, c3),
      c2: Fp22.cmov(c22, r2, c3)
    }),
    fromBigSix: (t2) => {
      if (!Array.isArray(t2) || t2.length !== 6)
        throw new Error("invalid Fp6 usage");
      return {
        c0: Fp22.fromBigTuple(t2.slice(0, 2)),
        c1: Fp22.fromBigTuple(t2.slice(2, 4)),
        c2: Fp22.fromBigTuple(t2.slice(4, 6))
      };
    },
    frobeniusMap: ({ c0, c1, c2: c22 }, power) => ({
      c0: Fp22.frobeniusMap(c0, power),
      c1: Fp22.mul(Fp22.frobeniusMap(c1, power), FP6_FROBENIUS_COEFFICIENTS_1[power % 6]),
      c2: Fp22.mul(Fp22.frobeniusMap(c22, power), FP6_FROBENIUS_COEFFICIENTS_2[power % 6])
    }),
    mulByFp2: ({ c0, c1, c2: c22 }, rhs) => ({
      c0: Fp22.mul(c0, rhs),
      c1: Fp22.mul(c1, rhs),
      c2: Fp22.mul(c22, rhs)
    }),
    mulByNonresidue: ({ c0, c1, c2: c22 }) => ({ c0: Fp22.mulByNonresidue(c22), c1: c0, c2: c1 }),
    // Sparse multiplication
    mul1: ({ c0, c1, c2: c22 }, b1) => ({
      c0: Fp22.mulByNonresidue(Fp22.mul(c22, b1)),
      c1: Fp22.mul(c0, b1),
      c2: Fp22.mul(c1, b1)
    }),
    // Sparse multiplication
    mul01({ c0, c1, c2: c22 }, b0, b1) {
      let t0 = Fp22.mul(c0, b0);
      let t1 = Fp22.mul(c1, b1);
      return {
        // ((c1 + c2) * b1 - T1) * (u + 1) + T0
        c0: Fp22.add(Fp22.mulByNonresidue(Fp22.sub(Fp22.mul(Fp22.add(c1, c22), b1), t1)), t0),
        // (b0 + b1) * (c0 + c1) - T0 - T1
        c1: Fp22.sub(Fp22.sub(Fp22.mul(Fp22.add(b0, b1), Fp22.add(c0, c1)), t0), t1),
        // (c0 + c2) * b0 - T0 + T1
        c2: Fp22.add(Fp22.sub(Fp22.mul(Fp22.add(c0, c22), b0), t0), t1)
      };
    }
  };
  const FP12_FROBENIUS_COEFFICIENTS = calcFrobeniusCoefficients(Fp22, Fp2Nonresidue, Fp3.ORDER, 12, 1, 6)[0];
  const Fp12Add = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp62.add(c0, r0),
    c1: Fp62.add(c1, r1)
  });
  const Fp12Subtract = ({ c0, c1 }, { c0: r0, c1: r1 }) => ({
    c0: Fp62.sub(c0, r0),
    c1: Fp62.sub(c1, r1)
  });
  const Fp12Multiply = ({ c0, c1 }, rhs) => {
    if (typeof rhs === "bigint")
      return { c0: Fp62.mul(c0, rhs), c1: Fp62.mul(c1, rhs) };
    let { c0: r0, c1: r1 } = rhs;
    let t1 = Fp62.mul(c0, r0);
    let t2 = Fp62.mul(c1, r1);
    return {
      c0: Fp62.add(t1, Fp62.mulByNonresidue(t2)),
      // T1 + T2 * v
      // (c0 + c1) * (r0 + r1) - (T1 + T2)
      c1: Fp62.sub(Fp62.mul(Fp62.add(c0, c1), Fp62.add(r0, r1)), Fp62.add(t1, t2))
    };
  };
  const Fp12Square = ({ c0, c1 }) => {
    let ab = Fp62.mul(c0, c1);
    return {
      // (c1 * v + c0) * (c0 + c1) - AB - AB * v
      c0: Fp62.sub(Fp62.sub(Fp62.mul(Fp62.add(Fp62.mulByNonresidue(c1), c0), Fp62.add(c0, c1)), ab), Fp62.mulByNonresidue(ab)),
      c1: Fp62.add(ab, ab)
    };
  };
  function Fp4Square2(a3, b4) {
    const a22 = Fp22.sqr(a3);
    const b22 = Fp22.sqr(b4);
    return {
      first: Fp22.add(Fp22.mulByNonresidue(b22), a22),
      // b * Nonresidue + a
      second: Fp22.sub(Fp22.sub(Fp22.sqr(Fp22.add(a3, b4)), a22), b22)
      // (a + b) - a - b
    };
  }
  const Fp122 = {
    ORDER: Fp22.ORDER,
    // TODO: unused, but need to verify
    isLE: Fp62.isLE,
    BITS: 2 * Fp62.BITS,
    BYTES: 2 * Fp62.BYTES,
    MASK: bitMask(2 * Fp62.BITS),
    ZERO: { c0: Fp62.ZERO, c1: Fp62.ZERO },
    ONE: { c0: Fp62.ONE, c1: Fp62.ZERO },
    create: (num) => num,
    isValid: ({ c0, c1 }) => Fp62.isValid(c0) && Fp62.isValid(c1),
    is0: ({ c0, c1 }) => Fp62.is0(c0) && Fp62.is0(c1),
    neg: ({ c0, c1 }) => ({ c0: Fp62.neg(c0), c1: Fp62.neg(c1) }),
    eql: ({ c0, c1 }, { c0: r0, c1: r1 }) => Fp62.eql(c0, r0) && Fp62.eql(c1, r1),
    sqrt: notImplemented,
    inv: ({ c0, c1 }) => {
      let t2 = Fp62.inv(Fp62.sub(Fp62.sqr(c0), Fp62.mulByNonresidue(Fp62.sqr(c1))));
      return { c0: Fp62.mul(c0, t2), c1: Fp62.neg(Fp62.mul(c1, t2)) };
    },
    div: (lhs, rhs) => Fp122.mul(lhs, typeof rhs === "bigint" ? Fp3.inv(Fp3.create(rhs)) : Fp122.inv(rhs)),
    pow: (num, power) => FpPow(Fp122, num, power),
    invertBatch: (nums) => FpInvertBatch(Fp122, nums),
    // Normalized
    add: Fp12Add,
    sub: Fp12Subtract,
    mul: Fp12Multiply,
    sqr: Fp12Square,
    // NonNormalized stuff
    addN: Fp12Add,
    subN: Fp12Subtract,
    mulN: Fp12Multiply,
    sqrN: Fp12Square,
    // Bytes utils
    fromBytes: (b4) => {
      if (b4.length !== Fp122.BYTES)
        throw new Error("fromBytes invalid length=" + b4.length);
      return {
        c0: Fp62.fromBytes(b4.subarray(0, Fp62.BYTES)),
        c1: Fp62.fromBytes(b4.subarray(Fp62.BYTES))
      };
    },
    toBytes: ({ c0, c1 }) => concatBytes(Fp62.toBytes(c0), Fp62.toBytes(c1)),
    cmov: ({ c0, c1 }, { c0: r0, c1: r1 }, c3) => ({
      c0: Fp62.cmov(c0, r0, c3),
      c1: Fp62.cmov(c1, r1, c3)
    }),
    // Utils
    // toString() {
    //   return '' + 'Fp12(' + this.c0 + this.c1 + '* w');
    // },
    // fromTuple(c: [Fp6, Fp6]) {
    //   return new Fp12(...c);
    // }
    fromBigTwelve: (t2) => ({
      c0: Fp62.fromBigSix(t2.slice(0, 6)),
      c1: Fp62.fromBigSix(t2.slice(6, 12))
    }),
    // Raises to q**i -th power
    frobeniusMap(lhs, power) {
      const { c0, c1, c2: c22 } = Fp62.frobeniusMap(lhs.c1, power);
      const coeff = FP12_FROBENIUS_COEFFICIENTS[power % 12];
      return {
        c0: Fp62.frobeniusMap(lhs.c0, power),
        c1: Fp62.create({
          c0: Fp22.mul(c0, coeff),
          c1: Fp22.mul(c1, coeff),
          c2: Fp22.mul(c22, coeff)
        })
      };
    },
    mulByFp2: ({ c0, c1 }, rhs) => ({
      c0: Fp62.mulByFp2(c0, rhs),
      c1: Fp62.mulByFp2(c1, rhs)
    }),
    conjugate: ({ c0, c1 }) => ({ c0, c1: Fp62.neg(c1) }),
    // Sparse multiplication
    mul014: ({ c0, c1 }, o0, o1, o4) => {
      let t0 = Fp62.mul01(c0, o0, o1);
      let t1 = Fp62.mul1(c1, o4);
      return {
        c0: Fp62.add(Fp62.mulByNonresidue(t1), t0),
        // T1 * v + T0
        // (c1 + c0) * [o0, o1+o4] - T0 - T1
        c1: Fp62.sub(Fp62.sub(Fp62.mul01(Fp62.add(c1, c0), o0, Fp22.add(o1, o4)), t0), t1)
      };
    },
    mul034: ({ c0, c1 }, o0, o3, o4) => {
      const a3 = Fp62.create({
        c0: Fp22.mul(c0.c0, o0),
        c1: Fp22.mul(c0.c1, o0),
        c2: Fp22.mul(c0.c2, o0)
      });
      const b4 = Fp62.mul01(c1, o3, o4);
      const e2 = Fp62.mul01(Fp62.add(c0, c1), Fp22.add(o0, o3), o4);
      return {
        c0: Fp62.add(Fp62.mulByNonresidue(b4), a3),
        c1: Fp62.sub(e2, Fp62.add(a3, b4))
      };
    },
    // A cyclotomic group is a subgroup of Fp^n defined by
    //   G(p) = {  Fp : ^(p) = 1}
    // The result of any pairing is in a cyclotomic subgroup
    // https://eprint.iacr.org/2009/565.pdf
    _cyclotomicSquare: opts.Fp12cyclotomicSquare,
    _cyclotomicExp: opts.Fp12cyclotomicExp,
    // https://eprint.iacr.org/2010/354.pdf
    // https://eprint.iacr.org/2009/565.pdf
    finalExponentiate: opts.Fp12finalExponentiate
  };
  return { Fp: Fp3, Fp2: Fp22, Fp6: Fp62, Fp4Square: Fp4Square2, Fp12: Fp122 };
}

// node_modules/@noble/curves/esm/bls12-381.js
var _0n3 = BigInt(0);
var _1n3 = BigInt(1);
var _2n3 = BigInt(2);
var _3n3 = BigInt(3);
var _4n = BigInt(4);
var BLS_X = BigInt("0xd201000000010000");
var BLS_X_LEN = bitLen(BLS_X);
var { Fp, Fp2, Fp6, Fp4Square, Fp12 } = tower12({
  // Order of Fp
  ORDER: BigInt("0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab"),
  // Finite extension field over irreducible polynominal.
  // Fp(u) / (u - ) where  = -1
  FP2_NONRESIDUE: [_1n3, _1n3],
  Fp2mulByB: ({ c0, c1 }) => {
    const t0 = Fp.mul(c0, _4n);
    const t1 = Fp.mul(c1, _4n);
    return { c0: Fp.sub(t0, t1), c1: Fp.add(t0, t1) };
  },
  // Fp12
  // A cyclotomic group is a subgroup of Fp^n defined by
  //   G(p) = {  Fp : ^(p) = 1}
  // The result of any pairing is in a cyclotomic subgroup
  // https://eprint.iacr.org/2009/565.pdf
  Fp12cyclotomicSquare: ({ c0, c1 }) => {
    const { c0: c0c0, c1: c0c1, c2: c0c2 } = c0;
    const { c0: c1c0, c1: c1c1, c2: c1c2 } = c1;
    const { first: t3, second: t4 } = Fp4Square(c0c0, c1c1);
    const { first: t5, second: t6 } = Fp4Square(c1c0, c0c2);
    const { first: t7, second: t8 } = Fp4Square(c0c1, c1c2);
    const t9 = Fp2.mulByNonresidue(t8);
    return {
      c0: Fp6.create({
        c0: Fp2.add(Fp2.mul(Fp2.sub(t3, c0c0), _2n3), t3),
        // 2 * (T3 - c0c0)  + T3
        c1: Fp2.add(Fp2.mul(Fp2.sub(t5, c0c1), _2n3), t5),
        // 2 * (T5 - c0c1)  + T5
        c2: Fp2.add(Fp2.mul(Fp2.sub(t7, c0c2), _2n3), t7)
      }),
      // 2 * (T7 - c0c2)  + T7
      c1: Fp6.create({
        c0: Fp2.add(Fp2.mul(Fp2.add(t9, c1c0), _2n3), t9),
        // 2 * (T9 + c1c0) + T9
        c1: Fp2.add(Fp2.mul(Fp2.add(t4, c1c1), _2n3), t4),
        // 2 * (T4 + c1c1) + T4
        c2: Fp2.add(Fp2.mul(Fp2.add(t6, c1c2), _2n3), t6)
      })
    };
  },
  Fp12cyclotomicExp(num, n2) {
    let z3 = Fp12.ONE;
    for (let i2 = BLS_X_LEN - 1; i2 >= 0; i2--) {
      z3 = Fp12._cyclotomicSquare(z3);
      if (bitGet(n2, i2))
        z3 = Fp12.mul(z3, num);
    }
    return z3;
  },
  // https://eprint.iacr.org/2010/354.pdf
  // https://eprint.iacr.org/2009/565.pdf
  Fp12finalExponentiate: (num) => {
    const x2 = BLS_X;
    const t0 = Fp12.div(Fp12.frobeniusMap(num, 6), num);
    const t1 = Fp12.mul(Fp12.frobeniusMap(t0, 2), t0);
    const t2 = Fp12.conjugate(Fp12._cyclotomicExp(t1, x2));
    const t3 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicSquare(t1)), t2);
    const t4 = Fp12.conjugate(Fp12._cyclotomicExp(t3, x2));
    const t5 = Fp12.conjugate(Fp12._cyclotomicExp(t4, x2));
    const t6 = Fp12.mul(Fp12.conjugate(Fp12._cyclotomicExp(t5, x2)), Fp12._cyclotomicSquare(t2));
    const t7 = Fp12.conjugate(Fp12._cyclotomicExp(t6, x2));
    const t2_t5_pow_q2 = Fp12.frobeniusMap(Fp12.mul(t2, t5), 2);
    const t4_t1_pow_q3 = Fp12.frobeniusMap(Fp12.mul(t4, t1), 3);
    const t6_t1c_pow_q1 = Fp12.frobeniusMap(Fp12.mul(t6, Fp12.conjugate(t1)), 1);
    const t7_t3c_t1 = Fp12.mul(Fp12.mul(t7, Fp12.conjugate(t3)), t1);
    return Fp12.mul(Fp12.mul(Fp12.mul(t2_t5_pow_q2, t4_t1_pow_q3), t6_t1c_pow_q1), t7_t3c_t1);
  }
});
var Fr = Field(BigInt("0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001"));
var isogenyMapG2 = isogenyMap(Fp2, [
  // xNum
  [
    [
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97d6"
    ],
    [
      "0x0",
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71a"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71e",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38d"
    ],
    [
      "0x171d6541fa38ccfaed6dea691f5fb614cb14b4e7f4e810aa22d6108f142b85757098e38d0f671c7188e2aaaaaaaa5ed1",
      "0x0"
    ]
  ],
  // xDen
  [
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa63"
    ],
    [
      "0xc",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa9f"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ],
  // yNum
  [
    [
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706",
      "0x1530477c7ab4113b59a4c18b076d11930f7da5d4a07f649bf54439d87d27e500fc8c25ebf8c92f6812cfc71c71c6d706"
    ],
    [
      "0x0",
      "0x5c759507e8e333ebb5b7a9a47d7ed8532c52d39fd3a042a88b58423c50ae15d5c2638e343d9c71c6238aaaaaaaa97be"
    ],
    [
      "0x11560bf17baa99bc32126fced787c88f984f87adf7ae0c7f9a208c6b4f20a4181472aaa9cb8d555526a9ffffffffc71c",
      "0x8ab05f8bdd54cde190937e76bc3e447cc27c3d6fbd7063fcd104635a790520c0a395554e5c6aaaa9354ffffffffe38f"
    ],
    [
      "0x124c9ad43b6cf79bfbf7043de3811ad0761b0f37a1e26286b0e977c69aa274524e79097a56dc4bd9e1b371c71c718b10",
      "0x0"
    ]
  ],
  // yDen
  [
    [
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa8fb"
    ],
    [
      "0x0",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffa9d3"
    ],
    [
      "0x12",
      "0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaa99"
    ],
    ["0x1", "0x0"]
    // LAST 1
  ]
].map((i2) => i2.map((pair) => Fp2.fromBigTuple(pair.map(BigInt)))));
var isogenyMapG1 = isogenyMap(Fp, [
  // xNum
  [
    "0x11a05f2b1e833340b809101dd99815856b303e88a2d7005ff2627b56cdb4e2c85610c2d5f2e62d6eaeac1662734649b7",
    "0x17294ed3e943ab2f0588bab22147a81c7c17e75b2f6a8417f565e33c70d1e86b4838f2a6f318c356e834eef1b3cb83bb",
    "0xd54005db97678ec1d1048c5d10a9a1bce032473295983e56878e501ec68e25c958c3e3d2a09729fe0179f9dac9edcb0",
    "0x1778e7166fcc6db74e0609d307e55412d7f5e4656a8dbf25f1b33289f1b330835336e25ce3107193c5b388641d9b6861",
    "0xe99726a3199f4436642b4b3e4118e5499db995a1257fb3f086eeb65982fac18985a286f301e77c451154ce9ac8895d9",
    "0x1630c3250d7313ff01d1201bf7a74ab5db3cb17dd952799b9ed3ab9097e68f90a0870d2dcae73d19cd13c1c66f652983",
    "0xd6ed6553fe44d296a3726c38ae652bfb11586264f0f8ce19008e218f9c86b2a8da25128c1052ecaddd7f225a139ed84",
    "0x17b81e7701abdbe2e8743884d1117e53356de5ab275b4db1a682c62ef0f2753339b7c8f8c8f475af9ccb5618e3f0c88e",
    "0x80d3cf1f9a78fc47b90b33563be990dc43b756ce79f5574a2c596c928c5d1de4fa295f296b74e956d71986a8497e317",
    "0x169b1f8e1bcfa7c42e0c37515d138f22dd2ecb803a0c5c99676314baf4bb1b7fa3190b2edc0327797f241067be390c9e",
    "0x10321da079ce07e272d8ec09d2565b0dfa7dccdde6787f96d50af36003b14866f69b771f8c285decca67df3f1605fb7b",
    "0x6e08c248e260e70bd1e962381edee3d31d79d7e22c837bc23c0bf1bc24c6b68c24b1b80b64d391fa9c8ba2e8ba2d229"
  ],
  // xDen
  [
    "0x8ca8d548cff19ae18b2e62f4bd3fa6f01d5ef4ba35b48ba9c9588617fc8ac62b558d681be343df8993cf9fa40d21b1c",
    "0x12561a5deb559c4348b4711298e536367041e8ca0cf0800c0126c2588c48bf5713daa8846cb026e9e5c8276ec82b3bff",
    "0xb2962fe57a3225e8137e629bff2991f6f89416f5a718cd1fca64e00b11aceacd6a3d0967c94fedcfcc239ba5cb83e19",
    "0x3425581a58ae2fec83aafef7c40eb545b08243f16b1655154cca8abc28d6fd04976d5243eecf5c4130de8938dc62cd8",
    "0x13a8e162022914a80a6f1d5f43e7a07dffdfc759a12062bb8d6b44e833b306da9bd29ba81f35781d539d395b3532a21e",
    "0xe7355f8e4e667b955390f7f0506c6e9395735e9ce9cad4d0a43bcef24b8982f7400d24bc4228f11c02df9a29f6304a5",
    "0x772caacf16936190f3e0c63e0596721570f5799af53a1894e2e073062aede9cea73b3538f0de06cec2574496ee84a3a",
    "0x14a7ac2a9d64a8b230b3f5b074cf01996e7f63c21bca68a81996e1cdf9822c580fa5b9489d11e2d311f7d99bbdcc5a5e",
    "0xa10ecf6ada54f825e920b3dafc7a3cce07f8d1d7161366b74100da67f39883503826692abba43704776ec3a79a1d641",
    "0x95fc13ab9e92ad4476d6e3eb3a56680f682b4ee96f7d03776df533978f31c1593174e4b4b7865002d6384d168ecdd0a",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ],
  // yNum
  [
    "0x90d97c81ba24ee0259d1f094980dcfa11ad138e48a869522b52af6c956543d3cd0c7aee9b3ba3c2be9845719707bb33",
    "0x134996a104ee5811d51036d776fb46831223e96c254f383d0f906343eb67ad34d6c56711962fa8bfe097e75a2e41c696",
    "0xcc786baa966e66f4a384c86a3b49942552e2d658a31ce2c344be4b91400da7d26d521628b00523b8dfe240c72de1f6",
    "0x1f86376e8981c217898751ad8746757d42aa7b90eeb791c09e4a3ec03251cf9de405aba9ec61deca6355c77b0e5f4cb",
    "0x8cc03fdefe0ff135caf4fe2a21529c4195536fbe3ce50b879833fd221351adc2ee7f8dc099040a841b6daecf2e8fedb",
    "0x16603fca40634b6a2211e11db8f0a6a074a7d0d4afadb7bd76505c3d3ad5544e203f6326c95a807299b23ab13633a5f0",
    "0x4ab0b9bcfac1bbcb2c977d027796b3ce75bb8ca2be184cb5231413c4d634f3747a87ac2460f415ec961f8855fe9d6f2",
    "0x987c8d5333ab86fde9926bd2ca6c674170a05bfe3bdd81ffd038da6c26c842642f64550fedfe935a15e4ca31870fb29",
    "0x9fc4018bd96684be88c9e221e4da1bb8f3abd16679dc26c1e8b6e6a1f20cabe69d65201c78607a360370e577bdba587",
    "0xe1bba7a1186bdb5223abde7ada14a23c42a0ca7915af6fe06985e7ed1e4d43b9b3f7055dd4eba6f2bafaaebca731c30",
    "0x19713e47937cd1be0dfd0b8f1d43fb93cd2fcbcb6caf493fd1183e416389e61031bf3a5cce3fbafce813711ad011c132",
    "0x18b46a908f36f6deb918c143fed2edcc523559b8aaf0c2462e6bfe7f911f643249d9cdf41b44d606ce07c8a4d0074d8e",
    "0xb182cac101b9399d155096004f53f447aa7b12a3426b08ec02710e807b4633f06c851c1919211f20d4c04f00b971ef8",
    "0x245a394ad1eca9b72fc00ae7be315dc757b3b080d4c158013e6632d3c40659cc6cf90ad1c232a6442d9d3f5db980133",
    "0x5c129645e44cf1102a159f748c4a3fc5e673d81d7e86568d9ab0f5d396a7ce46ba1049b6579afb7866b1e715475224b",
    "0x15e6be4e990f03ce4ea50b3b42df2eb5cb181d8f84965a3957add4fa95af01b2b665027efec01c7704b456be69c8b604"
  ],
  // yDen
  [
    "0x16112c4c3a9c98b252181140fad0eae9601a6de578980be6eec3232b5be72e7a07f3688ef60c206d01479253b03663c1",
    "0x1962d75c2381201e1a0cbd6c43c348b885c84ff731c4d59ca4a10356f453e01f78a4260763529e3532f6102c2e49a03d",
    "0x58df3306640da276faaae7d6e8eb15778c4855551ae7f310c35a5dd279cd2eca6757cd636f96f891e2538b53dbf67f2",
    "0x16b7d288798e5395f20d23bf89edb4d1d115c5dbddbcd30e123da489e726af41727364f2c28297ada8d26d98445f5416",
    "0xbe0e079545f43e4b00cc912f8228ddcc6d19c9f0f69bbb0542eda0fc9dec916a20b15dc0fd2ededda39142311a5001d",
    "0x8d9e5297186db2d9fb266eaac783182b70152c65550d881c5ecd87b6f0f5a6449f38db9dfa9cce202c6477faaf9b7ac",
    "0x166007c08a99db2fc3ba8734ace9824b5eecfdfa8d0cf8ef5dd365bc400a0051d5fa9c01a58b1fb93d1a1399126a775c",
    "0x16a3ef08be3ea7ea03bcddfabba6ff6ee5a4375efa1f4fd7feb34fd206357132b920f5b00801dee460ee415a15812ed9",
    "0x1866c8ed336c61231a1be54fd1d74cc4f9fb0ce4c6af5920abc5750c4bf39b4852cfe2f7bb9248836b233d9d55535d4a",
    "0x167a55cda70a6e1cea820597d94a84903216f763e13d87bb5308592e7ea7d4fbc7385ea3d529b35e346ef48bb8913f55",
    "0x4d2f259eea405bd48f010a01ad2911d9c6dd039bb61a6290e591b36e636a5c871a5c29f4f83060400f8b49cba8f6aa8",
    "0xaccbb67481d033ff5852c1e48c50c477f94ff8aefce42d28c0f9a88cea7913516f968986f7ebbea9684b529e2561092",
    "0xad6b9514c767fe3c3613144b45f1496543346d98adf02267d5ceef9a00d9b8693000763e3b90ac11e99b138573345cc",
    "0x2660400eb2e4f3b628bdd0d53cd76f2bf565b94e72927c1cb748df27942480e420517bd8714cc80d1fadc1326ed06f7",
    "0xe0fa1d816ddc03e6b24255e0d7819c171c40f65e273b853324efcd6356caa205ca2f570f13497804415473a1d634b8f",
    "0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000001"
    // LAST 1
  ]
].map((i2) => i2.map((j3) => BigInt(j3))));
var G2_SWU = mapToCurveSimpleSWU(Fp2, {
  A: Fp2.create({ c0: Fp.create(_0n3), c1: Fp.create(BigInt(240)) }),
  // A' = 240 * I
  B: Fp2.create({ c0: Fp.create(BigInt(1012)), c1: Fp.create(BigInt(1012)) }),
  // B' = 1012 * (1 + I)
  Z: Fp2.create({ c0: Fp.create(BigInt(-2)), c1: Fp.create(BigInt(-1)) })
  // Z: -(2 + I)
});
var G1_SWU = mapToCurveSimpleSWU(Fp, {
  A: Fp.create(BigInt("0x144698a3b8e9433d693a02c96d4982b0ea985383ee66a8d8e8981aefd881ac98936f8da0e0f97f5cf428082d584c1d")),
  B: Fp.create(BigInt("0x12e2908d11688030018b12e8753eee3b2016c1f0f24f4070a0b9c14fcef35ef55a23215a316ceaa5d1cc48e98e172be0")),
  Z: Fp.create(BigInt(11))
});
var { G2psi, G2psi2 } = psiFrobenius(Fp, Fp2, Fp2.div(Fp2.ONE, Fp2.NONRESIDUE));
var htfDefaults = Object.freeze({
  // DST: a domain separation tag
  // defined in section 2.2.5
  // Use utils.getDSTLabel(), utils.setDSTLabel(value)
  DST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  encodeDST: "BLS_SIG_BLS12381G2_XMD:SHA-256_SSWU_RO_NUL_",
  // p: the characteristic of F
  //    where F is a finite field of characteristic p and order q = p^m
  p: Fp.ORDER,
  // m: the extension degree of F, m >= 1
  //     where F is a finite field of characteristic p and order q = p^m
  m: 2,
  // k: the target security level for the suite in bits
  // defined in section 5.1
  k: 128,
  // option to use a message that has already been processed by
  // expand_message_xmd
  expand: "xmd",
  // Hash functions for: expand_message_xmd is appropriate for use with a
  // wide range of hash functions, including SHA-2, SHA-3, BLAKE2, and others.
  // BBS+ uses blake2: https://github.com/hyperledger/aries-framework-go/issues/2247
  hash: sha256
});
var COMPRESSED_ZERO = setMask(Fp.toBytes(_0n3), { infinity: true, compressed: true });
function parseMask(bytes) {
  bytes = bytes.slice();
  const mask = bytes[0] & 224;
  const compressed = !!(mask >> 7 & 1);
  const infinity = !!(mask >> 6 & 1);
  const sort = !!(mask >> 5 & 1);
  bytes[0] &= 31;
  return { compressed, infinity, sort, value: bytes };
}
function setMask(bytes, mask) {
  if (bytes[0] & 224)
    throw new Error("setMask: non-empty mask");
  if (mask.compressed)
    bytes[0] |= 128;
  if (mask.infinity)
    bytes[0] |= 64;
  if (mask.sort)
    bytes[0] |= 32;
  return bytes;
}
function signatureG1ToRawBytes(point) {
  point.assertValidity();
  const isZero2 = point.equals(bls12_381.G1.ProjectivePoint.ZERO);
  const { x: x2, y: y2 } = point.toAffine();
  if (isZero2)
    return COMPRESSED_ZERO.slice();
  const P = Fp.ORDER;
  const sort = Boolean(y2 * _2n3 / P);
  return setMask(numberToBytesBE(x2, Fp.BYTES), { compressed: true, sort });
}
function signatureG2ToRawBytes(point) {
  point.assertValidity();
  const len = Fp.BYTES;
  if (point.equals(bls12_381.G2.ProjectivePoint.ZERO))
    return concatBytes(COMPRESSED_ZERO, numberToBytesBE(_0n3, len));
  const { x: x2, y: y2 } = point.toAffine();
  const { re: x0, im: x1 } = Fp2.reim(x2);
  const { re: y0, im: y1 } = Fp2.reim(y2);
  const tmp = y1 > _0n3 ? y1 * _2n3 : y0 * _2n3;
  const sort = Boolean(tmp / Fp.ORDER & _1n3);
  const z22 = x0;
  return concatBytes(setMask(numberToBytesBE(x1, len), { sort, compressed: true }), numberToBytesBE(z22, len));
}
var bls12_381 = bls({
  // Fields
  fields: {
    Fp,
    Fp2,
    Fp6,
    Fp12,
    Fr
  },
  // G1 is the order-q subgroup of E1(Fp) : y = x + 4, #E1(Fp) = h1q, where
  // characteristic; z + (z - z + 1)(z - 1)/3
  G1: {
    Fp,
    // cofactor; (z - 1)/3
    h: BigInt("0x396c8c005555e1568c00aaab0000aaab"),
    // generator's coordinates
    // x = 3685416753713387016781088315183077757961620795782546409894578378688607592378376318836054947676345821548104185464507
    // y = 1339506544944476473020471379941921221584933875938349620426543736416511423956333506472724655353366534992391756441569
    Gx: BigInt("0x17f1d3a73197d7942695638c4fa9ac0fc3688c4f9774b905a14e3a3f171bac586c55e83ff97a1aeffb3af00adb22c6bb"),
    Gy: BigInt("0x08b3f481e3aaa0f1a09e30ed741d8ae4fcf5e095d5d00af600db18cb2c04b3edd03cc744a2888ae40caa232946c5e7e1"),
    a: Fp.ZERO,
    b: _4n,
    htfDefaults: { ...htfDefaults, m: 1, DST: "BLS_SIG_BLS12381G1_XMD:SHA-256_SSWU_RO_NUL_" },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    isTorsionFree: (c3, point) => {
      const cubicRootOfUnityModP = BigInt("0x5f19672fdf76ce51ba69c6076a0f77eaddb3a93be6f89688de17d813620a00022e01fffffffefffe");
      const phi = new c3(Fp.mul(point.px, cubicRootOfUnityModP), point.py, point.pz);
      const xP = point.multiplyUnsafe(BLS_X).negate();
      const u2P = xP.multiplyUnsafe(BLS_X);
      return u2P.equals(phi);
    },
    // Clear cofactor of G1
    // https://eprint.iacr.org/2019/403
    clearCofactor: (_c2, point) => {
      return point.multiplyUnsafe(BLS_X).add(point);
    },
    mapToCurve: (scalars) => {
      const { x: x2, y: y2 } = G1_SWU(Fp.create(scalars[0]));
      return isogenyMapG1(x2, y2);
    },
    fromBytes: (bytes) => {
      const { compressed, infinity, sort, value } = parseMask(bytes);
      if (value.length === 48 && compressed) {
        const P = Fp.ORDER;
        const compressedValue = bytesToNumberBE(value);
        const x2 = Fp.create(compressedValue & Fp.MASK);
        if (infinity) {
          if (x2 !== _0n3)
            throw new Error("G1: non-empty compressed point at infinity");
          return { x: _0n3, y: _0n3 };
        }
        const right = Fp.add(Fp.pow(x2, _3n3), Fp.create(bls12_381.params.G1b));
        let y2 = Fp.sqrt(right);
        if (!y2)
          throw new Error("invalid compressed G1 point");
        if (y2 * _2n3 / P !== BigInt(sort))
          y2 = Fp.neg(y2);
        return { x: Fp.create(x2), y: Fp.create(y2) };
      } else if (value.length === 96 && !compressed) {
        const x2 = bytesToNumberBE(value.subarray(0, Fp.BYTES));
        const y2 = bytesToNumberBE(value.subarray(Fp.BYTES));
        if (infinity) {
          if (x2 !== _0n3 || y2 !== _0n3)
            throw new Error("G1: non-empty point at infinity");
          return bls12_381.G1.ProjectivePoint.ZERO.toAffine();
        }
        return { x: Fp.create(x2), y: Fp.create(y2) };
      } else {
        throw new Error("invalid point G1, expected 48/96 bytes");
      }
    },
    toBytes: (c3, point, isCompressed) => {
      const isZero2 = point.equals(c3.ZERO);
      const { x: x2, y: y2 } = point.toAffine();
      if (isCompressed) {
        if (isZero2)
          return COMPRESSED_ZERO.slice();
        const P = Fp.ORDER;
        const sort = Boolean(y2 * _2n3 / P);
        return setMask(numberToBytesBE(x2, Fp.BYTES), { compressed: true, sort });
      } else {
        if (isZero2) {
          const x3 = concatBytes(new Uint8Array([64]), new Uint8Array(2 * Fp.BYTES - 1));
          return x3;
        } else {
          return concatBytes(numberToBytesBE(x2, Fp.BYTES), numberToBytesBE(y2, Fp.BYTES));
        }
      }
    },
    ShortSignature: {
      fromHex(hex3) {
        const { infinity, sort, value } = parseMask(ensureBytes("signatureHex", hex3, 48));
        const P = Fp.ORDER;
        const compressedValue = bytesToNumberBE(value);
        if (infinity)
          return bls12_381.G1.ProjectivePoint.ZERO;
        const x2 = Fp.create(compressedValue & Fp.MASK);
        const right = Fp.add(Fp.pow(x2, _3n3), Fp.create(bls12_381.params.G1b));
        let y2 = Fp.sqrt(right);
        if (!y2)
          throw new Error("invalid compressed G1 point");
        const aflag = BigInt(sort);
        if (y2 * _2n3 / P !== aflag)
          y2 = Fp.neg(y2);
        const point = bls12_381.G1.ProjectivePoint.fromAffine({ x: x2, y: y2 });
        point.assertValidity();
        return point;
      },
      toRawBytes(point) {
        return signatureG1ToRawBytes(point);
      },
      toHex(point) {
        return bytesToHex(signatureG1ToRawBytes(point));
      }
    }
  },
  // G2 is the order-q subgroup of E2(Fp) : y = x+4(1+1),
  // where Fp2 is Fp[1]/(x2+1). #E2(Fp2 ) = h2q, where
  // G - 1
  // h2q
  G2: {
    Fp: Fp2,
    // cofactor
    h: BigInt("0x5d543a95414e7f1091d50792876a202cd91de4547085abaa68a205b2e5a7ddfa628f1cb4d9e82ef21537e293a6691ae1616ec6e786f0c70cf1c38e31c7238e5"),
    Gx: Fp2.fromBigTuple([
      BigInt("0x024aa2b2f08f0a91260805272dc51051c6e47ad4fa403b02b4510b647ae3d1770bac0326a805bbefd48056c8c121bdb8"),
      BigInt("0x13e02b6052719f607dacd3a088274f65596bd0d09920b61ab5da61bbdc7f5049334cf11213945d57e5ac7d055d042b7e")
    ]),
    // y =
    // 927553665492332455747201965776037880757740193453592970025027978793976877002675564980949289727957565575433344219582,
    // 1985150602287291935568054521177171638300868978215655730859378665066344726373823718423869104263333984641494340347905
    Gy: Fp2.fromBigTuple([
      BigInt("0x0ce5d527727d6e118cc9cdc6da2e351aadfd9baa8cbdd3a76d429a695160d12c923ac9cc3baca289e193548608b82801"),
      BigInt("0x0606c4a02ea734cc32acd2b02bc28b99cb3e287e85a763af267492ab572e99ab3f370d275cec1da1aaa9075ff05f79be")
    ]),
    a: Fp2.ZERO,
    b: Fp2.fromBigTuple([_4n, _4n]),
    hEff: BigInt("0xbc69f08f2ee75b3584c6a0ea91b352888e2a8e9145ad7689986ff031508ffe1329c2f178731db956d82bf015d1212b02ec0ec69d7477c1ae954cbc06689f6a359894c0adebbf6b4e8020005aaa95551"),
    htfDefaults: { ...htfDefaults },
    wrapPrivateKey: true,
    allowInfinityPoint: true,
    mapToCurve: (scalars) => {
      const { x: x2, y: y2 } = G2_SWU(Fp2.fromBigTuple(scalars));
      return isogenyMapG2(x2, y2);
    },
    // Checks is the point resides in prime-order subgroup.
    // point.isTorsionFree() should return true for valid points
    // It returns false for shitty points.
    // https://eprint.iacr.org/2021/1130.pdf
    isTorsionFree: (c3, P) => {
      return P.multiplyUnsafe(BLS_X).negate().equals(G2psi(c3, P));
    },
    // Maps the point into the prime-order subgroup G2.
    // clear_cofactor_bls12381_g2 from cfrg-hash-to-curve-11
    // https://eprint.iacr.org/2017/419.pdf
    // prettier-ignore
    clearCofactor: (c3, P) => {
      const x2 = BLS_X;
      let t1 = P.multiplyUnsafe(x2).negate();
      let t2 = G2psi(c3, P);
      let t3 = P.double();
      t3 = G2psi2(c3, t3);
      t3 = t3.subtract(t2);
      t2 = t1.add(t2);
      t2 = t2.multiplyUnsafe(x2).negate();
      t3 = t3.add(t2);
      t3 = t3.subtract(t1);
      const Q2 = t3.subtract(P);
      return Q2;
    },
    fromBytes: (bytes) => {
      const { compressed, infinity, sort, value } = parseMask(bytes);
      if (!compressed && !infinity && sort || // 00100000
      !compressed && infinity && sort || // 01100000
      sort && infinity && compressed) {
        throw new Error("invalid encoding flag: " + (bytes[0] & 224));
      }
      const L2 = Fp.BYTES;
      const slc = (b4, from26, to4) => bytesToNumberBE(b4.slice(from26, to4));
      if (value.length === 96 && compressed) {
        const b4 = bls12_381.params.G2b;
        const P = Fp.ORDER;
        if (infinity) {
          if (value.reduce((p2, c3) => p2 !== 0 ? c3 + 1 : c3, 0) > 0) {
            throw new Error("invalid compressed G2 point");
          }
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        }
        const x_1 = slc(value, 0, L2);
        const x_0 = slc(value, L2, 2 * L2);
        const x2 = Fp2.create({ c0: Fp.create(x_0), c1: Fp.create(x_1) });
        const right = Fp2.add(Fp2.pow(x2, _3n3), b4);
        let y2 = Fp2.sqrt(right);
        const Y_bit = y2.c1 === _0n3 ? y2.c0 * _2n3 / P : y2.c1 * _2n3 / P ? _1n3 : _0n3;
        y2 = sort && Y_bit > 0 ? y2 : Fp2.neg(y2);
        return { x: x2, y: y2 };
      } else if (value.length === 192 && !compressed) {
        if (infinity) {
          if (value.reduce((p2, c3) => p2 !== 0 ? c3 + 1 : c3, 0) > 0) {
            throw new Error("invalid uncompressed G2 point");
          }
          return { x: Fp2.ZERO, y: Fp2.ZERO };
        }
        const x1 = slc(value, 0, L2);
        const x0 = slc(value, L2, 2 * L2);
        const y1 = slc(value, 2 * L2, 3 * L2);
        const y0 = slc(value, 3 * L2, 4 * L2);
        return { x: Fp2.fromBigTuple([x0, x1]), y: Fp2.fromBigTuple([y0, y1]) };
      } else {
        throw new Error("invalid point G2, expected 96/192 bytes");
      }
    },
    toBytes: (c3, point, isCompressed) => {
      const { BYTES: len, ORDER: P } = Fp;
      const isZero2 = point.equals(c3.ZERO);
      const { x: x2, y: y2 } = point.toAffine();
      if (isCompressed) {
        if (isZero2)
          return concatBytes(COMPRESSED_ZERO, numberToBytesBE(_0n3, len));
        const flag = Boolean(y2.c1 === _0n3 ? y2.c0 * _2n3 / P : y2.c1 * _2n3 / P);
        return concatBytes(setMask(numberToBytesBE(x2.c1, len), { compressed: true, sort: flag }), numberToBytesBE(x2.c0, len));
      } else {
        if (isZero2)
          return concatBytes(new Uint8Array([64]), new Uint8Array(4 * len - 1));
        const { re: x0, im: x1 } = Fp2.reim(x2);
        const { re: y0, im: y1 } = Fp2.reim(y2);
        return concatBytes(numberToBytesBE(x1, len), numberToBytesBE(x0, len), numberToBytesBE(y1, len), numberToBytesBE(y0, len));
      }
    },
    Signature: {
      // TODO: Optimize, it's very slow because of sqrt.
      fromHex(hex3) {
        const { infinity, sort, value } = parseMask(ensureBytes("signatureHex", hex3));
        const P = Fp.ORDER;
        const half = value.length / 2;
        if (half !== 48 && half !== 96)
          throw new Error("invalid compressed signature length, must be 96 or 192");
        const z1 = bytesToNumberBE(value.slice(0, half));
        const z22 = bytesToNumberBE(value.slice(half));
        if (infinity)
          return bls12_381.G2.ProjectivePoint.ZERO;
        const x1 = Fp.create(z1 & Fp.MASK);
        const x2 = Fp.create(z22);
        const x3 = Fp2.create({ c0: x2, c1: x1 });
        const y2 = Fp2.add(Fp2.pow(x3, _3n3), bls12_381.params.G2b);
        let y3 = Fp2.sqrt(y2);
        if (!y3)
          throw new Error("Failed to find a square root");
        const { re: y0, im: y1 } = Fp2.reim(y3);
        const aflag1 = BigInt(sort);
        const isGreater = y1 > _0n3 && y1 * _2n3 / P !== aflag1;
        const isZero2 = y1 === _0n3 && y0 * _2n3 / P !== aflag1;
        if (isGreater || isZero2)
          y3 = Fp2.neg(y3);
        const point = bls12_381.G2.ProjectivePoint.fromAffine({ x: x3, y: y3 });
        point.assertValidity();
        return point;
      },
      toRawBytes(point) {
        return signatureG2ToRawBytes(point);
      },
      toHex(point) {
        return bytesToHex(signatureG2ToRawBytes(point));
      }
    }
  },
  params: {
    ateLoopSize: BLS_X,
    // The BLS parameter x for BLS12-381
    r: Fr.ORDER,
    // order; z  z + 1; CURVE.n from other curves
    xNegative: true,
    twistType: "multiplicative"
  },
  htfDefaults,
  hash: sha256,
  randomBytes
});

// node_modules/ox/_esm/core/Bls.js
var noble = bls12_381;
function aggregate(points) {
  var _a2;
  const group = typeof ((_a2 = points[0]) == null ? void 0 : _a2.x) === "bigint" ? bls12_381.G1 : bls12_381.G2;
  const point = points.reduce((acc, point2) => acc.add(new group.ProjectivePoint(point2.x, point2.y, point2.z)), group.ProjectivePoint.ZERO);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
function getPublicKey(options) {
  const { privateKey, size: size5 = "short-key:long-sig" } = options;
  const group = size5 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const { px: px2, py, pz } = group.ProjectivePoint.fromPrivateKey(from2(privateKey).slice(2));
  return { x: px2, y: py, z: pz };
}
function randomPrivateKey(options = {}) {
  const { as: as2 = "Hex" } = options;
  const bytes = bls12_381.utils.randomPrivateKey();
  if (as2 === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function sign(options) {
  const { payload, privateKey, suite, size: size5 = "short-key:long-sig" } = options;
  const payloadGroup = size5 === "short-key:long-sig" ? bls12_381.G2 : bls12_381.G1;
  const payloadPoint = payloadGroup.hashToCurve(from(payload), suite ? { DST: fromString(suite) } : void 0);
  const privateKeyGroup = size5 === "short-key:long-sig" ? bls12_381.G1 : bls12_381.G2;
  const signature = payloadPoint.multiply(privateKeyGroup.normPrivateKeyToScalar(privateKey.slice(2)));
  return {
    x: signature.px,
    y: signature.py,
    z: signature.pz
  };
}
function verify(options) {
  const { payload, suite } = options;
  const publicKey = options.publicKey;
  const signature = options.signature;
  const isShortSig = typeof signature.x === "bigint";
  const group = isShortSig ? bls12_381.G1 : bls12_381.G2;
  const payloadPoint = group.hashToCurve(from(payload), suite ? { DST: fromString(suite) } : void 0);
  const shortSigPairing = () => bls12_381.pairingBatch([
    {
      g1: payloadPoint,
      g2: new bls12_381.G2.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z)
    },
    {
      g1: new bls12_381.G1.ProjectivePoint(signature.x, signature.y, signature.z),
      g2: bls12_381.G2.ProjectivePoint.BASE.negate()
    }
  ]);
  const longSigPairing = () => bls12_381.pairingBatch([
    {
      g1: new bls12_381.G1.ProjectivePoint(publicKey.x, publicKey.y, publicKey.z).negate(),
      g2: payloadPoint
    },
    {
      g1: bls12_381.G1.ProjectivePoint.BASE,
      g2: new bls12_381.G2.ProjectivePoint(signature.x, signature.y, signature.z)
    }
  ]);
  return bls12_381.fields.Fp12.eql(isShortSig ? shortSigPairing() : longSigPairing(), bls12_381.fields.Fp12.ONE);
}

// node_modules/ox/_esm/core/BlsPoint.js
var BlsPoint_exports = {};
__export(BlsPoint_exports, {
  fromBytes: () => fromBytes6,
  fromHex: () => fromHex7,
  toBytes: () => toBytes10,
  toHex: () => toHex9
});
function toBytes10(point) {
  const group = typeof point.z === "bigint" ? bls12_381.G1 : bls12_381.G2;
  return new group.ProjectivePoint(point.x, point.y, point.z).toRawBytes();
}
function toHex9(point) {
  return fromBytes(toBytes10(point));
}
function fromBytes6(bytes) {
  const group = bytes.length === 48 ? bls12_381.G1 : bls12_381.G2;
  const point = group.ProjectivePoint.fromHex(bytes);
  return {
    x: point.px,
    y: point.py,
    z: point.pz
  };
}
function fromHex7(hex3, group) {
  return fromBytes6(toBytes2(hex3), group);
}

// node_modules/ox/_esm/core/ContractAddress.js
var ContractAddress_exports = {};
__export(ContractAddress_exports, {
  from: () => from15,
  fromCreate: () => fromCreate,
  fromCreate2: () => fromCreate2
});
function from15(options) {
  if (options.salt)
    return fromCreate2(options);
  return fromCreate(options);
}
function fromCreate(options) {
  const from26 = fromHex2(from4(options.from));
  let nonce = fromNumber(options.nonce);
  if (nonce[0] === 0)
    nonce = new Uint8Array([]);
  return from4(`0x${keccak2562(fromBytes2([from26, nonce], { as: "Hex" })).slice(26)}`);
}
function fromCreate2(options) {
  const from26 = fromHex2(from4(options.from));
  const salt = padLeft(validate(options.salt) ? options.salt : fromHex2(options.salt), 32);
  const bytecodeHash = (() => {
    if ("bytecodeHash" in options) {
      if (validate(options.bytecodeHash))
        return options.bytecodeHash;
      return fromHex2(options.bytecodeHash);
    }
    return keccak2562(options.bytecode, { as: "Bytes" });
  })();
  return from4(slice2(keccak2562(concat(fromHex2("0xff"), from26, salt, bytecodeHash), { as: "Hex" }), 12));
}

// node_modules/ox/_esm/core/Filter.js
var Filter_exports = {};
__export(Filter_exports, {
  fromRpc: () => fromRpc6,
  toRpc: () => toRpc6
});
function fromRpc6(filter3) {
  const { fromBlock, toBlock } = filter3;
  return {
    ...filter3,
    ...fromBlock && {
      fromBlock: validate2(fromBlock, { strict: false }) ? BigInt(fromBlock) : fromBlock
    },
    ...toBlock && {
      toBlock: validate2(toBlock, { strict: false }) ? BigInt(toBlock) : toBlock
    }
  };
}
function toRpc6(filter3) {
  const { address, topics, fromBlock, toBlock } = filter3;
  return {
    ...address && { address },
    ...topics && { topics },
    ...typeof fromBlock !== "undefined" ? {
      fromBlock: typeof fromBlock === "bigint" ? fromNumber2(fromBlock) : fromBlock
    } : {},
    ...typeof toBlock !== "undefined" ? {
      toBlock: typeof toBlock === "bigint" ? fromNumber2(toBlock) : toBlock
    } : {}
  };
}

// node_modules/ox/_esm/core/HdKey.js
var HdKey_exports = {};
__export(HdKey_exports, {
  fromExtendedKey: () => fromExtendedKey,
  fromJson: () => fromJson,
  fromSeed: () => fromSeed,
  path: () => path
});

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_assert.js
function anumber2(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function isBytes(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes2(b4, ...lengths) {
  if (!isBytes(b4))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b4.length);
}
function ahash(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber2(h.outputLen);
  anumber2(h.blockLen);
}
function aexists2(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput2(out, instance) {
  abytes2(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/crypto.js
var crypto2 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/utils.js
function createView(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr2(word, shift) {
  return word << 32 - shift | word >>> shift;
}
function rotl(word, shift) {
  return word << shift | word >>> 32 - shift >>> 0;
}
var isLE = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin = (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
);
var hexes = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function bytesToHex2(bytes) {
  abytes2(bytes);
  if (hasHexBuiltin)
    return bytes.toHex();
  let hex3 = "";
  for (let i2 = 0; i2 < bytes.length; i2++) {
    hex3 += hexes[bytes[i2]];
  }
  return hex3;
}
var asciis = { _0: 48, _9: 57, A: 65, F: 70, a: 97, f: 102 };
function asciiToBase16(ch) {
  if (ch >= asciis._0 && ch <= asciis._9)
    return ch - asciis._0;
  if (ch >= asciis.A && ch <= asciis.F)
    return ch - (asciis.A - 10);
  if (ch >= asciis.a && ch <= asciis.f)
    return ch - (asciis.a - 10);
  return;
}
function hexToBytes2(hex3) {
  if (typeof hex3 !== "string")
    throw new Error("hex string expected, got " + typeof hex3);
  if (hasHexBuiltin)
    return Uint8Array.fromHex(hex3);
  const hl2 = hex3.length;
  const al2 = hl2 / 2;
  if (hl2 % 2)
    throw new Error("hex string expected, got unpadded hex of length " + hl2);
  const array = new Uint8Array(al2);
  for (let ai = 0, hi = 0; ai < al2; ai++, hi += 2) {
    const n1 = asciiToBase16(hex3.charCodeAt(hi));
    const n2 = asciiToBase16(hex3.charCodeAt(hi + 1));
    if (n1 === void 0 || n2 === void 0) {
      const char = hex3[hi] + hex3[hi + 1];
      throw new Error('hex string expected, got non-hex character "' + char + '" at index ' + hi);
    }
    array[ai] = n1 * 16 + n2;
  }
  return array;
}
function utf8ToBytes(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes11(data) {
  if (typeof data === "string")
    data = utf8ToBytes(data);
  abytes2(data);
  return data;
}
function concatBytes2(...arrays) {
  let sum = 0;
  for (let i2 = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    abytes2(a3);
    sum += a3.length;
  }
  const res = new Uint8Array(sum);
  for (let i2 = 0, pad2 = 0; i2 < arrays.length; i2++) {
    const a3 = arrays[i2];
    res.set(a3, pad2);
    pad2 += a3.length;
  }
  return res;
}
var Hash2 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function wrapConstructor(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes11(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/hmac.js
var HMAC = class extends Hash2 {
  constructor(hash8, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash(hash8);
    const key = toBytes11(_key);
    this.iHash = hash8.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash8.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash8.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    aexists2(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists2(this);
    abytes2(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to4) {
    to4 || (to4 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to4 = to4;
    to4.finished = finished;
    to4.destroyed = destroyed;
    to4.blockLen = blockLen;
    to4.outputLen = outputLen;
    to4.oHash = oHash._cloneInto(to4.oHash);
    to4.iHash = iHash._cloneInto(to4.iHash);
    return to4;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac = (hash8, key, message) => new HMAC(hash8, key).update(message).digest();
hmac.create = (hash8, key) => new HMAC(hash8, key);

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_md.js
function setBigUint64(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl2 = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l3 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l3, wl2, isLE3);
}
function Chi(a3, b4, c3) {
  return a3 & b4 ^ ~a3 & c3;
}
function Maj(a3, b4, c3) {
  return a3 & b4 ^ a3 & c3 ^ b4 & c3;
}
var HashMD = class extends Hash2 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView(this.buffer);
  }
  update(data) {
    aexists2(this);
    const { view, buffer: buffer3, blockLen } = this;
    data = toBytes11(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists2(this);
    aoutput2(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer3[i2] = 0;
    setBigUint64(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE3);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to4) {
    to4 || (to4 = new this.constructor());
    to4.set(...this.get());
    const { blockLen, buffer: buffer3, length: length2, finished, destroyed, pos } = this;
    to4.length = length2;
    to4.pos = pos;
    to4.finished = finished;
    to4.destroyed = destroyed;
    if (length2 % blockLen)
      to4.buffer.set(buffer3);
    return to4;
  }
};

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/ripemd160.js
var Rho = new Uint8Array([7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8]);
var Id = new Uint8Array(new Array(16).fill(0).map((_2, i2) => i2));
var Pi = Id.map((i2) => (9 * i2 + 5) % 16);
var idxL = [Id];
var idxR = [Pi];
for (let i2 = 0; i2 < 4; i2++)
  for (let j3 of [idxL, idxR])
    j3.push(j3[i2].map((k4) => Rho[k4]));
var shifts = [
  [11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8],
  [12, 13, 11, 15, 6, 9, 9, 7, 12, 15, 11, 13, 7, 8, 7, 7],
  [13, 15, 14, 11, 7, 7, 6, 8, 13, 14, 13, 12, 5, 5, 6, 9],
  [14, 11, 12, 14, 8, 6, 5, 5, 15, 12, 15, 14, 9, 9, 8, 6],
  [15, 12, 13, 13, 9, 5, 8, 6, 14, 11, 12, 11, 8, 6, 5, 5]
].map((i2) => new Uint8Array(i2));
var shiftsL = idxL.map((idx, i2) => idx.map((j3) => shifts[i2][j3]));
var shiftsR = idxR.map((idx, i2) => idx.map((j3) => shifts[i2][j3]));
var Kl = new Uint32Array([
  0,
  1518500249,
  1859775393,
  2400959708,
  2840853838
]);
var Kr = new Uint32Array([
  1352829926,
  1548603684,
  1836072691,
  2053994217,
  0
]);
function f(group, x2, y2, z3) {
  if (group === 0)
    return x2 ^ y2 ^ z3;
  else if (group === 1)
    return x2 & y2 | ~x2 & z3;
  else if (group === 2)
    return (x2 | ~y2) ^ z3;
  else if (group === 3)
    return x2 & z3 | y2 & ~z3;
  else
    return x2 ^ (y2 | ~z3);
}
var R_BUF = new Uint32Array(16);
var RIPEMD160 = class extends HashMD {
  constructor() {
    super(64, 20, 8, true);
    this.h0 = 1732584193 | 0;
    this.h1 = 4023233417 | 0;
    this.h2 = 2562383102 | 0;
    this.h3 = 271733878 | 0;
    this.h4 = 3285377520 | 0;
  }
  get() {
    const { h0, h1, h2, h3, h4 } = this;
    return [h0, h1, h2, h3, h4];
  }
  set(h0, h1, h2, h3, h4) {
    this.h0 = h0 | 0;
    this.h1 = h1 | 0;
    this.h2 = h2 | 0;
    this.h3 = h3 | 0;
    this.h4 = h4 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      R_BUF[i2] = view.getUint32(offset, true);
    let al2 = this.h0 | 0, ar2 = al2, bl2 = this.h1 | 0, br2 = bl2, cl2 = this.h2 | 0, cr2 = cl2, dl2 = this.h3 | 0, dr2 = dl2, el2 = this.h4 | 0, er2 = el2;
    for (let group = 0; group < 5; group++) {
      const rGroup = 4 - group;
      const hbl = Kl[group], hbr = Kr[group];
      const rl2 = idxL[group], rr2 = idxR[group];
      const sl2 = shiftsL[group], sr2 = shiftsR[group];
      for (let i2 = 0; i2 < 16; i2++) {
        const tl2 = rotl(al2 + f(group, bl2, cl2, dl2) + R_BUF[rl2[i2]] + hbl, sl2[i2]) + el2 | 0;
        al2 = el2, el2 = dl2, dl2 = rotl(cl2, 10) | 0, cl2 = bl2, bl2 = tl2;
      }
      for (let i2 = 0; i2 < 16; i2++) {
        const tr2 = rotl(ar2 + f(rGroup, br2, cr2, dr2) + R_BUF[rr2[i2]] + hbr, sr2[i2]) + er2 | 0;
        ar2 = er2, er2 = dr2, dr2 = rotl(cr2, 10) | 0, cr2 = br2, br2 = tr2;
      }
    }
    this.set(this.h1 + cl2 + dr2 | 0, this.h2 + dl2 + er2 | 0, this.h3 + el2 + ar2 | 0, this.h4 + al2 + br2 | 0, this.h0 + bl2 + cr2 | 0);
  }
  roundClean() {
    R_BUF.fill(0);
  }
  destroy() {
    this.destroyed = true;
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0);
  }
};
var ripemd160 = wrapConstructor(() => new RIPEMD160());

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W = new Uint32Array(64);
var SHA256 = class extends HashMD {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV2[0] | 0;
    this.B = SHA256_IV2[1] | 0;
    this.C = SHA256_IV2[2] | 0;
    this.D = SHA256_IV2[3] | 0;
    this.E = SHA256_IV2[4] | 0;
    this.F = SHA256_IV2[5] | 0;
    this.G = SHA256_IV2[6] | 0;
    this.H = SHA256_IV2[7] | 0;
  }
  get() {
    const { A, B: B2, C: C2, D: D3, E: E3, F: F2, G: G2, H: H3 } = this;
    return [A, B2, C2, D3, E3, F2, G2, H3];
  }
  // prettier-ignore
  set(A, B2, C2, D3, E3, F2, G2, H3) {
    this.A = A | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D3 | 0;
    this.E = E3 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H3 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W[i2 - 15];
      const W22 = SHA256_W[i2 - 2];
      const s0 = rotr2(W15, 7) ^ rotr2(W15, 18) ^ W15 >>> 3;
      const s1 = rotr2(W22, 17) ^ rotr2(W22, 19) ^ W22 >>> 10;
      SHA256_W[i2] = s1 + SHA256_W[i2 - 7] + s0 + SHA256_W[i2 - 16] | 0;
    }
    let { A, B: B2, C: C2, D: D3, E: E3, F: F2, G: G2, H: H3 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr2(E3, 6) ^ rotr2(E3, 11) ^ rotr2(E3, 25);
      const T12 = H3 + sigma1 + Chi(E3, F2, G2) + SHA256_K[i2] + SHA256_W[i2] | 0;
      const sigma0 = rotr2(A, 2) ^ rotr2(A, 13) ^ rotr2(A, 22);
      const T22 = sigma0 + Maj(A, B2, C2) | 0;
      H3 = G2;
      G2 = F2;
      F2 = E3;
      E3 = D3 + T12 | 0;
      D3 = C2;
      C2 = B2;
      B2 = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D3 = D3 + this.D | 0;
    E3 = E3 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H3 = H3 + this.H | 0;
    this.set(A, B2, C2, D3, E3, F2, G2, H3);
  }
  roundClean() {
    SHA256_W.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA224 = class extends SHA256 {
  constructor() {
    super(28);
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
  }
};
var sha2564 = wrapConstructor(() => new SHA256());
var sha224 = wrapConstructor(() => new SHA224());

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK64 = BigInt(2 ** 32 - 1);
var _32n = BigInt(32);
function fromBig2(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK64), l: Number(n2 >> _32n & U32_MASK64) };
  return { h: Number(n2 >> _32n & U32_MASK64) | 0, l: Number(n2 & U32_MASK64) | 0 };
}
function split2(lst, le2 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al2 = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h, l: l3 } = fromBig2(lst[i2], le2);
    [Ah[i2], Al2[i2]] = [h, l3];
  }
  return [Ah, Al2];
}
var toBig = (h, l3) => BigInt(h >>> 0) << _32n | BigInt(l3 >>> 0);
var shrSH = (h, _l2, s2) => h >>> s2;
var shrSL = (h, l3, s2) => h << 32 - s2 | l3 >>> s2;
var rotrSH2 = (h, l3, s2) => h >>> s2 | l3 << 32 - s2;
var rotrSL2 = (h, l3, s2) => h << 32 - s2 | l3 >>> s2;
var rotrBH2 = (h, l3, s2) => h << 64 - s2 | l3 >>> s2 - 32;
var rotrBL2 = (h, l3, s2) => h >>> s2 - 32 | l3 << 64 - s2;
var rotr32H2 = (_h, l3) => l3;
var rotr32L2 = (h, _l2) => h;
var rotlSH = (h, l3, s2) => h << s2 | l3 >>> 32 - s2;
var rotlSL = (h, l3, s2) => l3 << s2 | h >>> 32 - s2;
var rotlBH = (h, l3, s2) => l3 << s2 - 32 | h >>> 64 - s2;
var rotlBL = (h, l3, s2) => h << s2 - 32 | l3 >>> 64 - s2;
function add2(Ah, Al2, Bh, Bl2) {
  const l3 = (Al2 >>> 0) + (Bl2 >>> 0);
  return { h: Ah + Bh + (l3 / 2 ** 32 | 0) | 0, l: l3 | 0 };
}
var add3L2 = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
var add3H2 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
var add4H = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
var add5H = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u64 = {
  fromBig: fromBig2,
  split: split2,
  toBig,
  shrSH,
  shrSL,
  rotrSH: rotrSH2,
  rotrSL: rotrSL2,
  rotrBH: rotrBH2,
  rotrBL: rotrBL2,
  rotr32H: rotr32H2,
  rotr32L: rotr32L2,
  rotlSH,
  rotlSL,
  rotlBH,
  rotlBL,
  add: add2,
  add3L: add3L2,
  add3H: add3H2,
  add4L,
  add4H,
  add5H,
  add5L
};
var u64_default = u64;

// node_modules/@scure/bip32/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh, SHA512_Kl] = (() => u64_default.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_W_H = new Uint32Array(80);
var SHA512_W_L = new Uint32Array(80);
var SHA512 = class extends HashMD {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al: Al2, Bh, Bl: Bl2, Ch, Cl: Cl2, Dh, Dl: Dl2, Eh, El: El2, Fh, Fl: Fl2, Gh, Gl: Gl2, Hh, Hl: Hl2 } = this;
    return [Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2];
  }
  // prettier-ignore
  set(Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2) {
    this.Ah = Ah | 0;
    this.Al = Al2 | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl2 | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl2 | 0;
    this.Eh = Eh | 0;
    this.El = El2 | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl2 | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl2 | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H[i2] = view.getUint32(offset);
      SHA512_W_L[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H[i2 - 15] | 0;
      const W15l = SHA512_W_L[i2 - 15] | 0;
      const s0h = u64_default.rotrSH(W15h, W15l, 1) ^ u64_default.rotrSH(W15h, W15l, 8) ^ u64_default.shrSH(W15h, W15l, 7);
      const s0l = u64_default.rotrSL(W15h, W15l, 1) ^ u64_default.rotrSL(W15h, W15l, 8) ^ u64_default.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H[i2 - 2] | 0;
      const W2l = SHA512_W_L[i2 - 2] | 0;
      const s1h = u64_default.rotrSH(W2h, W2l, 19) ^ u64_default.rotrBH(W2h, W2l, 61) ^ u64_default.shrSH(W2h, W2l, 6);
      const s1l = u64_default.rotrSL(W2h, W2l, 19) ^ u64_default.rotrBL(W2h, W2l, 61) ^ u64_default.shrSL(W2h, W2l, 6);
      const SUMl = u64_default.add4L(s0l, s1l, SHA512_W_L[i2 - 7], SHA512_W_L[i2 - 16]);
      const SUMh = u64_default.add4H(SUMl, s0h, s1h, SHA512_W_H[i2 - 7], SHA512_W_H[i2 - 16]);
      SHA512_W_H[i2] = SUMh | 0;
      SHA512_W_L[i2] = SUMl | 0;
    }
    let { Ah, Al: Al2, Bh, Bl: Bl2, Ch, Cl: Cl2, Dh, Dl: Dl2, Eh, El: El2, Fh, Fl: Fl2, Gh, Gl: Gl2, Hh, Hl: Hl2 } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = u64_default.rotrSH(Eh, El2, 14) ^ u64_default.rotrSH(Eh, El2, 18) ^ u64_default.rotrBH(Eh, El2, 41);
      const sigma1l = u64_default.rotrSL(Eh, El2, 14) ^ u64_default.rotrSL(Eh, El2, 18) ^ u64_default.rotrBL(Eh, El2, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
      const T1ll = u64_default.add5L(Hl2, sigma1l, CHIl, SHA512_Kl[i2], SHA512_W_L[i2]);
      const T1h = u64_default.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh[i2], SHA512_W_H[i2]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default.rotrSH(Ah, Al2, 28) ^ u64_default.rotrBH(Ah, Al2, 34) ^ u64_default.rotrBH(Ah, Al2, 39);
      const sigma0l = u64_default.rotrSL(Ah, Al2, 28) ^ u64_default.rotrBL(Ah, Al2, 34) ^ u64_default.rotrBL(Ah, Al2, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
      Hh = Gh | 0;
      Hl2 = Gl2 | 0;
      Gh = Fh | 0;
      Gl2 = Fl2 | 0;
      Fh = Eh | 0;
      Fl2 = El2 | 0;
      ({ h: Eh, l: El2 } = u64_default.add(Dh | 0, Dl2 | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl2 = Cl2 | 0;
      Ch = Bh | 0;
      Cl2 = Bl2 | 0;
      Bh = Ah | 0;
      Bl2 = Al2 | 0;
      const All = u64_default.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default.add3H(All, T1h, sigma0h, MAJh);
      Al2 = All | 0;
    }
    ({ h: Ah, l: Al2 } = u64_default.add(this.Ah | 0, this.Al | 0, Ah | 0, Al2 | 0));
    ({ h: Bh, l: Bl2 } = u64_default.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
    ({ h: Ch, l: Cl2 } = u64_default.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl2 | 0));
    ({ h: Dh, l: Dl2 } = u64_default.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl2 | 0));
    ({ h: Eh, l: El2 } = u64_default.add(this.Eh | 0, this.El | 0, Eh | 0, El2 | 0));
    ({ h: Fh, l: Fl2 } = u64_default.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl2 | 0));
    ({ h: Gh, l: Gl2 } = u64_default.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl2 | 0));
    ({ h: Hh, l: Hl2 } = u64_default.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl2 | 0));
    this.set(Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2);
  }
  roundClean() {
    SHA512_W_H.fill(0);
    SHA512_W_L.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_224 = class extends SHA512 {
  constructor() {
    super(28);
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
  }
};
var SHA512_256 = class extends SHA512 {
  constructor() {
    super(32);
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
  }
};
var SHA384 = class extends SHA512 {
  constructor() {
    super(48);
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
  }
};
var sha512 = wrapConstructor(() => new SHA512());
var sha512_224 = wrapConstructor(() => new SHA512_224());
var sha512_256 = wrapConstructor(() => new SHA512_256());
var sha384 = wrapConstructor(() => new SHA384());

// node_modules/@scure/base/lib/esm/index.js
function isBytes2(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes3(b4, ...lengths) {
  if (!isBytes2(b4))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b4.length);
}
function isArrayOf(isString5, arr) {
  if (!Array.isArray(arr))
    return false;
  if (arr.length === 0)
    return true;
  if (isString5) {
    return arr.every((item) => typeof item === "string");
  } else {
    return arr.every((item) => Number.isSafeInteger(item));
  }
}
function afn(input) {
  if (typeof input !== "function")
    throw new Error("function expected");
  return true;
}
function astr(label, input) {
  if (typeof input !== "string")
    throw new Error(`${label}: string expected`);
  return true;
}
function anumber3(n2) {
  if (!Number.isSafeInteger(n2))
    throw new Error(`invalid integer: ${n2}`);
}
function aArr(input) {
  if (!Array.isArray(input))
    throw new Error("array expected");
}
function astrArr(label, input) {
  if (!isArrayOf(true, input))
    throw new Error(`${label}: array of strings expected`);
}
function anumArr(label, input) {
  if (!isArrayOf(false, input))
    throw new Error(`${label}: array of numbers expected`);
}
function chain(...args) {
  const id3 = (a3) => a3;
  const wrap2 = (a3, b4) => (c3) => a3(b4(c3));
  const encode9 = args.map((x2) => x2.encode).reduceRight(wrap2, id3);
  const decode4 = args.map((x2) => x2.decode).reduce(wrap2, id3);
  return { encode: encode9, decode: decode4 };
}
function alphabet(letters) {
  const lettersA = typeof letters === "string" ? letters.split("") : letters;
  const len = lettersA.length;
  astrArr("alphabet", lettersA);
  const indexes = new Map(lettersA.map((l3, i2) => [l3, i2]));
  return {
    encode: (digits) => {
      aArr(digits);
      return digits.map((i2) => {
        if (!Number.isSafeInteger(i2) || i2 < 0 || i2 >= len)
          throw new Error(`alphabet.encode: digit index outside alphabet "${i2}". Allowed: ${letters}`);
        return lettersA[i2];
      });
    },
    decode: (input) => {
      aArr(input);
      return input.map((letter) => {
        astr("alphabet.decode", letter);
        const i2 = indexes.get(letter);
        if (i2 === void 0)
          throw new Error(`Unknown letter: "${letter}". Allowed: ${letters}`);
        return i2;
      });
    }
  };
}
function join(separator = "") {
  astr("join", separator);
  return {
    encode: (from26) => {
      astrArr("join.decode", from26);
      return from26.join(separator);
    },
    decode: (to4) => {
      astr("join.decode", to4);
      return to4.split(separator);
    }
  };
}
function padding(bits, chr = "=") {
  anumber3(bits);
  astr("padding", chr);
  return {
    encode(data) {
      astrArr("padding.encode", data);
      while (data.length * bits % 8)
        data.push(chr);
      return data;
    },
    decode(input) {
      astrArr("padding.decode", input);
      let end = input.length;
      if (end * bits % 8)
        throw new Error("padding: invalid, string should have whole number of bytes");
      for (; end > 0 && input[end - 1] === chr; end--) {
        const last = end - 1;
        const byte = last * bits;
        if (byte % 8 === 0)
          throw new Error("padding: invalid, string has too much padding");
      }
      return input.slice(0, end);
    }
  };
}
function normalize(fn2) {
  afn(fn2);
  return { encode: (from26) => from26, decode: (to4) => fn2(to4) };
}
function convertRadix(data, from26, to4) {
  if (from26 < 2)
    throw new Error(`convertRadix: invalid from=${from26}, base cannot be less than 2`);
  if (to4 < 2)
    throw new Error(`convertRadix: invalid to=${to4}, base cannot be less than 2`);
  aArr(data);
  if (!data.length)
    return [];
  let pos = 0;
  const res = [];
  const digits = Array.from(data, (d2) => {
    anumber3(d2);
    if (d2 < 0 || d2 >= from26)
      throw new Error(`invalid integer: ${d2}`);
    return d2;
  });
  const dlen = digits.length;
  while (true) {
    let carry = 0;
    let done = true;
    for (let i2 = pos; i2 < dlen; i2++) {
      const digit = digits[i2];
      const fromCarry = from26 * carry;
      const digitBase = fromCarry + digit;
      if (!Number.isSafeInteger(digitBase) || fromCarry / from26 !== carry || digitBase - digit !== fromCarry) {
        throw new Error("convertRadix: carry overflow");
      }
      const div = digitBase / to4;
      carry = digitBase % to4;
      const rounded2 = Math.floor(div);
      digits[i2] = rounded2;
      if (!Number.isSafeInteger(rounded2) || rounded2 * to4 + carry !== digitBase)
        throw new Error("convertRadix: carry overflow");
      if (!done)
        continue;
      else if (!rounded2)
        pos = i2;
      else
        done = false;
    }
    res.push(carry);
    if (done)
      break;
  }
  for (let i2 = 0; i2 < data.length - 1 && data[i2] === 0; i2++)
    res.push(0);
  return res.reverse();
}
var gcd = (a3, b4) => b4 === 0 ? a3 : gcd(b4, a3 % b4);
var radix2carry = (from26, to4) => from26 + (to4 - gcd(from26, to4));
var powers = (() => {
  let res = [];
  for (let i2 = 0; i2 < 40; i2++)
    res.push(2 ** i2);
  return res;
})();
function convertRadix2(data, from26, to4, padding2) {
  aArr(data);
  if (from26 <= 0 || from26 > 32)
    throw new Error(`convertRadix2: wrong from=${from26}`);
  if (to4 <= 0 || to4 > 32)
    throw new Error(`convertRadix2: wrong to=${to4}`);
  if (radix2carry(from26, to4) > 32) {
    throw new Error(`convertRadix2: carry overflow from=${from26} to=${to4} carryBits=${radix2carry(from26, to4)}`);
  }
  let carry = 0;
  let pos = 0;
  const max = powers[from26];
  const mask = powers[to4] - 1;
  const res = [];
  for (const n2 of data) {
    anumber3(n2);
    if (n2 >= max)
      throw new Error(`convertRadix2: invalid data word=${n2} from=${from26}`);
    carry = carry << from26 | n2;
    if (pos + from26 > 32)
      throw new Error(`convertRadix2: carry overflow pos=${pos} from=${from26}`);
    pos += from26;
    for (; pos >= to4; pos -= to4)
      res.push((carry >> pos - to4 & mask) >>> 0);
    const pow = powers[pos];
    if (pow === void 0)
      throw new Error("invalid carry");
    carry &= pow - 1;
  }
  carry = carry << to4 - pos & mask;
  if (!padding2 && pos >= from26)
    throw new Error("Excess padding");
  if (!padding2 && carry > 0)
    throw new Error(`Non-zero padding: ${carry}`);
  if (padding2 && pos > 0)
    res.push(carry >>> 0);
  return res;
}
function radix(num) {
  anumber3(num);
  const _256 = 2 ** 8;
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix.encode input should be Uint8Array");
      return convertRadix(Array.from(bytes), _256, num);
    },
    decode: (digits) => {
      anumArr("radix.decode", digits);
      return Uint8Array.from(convertRadix(digits, num, _256));
    }
  };
}
function radix2(bits, revPadding = false) {
  anumber3(bits);
  if (bits <= 0 || bits > 32)
    throw new Error("radix2: bits should be in (0..32]");
  if (radix2carry(8, bits) > 32 || radix2carry(bits, 8) > 32)
    throw new Error("radix2: carry overflow");
  return {
    encode: (bytes) => {
      if (!isBytes2(bytes))
        throw new Error("radix2.encode input should be Uint8Array");
      return convertRadix2(Array.from(bytes), 8, bits, !revPadding);
    },
    decode: (digits) => {
      anumArr("radix2.decode", digits);
      return Uint8Array.from(convertRadix2(digits, bits, 8, revPadding));
    }
  };
}
function unsafeWrapper(fn2) {
  afn(fn2);
  return function(...args) {
    try {
      return fn2.apply(null, args);
    } catch (e2) {
    }
  };
}
function checksum(len, fn2) {
  anumber3(len);
  afn(fn2);
  return {
    encode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.encode: input should be Uint8Array");
      const sum = fn2(data).slice(0, len);
      const res = new Uint8Array(data.length + len);
      res.set(data);
      res.set(sum, data.length);
      return res;
    },
    decode(data) {
      if (!isBytes2(data))
        throw new Error("checksum.decode: input should be Uint8Array");
      const payload = data.slice(0, -len);
      const oldChecksum = data.slice(-len);
      const newChecksum = fn2(payload).slice(0, len);
      for (let i2 = 0; i2 < len; i2++)
        if (newChecksum[i2] !== oldChecksum[i2])
          throw new Error("Invalid checksum");
      return payload;
    }
  };
}
var utils = {
  alphabet,
  chain,
  checksum,
  convertRadix,
  convertRadix2,
  radix,
  radix2,
  join,
  padding
};
var base16 = chain(radix2(4), alphabet("0123456789ABCDEF"), join(""));
var base32 = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), padding(5), join(""));
var base32nopad = chain(radix2(5), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZ234567"), join(""));
var base32hex = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), padding(5), join(""));
var base32hexnopad = chain(radix2(5), alphabet("0123456789ABCDEFGHIJKLMNOPQRSTUV"), join(""));
var base32crockford = chain(radix2(5), alphabet("0123456789ABCDEFGHJKMNPQRSTVWXYZ"), join(""), normalize((s2) => s2.toUpperCase().replace(/O/g, "0").replace(/[IL]/g, "1")));
var hasBase64Builtin = (() => typeof Uint8Array.from([]).toBase64 === "function" && typeof Uint8Array.fromBase64 === "function")();
var base64 = hasBase64Builtin ? {
  encode(b4) {
    abytes3(b4);
    return b4.toBase64();
  },
  decode(s2) {
    astr("base64", s2);
    return Uint8Array.fromBase64(s2, { lastChunkHandling: "strict" });
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), padding(6), join(""));
var base64nopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"), join(""));
var base64url = hasBase64Builtin ? {
  encode(b4) {
    abytes3(b4);
    return b4.toBase64({ alphabet: "base64url" });
  },
  decode(s2) {
    astr("base64", s2);
    return Uint8Array.fromBase64(s2, { alphabet: "base64url" });
  }
} : chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), padding(6), join(""));
var base64urlnopad = chain(radix2(6), alphabet("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"), join(""));
var genBase58 = (abc) => chain(radix(58), alphabet(abc), join(""));
var base58 = genBase58("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");
var base58flickr = genBase58("123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ");
var base58xrp = genBase58("rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz");
var createBase58check = (sha2566) => chain(checksum(4, (data) => sha2566(sha2566(data))), base58);
var BECH_ALPHABET = chain(alphabet("qpzry9x8gf2tvdw0s3jn54khce6mua7l"), join(""));
var POLYMOD_GENERATORS = [996825010, 642813549, 513874426, 1027748829, 705979059];
function bech32Polymod(pre) {
  const b4 = pre >> 25;
  let chk = (pre & 33554431) << 5;
  for (let i2 = 0; i2 < POLYMOD_GENERATORS.length; i2++) {
    if ((b4 >> i2 & 1) === 1)
      chk ^= POLYMOD_GENERATORS[i2];
  }
  return chk;
}
function bechChecksum(prefix, words, encodingConst = 1) {
  const len = prefix.length;
  let chk = 1;
  for (let i2 = 0; i2 < len; i2++) {
    const c3 = prefix.charCodeAt(i2);
    if (c3 < 33 || c3 > 126)
      throw new Error(`Invalid prefix (${prefix})`);
    chk = bech32Polymod(chk) ^ c3 >> 5;
  }
  chk = bech32Polymod(chk);
  for (let i2 = 0; i2 < len; i2++)
    chk = bech32Polymod(chk) ^ prefix.charCodeAt(i2) & 31;
  for (let v2 of words)
    chk = bech32Polymod(chk) ^ v2;
  for (let i2 = 0; i2 < 6; i2++)
    chk = bech32Polymod(chk);
  chk ^= encodingConst;
  return BECH_ALPHABET.encode(convertRadix2([chk % powers[30]], 30, 5, false));
}
function genBech32(encoding) {
  const ENCODING_CONST = encoding === "bech32" ? 1 : 734539939;
  const _words = radix2(5);
  const fromWords = _words.decode;
  const toWords = _words.encode;
  const fromWordsUnsafe = unsafeWrapper(fromWords);
  function encode9(prefix, words, limit = 90) {
    astr("bech32.encode prefix", prefix);
    if (isBytes2(words))
      words = Array.from(words);
    anumArr("bech32.encode", words);
    const plen = prefix.length;
    if (plen === 0)
      throw new TypeError(`Invalid prefix length ${plen}`);
    const actualLength = plen + 7 + words.length;
    if (limit !== false && actualLength > limit)
      throw new TypeError(`Length ${actualLength} exceeds limit ${limit}`);
    const lowered = prefix.toLowerCase();
    const sum = bechChecksum(lowered, words, ENCODING_CONST);
    return `${lowered}1${BECH_ALPHABET.encode(words)}${sum}`;
  }
  function decode4(str, limit = 90) {
    astr("bech32.decode input", str);
    const slen = str.length;
    if (slen < 8 || limit !== false && slen > limit)
      throw new TypeError(`invalid string length: ${slen} (${str}). Expected (8..${limit})`);
    const lowered = str.toLowerCase();
    if (str !== lowered && str !== str.toUpperCase())
      throw new Error(`String must be lowercase or uppercase`);
    const sepIndex = lowered.lastIndexOf("1");
    if (sepIndex === 0 || sepIndex === -1)
      throw new Error(`Letter "1" must be present between prefix and data only`);
    const prefix = lowered.slice(0, sepIndex);
    const data = lowered.slice(sepIndex + 1);
    if (data.length < 6)
      throw new Error("Data must be at least 6 characters long");
    const words = BECH_ALPHABET.decode(data).slice(0, -6);
    const sum = bechChecksum(prefix, words, ENCODING_CONST);
    if (!data.endsWith(sum))
      throw new Error(`Invalid checksum in ${str}: expected "${sum}"`);
    return { prefix, words };
  }
  const decodeUnsafe = unsafeWrapper(decode4);
  function decodeToBytes(str) {
    const { prefix, words } = decode4(str, false);
    return { prefix, words, bytes: fromWords(words) };
  }
  function encodeFromBytes(prefix, bytes) {
    return encode9(prefix, toWords(bytes));
  }
  return {
    encode: encode9,
    decode: decode4,
    encodeFromBytes,
    decodeToBytes,
    decodeUnsafe,
    fromWords,
    fromWordsUnsafe,
    toWords
  };
}
var bech32 = genBech32("bech32");
var bech32m = genBech32("bech32m");
var hasHexBuiltin2 = (() => typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function")();
var hexBuiltin = {
  encode(data) {
    abytes3(data);
    return data.toHex();
  },
  decode(s2) {
    astr("hex", s2);
    return Uint8Array.fromHex(s2);
  }
};
var hex2 = hasHexBuiltin2 ? hexBuiltin : chain(radix2(4), alphabet("0123456789abcdef"), join(""), normalize((s2) => {
  if (typeof s2 !== "string" || s2.length % 2 !== 0)
    throw new TypeError(`hex.decode: expected string, got ${typeof s2} with length ${s2.length}`);
  return s2.toLowerCase();
}));

// node_modules/@scure/bip32/lib/esm/index.js
var Point = secp256k1.ProjectivePoint;
var base58check = createBase58check(sha2564);
function bytesToNumber(bytes) {
  abytes2(bytes);
  const h = bytes.length === 0 ? "0" : bytesToHex2(bytes);
  return BigInt("0x" + h);
}
function numberToBytes(num) {
  if (typeof num !== "bigint")
    throw new Error("bigint expected");
  return hexToBytes2(num.toString(16).padStart(64, "0"));
}
var MASTER_SECRET = utf8ToBytes("Bitcoin seed");
var BITCOIN_VERSIONS = { private: 76066276, public: 76067358 };
var HARDENED_OFFSET = 2147483648;
var hash160 = (data) => ripemd160(sha2564(data));
var fromU32 = (data) => createView(data).getUint32(0, false);
var toU32 = (n2) => {
  if (!Number.isSafeInteger(n2) || n2 < 0 || n2 > 2 ** 32 - 1) {
    throw new Error("invalid number, should be from 0 to 2**32-1, got " + n2);
  }
  const buf = new Uint8Array(4);
  createView(buf).setUint32(0, n2, false);
  return buf;
};
var HDKey = class _HDKey {
  get fingerprint() {
    if (!this.pubHash) {
      throw new Error("No publicKey set!");
    }
    return fromU32(this.pubHash);
  }
  get identifier() {
    return this.pubHash;
  }
  get pubKeyHash() {
    return this.pubHash;
  }
  get privateKey() {
    return this.privKeyBytes || null;
  }
  get publicKey() {
    return this.pubKey || null;
  }
  get privateExtendedKey() {
    const priv = this.privateKey;
    if (!priv) {
      throw new Error("No private key");
    }
    return base58check.encode(this.serialize(this.versions.private, concatBytes2(new Uint8Array([0]), priv)));
  }
  get publicExtendedKey() {
    if (!this.pubKey) {
      throw new Error("No public key");
    }
    return base58check.encode(this.serialize(this.versions.public, this.pubKey));
  }
  static fromMasterSeed(seed, versions = BITCOIN_VERSIONS) {
    abytes2(seed);
    if (8 * seed.length < 128 || 8 * seed.length > 512) {
      throw new Error("HDKey: seed length must be between 128 and 512 bits; 256 bits is advised, got " + seed.length);
    }
    const I3 = hmac(sha512, MASTER_SECRET, seed);
    return new _HDKey({
      versions,
      chainCode: I3.slice(32),
      privateKey: I3.slice(0, 32)
    });
  }
  static fromExtendedKey(base58key, versions = BITCOIN_VERSIONS) {
    const keyBuffer = base58check.decode(base58key);
    const keyView = createView(keyBuffer);
    const version7 = keyView.getUint32(0, false);
    const opt = {
      versions,
      depth: keyBuffer[4],
      parentFingerprint: keyView.getUint32(5, false),
      index: keyView.getUint32(9, false),
      chainCode: keyBuffer.slice(13, 45)
    };
    const key = keyBuffer.slice(45);
    const isPriv = key[0] === 0;
    if (version7 !== versions[isPriv ? "private" : "public"]) {
      throw new Error("Version mismatch");
    }
    if (isPriv) {
      return new _HDKey({ ...opt, privateKey: key.slice(1) });
    } else {
      return new _HDKey({ ...opt, publicKey: key });
    }
  }
  static fromJSON(json) {
    return _HDKey.fromExtendedKey(json.xpriv);
  }
  constructor(opt) {
    this.depth = 0;
    this.index = 0;
    this.chainCode = null;
    this.parentFingerprint = 0;
    if (!opt || typeof opt !== "object") {
      throw new Error("HDKey.constructor must not be called directly");
    }
    this.versions = opt.versions || BITCOIN_VERSIONS;
    this.depth = opt.depth || 0;
    this.chainCode = opt.chainCode || null;
    this.index = opt.index || 0;
    this.parentFingerprint = opt.parentFingerprint || 0;
    if (!this.depth) {
      if (this.parentFingerprint || this.index) {
        throw new Error("HDKey: zero depth with non-zero index/parent fingerprint");
      }
    }
    if (opt.publicKey && opt.privateKey) {
      throw new Error("HDKey: publicKey and privateKey at same time.");
    }
    if (opt.privateKey) {
      if (!secp256k1.utils.isValidPrivateKey(opt.privateKey)) {
        throw new Error("Invalid private key");
      }
      this.privKey = typeof opt.privateKey === "bigint" ? opt.privateKey : bytesToNumber(opt.privateKey);
      this.privKeyBytes = numberToBytes(this.privKey);
      this.pubKey = secp256k1.getPublicKey(opt.privateKey, true);
    } else if (opt.publicKey) {
      this.pubKey = Point.fromHex(opt.publicKey).toRawBytes(true);
    } else {
      throw new Error("HDKey: no public or private key provided");
    }
    this.pubHash = hash160(this.pubKey);
  }
  derive(path2) {
    if (!/^[mM]'?/.test(path2)) {
      throw new Error('Path must start with "m" or "M"');
    }
    if (/^[mM]'?$/.test(path2)) {
      return this;
    }
    const parts = path2.replace(/^[mM]'?\//, "").split("/");
    let child = this;
    for (const c3 of parts) {
      const m3 = /^(\d+)('?)$/.exec(c3);
      const m1 = m3 && m3[1];
      if (!m3 || m3.length !== 3 || typeof m1 !== "string")
        throw new Error("invalid child index: " + c3);
      let idx = +m1;
      if (!Number.isSafeInteger(idx) || idx >= HARDENED_OFFSET) {
        throw new Error("Invalid index");
      }
      if (m3[2] === "'") {
        idx += HARDENED_OFFSET;
      }
      child = child.deriveChild(idx);
    }
    return child;
  }
  deriveChild(index5) {
    if (!this.pubKey || !this.chainCode) {
      throw new Error("No publicKey or chainCode set");
    }
    let data = toU32(index5);
    if (index5 >= HARDENED_OFFSET) {
      const priv = this.privateKey;
      if (!priv) {
        throw new Error("Could not derive hardened child key");
      }
      data = concatBytes2(new Uint8Array([0]), priv, data);
    } else {
      data = concatBytes2(this.pubKey, data);
    }
    const I3 = hmac(sha512, this.chainCode, data);
    const childTweak = bytesToNumber(I3.slice(0, 32));
    const chainCode = I3.slice(32);
    if (!secp256k1.utils.isValidPrivateKey(childTweak)) {
      throw new Error("Tweak bigger than curve order");
    }
    const opt = {
      versions: this.versions,
      chainCode,
      depth: this.depth + 1,
      parentFingerprint: this.fingerprint,
      index: index5
    };
    try {
      if (this.privateKey) {
        const added = mod(this.privKey + childTweak, secp256k1.CURVE.n);
        if (!secp256k1.utils.isValidPrivateKey(added)) {
          throw new Error("The tweak was out of range or the resulted private key is invalid");
        }
        opt.privateKey = added;
      } else {
        const added = Point.fromHex(this.pubKey).add(Point.fromPrivateKey(childTweak));
        if (added.equals(Point.ZERO)) {
          throw new Error("The tweak was equal to negative P, which made the result key invalid");
        }
        opt.publicKey = added.toRawBytes(true);
      }
      return new _HDKey(opt);
    } catch (err) {
      return this.deriveChild(index5 + 1);
    }
  }
  sign(hash8) {
    if (!this.privateKey) {
      throw new Error("No privateKey set!");
    }
    abytes2(hash8, 32);
    return secp256k1.sign(hash8, this.privKey).toCompactRawBytes();
  }
  verify(hash8, signature) {
    abytes2(hash8, 32);
    abytes2(signature, 64);
    if (!this.publicKey) {
      throw new Error("No publicKey set!");
    }
    let sig;
    try {
      sig = secp256k1.Signature.fromCompact(signature);
    } catch (error) {
      return false;
    }
    return secp256k1.verify(sig, hash8, this.publicKey);
  }
  wipePrivateData() {
    this.privKey = void 0;
    if (this.privKeyBytes) {
      this.privKeyBytes.fill(0);
      this.privKeyBytes = void 0;
    }
    return this;
  }
  toJSON() {
    return {
      xpriv: this.privateExtendedKey,
      xpub: this.publicExtendedKey
    };
  }
  serialize(version7, key) {
    if (!this.chainCode) {
      throw new Error("No chainCode set");
    }
    abytes2(key, 33);
    return concatBytes2(toU32(version7), new Uint8Array([this.depth]), toU32(this.parentFingerprint), toU32(this.index), this.chainCode, key);
  }
};

// node_modules/ox/_esm/core/Secp256k1.js
var Secp256k1_exports = {};
__export(Secp256k1_exports, {
  getPublicKey: () => getPublicKey2,
  noble: () => noble2,
  randomPrivateKey: () => randomPrivateKey2,
  recoverAddress: () => recoverAddress,
  recoverPublicKey: () => recoverPublicKey,
  sign: () => sign2,
  verify: () => verify2
});

// node_modules/ox/_esm/core/internal/entropy.js
var extraEntropy = false;

// node_modules/ox/_esm/core/Secp256k1.js
var noble2 = secp256k1;
function getPublicKey2(options) {
  const { privateKey } = options;
  const point = secp256k1.ProjectivePoint.fromPrivateKey(from2(privateKey).slice(2));
  return from3(point);
}
function randomPrivateKey2(options = {}) {
  const { as: as2 = "Hex" } = options;
  const bytes = secp256k1.utils.randomPrivateKey();
  if (as2 === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function recoverAddress(options) {
  return fromPublicKey(recoverPublicKey(options));
}
function recoverPublicKey(options) {
  const { payload, signature } = options;
  const { r: r2, s: s2, yParity } = signature;
  const signature_ = new secp256k1.Signature(BigInt(r2), BigInt(s2)).addRecoveryBit(yParity);
  const point = signature_.recoverPublicKey(from2(payload).substring(2));
  return from3(point);
}
function sign2(options) {
  const { extraEntropy: extraEntropy2 = extraEntropy, hash: hash8, payload, privateKey } = options;
  const { r: r2, s: s2, recovery } = secp256k1.sign(from(payload), from(privateKey), {
    extraEntropy: typeof extraEntropy2 === "boolean" ? extraEntropy2 : from2(extraEntropy2).slice(2),
    lowS: true,
    ...hash8 ? { prehash: true } : {}
  });
  return {
    r: r2,
    s: s2,
    yParity: recovery
  };
}
function verify2(options) {
  const { address, hash: hash8, payload, publicKey, signature } = options;
  if (address)
    return isEqual2(address, recoverAddress({ payload, signature }));
  return secp256k1.verify(signature, from(payload), toBytes4(publicKey), ...hash8 ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/internal/hdKey.js
function fromScure(key) {
  return {
    derive: (path2) => fromScure(key.derive(path2)),
    depth: key.depth,
    identifier: fromBytes(key.identifier),
    index: key.index,
    privateKey: fromBytes(key.privateKey),
    privateExtendedKey: key.privateExtendedKey,
    publicKey: getPublicKey2({ privateKey: key.privateKey }),
    publicExtendedKey: key.publicExtendedKey,
    versions: key.versions
  };
}

// node_modules/ox/_esm/core/HdKey.js
function fromExtendedKey(extendedKey) {
  const key = HDKey.fromExtendedKey(extendedKey);
  return fromScure(key);
}
function fromJson(json) {
  return fromScure(HDKey.fromJSON(json));
}
function fromSeed(seed, options = {}) {
  const { versions } = options;
  const key = HDKey.fromMasterSeed(from(seed), versions);
  return fromScure(key);
}
function path(options = {}) {
  const { account = 0, change = 0, index: index5 = 0 } = options;
  return `m/44'/60'/${account}'/${change}/${index5}`;
}

// node_modules/ox/_esm/core/Fee.js
var Fee_exports = {};

// node_modules/ox/_esm/core/Log.js
var Log_exports = {};
__export(Log_exports, {
  fromRpc: () => fromRpc7,
  toRpc: () => toRpc7
});
function fromRpc7(log, _options = {}) {
  return {
    ...log,
    blockNumber: log.blockNumber ? BigInt(log.blockNumber) : null,
    logIndex: log.logIndex ? Number(log.logIndex) : null,
    transactionIndex: log.transactionIndex ? Number(log.transactionIndex) : null
  };
}
function toRpc7(log, _options = {}) {
  return {
    address: log.address,
    blockHash: log.blockHash,
    blockNumber: typeof log.blockNumber === "bigint" ? fromNumber2(log.blockNumber) : null,
    data: log.data,
    logIndex: typeof log.logIndex === "number" ? fromNumber2(log.logIndex) : null,
    topics: log.topics,
    transactionHash: log.transactionHash,
    transactionIndex: typeof log.transactionIndex === "number" ? fromNumber2(log.transactionIndex) : null,
    removed: log.removed
  };
}

// node_modules/ox/_esm/core/Mnemonic.js
var Mnemonic_exports = {};
__export(Mnemonic_exports, {
  czech: () => wordlist,
  english: () => wordlist2,
  french: () => wordlist3,
  italian: () => wordlist4,
  japanese: () => wordlist5,
  korean: () => wordlist6,
  path: () => path,
  portuguese: () => wordlist7,
  random: () => random2,
  simplifiedChinese: () => wordlist8,
  spanish: () => wordlist9,
  toHdKey: () => toHdKey,
  toPrivateKey: () => toPrivateKey,
  toSeed: () => toSeed,
  traditionalChinese: () => wordlist10,
  validate: () => validate7
});

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_assert.js
function anumber4(n2) {
  if (!Number.isSafeInteger(n2) || n2 < 0)
    throw new Error("positive integer expected, got " + n2);
}
function isBytes3(a3) {
  return a3 instanceof Uint8Array || ArrayBuffer.isView(a3) && a3.constructor.name === "Uint8Array";
}
function abytes4(b4, ...lengths) {
  if (!isBytes3(b4))
    throw new Error("Uint8Array expected");
  if (lengths.length > 0 && !lengths.includes(b4.length))
    throw new Error("Uint8Array expected of length " + lengths + ", got length=" + b4.length);
}
function ahash2(h) {
  if (typeof h !== "function" || typeof h.create !== "function")
    throw new Error("Hash should be wrapped by utils.wrapConstructor");
  anumber4(h.outputLen);
  anumber4(h.blockLen);
}
function aexists3(instance, checkFinished = true) {
  if (instance.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (checkFinished && instance.finished)
    throw new Error("Hash#digest() has already been called");
}
function aoutput3(out, instance) {
  abytes4(out);
  const min = instance.outputLen;
  if (out.length < min) {
    throw new Error("digestInto() expects output buffer of length at least " + min);
  }
}

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/crypto.js
var crypto3 = typeof globalThis === "object" && "crypto" in globalThis ? globalThis.crypto : void 0;

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/utils.js
function createView2(arr) {
  return new DataView(arr.buffer, arr.byteOffset, arr.byteLength);
}
function rotr3(word, shift) {
  return word << 32 - shift | word >>> shift;
}
var isLE2 = (() => new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68)();
var hasHexBuiltin3 = (
  // @ts-ignore
  typeof Uint8Array.from([]).toHex === "function" && typeof Uint8Array.fromHex === "function"
);
var hexes2 = Array.from({ length: 256 }, (_2, i2) => i2.toString(16).padStart(2, "0"));
function utf8ToBytes2(str) {
  if (typeof str !== "string")
    throw new Error("utf8ToBytes expected string, got " + typeof str);
  return new Uint8Array(new TextEncoder().encode(str));
}
function toBytes12(data) {
  if (typeof data === "string")
    data = utf8ToBytes2(data);
  abytes4(data);
  return data;
}
var Hash3 = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function checkOpts(defaults3, opts) {
  if (opts !== void 0 && {}.toString.call(opts) !== "[object Object]")
    throw new Error("Options should be object or undefined");
  const merged = Object.assign(defaults3, opts);
  return merged;
}
function wrapConstructor2(hashCons) {
  const hashC = (msg) => hashCons().update(toBytes12(msg)).digest();
  const tmp = hashCons();
  hashC.outputLen = tmp.outputLen;
  hashC.blockLen = tmp.blockLen;
  hashC.create = () => hashCons();
  return hashC;
}
function randomBytes2(bytesLength = 32) {
  if (crypto3 && typeof crypto3.getRandomValues === "function") {
    return crypto3.getRandomValues(new Uint8Array(bytesLength));
  }
  if (crypto3 && typeof crypto3.randomBytes === "function") {
    return Uint8Array.from(crypto3.randomBytes(bytesLength));
  }
  throw new Error("crypto.getRandomValues must be defined");
}

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/hmac.js
var HMAC2 = class extends Hash3 {
  constructor(hash8, _key) {
    super();
    this.finished = false;
    this.destroyed = false;
    ahash2(hash8);
    const key = toBytes12(_key);
    this.iHash = hash8.create();
    if (typeof this.iHash.update !== "function")
      throw new Error("Expected instance of class which extends utils.Hash");
    this.blockLen = this.iHash.blockLen;
    this.outputLen = this.iHash.outputLen;
    const blockLen = this.blockLen;
    const pad2 = new Uint8Array(blockLen);
    pad2.set(key.length > blockLen ? hash8.create().update(key).digest() : key);
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54;
    this.iHash.update(pad2);
    this.oHash = hash8.create();
    for (let i2 = 0; i2 < pad2.length; i2++)
      pad2[i2] ^= 54 ^ 92;
    this.oHash.update(pad2);
    pad2.fill(0);
  }
  update(buf) {
    aexists3(this);
    this.iHash.update(buf);
    return this;
  }
  digestInto(out) {
    aexists3(this);
    abytes4(out, this.outputLen);
    this.finished = true;
    this.iHash.digestInto(out);
    this.oHash.update(out);
    this.oHash.digestInto(out);
    this.destroy();
  }
  digest() {
    const out = new Uint8Array(this.oHash.outputLen);
    this.digestInto(out);
    return out;
  }
  _cloneInto(to4) {
    to4 || (to4 = Object.create(Object.getPrototypeOf(this), {}));
    const { oHash, iHash, finished, destroyed, blockLen, outputLen } = this;
    to4 = to4;
    to4.finished = finished;
    to4.destroyed = destroyed;
    to4.blockLen = blockLen;
    to4.outputLen = outputLen;
    to4.oHash = oHash._cloneInto(to4.oHash);
    to4.iHash = iHash._cloneInto(to4.iHash);
    return to4;
  }
  destroy() {
    this.destroyed = true;
    this.oHash.destroy();
    this.iHash.destroy();
  }
};
var hmac2 = (hash8, key, message) => new HMAC2(hash8, key).update(message).digest();
hmac2.create = (hash8, key) => new HMAC2(hash8, key);

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/pbkdf2.js
function pbkdf2Init(hash8, _password, _salt, _opts) {
  ahash2(hash8);
  const opts = checkOpts({ dkLen: 32, asyncTick: 10 }, _opts);
  const { c: c3, dkLen, asyncTick } = opts;
  anumber4(c3);
  anumber4(dkLen);
  anumber4(asyncTick);
  if (c3 < 1)
    throw new Error("PBKDF2: iterations (c) should be >= 1");
  const password = toBytes12(_password);
  const salt = toBytes12(_salt);
  const DK = new Uint8Array(dkLen);
  const PRF = hmac2.create(hash8, password);
  const PRFSalt = PRF._cloneInto().update(salt);
  return { c: c3, dkLen, asyncTick, DK, PRF, PRFSalt };
}
function pbkdf2Output(PRF, PRFSalt, DK, prfW, u3) {
  PRF.destroy();
  PRFSalt.destroy();
  if (prfW)
    prfW.destroy();
  u3.fill(0);
  return DK;
}
function pbkdf2(hash8, password, salt, opts) {
  const { c: c3, dkLen, DK, PRF, PRFSalt } = pbkdf2Init(hash8, password, salt, opts);
  let prfW;
  const arr = new Uint8Array(4);
  const view = createView2(arr);
  const u3 = new Uint8Array(PRF.outputLen);
  for (let ti2 = 1, pos = 0; pos < dkLen; ti2++, pos += PRF.outputLen) {
    const Ti2 = DK.subarray(pos, pos + PRF.outputLen);
    view.setInt32(0, ti2, false);
    (prfW = PRFSalt._cloneInto(prfW)).update(arr).digestInto(u3);
    Ti2.set(u3.subarray(0, Ti2.length));
    for (let ui = 1; ui < c3; ui++) {
      PRF._cloneInto(prfW).update(u3).digestInto(u3);
      for (let i2 = 0; i2 < Ti2.length; i2++)
        Ti2[i2] ^= u3[i2];
    }
  }
  return pbkdf2Output(PRF, PRFSalt, DK, prfW, u3);
}

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_md.js
function setBigUint642(view, byteOffset, value, isLE3) {
  if (typeof view.setBigUint64 === "function")
    return view.setBigUint64(byteOffset, value, isLE3);
  const _32n3 = BigInt(32);
  const _u32_max = BigInt(4294967295);
  const wh = Number(value >> _32n3 & _u32_max);
  const wl2 = Number(value & _u32_max);
  const h = isLE3 ? 4 : 0;
  const l3 = isLE3 ? 0 : 4;
  view.setUint32(byteOffset + h, wh, isLE3);
  view.setUint32(byteOffset + l3, wl2, isLE3);
}
function Chi2(a3, b4, c3) {
  return a3 & b4 ^ ~a3 & c3;
}
function Maj2(a3, b4, c3) {
  return a3 & b4 ^ a3 & c3 ^ b4 & c3;
}
var HashMD2 = class extends Hash3 {
  constructor(blockLen, outputLen, padOffset, isLE3) {
    super();
    this.finished = false;
    this.length = 0;
    this.pos = 0;
    this.destroyed = false;
    this.blockLen = blockLen;
    this.outputLen = outputLen;
    this.padOffset = padOffset;
    this.isLE = isLE3;
    this.buffer = new Uint8Array(blockLen);
    this.view = createView2(this.buffer);
  }
  update(data) {
    aexists3(this);
    const { view, buffer: buffer3, blockLen } = this;
    data = toBytes12(data);
    const len = data.length;
    for (let pos = 0; pos < len; ) {
      const take = Math.min(blockLen - this.pos, len - pos);
      if (take === blockLen) {
        const dataView = createView2(data);
        for (; blockLen <= len - pos; pos += blockLen)
          this.process(dataView, pos);
        continue;
      }
      buffer3.set(data.subarray(pos, pos + take), this.pos);
      this.pos += take;
      pos += take;
      if (this.pos === blockLen) {
        this.process(view, 0);
        this.pos = 0;
      }
    }
    this.length += data.length;
    this.roundClean();
    return this;
  }
  digestInto(out) {
    aexists3(this);
    aoutput3(out, this);
    this.finished = true;
    const { buffer: buffer3, view, blockLen, isLE: isLE3 } = this;
    let { pos } = this;
    buffer3[pos++] = 128;
    this.buffer.subarray(pos).fill(0);
    if (this.padOffset > blockLen - pos) {
      this.process(view, 0);
      pos = 0;
    }
    for (let i2 = pos; i2 < blockLen; i2++)
      buffer3[i2] = 0;
    setBigUint642(view, blockLen - 8, BigInt(this.length * 8), isLE3);
    this.process(view, 0);
    const oview = createView2(out);
    const len = this.outputLen;
    if (len % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const outLen = len / 4;
    const state = this.get();
    if (outLen > state.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let i2 = 0; i2 < outLen; i2++)
      oview.setUint32(4 * i2, state[i2], isLE3);
  }
  digest() {
    const { buffer: buffer3, outputLen } = this;
    this.digestInto(buffer3);
    const res = buffer3.slice(0, outputLen);
    this.destroy();
    return res;
  }
  _cloneInto(to4) {
    to4 || (to4 = new this.constructor());
    to4.set(...this.get());
    const { blockLen, buffer: buffer3, length: length2, finished, destroyed, pos } = this;
    to4.length = length2;
    to4.pos = pos;
    to4.finished = finished;
    to4.destroyed = destroyed;
    if (length2 % blockLen)
      to4.buffer.set(buffer3);
    return to4;
  }
};

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha256.js
var SHA256_K2 = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var SHA256_IV3 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var SHA256_W2 = new Uint32Array(64);
var SHA2562 = class extends HashMD2 {
  constructor(outputLen = 32) {
    super(64, outputLen, 8, false);
    this.A = SHA256_IV3[0] | 0;
    this.B = SHA256_IV3[1] | 0;
    this.C = SHA256_IV3[2] | 0;
    this.D = SHA256_IV3[3] | 0;
    this.E = SHA256_IV3[4] | 0;
    this.F = SHA256_IV3[5] | 0;
    this.G = SHA256_IV3[6] | 0;
    this.H = SHA256_IV3[7] | 0;
  }
  get() {
    const { A, B: B2, C: C2, D: D3, E: E3, F: F2, G: G2, H: H3 } = this;
    return [A, B2, C2, D3, E3, F2, G2, H3];
  }
  // prettier-ignore
  set(A, B2, C2, D3, E3, F2, G2, H3) {
    this.A = A | 0;
    this.B = B2 | 0;
    this.C = C2 | 0;
    this.D = D3 | 0;
    this.E = E3 | 0;
    this.F = F2 | 0;
    this.G = G2 | 0;
    this.H = H3 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4)
      SHA256_W2[i2] = view.getUint32(offset, false);
    for (let i2 = 16; i2 < 64; i2++) {
      const W15 = SHA256_W2[i2 - 15];
      const W22 = SHA256_W2[i2 - 2];
      const s0 = rotr3(W15, 7) ^ rotr3(W15, 18) ^ W15 >>> 3;
      const s1 = rotr3(W22, 17) ^ rotr3(W22, 19) ^ W22 >>> 10;
      SHA256_W2[i2] = s1 + SHA256_W2[i2 - 7] + s0 + SHA256_W2[i2 - 16] | 0;
    }
    let { A, B: B2, C: C2, D: D3, E: E3, F: F2, G: G2, H: H3 } = this;
    for (let i2 = 0; i2 < 64; i2++) {
      const sigma1 = rotr3(E3, 6) ^ rotr3(E3, 11) ^ rotr3(E3, 25);
      const T12 = H3 + sigma1 + Chi2(E3, F2, G2) + SHA256_K2[i2] + SHA256_W2[i2] | 0;
      const sigma0 = rotr3(A, 2) ^ rotr3(A, 13) ^ rotr3(A, 22);
      const T22 = sigma0 + Maj2(A, B2, C2) | 0;
      H3 = G2;
      G2 = F2;
      F2 = E3;
      E3 = D3 + T12 | 0;
      D3 = C2;
      C2 = B2;
      B2 = A;
      A = T12 + T22 | 0;
    }
    A = A + this.A | 0;
    B2 = B2 + this.B | 0;
    C2 = C2 + this.C | 0;
    D3 = D3 + this.D | 0;
    E3 = E3 + this.E | 0;
    F2 = F2 + this.F | 0;
    G2 = G2 + this.G | 0;
    H3 = H3 + this.H | 0;
    this.set(A, B2, C2, D3, E3, F2, G2, H3);
  }
  roundClean() {
    SHA256_W2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0);
    this.buffer.fill(0);
  }
};
var SHA2242 = class extends SHA2562 {
  constructor() {
    super(28);
    this.A = 3238371032 | 0;
    this.B = 914150663 | 0;
    this.C = 812702999 | 0;
    this.D = 4144912697 | 0;
    this.E = 4290775857 | 0;
    this.F = 1750603025 | 0;
    this.G = 1694076839 | 0;
    this.H = 3204075428 | 0;
  }
};
var sha2565 = wrapConstructor2(() => new SHA2562());
var sha2242 = wrapConstructor2(() => new SHA2242());

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/_u64.js
var U32_MASK642 = BigInt(2 ** 32 - 1);
var _32n2 = BigInt(32);
function fromBig3(n2, le2 = false) {
  if (le2)
    return { h: Number(n2 & U32_MASK642), l: Number(n2 >> _32n2 & U32_MASK642) };
  return { h: Number(n2 >> _32n2 & U32_MASK642) | 0, l: Number(n2 & U32_MASK642) | 0 };
}
function split3(lst, le2 = false) {
  let Ah = new Uint32Array(lst.length);
  let Al2 = new Uint32Array(lst.length);
  for (let i2 = 0; i2 < lst.length; i2++) {
    const { h, l: l3 } = fromBig3(lst[i2], le2);
    [Ah[i2], Al2[i2]] = [h, l3];
  }
  return [Ah, Al2];
}
var toBig2 = (h, l3) => BigInt(h >>> 0) << _32n2 | BigInt(l3 >>> 0);
var shrSH2 = (h, _l2, s2) => h >>> s2;
var shrSL2 = (h, l3, s2) => h << 32 - s2 | l3 >>> s2;
var rotrSH3 = (h, l3, s2) => h >>> s2 | l3 << 32 - s2;
var rotrSL3 = (h, l3, s2) => h << 32 - s2 | l3 >>> s2;
var rotrBH3 = (h, l3, s2) => h << 64 - s2 | l3 >>> s2 - 32;
var rotrBL3 = (h, l3, s2) => h >>> s2 - 32 | l3 << 64 - s2;
var rotr32H3 = (_h, l3) => l3;
var rotr32L3 = (h, _l2) => h;
var rotlSH2 = (h, l3, s2) => h << s2 | l3 >>> 32 - s2;
var rotlSL2 = (h, l3, s2) => l3 << s2 | h >>> 32 - s2;
var rotlBH2 = (h, l3, s2) => l3 << s2 - 32 | h >>> 64 - s2;
var rotlBL2 = (h, l3, s2) => h << s2 - 32 | l3 >>> 64 - s2;
function add3(Ah, Al2, Bh, Bl2) {
  const l3 = (Al2 >>> 0) + (Bl2 >>> 0);
  return { h: Ah + Bh + (l3 / 2 ** 32 | 0) | 0, l: l3 | 0 };
}
var add3L3 = (Al2, Bl2, Cl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0);
var add3H3 = (low, Ah, Bh, Ch) => Ah + Bh + Ch + (low / 2 ** 32 | 0) | 0;
var add4L2 = (Al2, Bl2, Cl2, Dl2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0);
var add4H2 = (low, Ah, Bh, Ch, Dh) => Ah + Bh + Ch + Dh + (low / 2 ** 32 | 0) | 0;
var add5L2 = (Al2, Bl2, Cl2, Dl2, El2) => (Al2 >>> 0) + (Bl2 >>> 0) + (Cl2 >>> 0) + (Dl2 >>> 0) + (El2 >>> 0);
var add5H2 = (low, Ah, Bh, Ch, Dh, Eh) => Ah + Bh + Ch + Dh + Eh + (low / 2 ** 32 | 0) | 0;
var u642 = {
  fromBig: fromBig3,
  split: split3,
  toBig: toBig2,
  shrSH: shrSH2,
  shrSL: shrSL2,
  rotrSH: rotrSH3,
  rotrSL: rotrSL3,
  rotrBH: rotrBH3,
  rotrBL: rotrBL3,
  rotr32H: rotr32H3,
  rotr32L: rotr32L3,
  rotlSH: rotlSH2,
  rotlSL: rotlSL2,
  rotlBH: rotlBH2,
  rotlBL: rotlBL2,
  add: add3,
  add3L: add3L3,
  add3H: add3H3,
  add4L: add4L2,
  add4H: add4H2,
  add5H: add5H2,
  add5L: add5L2
};
var u64_default2 = u642;

// node_modules/@scure/bip39/node_modules/@noble/hashes/esm/sha512.js
var [SHA512_Kh2, SHA512_Kl2] = (() => u64_default2.split([
  "0x428a2f98d728ae22",
  "0x7137449123ef65cd",
  "0xb5c0fbcfec4d3b2f",
  "0xe9b5dba58189dbbc",
  "0x3956c25bf348b538",
  "0x59f111f1b605d019",
  "0x923f82a4af194f9b",
  "0xab1c5ed5da6d8118",
  "0xd807aa98a3030242",
  "0x12835b0145706fbe",
  "0x243185be4ee4b28c",
  "0x550c7dc3d5ffb4e2",
  "0x72be5d74f27b896f",
  "0x80deb1fe3b1696b1",
  "0x9bdc06a725c71235",
  "0xc19bf174cf692694",
  "0xe49b69c19ef14ad2",
  "0xefbe4786384f25e3",
  "0x0fc19dc68b8cd5b5",
  "0x240ca1cc77ac9c65",
  "0x2de92c6f592b0275",
  "0x4a7484aa6ea6e483",
  "0x5cb0a9dcbd41fbd4",
  "0x76f988da831153b5",
  "0x983e5152ee66dfab",
  "0xa831c66d2db43210",
  "0xb00327c898fb213f",
  "0xbf597fc7beef0ee4",
  "0xc6e00bf33da88fc2",
  "0xd5a79147930aa725",
  "0x06ca6351e003826f",
  "0x142929670a0e6e70",
  "0x27b70a8546d22ffc",
  "0x2e1b21385c26c926",
  "0x4d2c6dfc5ac42aed",
  "0x53380d139d95b3df",
  "0x650a73548baf63de",
  "0x766a0abb3c77b2a8",
  "0x81c2c92e47edaee6",
  "0x92722c851482353b",
  "0xa2bfe8a14cf10364",
  "0xa81a664bbc423001",
  "0xc24b8b70d0f89791",
  "0xc76c51a30654be30",
  "0xd192e819d6ef5218",
  "0xd69906245565a910",
  "0xf40e35855771202a",
  "0x106aa07032bbd1b8",
  "0x19a4c116b8d2d0c8",
  "0x1e376c085141ab53",
  "0x2748774cdf8eeb99",
  "0x34b0bcb5e19b48a8",
  "0x391c0cb3c5c95a63",
  "0x4ed8aa4ae3418acb",
  "0x5b9cca4f7763e373",
  "0x682e6ff3d6b2b8a3",
  "0x748f82ee5defb2fc",
  "0x78a5636f43172f60",
  "0x84c87814a1f0ab72",
  "0x8cc702081a6439ec",
  "0x90befffa23631e28",
  "0xa4506cebde82bde9",
  "0xbef9a3f7b2c67915",
  "0xc67178f2e372532b",
  "0xca273eceea26619c",
  "0xd186b8c721c0c207",
  "0xeada7dd6cde0eb1e",
  "0xf57d4f7fee6ed178",
  "0x06f067aa72176fba",
  "0x0a637dc5a2c898a6",
  "0x113f9804bef90dae",
  "0x1b710b35131c471b",
  "0x28db77f523047d84",
  "0x32caab7b40c72493",
  "0x3c9ebe0a15c9bebc",
  "0x431d67c49c100d4c",
  "0x4cc5d4becb3e42b6",
  "0x597f299cfc657e2a",
  "0x5fcb6fab3ad6faec",
  "0x6c44198c4a475817"
].map((n2) => BigInt(n2))))();
var SHA512_W_H2 = new Uint32Array(80);
var SHA512_W_L2 = new Uint32Array(80);
var SHA5122 = class extends HashMD2 {
  constructor(outputLen = 64) {
    super(128, outputLen, 16, false);
    this.Ah = 1779033703 | 0;
    this.Al = 4089235720 | 0;
    this.Bh = 3144134277 | 0;
    this.Bl = 2227873595 | 0;
    this.Ch = 1013904242 | 0;
    this.Cl = 4271175723 | 0;
    this.Dh = 2773480762 | 0;
    this.Dl = 1595750129 | 0;
    this.Eh = 1359893119 | 0;
    this.El = 2917565137 | 0;
    this.Fh = 2600822924 | 0;
    this.Fl = 725511199 | 0;
    this.Gh = 528734635 | 0;
    this.Gl = 4215389547 | 0;
    this.Hh = 1541459225 | 0;
    this.Hl = 327033209 | 0;
  }
  // prettier-ignore
  get() {
    const { Ah, Al: Al2, Bh, Bl: Bl2, Ch, Cl: Cl2, Dh, Dl: Dl2, Eh, El: El2, Fh, Fl: Fl2, Gh, Gl: Gl2, Hh, Hl: Hl2 } = this;
    return [Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2];
  }
  // prettier-ignore
  set(Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2) {
    this.Ah = Ah | 0;
    this.Al = Al2 | 0;
    this.Bh = Bh | 0;
    this.Bl = Bl2 | 0;
    this.Ch = Ch | 0;
    this.Cl = Cl2 | 0;
    this.Dh = Dh | 0;
    this.Dl = Dl2 | 0;
    this.Eh = Eh | 0;
    this.El = El2 | 0;
    this.Fh = Fh | 0;
    this.Fl = Fl2 | 0;
    this.Gh = Gh | 0;
    this.Gl = Gl2 | 0;
    this.Hh = Hh | 0;
    this.Hl = Hl2 | 0;
  }
  process(view, offset) {
    for (let i2 = 0; i2 < 16; i2++, offset += 4) {
      SHA512_W_H2[i2] = view.getUint32(offset);
      SHA512_W_L2[i2] = view.getUint32(offset += 4);
    }
    for (let i2 = 16; i2 < 80; i2++) {
      const W15h = SHA512_W_H2[i2 - 15] | 0;
      const W15l = SHA512_W_L2[i2 - 15] | 0;
      const s0h = u64_default2.rotrSH(W15h, W15l, 1) ^ u64_default2.rotrSH(W15h, W15l, 8) ^ u64_default2.shrSH(W15h, W15l, 7);
      const s0l = u64_default2.rotrSL(W15h, W15l, 1) ^ u64_default2.rotrSL(W15h, W15l, 8) ^ u64_default2.shrSL(W15h, W15l, 7);
      const W2h = SHA512_W_H2[i2 - 2] | 0;
      const W2l = SHA512_W_L2[i2 - 2] | 0;
      const s1h = u64_default2.rotrSH(W2h, W2l, 19) ^ u64_default2.rotrBH(W2h, W2l, 61) ^ u64_default2.shrSH(W2h, W2l, 6);
      const s1l = u64_default2.rotrSL(W2h, W2l, 19) ^ u64_default2.rotrBL(W2h, W2l, 61) ^ u64_default2.shrSL(W2h, W2l, 6);
      const SUMl = u64_default2.add4L(s0l, s1l, SHA512_W_L2[i2 - 7], SHA512_W_L2[i2 - 16]);
      const SUMh = u64_default2.add4H(SUMl, s0h, s1h, SHA512_W_H2[i2 - 7], SHA512_W_H2[i2 - 16]);
      SHA512_W_H2[i2] = SUMh | 0;
      SHA512_W_L2[i2] = SUMl | 0;
    }
    let { Ah, Al: Al2, Bh, Bl: Bl2, Ch, Cl: Cl2, Dh, Dl: Dl2, Eh, El: El2, Fh, Fl: Fl2, Gh, Gl: Gl2, Hh, Hl: Hl2 } = this;
    for (let i2 = 0; i2 < 80; i2++) {
      const sigma1h = u64_default2.rotrSH(Eh, El2, 14) ^ u64_default2.rotrSH(Eh, El2, 18) ^ u64_default2.rotrBH(Eh, El2, 41);
      const sigma1l = u64_default2.rotrSL(Eh, El2, 14) ^ u64_default2.rotrSL(Eh, El2, 18) ^ u64_default2.rotrBL(Eh, El2, 41);
      const CHIh = Eh & Fh ^ ~Eh & Gh;
      const CHIl = El2 & Fl2 ^ ~El2 & Gl2;
      const T1ll = u64_default2.add5L(Hl2, sigma1l, CHIl, SHA512_Kl2[i2], SHA512_W_L2[i2]);
      const T1h = u64_default2.add5H(T1ll, Hh, sigma1h, CHIh, SHA512_Kh2[i2], SHA512_W_H2[i2]);
      const T1l = T1ll | 0;
      const sigma0h = u64_default2.rotrSH(Ah, Al2, 28) ^ u64_default2.rotrBH(Ah, Al2, 34) ^ u64_default2.rotrBH(Ah, Al2, 39);
      const sigma0l = u64_default2.rotrSL(Ah, Al2, 28) ^ u64_default2.rotrBL(Ah, Al2, 34) ^ u64_default2.rotrBL(Ah, Al2, 39);
      const MAJh = Ah & Bh ^ Ah & Ch ^ Bh & Ch;
      const MAJl = Al2 & Bl2 ^ Al2 & Cl2 ^ Bl2 & Cl2;
      Hh = Gh | 0;
      Hl2 = Gl2 | 0;
      Gh = Fh | 0;
      Gl2 = Fl2 | 0;
      Fh = Eh | 0;
      Fl2 = El2 | 0;
      ({ h: Eh, l: El2 } = u64_default2.add(Dh | 0, Dl2 | 0, T1h | 0, T1l | 0));
      Dh = Ch | 0;
      Dl2 = Cl2 | 0;
      Ch = Bh | 0;
      Cl2 = Bl2 | 0;
      Bh = Ah | 0;
      Bl2 = Al2 | 0;
      const All = u64_default2.add3L(T1l, sigma0l, MAJl);
      Ah = u64_default2.add3H(All, T1h, sigma0h, MAJh);
      Al2 = All | 0;
    }
    ({ h: Ah, l: Al2 } = u64_default2.add(this.Ah | 0, this.Al | 0, Ah | 0, Al2 | 0));
    ({ h: Bh, l: Bl2 } = u64_default2.add(this.Bh | 0, this.Bl | 0, Bh | 0, Bl2 | 0));
    ({ h: Ch, l: Cl2 } = u64_default2.add(this.Ch | 0, this.Cl | 0, Ch | 0, Cl2 | 0));
    ({ h: Dh, l: Dl2 } = u64_default2.add(this.Dh | 0, this.Dl | 0, Dh | 0, Dl2 | 0));
    ({ h: Eh, l: El2 } = u64_default2.add(this.Eh | 0, this.El | 0, Eh | 0, El2 | 0));
    ({ h: Fh, l: Fl2 } = u64_default2.add(this.Fh | 0, this.Fl | 0, Fh | 0, Fl2 | 0));
    ({ h: Gh, l: Gl2 } = u64_default2.add(this.Gh | 0, this.Gl | 0, Gh | 0, Gl2 | 0));
    ({ h: Hh, l: Hl2 } = u64_default2.add(this.Hh | 0, this.Hl | 0, Hh | 0, Hl2 | 0));
    this.set(Ah, Al2, Bh, Bl2, Ch, Cl2, Dh, Dl2, Eh, El2, Fh, Fl2, Gh, Gl2, Hh, Hl2);
  }
  roundClean() {
    SHA512_W_H2.fill(0);
    SHA512_W_L2.fill(0);
  }
  destroy() {
    this.buffer.fill(0);
    this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
  }
};
var SHA512_2242 = class extends SHA5122 {
  constructor() {
    super(28);
    this.Ah = 2352822216 | 0;
    this.Al = 424955298 | 0;
    this.Bh = 1944164710 | 0;
    this.Bl = 2312950998 | 0;
    this.Ch = 502970286 | 0;
    this.Cl = 855612546 | 0;
    this.Dh = 1738396948 | 0;
    this.Dl = 1479516111 | 0;
    this.Eh = 258812777 | 0;
    this.El = 2077511080 | 0;
    this.Fh = 2011393907 | 0;
    this.Fl = 79989058 | 0;
    this.Gh = 1067287976 | 0;
    this.Gl = 1780299464 | 0;
    this.Hh = 286451373 | 0;
    this.Hl = 2446758561 | 0;
  }
};
var SHA512_2562 = class extends SHA5122 {
  constructor() {
    super(32);
    this.Ah = 573645204 | 0;
    this.Al = 4230739756 | 0;
    this.Bh = 2673172387 | 0;
    this.Bl = 3360449730 | 0;
    this.Ch = 596883563 | 0;
    this.Cl = 1867755857 | 0;
    this.Dh = 2520282905 | 0;
    this.Dl = 1497426621 | 0;
    this.Eh = 2519219938 | 0;
    this.El = 2827943907 | 0;
    this.Fh = 3193839141 | 0;
    this.Fl = 1401305490 | 0;
    this.Gh = 721525244 | 0;
    this.Gl = 746961066 | 0;
    this.Hh = 246885852 | 0;
    this.Hl = 2177182882 | 0;
  }
};
var SHA3842 = class extends SHA5122 {
  constructor() {
    super(48);
    this.Ah = 3418070365 | 0;
    this.Al = 3238371032 | 0;
    this.Bh = 1654270250 | 0;
    this.Bl = 914150663 | 0;
    this.Ch = 2438529370 | 0;
    this.Cl = 812702999 | 0;
    this.Dh = 355462360 | 0;
    this.Dl = 4144912697 | 0;
    this.Eh = 1731405415 | 0;
    this.El = 4290775857 | 0;
    this.Fh = 2394180231 | 0;
    this.Fl = 1750603025 | 0;
    this.Gh = 3675008525 | 0;
    this.Gl = 1694076839 | 0;
    this.Hh = 1203062813 | 0;
    this.Hl = 3204075428 | 0;
  }
};
var sha5122 = wrapConstructor2(() => new SHA5122());
var sha512_2242 = wrapConstructor2(() => new SHA512_2242());
var sha512_2562 = wrapConstructor2(() => new SHA512_2562());
var sha3842 = wrapConstructor2(() => new SHA3842());

// node_modules/@scure/bip39/esm/index.js
var isJapanese = (wordlist11) => wordlist11[0] === "";
function nfkd(str) {
  if (typeof str !== "string")
    throw new TypeError("invalid mnemonic type: " + typeof str);
  return str.normalize("NFKD");
}
function normalize2(str) {
  const norm = nfkd(str);
  const words = norm.split(" ");
  if (![12, 15, 18, 21, 24].includes(words.length))
    throw new Error("Invalid mnemonic");
  return { nfkd: norm, words };
}
function aentropy(ent) {
  abytes4(ent, 16, 20, 24, 28, 32);
}
function generateMnemonic(wordlist11, strength = 128) {
  anumber4(strength);
  if (strength % 32 !== 0 || strength > 256)
    throw new TypeError("Invalid entropy");
  return entropyToMnemonic(randomBytes2(strength / 8), wordlist11);
}
var calcChecksum = (entropy) => {
  const bitsLeft = 8 - entropy.length / 4;
  return new Uint8Array([sha2565(entropy)[0] >> bitsLeft << bitsLeft]);
};
function getCoder(wordlist11) {
  if (!Array.isArray(wordlist11) || wordlist11.length !== 2048 || typeof wordlist11[0] !== "string")
    throw new Error("Wordlist: expected array of 2048 strings");
  wordlist11.forEach((i2) => {
    if (typeof i2 !== "string")
      throw new Error("wordlist: non-string element: " + i2);
  });
  return utils.chain(utils.checksum(1, calcChecksum), utils.radix2(11, true), utils.alphabet(wordlist11));
}
function mnemonicToEntropy(mnemonic, wordlist11) {
  const { words } = normalize2(mnemonic);
  const entropy = getCoder(wordlist11).decode(words);
  aentropy(entropy);
  return entropy;
}
function entropyToMnemonic(entropy, wordlist11) {
  aentropy(entropy);
  const words = getCoder(wordlist11).encode(entropy);
  return words.join(isJapanese(wordlist11) ? "" : " ");
}
function validateMnemonic(mnemonic, wordlist11) {
  try {
    mnemonicToEntropy(mnemonic, wordlist11);
  } catch (e2) {
    return false;
  }
  return true;
}
var psalt = (passphrase) => nfkd("mnemonic" + passphrase);
function mnemonicToSeedSync(mnemonic, passphrase = "") {
  return pbkdf2(sha5122, normalize2(mnemonic).nfkd, psalt(passphrase), { c: 2048, dkLen: 64 });
}

// node_modules/@scure/bip39/esm/wordlists/czech.js
var wordlist = `abdikace
abeceda
adresa
agrese
akce
aktovka
alej
alkohol
amputace
ananas
andulka
anekdota
anketa
antika
anulovat
archa
arogance
asfalt
asistent
aspirace
astma
astronom
atlas
atletika
atol
autobus
azyl
babka
bachor
bacil
baculka
badatel
bageta
bagr
bahno
bakterie
balada
baletka
balkon
balonek
balvan
balza
bambus
bankomat
barbar
baret
barman
baroko
barva
baterka
batoh
bavlna
bazalka
bazilika
bazuka
bedna
beran
beseda
bestie
beton
bezinka
bezmoc
beztak
bicykl
bidlo
biftek
bikiny
bilance
biograf
biolog
bitva
bizon
blahobyt
blatouch
blecha
bledule
blesk
blikat
blizna
blokovat
bloudit
blud
bobek
bobr
bodlina
bodnout
bohatost
bojkot
bojovat
bokorys
bolest
borec
borovice
bota
boubel
bouchat
bouda
boule
bourat
boxer
bradavka
brambora
branka
bratr
brepta
briketa
brko
brloh
bronz
broskev
brunetka
brusinka
brzda
brzy
bublina
bubnovat
buchta
buditel
budka
budova
bufet
bujarost
bukvice
buldok
bulva
bunda
bunkr
burza
butik
buvol
buzola
bydlet
bylina
bytovka
bzukot
capart
carevna
cedr
cedule
cejch
cejn
cela
celer
celkem
celnice
cenina
cennost
cenovka
centrum
cenzor
cestopis
cetka
chalupa
chapadlo
charita
chata
chechtat
chemie
chichot
chirurg
chlad
chleba
chlubit
chmel
chmura
chobot
chochol
chodba
cholera
chomout
chopit
choroba
chov
chrapot
chrlit
chrt
chrup
chtivost
chudina
chutnat
chvat
chvilka
chvost
chyba
chystat
chytit
cibule
cigareta
cihelna
cihla
cinkot
cirkus
cisterna
citace
citrus
cizinec
cizost
clona
cokoliv
couvat
ctitel
ctnost
cudnost
cuketa
cukr
cupot
cvaknout
cval
cvik
cvrkot
cyklista
daleko
dareba
datel
datum
dcera
debata
dechovka
decibel
deficit
deflace
dekl
dekret
demokrat
deprese
derby
deska
detektiv
dikobraz
diktovat
dioda
diplom
disk
displej
divadlo
divoch
dlaha
dlouho
dluhopis
dnes
dobro
dobytek
docent
dochutit
dodnes
dohled
dohoda
dohra
dojem
dojnice
doklad
dokola
doktor
dokument
dolar
doleva
dolina
doma
dominant
domluvit
domov
donutit
dopad
dopis
doplnit
doposud
doprovod
dopustit
dorazit
dorost
dort
dosah
doslov
dostatek
dosud
dosyta
dotaz
dotek
dotknout
doufat
doutnat
dovozce
dozadu
doznat
dozorce
drahota
drak
dramatik
dravec
draze
drdol
drobnost
drogerie
drozd
drsnost
drtit
drzost
duben
duchovno
dudek
duha
duhovka
dusit
dusno
dutost
dvojice
dvorec
dynamit
ekolog
ekonomie
elektron
elipsa
email
emise
emoce
empatie
epizoda
epocha
epopej
epos
esej
esence
eskorta
eskymo
etiketa
euforie
evoluce
exekuce
exkurze
expedice
exploze
export
extrakt
facka
fajfka
fakulta
fanatik
fantazie
farmacie
favorit
fazole
federace
fejeton
fenka
fialka
figurant
filozof
filtr
finance
finta
fixace
fjord
flanel
flirt
flotila
fond
fosfor
fotbal
fotka
foton
frakce
freska
fronta
fukar
funkce
fyzika
galeje
garant
genetika
geolog
gilotina
glazura
glejt
golem
golfista
gotika
graf
gramofon
granule
grep
gril
grog
groteska
guma
hadice
hadr
hala
halenka
hanba
hanopis
harfa
harpuna
havran
hebkost
hejkal
hejno
hejtman
hektar
helma
hematom
herec
herna
heslo
hezky
historik
hladovka
hlasivky
hlava
hledat
hlen
hlodavec
hloh
hloupost
hltat
hlubina
hluchota
hmat
hmota
hmyz
hnis
hnojivo
hnout
hoblina
hoboj
hoch
hodiny
hodlat
hodnota
hodovat
hojnost
hokej
holinka
holka
holub
homole
honitba
honorace
horal
horda
horizont
horko
horlivec
hormon
hornina
horoskop
horstvo
hospoda
hostina
hotovost
houba
houf
houpat
houska
hovor
hradba
hranice
hravost
hrazda
hrbolek
hrdina
hrdlo
hrdost
hrnek
hrobka
hromada
hrot
hrouda
hrozen
hrstka
hrubost
hryzat
hubenost
hubnout
hudba
hukot
humr
husita
hustota
hvozd
hybnost
hydrant
hygiena
hymna
hysterik
idylka
ihned
ikona
iluze
imunita
infekce
inflace
inkaso
inovace
inspekce
internet
invalida
investor
inzerce
ironie
jablko
jachta
jahoda
jakmile
jakost
jalovec
jantar
jarmark
jaro
jasan
jasno
jatka
javor
jazyk
jedinec
jedle
jednatel
jehlan
jekot
jelen
jelito
jemnost
jenom
jepice
jeseter
jevit
jezdec
jezero
jinak
jindy
jinoch
jiskra
jistota
jitrnice
jizva
jmenovat
jogurt
jurta
kabaret
kabel
kabinet
kachna
kadet
kadidlo
kahan
kajak
kajuta
kakao
kaktus
kalamita
kalhoty
kalibr
kalnost
kamera
kamkoliv
kamna
kanibal
kanoe
kantor
kapalina
kapela
kapitola
kapka
kaple
kapota
kapr
kapusta
kapybara
karamel
karotka
karton
kasa
katalog
katedra
kauce
kauza
kavalec
kazajka
kazeta
kazivost
kdekoliv
kdesi
kedluben
kemp
keramika
kino
klacek
kladivo
klam
klapot
klasika
klaun
klec
klenba
klepat
klesnout
klid
klima
klisna
klobouk
klokan
klopa
kloub
klubovna
klusat
kluzkost
kmen
kmitat
kmotr
kniha
knot
koalice
koberec
kobka
kobliha
kobyla
kocour
kohout
kojenec
kokos
koktejl
kolaps
koleda
kolize
kolo
komando
kometa
komik
komnata
komora
kompas
komunita
konat
koncept
kondice
konec
konfese
kongres
konina
konkurs
kontakt
konzerva
kopanec
kopie
kopnout
koprovka
korbel
korektor
kormidlo
koroptev
korpus
koruna
koryto
korzet
kosatec
kostka
kotel
kotleta
kotoul
koukat
koupelna
kousek
kouzlo
kovboj
koza
kozoroh
krabice
krach
krajina
kralovat
krasopis
kravata
kredit
krejcar
kresba
kreveta
kriket
kritik
krize
krkavec
krmelec
krmivo
krocan
krok
kronika
kropit
kroupa
krovka
krtek
kruhadlo
krupice
krutost
krvinka
krychle
krypta
krystal
kryt
kudlanka
kufr
kujnost
kukla
kulajda
kulich
kulka
kulomet
kultura
kuna
kupodivu
kurt
kurzor
kutil
kvalita
kvasinka
kvestor
kynolog
kyselina
kytara
kytice
kytka
kytovec
kyvadlo
labrador
lachtan
ladnost
laik
lakomec
lamela
lampa
lanovka
lasice
laso
lastura
latinka
lavina
lebka
leckdy
leden
lednice
ledovka
ledvina
legenda
legie
legrace
lehce
lehkost
lehnout
lektvar
lenochod
lentilka
lepenka
lepidlo
letadlo
letec
letmo
letokruh
levhart
levitace
levobok
libra
lichotka
lidojed
lidskost
lihovina
lijavec
lilek
limetka
linie
linka
linoleum
listopad
litina
litovat
lobista
lodivod
logika
logoped
lokalita
loket
lomcovat
lopata
lopuch
lord
losos
lotr
loudal
louh
louka
louskat
lovec
lstivost
lucerna
lucifer
lump
lusk
lustrace
lvice
lyra
lyrika
lysina
madam
madlo
magistr
mahagon
majetek
majitel
majorita
makak
makovice
makrela
malba
malina
malovat
malvice
maminka
mandle
manko
marnost
masakr
maskot
masopust
matice
matrika
maturita
mazanec
mazivo
mazlit
mazurka
mdloba
mechanik
meditace
medovina
melasa
meloun
mentolka
metla
metoda
metr
mezera
migrace
mihnout
mihule
mikina
mikrofon
milenec
milimetr
milost
mimika
mincovna
minibar
minomet
minulost
miska
mistr
mixovat
mladost
mlha
mlhovina
mlok
mlsat
mluvit
mnich
mnohem
mobil
mocnost
modelka
modlitba
mohyla
mokro
molekula
momentka
monarcha
monokl
monstrum
montovat
monzun
mosaz
moskyt
most
motivace
motorka
motyka
moucha
moudrost
mozaika
mozek
mozol
mramor
mravenec
mrkev
mrtvola
mrzet
mrzutost
mstitel
mudrc
muflon
mulat
mumie
munice
muset
mutace
muzeum
muzikant
myslivec
mzda
nabourat
nachytat
nadace
nadbytek
nadhoz
nadobro
nadpis
nahlas
nahnat
nahodile
nahradit
naivita
najednou
najisto
najmout
naklonit
nakonec
nakrmit
nalevo
namazat
namluvit
nanometr
naoko
naopak
naostro
napadat
napevno
naplnit
napnout
naposled
naprosto
narodit
naruby
narychlo
nasadit
nasekat
naslepo
nastat
natolik
navenek
navrch
navzdory
nazvat
nebe
nechat
necky
nedaleko
nedbat
neduh
negace
nehet
nehoda
nejen
nejprve
neklid
nelibost
nemilost
nemoc
neochota
neonka
nepokoj
nerost
nerv
nesmysl
nesoulad
netvor
neuron
nevina
nezvykle
nicota
nijak
nikam
nikdy
nikl
nikterak
nitro
nocleh
nohavice
nominace
nora
norek
nositel
nosnost
nouze
noviny
novota
nozdra
nuda
nudle
nuget
nutit
nutnost
nutrie
nymfa
obal
obarvit
obava
obdiv
obec
obehnat
obejmout
obezita
obhajoba
obilnice
objasnit
objekt
obklopit
oblast
oblek
obliba
obloha
obluda
obnos
obohatit
obojek
obout
obrazec
obrna
obruba
obrys
obsah
obsluha
obstarat
obuv
obvaz
obvinit
obvod
obvykle
obyvatel
obzor
ocas
ocel
ocenit
ochladit
ochota
ochrana
ocitnout
odboj
odbyt
odchod
odcizit
odebrat
odeslat
odevzdat
odezva
odhadce
odhodit
odjet
odjinud
odkaz
odkoupit
odliv
odluka
odmlka
odolnost
odpad
odpis
odplout
odpor
odpustit
odpykat
odrazka
odsoudit
odstup
odsun
odtok
odtud
odvaha
odveta
odvolat
odvracet
odznak
ofina
ofsajd
ohlas
ohnisko
ohrada
ohrozit
ohryzek
okap
okenice
oklika
okno
okouzlit
okovy
okrasa
okres
okrsek
okruh
okupant
okurka
okusit
olejnina
olizovat
omak
omeleta
omezit
omladina
omlouvat
omluva
omyl
onehdy
opakovat
opasek
operace
opice
opilost
opisovat
opora
opozice
opravdu
oproti
orbital
orchestr
orgie
orlice
orloj
ortel
osada
oschnout
osika
osivo
oslava
oslepit
oslnit
oslovit
osnova
osoba
osolit
ospalec
osten
ostraha
ostuda
ostych
osvojit
oteplit
otisk
otop
otrhat
otrlost
otrok
otruby
otvor
ovanout
ovar
oves
ovlivnit
ovoce
oxid
ozdoba
pachatel
pacient
padouch
pahorek
pakt
palanda
palec
palivo
paluba
pamflet
pamlsek
panenka
panika
panna
panovat
panstvo
pantofle
paprika
parketa
parodie
parta
paruka
paryba
paseka
pasivita
pastelka
patent
patrona
pavouk
pazneht
pazourek
pecka
pedagog
pejsek
peklo
peloton
penalta
pendrek
penze
periskop
pero
pestrost
petarda
petice
petrolej
pevnina
pexeso
pianista
piha
pijavice
pikle
piknik
pilina
pilnost
pilulka
pinzeta
pipeta
pisatel
pistole
pitevna
pivnice
pivovar
placenta
plakat
plamen
planeta
plastika
platit
plavidlo
plaz
plech
plemeno
plenta
ples
pletivo
plevel
plivat
plnit
plno
plocha
plodina
plomba
plout
pluk
plyn
pobavit
pobyt
pochod
pocit
poctivec
podat
podcenit
podepsat
podhled
podivit
podklad
podmanit
podnik
podoba
podpora
podraz
podstata
podvod
podzim
poezie
pohanka
pohnutka
pohovor
pohroma
pohyb
pointa
pojistka
pojmout
pokazit
pokles
pokoj
pokrok
pokuta
pokyn
poledne
polibek
polknout
poloha
polynom
pomalu
pominout
pomlka
pomoc
pomsta
pomyslet
ponechat
ponorka
ponurost
popadat
popel
popisek
poplach
poprosit
popsat
popud
poradce
porce
porod
porucha
poryv
posadit
posed
posila
poskok
poslanec
posoudit
pospolu
postava
posudek
posyp
potah
potkan
potlesk
potomek
potrava
potupa
potvora
poukaz
pouto
pouzdro
povaha
povidla
povlak
povoz
povrch
povstat
povyk
povzdech
pozdrav
pozemek
poznatek
pozor
pozvat
pracovat
prahory
praktika
prales
praotec
praporek
prase
pravda
princip
prkno
probudit
procento
prodej
profese
prohra
projekt
prolomit
promile
pronikat
propad
prorok
prosba
proton
proutek
provaz
prskavka
prsten
prudkost
prut
prvek
prvohory
psanec
psovod
pstruh
ptactvo
puberta
puch
pudl
pukavec
puklina
pukrle
pult
pumpa
punc
pupen
pusa
pusinka
pustina
putovat
putyka
pyramida
pysk
pytel
racek
rachot
radiace
radnice
radon
raft
ragby
raketa
rakovina
rameno
rampouch
rande
rarach
rarita
rasovna
rastr
ratolest
razance
razidlo
reagovat
reakce
recept
redaktor
referent
reflex
rejnok
reklama
rekord
rekrut
rektor
reputace
revize
revma
revolver
rezerva
riskovat
riziko
robotika
rodokmen
rohovka
rokle
rokoko
romaneto
ropovod
ropucha
rorejs
rosol
rostlina
rotmistr
rotoped
rotunda
roubenka
roucho
roup
roura
rovina
rovnice
rozbor
rozchod
rozdat
rozeznat
rozhodce
rozinka
rozjezd
rozkaz
rozloha
rozmar
rozpad
rozruch
rozsah
roztok
rozum
rozvod
rubrika
ruchadlo
rukavice
rukopis
ryba
rybolov
rychlost
rydlo
rypadlo
rytina
ryzost
sadista
sahat
sako
samec
samizdat
samota
sanitka
sardinka
sasanka
satelit
sazba
sazenice
sbor
schovat
sebranka
secese
sedadlo
sediment
sedlo
sehnat
sejmout
sekera
sekta
sekunda
sekvoje
semeno
seno
servis
sesadit
seshora
seskok
seslat
sestra
sesuv
sesypat
setba
setina
setkat
setnout
setrvat
sever
seznam
shoda
shrnout
sifon
silnice
sirka
sirotek
sirup
situace
skafandr
skalisko
skanzen
skaut
skeptik
skica
skladba
sklenice
sklo
skluz
skoba
skokan
skoro
skripta
skrz
skupina
skvost
skvrna
slabika
sladidlo
slanina
slast
slavnost
sledovat
slepec
sleva
slezina
slib
slina
sliznice
slon
sloupek
slovo
sluch
sluha
slunce
slupka
slza
smaragd
smetana
smilstvo
smlouva
smog
smrad
smrk
smrtka
smutek
smysl
snad
snaha
snob
sobota
socha
sodovka
sokol
sopka
sotva
souboj
soucit
soudce
souhlas
soulad
soumrak
souprava
soused
soutok
souviset
spalovna
spasitel
spis
splav
spodek
spojenec
spolu
sponzor
spornost
spousta
sprcha
spustit
sranda
sraz
srdce
srna
srnec
srovnat
srpen
srst
srub
stanice
starosta
statika
stavba
stehno
stezka
stodola
stolek
stopa
storno
stoupat
strach
stres
strhnout
strom
struna
studna
stupnice
stvol
styk
subjekt
subtropy
suchar
sudost
sukno
sundat
sunout
surikata
surovina
svah
svalstvo
svetr
svatba
svazek
svisle
svitek
svoboda
svodidlo
svorka
svrab
sykavka
sykot
synek
synovec
sypat
sypkost
syrovost
sysel
sytost
tabletka
tabule
tahoun
tajemno
tajfun
tajga
tajit
tajnost
taktika
tamhle
tampon
tancovat
tanec
tanker
tapeta
tavenina
tazatel
technika
tehdy
tekutina
telefon
temnota
tendence
tenista
tenor
teplota
tepna
teprve
terapie
termoska
textil
ticho
tiskopis
titulek
tkadlec
tkanina
tlapka
tleskat
tlukot
tlupa
tmel
toaleta
topinka
topol
torzo
touha
toulec
tradice
traktor
tramp
trasa
traverza
trefit
trest
trezor
trhavina
trhlina
trochu
trojice
troska
trouba
trpce
trpitel
trpkost
trubec
truchlit
truhlice
trus
trvat
tudy
tuhnout
tuhost
tundra
turista
turnaj
tuzemsko
tvaroh
tvorba
tvrdost
tvrz
tygr
tykev
ubohost
uboze
ubrat
ubrousek
ubrus
ubytovna
ucho
uctivost
udivit
uhradit
ujednat
ujistit
ujmout
ukazatel
uklidnit
uklonit
ukotvit
ukrojit
ulice
ulita
ulovit
umyvadlo
unavit
uniforma
uniknout
upadnout
uplatnit
uplynout
upoutat
upravit
uran
urazit
usednout
usilovat
usmrtit
usnadnit
usnout
usoudit
ustlat
ustrnout
utahovat
utkat
utlumit
utonout
utopenec
utrousit
uvalit
uvolnit
uvozovka
uzdravit
uzel
uzenina
uzlina
uznat
vagon
valcha
valoun
vana
vandal
vanilka
varan
varhany
varovat
vcelku
vchod
vdova
vedro
vegetace
vejce
velbloud
veletrh
velitel
velmoc
velryba
venkov
veranda
verze
veselka
veskrze
vesnice
vespodu
vesta
veterina
veverka
vibrace
vichr
videohra
vidina
vidle
vila
vinice
viset
vitalita
vize
vizitka
vjezd
vklad
vkus
vlajka
vlak
vlasec
vlevo
vlhkost
vliv
vlnovka
vloupat
vnucovat
vnuk
voda
vodivost
vodoznak
vodstvo
vojensky
vojna
vojsko
volant
volba
volit
volno
voskovka
vozidlo
vozovna
vpravo
vrabec
vracet
vrah
vrata
vrba
vrcholek
vrhat
vrstva
vrtule
vsadit
vstoupit
vstup
vtip
vybavit
vybrat
vychovat
vydat
vydra
vyfotit
vyhledat
vyhnout
vyhodit
vyhradit
vyhubit
vyjasnit
vyjet
vyjmout
vyklopit
vykonat
vylekat
vymazat
vymezit
vymizet
vymyslet
vynechat
vynikat
vynutit
vypadat
vyplatit
vypravit
vypustit
vyrazit
vyrovnat
vyrvat
vyslovit
vysoko
vystavit
vysunout
vysypat
vytasit
vytesat
vytratit
vyvinout
vyvolat
vyvrhel
vyzdobit
vyznat
vzadu
vzbudit
vzchopit
vzdor
vzduch
vzdychat
vzestup
vzhledem
vzkaz
vzlykat
vznik
vzorek
vzpoura
vztah
vztek
xylofon
zabrat
zabydlet
zachovat
zadarmo
zadusit
zafoukat
zahltit
zahodit
zahrada
zahynout
zajatec
zajet
zajistit
zaklepat
zakoupit
zalepit
zamezit
zamotat
zamyslet
zanechat
zanikat
zaplatit
zapojit
zapsat
zarazit
zastavit
zasunout
zatajit
zatemnit
zatknout
zaujmout
zavalit
zavelet
zavinit
zavolat
zavrtat
zazvonit
zbavit
zbrusu
zbudovat
zbytek
zdaleka
zdarma
zdatnost
zdivo
zdobit
zdroj
zdvih
zdymadlo
zelenina
zeman
zemina
zeptat
zezadu
zezdola
zhatit
zhltnout
zhluboka
zhotovit
zhruba
zima
zimnice
zjemnit
zklamat
zkoumat
zkratka
zkumavka
zlato
zlehka
zloba
zlom
zlost
zlozvyk
zmapovat
zmar
zmatek
zmije
zmizet
zmocnit
zmodrat
zmrzlina
zmutovat
znak
znalost
znamenat
znovu
zobrazit
zotavit
zoubek
zoufale
zplodit
zpomalit
zprava
zprostit
zprudka
zprvu
zrada
zranit
zrcadlo
zrnitost
zrno
zrovna
zrychlit
zrzavost
zticha
ztratit
zubovina
zubr
zvednout
zvenku
zvesela
zvon
zvrat
zvukovod
zvyk`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/english.js
var wordlist2 = `abandon
ability
able
about
above
absent
absorb
abstract
absurd
abuse
access
accident
account
accuse
achieve
acid
acoustic
acquire
across
act
action
actor
actress
actual
adapt
add
addict
address
adjust
admit
adult
advance
advice
aerobic
affair
afford
afraid
again
age
agent
agree
ahead
aim
air
airport
aisle
alarm
album
alcohol
alert
alien
all
alley
allow
almost
alone
alpha
already
also
alter
always
amateur
amazing
among
amount
amused
analyst
anchor
ancient
anger
angle
angry
animal
ankle
announce
annual
another
answer
antenna
antique
anxiety
any
apart
apology
appear
apple
approve
april
arch
arctic
area
arena
argue
arm
armed
armor
army
around
arrange
arrest
arrive
arrow
art
artefact
artist
artwork
ask
aspect
assault
asset
assist
assume
asthma
athlete
atom
attack
attend
attitude
attract
auction
audit
august
aunt
author
auto
autumn
average
avocado
avoid
awake
aware
away
awesome
awful
awkward
axis
baby
bachelor
bacon
badge
bag
balance
balcony
ball
bamboo
banana
banner
bar
barely
bargain
barrel
base
basic
basket
battle
beach
bean
beauty
because
become
beef
before
begin
behave
behind
believe
below
belt
bench
benefit
best
betray
better
between
beyond
bicycle
bid
bike
bind
biology
bird
birth
bitter
black
blade
blame
blanket
blast
bleak
bless
blind
blood
blossom
blouse
blue
blur
blush
board
boat
body
boil
bomb
bone
bonus
book
boost
border
boring
borrow
boss
bottom
bounce
box
boy
bracket
brain
brand
brass
brave
bread
breeze
brick
bridge
brief
bright
bring
brisk
broccoli
broken
bronze
broom
brother
brown
brush
bubble
buddy
budget
buffalo
build
bulb
bulk
bullet
bundle
bunker
burden
burger
burst
bus
business
busy
butter
buyer
buzz
cabbage
cabin
cable
cactus
cage
cake
call
calm
camera
camp
can
canal
cancel
candy
cannon
canoe
canvas
canyon
capable
capital
captain
car
carbon
card
cargo
carpet
carry
cart
case
cash
casino
castle
casual
cat
catalog
catch
category
cattle
caught
cause
caution
cave
ceiling
celery
cement
census
century
cereal
certain
chair
chalk
champion
change
chaos
chapter
charge
chase
chat
cheap
check
cheese
chef
cherry
chest
chicken
chief
child
chimney
choice
choose
chronic
chuckle
chunk
churn
cigar
cinnamon
circle
citizen
city
civil
claim
clap
clarify
claw
clay
clean
clerk
clever
click
client
cliff
climb
clinic
clip
clock
clog
close
cloth
cloud
clown
club
clump
cluster
clutch
coach
coast
coconut
code
coffee
coil
coin
collect
color
column
combine
come
comfort
comic
common
company
concert
conduct
confirm
congress
connect
consider
control
convince
cook
cool
copper
copy
coral
core
corn
correct
cost
cotton
couch
country
couple
course
cousin
cover
coyote
crack
cradle
craft
cram
crane
crash
crater
crawl
crazy
cream
credit
creek
crew
cricket
crime
crisp
critic
crop
cross
crouch
crowd
crucial
cruel
cruise
crumble
crunch
crush
cry
crystal
cube
culture
cup
cupboard
curious
current
curtain
curve
cushion
custom
cute
cycle
dad
damage
damp
dance
danger
daring
dash
daughter
dawn
day
deal
debate
debris
decade
december
decide
decline
decorate
decrease
deer
defense
define
defy
degree
delay
deliver
demand
demise
denial
dentist
deny
depart
depend
deposit
depth
deputy
derive
describe
desert
design
desk
despair
destroy
detail
detect
develop
device
devote
diagram
dial
diamond
diary
dice
diesel
diet
differ
digital
dignity
dilemma
dinner
dinosaur
direct
dirt
disagree
discover
disease
dish
dismiss
disorder
display
distance
divert
divide
divorce
dizzy
doctor
document
dog
doll
dolphin
domain
donate
donkey
donor
door
dose
double
dove
draft
dragon
drama
drastic
draw
dream
dress
drift
drill
drink
drip
drive
drop
drum
dry
duck
dumb
dune
during
dust
dutch
duty
dwarf
dynamic
eager
eagle
early
earn
earth
easily
east
easy
echo
ecology
economy
edge
edit
educate
effort
egg
eight
either
elbow
elder
electric
elegant
element
elephant
elevator
elite
else
embark
embody
embrace
emerge
emotion
employ
empower
empty
enable
enact
end
endless
endorse
enemy
energy
enforce
engage
engine
enhance
enjoy
enlist
enough
enrich
enroll
ensure
enter
entire
entry
envelope
episode
equal
equip
era
erase
erode
erosion
error
erupt
escape
essay
essence
estate
eternal
ethics
evidence
evil
evoke
evolve
exact
example
excess
exchange
excite
exclude
excuse
execute
exercise
exhaust
exhibit
exile
exist
exit
exotic
expand
expect
expire
explain
expose
express
extend
extra
eye
eyebrow
fabric
face
faculty
fade
faint
faith
fall
false
fame
family
famous
fan
fancy
fantasy
farm
fashion
fat
fatal
father
fatigue
fault
favorite
feature
february
federal
fee
feed
feel
female
fence
festival
fetch
fever
few
fiber
fiction
field
figure
file
film
filter
final
find
fine
finger
finish
fire
firm
first
fiscal
fish
fit
fitness
fix
flag
flame
flash
flat
flavor
flee
flight
flip
float
flock
floor
flower
fluid
flush
fly
foam
focus
fog
foil
fold
follow
food
foot
force
forest
forget
fork
fortune
forum
forward
fossil
foster
found
fox
fragile
frame
frequent
fresh
friend
fringe
frog
front
frost
frown
frozen
fruit
fuel
fun
funny
furnace
fury
future
gadget
gain
galaxy
gallery
game
gap
garage
garbage
garden
garlic
garment
gas
gasp
gate
gather
gauge
gaze
general
genius
genre
gentle
genuine
gesture
ghost
giant
gift
giggle
ginger
giraffe
girl
give
glad
glance
glare
glass
glide
glimpse
globe
gloom
glory
glove
glow
glue
goat
goddess
gold
good
goose
gorilla
gospel
gossip
govern
gown
grab
grace
grain
grant
grape
grass
gravity
great
green
grid
grief
grit
grocery
group
grow
grunt
guard
guess
guide
guilt
guitar
gun
gym
habit
hair
half
hammer
hamster
hand
happy
harbor
hard
harsh
harvest
hat
have
hawk
hazard
head
health
heart
heavy
hedgehog
height
hello
helmet
help
hen
hero
hidden
high
hill
hint
hip
hire
history
hobby
hockey
hold
hole
holiday
hollow
home
honey
hood
hope
horn
horror
horse
hospital
host
hotel
hour
hover
hub
huge
human
humble
humor
hundred
hungry
hunt
hurdle
hurry
hurt
husband
hybrid
ice
icon
idea
identify
idle
ignore
ill
illegal
illness
image
imitate
immense
immune
impact
impose
improve
impulse
inch
include
income
increase
index
indicate
indoor
industry
infant
inflict
inform
inhale
inherit
initial
inject
injury
inmate
inner
innocent
input
inquiry
insane
insect
inside
inspire
install
intact
interest
into
invest
invite
involve
iron
island
isolate
issue
item
ivory
jacket
jaguar
jar
jazz
jealous
jeans
jelly
jewel
job
join
joke
journey
joy
judge
juice
jump
jungle
junior
junk
just
kangaroo
keen
keep
ketchup
key
kick
kid
kidney
kind
kingdom
kiss
kit
kitchen
kite
kitten
kiwi
knee
knife
knock
know
lab
label
labor
ladder
lady
lake
lamp
language
laptop
large
later
latin
laugh
laundry
lava
law
lawn
lawsuit
layer
lazy
leader
leaf
learn
leave
lecture
left
leg
legal
legend
leisure
lemon
lend
length
lens
leopard
lesson
letter
level
liar
liberty
library
license
life
lift
light
like
limb
limit
link
lion
liquid
list
little
live
lizard
load
loan
lobster
local
lock
logic
lonely
long
loop
lottery
loud
lounge
love
loyal
lucky
luggage
lumber
lunar
lunch
luxury
lyrics
machine
mad
magic
magnet
maid
mail
main
major
make
mammal
man
manage
mandate
mango
mansion
manual
maple
marble
march
margin
marine
market
marriage
mask
mass
master
match
material
math
matrix
matter
maximum
maze
meadow
mean
measure
meat
mechanic
medal
media
melody
melt
member
memory
mention
menu
mercy
merge
merit
merry
mesh
message
metal
method
middle
midnight
milk
million
mimic
mind
minimum
minor
minute
miracle
mirror
misery
miss
mistake
mix
mixed
mixture
mobile
model
modify
mom
moment
monitor
monkey
monster
month
moon
moral
more
morning
mosquito
mother
motion
motor
mountain
mouse
move
movie
much
muffin
mule
multiply
muscle
museum
mushroom
music
must
mutual
myself
mystery
myth
naive
name
napkin
narrow
nasty
nation
nature
near
neck
need
negative
neglect
neither
nephew
nerve
nest
net
network
neutral
never
news
next
nice
night
noble
noise
nominee
noodle
normal
north
nose
notable
note
nothing
notice
novel
now
nuclear
number
nurse
nut
oak
obey
object
oblige
obscure
observe
obtain
obvious
occur
ocean
october
odor
off
offer
office
often
oil
okay
old
olive
olympic
omit
once
one
onion
online
only
open
opera
opinion
oppose
option
orange
orbit
orchard
order
ordinary
organ
orient
original
orphan
ostrich
other
outdoor
outer
output
outside
oval
oven
over
own
owner
oxygen
oyster
ozone
pact
paddle
page
pair
palace
palm
panda
panel
panic
panther
paper
parade
parent
park
parrot
party
pass
patch
path
patient
patrol
pattern
pause
pave
payment
peace
peanut
pear
peasant
pelican
pen
penalty
pencil
people
pepper
perfect
permit
person
pet
phone
photo
phrase
physical
piano
picnic
picture
piece
pig
pigeon
pill
pilot
pink
pioneer
pipe
pistol
pitch
pizza
place
planet
plastic
plate
play
please
pledge
pluck
plug
plunge
poem
poet
point
polar
pole
police
pond
pony
pool
popular
portion
position
possible
post
potato
pottery
poverty
powder
power
practice
praise
predict
prefer
prepare
present
pretty
prevent
price
pride
primary
print
priority
prison
private
prize
problem
process
produce
profit
program
project
promote
proof
property
prosper
protect
proud
provide
public
pudding
pull
pulp
pulse
pumpkin
punch
pupil
puppy
purchase
purity
purpose
purse
push
put
puzzle
pyramid
quality
quantum
quarter
question
quick
quit
quiz
quote
rabbit
raccoon
race
rack
radar
radio
rail
rain
raise
rally
ramp
ranch
random
range
rapid
rare
rate
rather
raven
raw
razor
ready
real
reason
rebel
rebuild
recall
receive
recipe
record
recycle
reduce
reflect
reform
refuse
region
regret
regular
reject
relax
release
relief
rely
remain
remember
remind
remove
render
renew
rent
reopen
repair
repeat
replace
report
require
rescue
resemble
resist
resource
response
result
retire
retreat
return
reunion
reveal
review
reward
rhythm
rib
ribbon
rice
rich
ride
ridge
rifle
right
rigid
ring
riot
ripple
risk
ritual
rival
river
road
roast
robot
robust
rocket
romance
roof
rookie
room
rose
rotate
rough
round
route
royal
rubber
rude
rug
rule
run
runway
rural
sad
saddle
sadness
safe
sail
salad
salmon
salon
salt
salute
same
sample
sand
satisfy
satoshi
sauce
sausage
save
say
scale
scan
scare
scatter
scene
scheme
school
science
scissors
scorpion
scout
scrap
screen
script
scrub
sea
search
season
seat
second
secret
section
security
seed
seek
segment
select
sell
seminar
senior
sense
sentence
series
service
session
settle
setup
seven
shadow
shaft
shallow
share
shed
shell
sheriff
shield
shift
shine
ship
shiver
shock
shoe
shoot
shop
short
shoulder
shove
shrimp
shrug
shuffle
shy
sibling
sick
side
siege
sight
sign
silent
silk
silly
silver
similar
simple
since
sing
siren
sister
situate
six
size
skate
sketch
ski
skill
skin
skirt
skull
slab
slam
sleep
slender
slice
slide
slight
slim
slogan
slot
slow
slush
small
smart
smile
smoke
smooth
snack
snake
snap
sniff
snow
soap
soccer
social
sock
soda
soft
solar
soldier
solid
solution
solve
someone
song
soon
sorry
sort
soul
sound
soup
source
south
space
spare
spatial
spawn
speak
special
speed
spell
spend
sphere
spice
spider
spike
spin
spirit
split
spoil
sponsor
spoon
sport
spot
spray
spread
spring
spy
square
squeeze
squirrel
stable
stadium
staff
stage
stairs
stamp
stand
start
state
stay
steak
steel
stem
step
stereo
stick
still
sting
stock
stomach
stone
stool
story
stove
strategy
street
strike
strong
struggle
student
stuff
stumble
style
subject
submit
subway
success
such
sudden
suffer
sugar
suggest
suit
summer
sun
sunny
sunset
super
supply
supreme
sure
surface
surge
surprise
surround
survey
suspect
sustain
swallow
swamp
swap
swarm
swear
sweet
swift
swim
swing
switch
sword
symbol
symptom
syrup
system
table
tackle
tag
tail
talent
talk
tank
tape
target
task
taste
tattoo
taxi
teach
team
tell
ten
tenant
tennis
tent
term
test
text
thank
that
theme
then
theory
there
they
thing
this
thought
three
thrive
throw
thumb
thunder
ticket
tide
tiger
tilt
timber
time
tiny
tip
tired
tissue
title
toast
tobacco
today
toddler
toe
together
toilet
token
tomato
tomorrow
tone
tongue
tonight
tool
tooth
top
topic
topple
torch
tornado
tortoise
toss
total
tourist
toward
tower
town
toy
track
trade
traffic
tragic
train
transfer
trap
trash
travel
tray
treat
tree
trend
trial
tribe
trick
trigger
trim
trip
trophy
trouble
truck
true
truly
trumpet
trust
truth
try
tube
tuition
tumble
tuna
tunnel
turkey
turn
turtle
twelve
twenty
twice
twin
twist
two
type
typical
ugly
umbrella
unable
unaware
uncle
uncover
under
undo
unfair
unfold
unhappy
uniform
unique
unit
universe
unknown
unlock
until
unusual
unveil
update
upgrade
uphold
upon
upper
upset
urban
urge
usage
use
used
useful
useless
usual
utility
vacant
vacuum
vague
valid
valley
valve
van
vanish
vapor
various
vast
vault
vehicle
velvet
vendor
venture
venue
verb
verify
version
very
vessel
veteran
viable
vibrant
vicious
victory
video
view
village
vintage
violin
virtual
virus
visa
visit
visual
vital
vivid
vocal
voice
void
volcano
volume
vote
voyage
wage
wagon
wait
walk
wall
walnut
want
warfare
warm
warrior
wash
wasp
waste
water
wave
way
wealth
weapon
wear
weasel
weather
web
wedding
weekend
weird
welcome
west
wet
whale
what
wheat
wheel
when
where
whip
whisper
wide
width
wife
wild
will
win
window
wine
wing
wink
winner
winter
wire
wisdom
wise
wish
witness
wolf
woman
wonder
wood
wool
word
work
world
worry
worth
wrap
wreck
wrestle
wrist
write
wrong
yard
year
yellow
you
young
youth
zebra
zero
zone
zoo`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/french.js
var wordlist3 = `abaisser
abandon
abdiquer
abeille
abolir
aborder
aboutir
aboyer
abrasif
abreuver
abriter
abroger
abrupt
absence
absolu
absurde
abusif
abyssal
academie
acajou
acarien
accabler
accepter
acclamer
accolade
accroche
accuser
acerbe
achat
acheter
aciduler
acier
acompte
acquerir
acronyme
acteur
actif
actuel
adepte
adequat
adhesif
adjectif
adjuger
admettre
admirer
adopter
adorer
adoucir
adresse
adroit
adulte
adverbe
aerer
aeronef
affaire
affecter
affiche
affreux
affubler
agacer
agencer
agile
agiter
agrafer
agreable
agrume
aider
aiguille
ailier
aimable
aisance
ajouter
ajuster
alarmer
alchimie
alerte
algebre
algue
aliener
aliment
alleger
alliage
allouer
allumer
alourdir
alpaga
altesse
alveole
amateur
ambigu
ambre
amenager
amertume
amidon
amiral
amorcer
amour
amovible
amphibie
ampleur
amusant
analyse
anaphore
anarchie
anatomie
ancien
aneantir
angle
angoisse
anguleux
animal
annexer
annonce
annuel
anodin
anomalie
anonyme
anormal
antenne
antidote
anxieux
apaiser
aperitif
aplanir
apologie
appareil
appeler
apporter
appuyer
aquarium
aqueduc
arbitre
arbuste
ardeur
ardoise
argent
arlequin
armature
armement
armoire
armure
arpenter
arracher
arriver
arroser
arsenic
arteriel
article
aspect
asphalte
aspirer
assaut
asservir
assiette
associer
assurer
asticot
astre
astuce
atelier
atome
atrium
atroce
attaque
attentif
attirer
attraper
aubaine
auberge
audace
audible
augurer
aurore
automne
autruche
avaler
avancer
avarice
avenir
averse
aveugle
aviateur
avide
avion
aviser
avoine
avouer
avril
axial
axiome
badge
bafouer
bagage
baguette
baignade
balancer
balcon
baleine
balisage
bambin
bancaire
bandage
banlieue
banniere
banquier
barbier
baril
baron
barque
barrage
bassin
bastion
bataille
bateau
batterie
baudrier
bavarder
belette
belier
belote
benefice
berceau
berger
berline
bermuda
besace
besogne
betail
beurre
biberon
bicycle
bidule
bijou
bilan
bilingue
billard
binaire
biologie
biopsie
biotype
biscuit
bison
bistouri
bitume
bizarre
blafard
blague
blanchir
blessant
blinder
blond
bloquer
blouson
bobard
bobine
boire
boiser
bolide
bonbon
bondir
bonheur
bonifier
bonus
bordure
borne
botte
boucle
boueux
bougie
boulon
bouquin
bourse
boussole
boutique
boxeur
branche
brasier
brave
brebis
breche
breuvage
bricoler
brigade
brillant
brioche
brique
brochure
broder
bronzer
brousse
broyeur
brume
brusque
brutal
bruyant
buffle
buisson
bulletin
bureau
burin
bustier
butiner
butoir
buvable
buvette
cabanon
cabine
cachette
cadeau
cadre
cafeine
caillou
caisson
calculer
calepin
calibre
calmer
calomnie
calvaire
camarade
camera
camion
campagne
canal
caneton
canon
cantine
canular
capable
caporal
caprice
capsule
capter
capuche
carabine
carbone
caresser
caribou
carnage
carotte
carreau
carton
cascade
casier
casque
cassure
causer
caution
cavalier
caverne
caviar
cedille
ceinture
celeste
cellule
cendrier
censurer
central
cercle
cerebral
cerise
cerner
cerveau
cesser
chagrin
chaise
chaleur
chambre
chance
chapitre
charbon
chasseur
chaton
chausson
chavirer
chemise
chenille
chequier
chercher
cheval
chien
chiffre
chignon
chimere
chiot
chlorure
chocolat
choisir
chose
chouette
chrome
chute
cigare
cigogne
cimenter
cinema
cintrer
circuler
cirer
cirque
citerne
citoyen
citron
civil
clairon
clameur
claquer
classe
clavier
client
cligner
climat
clivage
cloche
clonage
cloporte
cobalt
cobra
cocasse
cocotier
coder
codifier
coffre
cogner
cohesion
coiffer
coincer
colere
colibri
colline
colmater
colonel
combat
comedie
commande
compact
concert
conduire
confier
congeler
connoter
consonne
contact
convexe
copain
copie
corail
corbeau
cordage
corniche
corpus
correct
cortege
cosmique
costume
coton
coude
coupure
courage
couteau
couvrir
coyote
crabe
crainte
cravate
crayon
creature
crediter
cremeux
creuser
crevette
cribler
crier
cristal
critere
croire
croquer
crotale
crucial
cruel
crypter
cubique
cueillir
cuillere
cuisine
cuivre
culminer
cultiver
cumuler
cupide
curatif
curseur
cyanure
cycle
cylindre
cynique
daigner
damier
danger
danseur
dauphin
debattre
debiter
deborder
debrider
debutant
decaler
decembre
dechirer
decider
declarer
decorer
decrire
decupler
dedale
deductif
deesse
defensif
defiler
defrayer
degager
degivrer
deglutir
degrafer
dejeuner
delice
deloger
demander
demeurer
demolir
denicher
denouer
dentelle
denuder
depart
depenser
dephaser
deplacer
deposer
deranger
derober
desastre
descente
desert
designer
desobeir
dessiner
destrier
detacher
detester
detourer
detresse
devancer
devenir
deviner
devoir
diable
dialogue
diamant
dicter
differer
digerer
digital
digne
diluer
dimanche
diminuer
dioxyde
directif
diriger
discuter
disposer
dissiper
distance
divertir
diviser
docile
docteur
dogme
doigt
domaine
domicile
dompter
donateur
donjon
donner
dopamine
dortoir
dorure
dosage
doseur
dossier
dotation
douanier
double
douceur
douter
doyen
dragon
draper
dresser
dribbler
droiture
duperie
duplexe
durable
durcir
dynastie
eblouir
ecarter
echarpe
echelle
eclairer
eclipse
eclore
ecluse
ecole
economie
ecorce
ecouter
ecraser
ecremer
ecrivain
ecrou
ecume
ecureuil
edifier
eduquer
effacer
effectif
effigie
effort
effrayer
effusion
egaliser
egarer
ejecter
elaborer
elargir
electron
elegant
elephant
eleve
eligible
elitisme
eloge
elucider
eluder
emballer
embellir
embryon
emeraude
emission
emmener
emotion
emouvoir
empereur
employer
emporter
emprise
emulsion
encadrer
enchere
enclave
encoche
endiguer
endosser
endroit
enduire
energie
enfance
enfermer
enfouir
engager
engin
englober
enigme
enjamber
enjeu
enlever
ennemi
ennuyeux
enrichir
enrobage
enseigne
entasser
entendre
entier
entourer
entraver
enumerer
envahir
enviable
envoyer
enzyme
eolien
epaissir
epargne
epatant
epaule
epicerie
epidemie
epier
epilogue
epine
episode
epitaphe
epoque
epreuve
eprouver
epuisant
equerre
equipe
eriger
erosion
erreur
eruption
escalier
espadon
espece
espiegle
espoir
esprit
esquiver
essayer
essence
essieu
essorer
estime
estomac
estrade
etagere
etaler
etanche
etatique
eteindre
etendoir
eternel
ethanol
ethique
ethnie
etirer
etoffer
etoile
etonnant
etourdir
etrange
etroit
etude
euphorie
evaluer
evasion
eventail
evidence
eviter
evolutif
evoquer
exact
exagerer
exaucer
exceller
excitant
exclusif
excuse
executer
exemple
exercer
exhaler
exhorter
exigence
exiler
exister
exotique
expedier
explorer
exposer
exprimer
exquis
extensif
extraire
exulter
fable
fabuleux
facette
facile
facture
faiblir
falaise
fameux
famille
farceur
farfelu
farine
farouche
fasciner
fatal
fatigue
faucon
fautif
faveur
favori
febrile
feconder
federer
felin
femme
femur
fendoir
feodal
fermer
feroce
ferveur
festival
feuille
feutre
fevrier
fiasco
ficeler
fictif
fidele
figure
filature
filetage
filiere
filleul
filmer
filou
filtrer
financer
finir
fiole
firme
fissure
fixer
flairer
flamme
flasque
flatteur
fleau
fleche
fleur
flexion
flocon
flore
fluctuer
fluide
fluvial
folie
fonderie
fongible
fontaine
forcer
forgeron
formuler
fortune
fossile
foudre
fougere
fouiller
foulure
fourmi
fragile
fraise
franchir
frapper
frayeur
fregate
freiner
frelon
fremir
frenesie
frere
friable
friction
frisson
frivole
froid
fromage
frontal
frotter
fruit
fugitif
fuite
fureur
furieux
furtif
fusion
futur
gagner
galaxie
galerie
gambader
garantir
gardien
garnir
garrigue
gazelle
gazon
geant
gelatine
gelule
gendarme
general
genie
genou
gentil
geologie
geometre
geranium
germe
gestuel
geyser
gibier
gicler
girafe
givre
glace
glaive
glisser
globe
gloire
glorieux
golfeur
gomme
gonfler
gorge
gorille
goudron
gouffre
goulot
goupille
gourmand
goutte
graduel
graffiti
graine
grand
grappin
gratuit
gravir
grenat
griffure
griller
grimper
grogner
gronder
grotte
groupe
gruger
grutier
gruyere
guepard
guerrier
guide
guimauve
guitare
gustatif
gymnaste
gyrostat
habitude
hachoir
halte
hameau
hangar
hanneton
haricot
harmonie
harpon
hasard
helium
hematome
herbe
herisson
hermine
heron
hesiter
heureux
hiberner
hibou
hilarant
histoire
hiver
homard
hommage
homogene
honneur
honorer
honteux
horde
horizon
horloge
hormone
horrible
houleux
housse
hublot
huileux
humain
humble
humide
humour
hurler
hydromel
hygiene
hymne
hypnose
idylle
ignorer
iguane
illicite
illusion
image
imbiber
imiter
immense
immobile
immuable
impact
imperial
implorer
imposer
imprimer
imputer
incarner
incendie
incident
incliner
incolore
indexer
indice
inductif
inedit
ineptie
inexact
infini
infliger
informer
infusion
ingerer
inhaler
inhiber
injecter
injure
innocent
inoculer
inonder
inscrire
insecte
insigne
insolite
inspirer
instinct
insulter
intact
intense
intime
intrigue
intuitif
inutile
invasion
inventer
inviter
invoquer
ironique
irradier
irreel
irriter
isoler
ivoire
ivresse
jaguar
jaillir
jambe
janvier
jardin
jauger
jaune
javelot
jetable
jeton
jeudi
jeunesse
joindre
joncher
jongler
joueur
jouissif
journal
jovial
joyau
joyeux
jubiler
jugement
junior
jupon
juriste
justice
juteux
juvenile
kayak
kimono
kiosque
label
labial
labourer
lacerer
lactose
lagune
laine
laisser
laitier
lambeau
lamelle
lampe
lanceur
langage
lanterne
lapin
largeur
larme
laurier
lavabo
lavoir
lecture
legal
leger
legume
lessive
lettre
levier
lexique
lezard
liasse
liberer
libre
licence
licorne
liege
lievre
ligature
ligoter
ligue
limer
limite
limonade
limpide
lineaire
lingot
lionceau
liquide
lisiere
lister
lithium
litige
littoral
livreur
logique
lointain
loisir
lombric
loterie
louer
lourd
loutre
louve
loyal
lubie
lucide
lucratif
lueur
lugubre
luisant
lumiere
lunaire
lundi
luron
lutter
luxueux
machine
magasin
magenta
magique
maigre
maillon
maintien
mairie
maison
majorer
malaxer
malefice
malheur
malice
mallette
mammouth
mandater
maniable
manquant
manteau
manuel
marathon
marbre
marchand
mardi
maritime
marqueur
marron
marteler
mascotte
massif
materiel
matiere
matraque
maudire
maussade
mauve
maximal
mechant
meconnu
medaille
medecin
mediter
meduse
meilleur
melange
melodie
membre
memoire
menacer
mener
menhir
mensonge
mentor
mercredi
merite
merle
messager
mesure
metal
meteore
methode
metier
meuble
miauler
microbe
miette
mignon
migrer
milieu
million
mimique
mince
mineral
minimal
minorer
minute
miracle
miroiter
missile
mixte
mobile
moderne
moelleux
mondial
moniteur
monnaie
monotone
monstre
montagne
monument
moqueur
morceau
morsure
mortier
moteur
motif
mouche
moufle
moulin
mousson
mouton
mouvant
multiple
munition
muraille
murene
murmure
muscle
museum
musicien
mutation
muter
mutuel
myriade
myrtille
mystere
mythique
nageur
nappe
narquois
narrer
natation
nation
nature
naufrage
nautique
navire
nebuleux
nectar
nefaste
negation
negliger
negocier
neige
nerveux
nettoyer
neurone
neutron
neveu
niche
nickel
nitrate
niveau
noble
nocif
nocturne
noirceur
noisette
nomade
nombreux
nommer
normatif
notable
notifier
notoire
nourrir
nouveau
novateur
novembre
novice
nuage
nuancer
nuire
nuisible
numero
nuptial
nuque
nutritif
obeir
objectif
obliger
obscur
observer
obstacle
obtenir
obturer
occasion
occuper
ocean
octobre
octroyer
octupler
oculaire
odeur
odorant
offenser
officier
offrir
ogive
oiseau
oisillon
olfactif
olivier
ombrage
omettre
onctueux
onduler
onereux
onirique
opale
opaque
operer
opinion
opportun
opprimer
opter
optique
orageux
orange
orbite
ordonner
oreille
organe
orgueil
orifice
ornement
orque
ortie
osciller
osmose
ossature
otarie
ouragan
ourson
outil
outrager
ouvrage
ovation
oxyde
oxygene
ozone
paisible
palace
palmares
palourde
palper
panache
panda
pangolin
paniquer
panneau
panorama
pantalon
papaye
papier
papoter
papyrus
paradoxe
parcelle
paresse
parfumer
parler
parole
parrain
parsemer
partager
parure
parvenir
passion
pasteque
paternel
patience
patron
pavillon
pavoiser
payer
paysage
peigne
peintre
pelage
pelican
pelle
pelouse
peluche
pendule
penetrer
penible
pensif
penurie
pepite
peplum
perdrix
perforer
periode
permuter
perplexe
persil
perte
peser
petale
petit
petrir
peuple
pharaon
phobie
phoque
photon
phrase
physique
piano
pictural
piece
pierre
pieuvre
pilote
pinceau
pipette
piquer
pirogue
piscine
piston
pivoter
pixel
pizza
placard
plafond
plaisir
planer
plaque
plastron
plateau
pleurer
plexus
pliage
plomb
plonger
pluie
plumage
pochette
poesie
poete
pointe
poirier
poisson
poivre
polaire
policier
pollen
polygone
pommade
pompier
ponctuel
ponderer
poney
portique
position
posseder
posture
potager
poteau
potion
pouce
poulain
poumon
pourpre
poussin
pouvoir
prairie
pratique
precieux
predire
prefixe
prelude
prenom
presence
pretexte
prevoir
primitif
prince
prison
priver
probleme
proceder
prodige
profond
progres
proie
projeter
prologue
promener
propre
prospere
proteger
prouesse
proverbe
prudence
pruneau
psychose
public
puceron
puiser
pulpe
pulsar
punaise
punitif
pupitre
purifier
puzzle
pyramide
quasar
querelle
question
quietude
quitter
quotient
racine
raconter
radieux
ragondin
raideur
raisin
ralentir
rallonge
ramasser
rapide
rasage
ratisser
ravager
ravin
rayonner
reactif
reagir
realiser
reanimer
recevoir
reciter
reclamer
recolter
recruter
reculer
recycler
rediger
redouter
refaire
reflexe
reformer
refrain
refuge
regalien
region
reglage
regulier
reiterer
rejeter
rejouer
relatif
relever
relief
remarque
remede
remise
remonter
remplir
remuer
renard
renfort
renifler
renoncer
rentrer
renvoi
replier
reporter
reprise
reptile
requin
reserve
resineux
resoudre
respect
rester
resultat
retablir
retenir
reticule
retomber
retracer
reunion
reussir
revanche
revivre
revolte
revulsif
richesse
rideau
rieur
rigide
rigoler
rincer
riposter
risible
risque
rituel
rival
riviere
rocheux
romance
rompre
ronce
rondin
roseau
rosier
rotatif
rotor
rotule
rouge
rouille
rouleau
routine
royaume
ruban
rubis
ruche
ruelle
rugueux
ruiner
ruisseau
ruser
rustique
rythme
sabler
saboter
sabre
sacoche
safari
sagesse
saisir
salade
salive
salon
saluer
samedi
sanction
sanglier
sarcasme
sardine
saturer
saugrenu
saumon
sauter
sauvage
savant
savonner
scalpel
scandale
scelerat
scenario
sceptre
schema
science
scinder
score
scrutin
sculpter
seance
secable
secher
secouer
secreter
sedatif
seduire
seigneur
sejour
selectif
semaine
sembler
semence
seminal
senateur
sensible
sentence
separer
sequence
serein
sergent
serieux
serrure
serum
service
sesame
sevir
sevrage
sextuple
sideral
siecle
sieger
siffler
sigle
signal
silence
silicium
simple
sincere
sinistre
siphon
sirop
sismique
situer
skier
social
socle
sodium
soigneux
soldat
soleil
solitude
soluble
sombre
sommeil
somnoler
sonde
songeur
sonnette
sonore
sorcier
sortir
sosie
sottise
soucieux
soudure
souffle
soulever
soupape
source
soutirer
souvenir
spacieux
spatial
special
sphere
spiral
stable
station
sternum
stimulus
stipuler
strict
studieux
stupeur
styliste
sublime
substrat
subtil
subvenir
succes
sucre
suffixe
suggerer
suiveur
sulfate
superbe
supplier
surface
suricate
surmener
surprise
sursaut
survie
suspect
syllabe
symbole
symetrie
synapse
syntaxe
systeme
tabac
tablier
tactile
tailler
talent
talisman
talonner
tambour
tamiser
tangible
tapis
taquiner
tarder
tarif
tartine
tasse
tatami
tatouage
taupe
taureau
taxer
temoin
temporel
tenaille
tendre
teneur
tenir
tension
terminer
terne
terrible
tetine
texte
theme
theorie
therapie
thorax
tibia
tiede
timide
tirelire
tiroir
tissu
titane
titre
tituber
toboggan
tolerant
tomate
tonique
tonneau
toponyme
torche
tordre
tornade
torpille
torrent
torse
tortue
totem
toucher
tournage
tousser
toxine
traction
trafic
tragique
trahir
train
trancher
travail
trefle
tremper
tresor
treuil
triage
tribunal
tricoter
trilogie
triomphe
tripler
triturer
trivial
trombone
tronc
tropical
troupeau
tuile
tulipe
tumulte
tunnel
turbine
tuteur
tutoyer
tuyau
tympan
typhon
typique
tyran
ubuesque
ultime
ultrason
unanime
unifier
union
unique
unitaire
univers
uranium
urbain
urticant
usage
usine
usuel
usure
utile
utopie
vacarme
vaccin
vagabond
vague
vaillant
vaincre
vaisseau
valable
valise
vallon
valve
vampire
vanille
vapeur
varier
vaseux
vassal
vaste
vecteur
vedette
vegetal
vehicule
veinard
veloce
vendredi
venerer
venger
venimeux
ventouse
verdure
verin
vernir
verrou
verser
vertu
veston
veteran
vetuste
vexant
vexer
viaduc
viande
victoire
vidange
video
vignette
vigueur
vilain
village
vinaigre
violon
vipere
virement
virtuose
virus
visage
viseur
vision
visqueux
visuel
vital
vitesse
viticole
vitrine
vivace
vivipare
vocation
voguer
voile
voisin
voiture
volaille
volcan
voltiger
volume
vorace
vortex
voter
vouloir
voyage
voyelle
wagon
xenon
yacht
zebre
zenith
zeste
zoologie`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/italian.js
var wordlist4 = `abaco
abbaglio
abbinato
abete
abisso
abolire
abrasivo
abrogato
accadere
accenno
accusato
acetone
achille
acido
acqua
acre
acrilico
acrobata
acuto
adagio
addebito
addome
adeguato
aderire
adipe
adottare
adulare
affabile
affetto
affisso
affranto
aforisma
afoso
africano
agave
agente
agevole
aggancio
agire
agitare
agonismo
agricolo
agrumeto
aguzzo
alabarda
alato
albatro
alberato
albo
albume
alce
alcolico
alettone
alfa
algebra
aliante
alibi
alimento
allagato
allegro
allievo
allodola
allusivo
almeno
alogeno
alpaca
alpestre
altalena
alterno
alticcio
altrove
alunno
alveolo
alzare
amalgama
amanita
amarena
ambito
ambrato
ameba
america
ametista
amico
ammasso
ammenda
ammirare
ammonito
amore
ampio
ampliare
amuleto
anacardo
anagrafe
analista
anarchia
anatra
anca
ancella
ancora
andare
andrea
anello
angelo
angolare
angusto
anima
annegare
annidato
anno
annuncio
anonimo
anticipo
anzi
apatico
apertura
apode
apparire
appetito
appoggio
approdo
appunto
aprile
arabica
arachide
aragosta
araldica
arancio
aratura
arazzo
arbitro
archivio
ardito
arenile
argento
argine
arguto
aria
armonia
arnese
arredato
arringa
arrosto
arsenico
arso
artefice
arzillo
asciutto
ascolto
asepsi
asettico
asfalto
asino
asola
aspirato
aspro
assaggio
asse
assoluto
assurdo
asta
astenuto
astice
astratto
atavico
ateismo
atomico
atono
attesa
attivare
attorno
attrito
attuale
ausilio
austria
autista
autonomo
autunno
avanzato
avere
avvenire
avviso
avvolgere
azione
azoto
azzimo
azzurro
babele
baccano
bacino
baco
badessa
badilata
bagnato
baita
balcone
baldo
balena
ballata
balzano
bambino
bandire
baraonda
barbaro
barca
baritono
barlume
barocco
basilico
basso
batosta
battuto
baule
bava
bavosa
becco
beffa
belgio
belva
benda
benevole
benigno
benzina
bere
berlina
beta
bibita
bici
bidone
bifido
biga
bilancia
bimbo
binocolo
biologo
bipede
bipolare
birbante
birra
biscotto
bisesto
bisnonno
bisonte
bisturi
bizzarro
blando
blatta
bollito
bonifico
bordo
bosco
botanico
bottino
bozzolo
braccio
bradipo
brama
branca
bravura
bretella
brevetto
brezza
briglia
brillante
brindare
broccolo
brodo
bronzina
brullo
bruno
bubbone
buca
budino
buffone
buio
bulbo
buono
burlone
burrasca
bussola
busta
cadetto
caduco
calamaro
calcolo
calesse
calibro
calmo
caloria
cambusa
camerata
camicia
cammino
camola
campale
canapa
candela
cane
canino
canotto
cantina
capace
capello
capitolo
capogiro
cappero
capra
capsula
carapace
carcassa
cardo
carisma
carovana
carretto
cartolina
casaccio
cascata
caserma
caso
cassone
castello
casuale
catasta
catena
catrame
cauto
cavillo
cedibile
cedrata
cefalo
celebre
cellulare
cena
cenone
centesimo
ceramica
cercare
certo
cerume
cervello
cesoia
cespo
ceto
chela
chiaro
chicca
chiedere
chimera
china
chirurgo
chitarra
ciao
ciclismo
cifrare
cigno
cilindro
ciottolo
circa
cirrosi
citrico
cittadino
ciuffo
civetta
civile
classico
clinica
cloro
cocco
codardo
codice
coerente
cognome
collare
colmato
colore
colposo
coltivato
colza
coma
cometa
commando
comodo
computer
comune
conciso
condurre
conferma
congelare
coniuge
connesso
conoscere
consumo
continuo
convegno
coperto
copione
coppia
copricapo
corazza
cordata
coricato
cornice
corolla
corpo
corredo
corsia
cortese
cosmico
costante
cottura
covato
cratere
cravatta
creato
credere
cremoso
crescita
creta
criceto
crinale
crisi
critico
croce
cronaca
crostata
cruciale
crusca
cucire
cuculo
cugino
cullato
cupola
curatore
cursore
curvo
cuscino
custode
dado
daino
dalmata
damerino
daniela
dannoso
danzare
datato
davanti
davvero
debutto
decennio
deciso
declino
decollo
decreto
dedicato
definito
deforme
degno
delegare
delfino
delirio
delta
demenza
denotato
dentro
deposito
derapata
derivare
deroga
descritto
deserto
desiderio
desumere
detersivo
devoto
diametro
dicembre
diedro
difeso
diffuso
digerire
digitale
diluvio
dinamico
dinnanzi
dipinto
diploma
dipolo
diradare
dire
dirotto
dirupo
disagio
discreto
disfare
disgelo
disposto
distanza
disumano
dito
divano
divelto
dividere
divorato
doblone
docente
doganale
dogma
dolce
domato
domenica
dominare
dondolo
dono
dormire
dote
dottore
dovuto
dozzina
drago
druido
dubbio
dubitare
ducale
duna
duomo
duplice
duraturo
ebano
eccesso
ecco
eclissi
economia
edera
edicola
edile
editoria
educare
egemonia
egli
egoismo
egregio
elaborato
elargire
elegante
elencato
eletto
elevare
elfico
elica
elmo
elsa
eluso
emanato
emblema
emesso
emiro
emotivo
emozione
empirico
emulo
endemico
enduro
energia
enfasi
enoteca
entrare
enzima
epatite
epilogo
episodio
epocale
eppure
equatore
erario
erba
erboso
erede
eremita
erigere
ermetico
eroe
erosivo
errante
esagono
esame
esanime
esaudire
esca
esempio
esercito
esibito
esigente
esistere
esito
esofago
esortato
esoso
espanso
espresso
essenza
esso
esteso
estimare
estonia
estroso
esultare
etilico
etnico
etrusco
etto
euclideo
europa
evaso
evidenza
evitato
evoluto
evviva
fabbrica
faccenda
fachiro
falco
famiglia
fanale
fanfara
fango
fantasma
fare
farfalla
farinoso
farmaco
fascia
fastoso
fasullo
faticare
fato
favoloso
febbre
fecola
fede
fegato
felpa
feltro
femmina
fendere
fenomeno
fermento
ferro
fertile
fessura
festivo
fetta
feudo
fiaba
fiducia
fifa
figurato
filo
finanza
finestra
finire
fiore
fiscale
fisico
fiume
flacone
flamenco
flebo
flemma
florido
fluente
fluoro
fobico
focaccia
focoso
foderato
foglio
folata
folclore
folgore
fondente
fonetico
fonia
fontana
forbito
forchetta
foresta
formica
fornaio
foro
fortezza
forzare
fosfato
fosso
fracasso
frana
frassino
fratello
freccetta
frenata
fresco
frigo
frollino
fronde
frugale
frutta
fucilata
fucsia
fuggente
fulmine
fulvo
fumante
fumetto
fumoso
fune
funzione
fuoco
furbo
furgone
furore
fuso
futile
gabbiano
gaffe
galateo
gallina
galoppo
gambero
gamma
garanzia
garbo
garofano
garzone
gasdotto
gasolio
gastrico
gatto
gaudio
gazebo
gazzella
geco
gelatina
gelso
gemello
gemmato
gene
genitore
gennaio
genotipo
gergo
ghepardo
ghiaccio
ghisa
giallo
gilda
ginepro
giocare
gioiello
giorno
giove
girato
girone
gittata
giudizio
giurato
giusto
globulo
glutine
gnomo
gobba
golf
gomito
gommone
gonfio
gonna
governo
gracile
grado
grafico
grammo
grande
grattare
gravoso
grazia
greca
gregge
grifone
grigio
grinza
grotta
gruppo
guadagno
guaio
guanto
guardare
gufo
guidare
ibernato
icona
identico
idillio
idolo
idra
idrico
idrogeno
igiene
ignaro
ignorato
ilare
illeso
illogico
illudere
imballo
imbevuto
imbocco
imbuto
immane
immerso
immolato
impacco
impeto
impiego
importo
impronta
inalare
inarcare
inattivo
incanto
incendio
inchino
incisivo
incluso
incontro
incrocio
incubo
indagine
india
indole
inedito
infatti
infilare
inflitto
ingaggio
ingegno
inglese
ingordo
ingrosso
innesco
inodore
inoltrare
inondato
insano
insetto
insieme
insonnia
insulina
intasato
intero
intonaco
intuito
inumidire
invalido
invece
invito
iperbole
ipnotico
ipotesi
ippica
iride
irlanda
ironico
irrigato
irrorare
isolato
isotopo
isterico
istituto
istrice
italia
iterare
labbro
labirinto
lacca
lacerato
lacrima
lacuna
laddove
lago
lampo
lancetta
lanterna
lardoso
larga
laringe
lastra
latenza
latino
lattuga
lavagna
lavoro
legale
leggero
lembo
lentezza
lenza
leone
lepre
lesivo
lessato
lesto
letterale
leva
levigato
libero
lido
lievito
lilla
limatura
limitare
limpido
lineare
lingua
liquido
lira
lirica
lisca
lite
litigio
livrea
locanda
lode
logica
lombare
londra
longevo
loquace
lorenzo
loto
lotteria
luce
lucidato
lumaca
luminoso
lungo
lupo
luppolo
lusinga
lusso
lutto
macabro
macchina
macero
macinato
madama
magico
maglia
magnete
magro
maiolica
malafede
malgrado
malinteso
malsano
malto
malumore
mana
mancia
mandorla
mangiare
manifesto
mannaro
manovra
mansarda
mantide
manubrio
mappa
maratona
marcire
maretta
marmo
marsupio
maschera
massaia
mastino
materasso
matricola
mattone
maturo
mazurca
meandro
meccanico
mecenate
medesimo
meditare
mega
melassa
melis
melodia
meninge
meno
mensola
mercurio
merenda
merlo
meschino
mese
messere
mestolo
metallo
metodo
mettere
miagolare
mica
micelio
michele
microbo
midollo
miele
migliore
milano
milite
mimosa
minerale
mini
minore
mirino
mirtillo
miscela
missiva
misto
misurare
mitezza
mitigare
mitra
mittente
mnemonico
modello
modifica
modulo
mogano
mogio
mole
molosso
monastero
monco
mondina
monetario
monile
monotono
monsone
montato
monviso
mora
mordere
morsicato
mostro
motivato
motosega
motto
movenza
movimento
mozzo
mucca
mucosa
muffa
mughetto
mugnaio
mulatto
mulinello
multiplo
mummia
munto
muovere
murale
musa
muscolo
musica
mutevole
muto
nababbo
nafta
nanometro
narciso
narice
narrato
nascere
nastrare
naturale
nautica
naviglio
nebulosa
necrosi
negativo
negozio
nemmeno
neofita
neretto
nervo
nessuno
nettuno
neutrale
neve
nevrotico
nicchia
ninfa
nitido
nobile
nocivo
nodo
nome
nomina
nordico
normale
norvegese
nostrano
notare
notizia
notturno
novella
nucleo
nulla
numero
nuovo
nutrire
nuvola
nuziale
oasi
obbedire
obbligo
obelisco
oblio
obolo
obsoleto
occasione
occhio
occidente
occorrere
occultare
ocra
oculato
odierno
odorare
offerta
offrire
offuscato
oggetto
oggi
ognuno
olandese
olfatto
oliato
oliva
ologramma
oltre
omaggio
ombelico
ombra
omega
omissione
ondoso
onere
onice
onnivoro
onorevole
onta
operato
opinione
opposto
oracolo
orafo
ordine
orecchino
orefice
orfano
organico
origine
orizzonte
orma
ormeggio
ornativo
orologio
orrendo
orribile
ortensia
ortica
orzata
orzo
osare
oscurare
osmosi
ospedale
ospite
ossa
ossidare
ostacolo
oste
otite
otre
ottagono
ottimo
ottobre
ovale
ovest
ovino
oviparo
ovocito
ovunque
ovviare
ozio
pacchetto
pace
pacifico
padella
padrone
paese
paga
pagina
palazzina
palesare
pallido
palo
palude
pandoro
pannello
paolo
paonazzo
paprica
parabola
parcella
parere
pargolo
pari
parlato
parola
partire
parvenza
parziale
passivo
pasticca
patacca
patologia
pattume
pavone
peccato
pedalare
pedonale
peggio
peloso
penare
pendice
penisola
pennuto
penombra
pensare
pentola
pepe
pepita
perbene
percorso
perdonato
perforare
pergamena
periodo
permesso
perno
perplesso
persuaso
pertugio
pervaso
pesatore
pesista
peso
pestifero
petalo
pettine
petulante
pezzo
piacere
pianta
piattino
piccino
picozza
piega
pietra
piffero
pigiama
pigolio
pigro
pila
pilifero
pillola
pilota
pimpante
pineta
pinna
pinolo
pioggia
piombo
piramide
piretico
pirite
pirolisi
pitone
pizzico
placebo
planare
plasma
platano
plenario
pochezza
poderoso
podismo
poesia
poggiare
polenta
poligono
pollice
polmonite
polpetta
polso
poltrona
polvere
pomice
pomodoro
ponte
popoloso
porfido
poroso
porpora
porre
portata
posa
positivo
possesso
postulato
potassio
potere
pranzo
prassi
pratica
precluso
predica
prefisso
pregiato
prelievo
premere
prenotare
preparato
presenza
pretesto
prevalso
prima
principe
privato
problema
procura
produrre
profumo
progetto
prolunga
promessa
pronome
proposta
proroga
proteso
prova
prudente
prugna
prurito
psiche
pubblico
pudica
pugilato
pugno
pulce
pulito
pulsante
puntare
pupazzo
pupilla
puro
quadro
qualcosa
quasi
querela
quota
raccolto
raddoppio
radicale
radunato
raffica
ragazzo
ragione
ragno
ramarro
ramingo
ramo
randagio
rantolare
rapato
rapina
rappreso
rasatura
raschiato
rasente
rassegna
rastrello
rata
ravveduto
reale
recepire
recinto
recluta
recondito
recupero
reddito
redimere
regalato
registro
regola
regresso
relazione
remare
remoto
renna
replica
reprimere
reputare
resa
residente
responso
restauro
rete
retina
retorica
rettifica
revocato
riassunto
ribadire
ribelle
ribrezzo
ricarica
ricco
ricevere
riciclato
ricordo
ricreduto
ridicolo
ridurre
rifasare
riflesso
riforma
rifugio
rigare
rigettato
righello
rilassato
rilevato
rimanere
rimbalzo
rimedio
rimorchio
rinascita
rincaro
rinforzo
rinnovo
rinomato
rinsavito
rintocco
rinuncia
rinvenire
riparato
ripetuto
ripieno
riportare
ripresa
ripulire
risata
rischio
riserva
risibile
riso
rispetto
ristoro
risultato
risvolto
ritardo
ritegno
ritmico
ritrovo
riunione
riva
riverso
rivincita
rivolto
rizoma
roba
robotico
robusto
roccia
roco
rodaggio
rodere
roditore
rogito
rollio
romantico
rompere
ronzio
rosolare
rospo
rotante
rotondo
rotula
rovescio
rubizzo
rubrica
ruga
rullino
rumine
rumoroso
ruolo
rupe
russare
rustico
sabato
sabbiare
sabotato
sagoma
salasso
saldatura
salgemma
salivare
salmone
salone
saltare
saluto
salvo
sapere
sapido
saporito
saraceno
sarcasmo
sarto
sassoso
satellite
satira
satollo
saturno
savana
savio
saziato
sbadiglio
sbalzo
sbancato
sbarra
sbattere
sbavare
sbendare
sbirciare
sbloccato
sbocciato
sbrinare
sbruffone
sbuffare
scabroso
scadenza
scala
scambiare
scandalo
scapola
scarso
scatenare
scavato
scelto
scenico
scettro
scheda
schiena
sciarpa
scienza
scindere
scippo
sciroppo
scivolo
sclerare
scodella
scolpito
scomparto
sconforto
scoprire
scorta
scossone
scozzese
scriba
scrollare
scrutinio
scuderia
scultore
scuola
scuro
scusare
sdebitare
sdoganare
seccatura
secondo
sedano
seggiola
segnalato
segregato
seguito
selciato
selettivo
sella
selvaggio
semaforo
sembrare
seme
seminato
sempre
senso
sentire
sepolto
sequenza
serata
serbato
sereno
serio
serpente
serraglio
servire
sestina
setola
settimana
sfacelo
sfaldare
sfamato
sfarzoso
sfaticato
sfera
sfida
sfilato
sfinge
sfocato
sfoderare
sfogo
sfoltire
sforzato
sfratto
sfruttato
sfuggito
sfumare
sfuso
sgabello
sgarbato
sgonfiare
sgorbio
sgrassato
sguardo
sibilo
siccome
sierra
sigla
signore
silenzio
sillaba
simbolo
simpatico
simulato
sinfonia
singolo
sinistro
sino
sintesi
sinusoide
sipario
sisma
sistole
situato
slitta
slogatura
sloveno
smarrito
smemorato
smentito
smeraldo
smilzo
smontare
smottato
smussato
snellire
snervato
snodo
sobbalzo
sobrio
soccorso
sociale
sodale
soffitto
sogno
soldato
solenne
solido
sollazzo
solo
solubile
solvente
somatico
somma
sonda
sonetto
sonnifero
sopire
soppeso
sopra
sorgere
sorpasso
sorriso
sorso
sorteggio
sorvolato
sospiro
sosta
sottile
spada
spalla
spargere
spatola
spavento
spazzola
specie
spedire
spegnere
spelatura
speranza
spessore
spettrale
spezzato
spia
spigoloso
spillato
spinoso
spirale
splendido
sportivo
sposo
spranga
sprecare
spronato
spruzzo
spuntino
squillo
sradicare
srotolato
stabile
stacco
staffa
stagnare
stampato
stantio
starnuto
stasera
statuto
stelo
steppa
sterzo
stiletto
stima
stirpe
stivale
stizzoso
stonato
storico
strappo
stregato
stridulo
strozzare
strutto
stuccare
stufo
stupendo
subentro
succoso
sudore
suggerito
sugo
sultano
suonare
superbo
supporto
surgelato
surrogato
sussurro
sutura
svagare
svedese
sveglio
svelare
svenuto
svezia
sviluppo
svista
svizzera
svolta
svuotare
tabacco
tabulato
tacciare
taciturno
tale
talismano
tampone
tannino
tara
tardivo
targato
tariffa
tarpare
tartaruga
tasto
tattico
taverna
tavolata
tazza
teca
tecnico
telefono
temerario
tempo
temuto
tendone
tenero
tensione
tentacolo
teorema
terme
terrazzo
terzetto
tesi
tesserato
testato
tetro
tettoia
tifare
tigella
timbro
tinto
tipico
tipografo
tiraggio
tiro
titanio
titolo
titubante
tizio
tizzone
toccare
tollerare
tolto
tombola
tomo
tonfo
tonsilla
topazio
topologia
toppa
torba
tornare
torrone
tortora
toscano
tossire
tostatura
totano
trabocco
trachea
trafila
tragedia
tralcio
tramonto
transito
trapano
trarre
trasloco
trattato
trave
treccia
tremolio
trespolo
tributo
tricheco
trifoglio
trillo
trincea
trio
tristezza
triturato
trivella
tromba
trono
troppo
trottola
trovare
truccato
tubatura
tuffato
tulipano
tumulto
tunisia
turbare
turchino
tuta
tutela
ubicato
uccello
uccisore
udire
uditivo
uffa
ufficio
uguale
ulisse
ultimato
umano
umile
umorismo
uncinetto
ungere
ungherese
unicorno
unificato
unisono
unitario
unte
uovo
upupa
uragano
urgenza
urlo
usanza
usato
uscito
usignolo
usuraio
utensile
utilizzo
utopia
vacante
vaccinato
vagabondo
vagliato
valanga
valgo
valico
valletta
valoroso
valutare
valvola
vampata
vangare
vanitoso
vano
vantaggio
vanvera
vapore
varano
varcato
variante
vasca
vedetta
vedova
veduto
vegetale
veicolo
velcro
velina
velluto
veloce
venato
vendemmia
vento
verace
verbale
vergogna
verifica
vero
verruca
verticale
vescica
vessillo
vestale
veterano
vetrina
vetusto
viandante
vibrante
vicenda
vichingo
vicinanza
vidimare
vigilia
vigneto
vigore
vile
villano
vimini
vincitore
viola
vipera
virgola
virologo
virulento
viscoso
visione
vispo
vissuto
visura
vita
vitello
vittima
vivanda
vivido
viziare
voce
voga
volatile
volere
volpe
voragine
vulcano
zampogna
zanna
zappato
zattera
zavorra
zefiro
zelante
zelo
zenzero
zerbino
zibetto
zinco
zircone
zitto
zolla
zotico
zucchero
zufolo
zulu
zuppa`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/japanese.js
var wordlist5 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/korean.js
var wordlist6 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/portuguese.js
var wordlist7 = `abacate
abaixo
abalar
abater
abduzir
abelha
aberto
abismo
abotoar
abranger
abreviar
abrigar
abrupto
absinto
absoluto
absurdo
abutre
acabado
acalmar
acampar
acanhar
acaso
aceitar
acelerar
acenar
acervo
acessar
acetona
achatar
acidez
acima
acionado
acirrar
aclamar
aclive
acolhida
acomodar
acoplar
acordar
acumular
acusador
adaptar
adega
adentro
adepto
adequar
aderente
adesivo
adeus
adiante
aditivo
adjetivo
adjunto
admirar
adorar
adquirir
adubo
adverso
advogado
aeronave
afastar
aferir
afetivo
afinador
afivelar
aflito
afluente
afrontar
agachar
agarrar
agasalho
agenciar
agilizar
agiota
agitado
agora
agradar
agreste
agrupar
aguardar
agulha
ajoelhar
ajudar
ajustar
alameda
alarme
alastrar
alavanca
albergue
albino
alcatra
aldeia
alecrim
alegria
alertar
alface
alfinete
algum
alheio
aliar
alicate
alienar
alinhar
aliviar
almofada
alocar
alpiste
alterar
altitude
alucinar
alugar
aluno
alusivo
alvo
amaciar
amador
amarelo
amassar
ambas
ambiente
ameixa
amenizar
amido
amistoso
amizade
amolador
amontoar
amoroso
amostra
amparar
ampliar
ampola
anagrama
analisar
anarquia
anatomia
andaime
anel
anexo
angular
animar
anjo
anomalia
anotado
ansioso
anterior
anuidade
anunciar
anzol
apagador
apalpar
apanhado
apego
apelido
apertada
apesar
apetite
apito
aplauso
aplicada
apoio
apontar
aposta
aprendiz
aprovar
aquecer
arame
aranha
arara
arcada
ardente
areia
arejar
arenito
aresta
argiloso
argola
arma
arquivo
arraial
arrebate
arriscar
arroba
arrumar
arsenal
arterial
artigo
arvoredo
asfaltar
asilado
aspirar
assador
assinar
assoalho
assunto
astral
atacado
atadura
atalho
atarefar
atear
atender
aterro
ateu
atingir
atirador
ativo
atoleiro
atracar
atrevido
atriz
atual
atum
auditor
aumentar
aura
aurora
autismo
autoria
autuar
avaliar
avante
avaria
avental
avesso
aviador
avisar
avulso
axila
azarar
azedo
azeite
azulejo
babar
babosa
bacalhau
bacharel
bacia
bagagem
baiano
bailar
baioneta
bairro
baixista
bajular
baleia
baliza
balsa
banal
bandeira
banho
banir
banquete
barato
barbado
baronesa
barraca
barulho
baseado
bastante
batata
batedor
batida
batom
batucar
baunilha
beber
beijo
beirada
beisebol
beldade
beleza
belga
beliscar
bendito
bengala
benzer
berimbau
berlinda
berro
besouro
bexiga
bezerro
bico
bicudo
bienal
bifocal
bifurcar
bigorna
bilhete
bimestre
bimotor
biologia
biombo
biosfera
bipolar
birrento
biscoito
bisneto
bispo
bissexto
bitola
bizarro
blindado
bloco
bloquear
boato
bobagem
bocado
bocejo
bochecha
boicotar
bolada
boletim
bolha
bolo
bombeiro
bonde
boneco
bonita
borbulha
borda
boreal
borracha
bovino
boxeador
branco
brasa
braveza
breu
briga
brilho
brincar
broa
brochura
bronzear
broto
bruxo
bucha
budismo
bufar
bule
buraco
busca
busto
buzina
cabana
cabelo
cabide
cabo
cabrito
cacau
cacetada
cachorro
cacique
cadastro
cadeado
cafezal
caiaque
caipira
caixote
cajado
caju
calafrio
calcular
caldeira
calibrar
calmante
calota
camada
cambista
camisa
camomila
campanha
camuflar
canavial
cancelar
caneta
canguru
canhoto
canivete
canoa
cansado
cantar
canudo
capacho
capela
capinar
capotar
capricho
captador
capuz
caracol
carbono
cardeal
careca
carimbar
carneiro
carpete
carreira
cartaz
carvalho
casaco
casca
casebre
castelo
casulo
catarata
cativar
caule
causador
cautelar
cavalo
caverna
cebola
cedilha
cegonha
celebrar
celular
cenoura
censo
centeio
cercar
cerrado
certeiro
cerveja
cetim
cevada
chacota
chaleira
chamado
chapada
charme
chatice
chave
chefe
chegada
cheiro
cheque
chicote
chifre
chinelo
chocalho
chover
chumbo
chutar
chuva
cicatriz
ciclone
cidade
cidreira
ciente
cigana
cimento
cinto
cinza
ciranda
circuito
cirurgia
citar
clareza
clero
clicar
clone
clube
coado
coagir
cobaia
cobertor
cobrar
cocada
coelho
coentro
coeso
cogumelo
coibir
coifa
coiote
colar
coleira
colher
colidir
colmeia
colono
coluna
comando
combinar
comentar
comitiva
comover
complexo
comum
concha
condor
conectar
confuso
congelar
conhecer
conjugar
consumir
contrato
convite
cooperar
copeiro
copiador
copo
coquetel
coragem
cordial
corneta
coronha
corporal
correio
cortejo
coruja
corvo
cosseno
costela
cotonete
couro
couve
covil
cozinha
cratera
cravo
creche
credor
creme
crer
crespo
criada
criminal
crioulo
crise
criticar
crosta
crua
cruzeiro
cubano
cueca
cuidado
cujo
culatra
culminar
culpar
cultura
cumprir
cunhado
cupido
curativo
curral
cursar
curto
cuspir
custear
cutelo
damasco
datar
debater
debitar
deboche
debulhar
decalque
decimal
declive
decote
decretar
dedal
dedicado
deduzir
defesa
defumar
degelo
degrau
degustar
deitado
deixar
delator
delegado
delinear
delonga
demanda
demitir
demolido
dentista
depenado
depilar
depois
depressa
depurar
deriva
derramar
desafio
desbotar
descanso
desenho
desfiado
desgaste
desigual
deslize
desmamar
desova
despesa
destaque
desviar
detalhar
detentor
detonar
detrito
deusa
dever
devido
devotado
dezena
diagrama
dialeto
didata
difuso
digitar
dilatado
diluente
diminuir
dinastia
dinheiro
diocese
direto
discreta
disfarce
disparo
disquete
dissipar
distante
ditador
diurno
diverso
divisor
divulgar
dizer
dobrador
dolorido
domador
dominado
donativo
donzela
dormente
dorsal
dosagem
dourado
doutor
drenagem
drible
drogaria
duelar
duende
dueto
duplo
duquesa
durante
duvidoso
eclodir
ecoar
ecologia
edificar
edital
educado
efeito
efetivar
ejetar
elaborar
eleger
eleitor
elenco
elevador
eliminar
elogiar
embargo
embolado
embrulho
embutido
emenda
emergir
emissor
empatia
empenho
empinado
empolgar
emprego
empurrar
emulador
encaixe
encenado
enchente
encontro
endeusar
endossar
enfaixar
enfeite
enfim
engajado
engenho
englobar
engomado
engraxar
enguia
enjoar
enlatar
enquanto
enraizar
enrolado
enrugar
ensaio
enseada
ensino
ensopado
entanto
enteado
entidade
entortar
entrada
entulho
envergar
enviado
envolver
enxame
enxerto
enxofre
enxuto
epiderme
equipar
ereto
erguido
errata
erva
ervilha
esbanjar
esbelto
escama
escola
escrita
escuta
esfinge
esfolar
esfregar
esfumado
esgrima
esmalte
espanto
espelho
espiga
esponja
espreita
espumar
esquerda
estaca
esteira
esticar
estofado
estrela
estudo
esvaziar
etanol
etiqueta
euforia
europeu
evacuar
evaporar
evasivo
eventual
evidente
evoluir
exagero
exalar
examinar
exato
exausto
excesso
excitar
exclamar
executar
exemplo
exibir
exigente
exonerar
expandir
expelir
expirar
explanar
exposto
expresso
expulsar
externo
extinto
extrato
fabricar
fabuloso
faceta
facial
fada
fadiga
faixa
falar
falta
familiar
fandango
fanfarra
fantoche
fardado
farelo
farinha
farofa
farpa
fartura
fatia
fator
favorita
faxina
fazenda
fechado
feijoada
feirante
felino
feminino
fenda
feno
fera
feriado
ferrugem
ferver
festejar
fetal
feudal
fiapo
fibrose
ficar
ficheiro
figurado
fileira
filho
filme
filtrar
firmeza
fisgada
fissura
fita
fivela
fixador
fixo
flacidez
flamingo
flanela
flechada
flora
flutuar
fluxo
focal
focinho
fofocar
fogo
foguete
foice
folgado
folheto
forjar
formiga
forno
forte
fosco
fossa
fragata
fralda
frango
frasco
fraterno
freira
frente
fretar
frieza
friso
fritura
fronha
frustrar
fruteira
fugir
fulano
fuligem
fundar
fungo
funil
furador
furioso
futebol
gabarito
gabinete
gado
gaiato
gaiola
gaivota
galega
galho
galinha
galocha
ganhar
garagem
garfo
gargalo
garimpo
garoupa
garrafa
gasoduto
gasto
gata
gatilho
gaveta
gazela
gelado
geleia
gelo
gemada
gemer
gemido
generoso
gengiva
genial
genoma
genro
geologia
gerador
germinar
gesso
gestor
ginasta
gincana
gingado
girafa
girino
glacial
glicose
global
glorioso
goela
goiaba
golfe
golpear
gordura
gorjeta
gorro
gostoso
goteira
governar
gracejo
gradual
grafite
gralha
grampo
granada
gratuito
graveto
graxa
grego
grelhar
greve
grilo
grisalho
gritaria
grosso
grotesco
grudado
grunhido
gruta
guache
guarani
guaxinim
guerrear
guiar
guincho
guisado
gula
guloso
guru
habitar
harmonia
haste
haver
hectare
herdar
heresia
hesitar
hiato
hibernar
hidratar
hiena
hino
hipismo
hipnose
hipoteca
hoje
holofote
homem
honesto
honrado
hormonal
hospedar
humorado
iate
ideia
idoso
ignorado
igreja
iguana
ileso
ilha
iludido
iluminar
ilustrar
imagem
imediato
imenso
imersivo
iminente
imitador
imortal
impacto
impedir
implante
impor
imprensa
impune
imunizar
inalador
inapto
inativo
incenso
inchar
incidir
incluir
incolor
indeciso
indireto
indutor
ineficaz
inerente
infantil
infestar
infinito
inflamar
informal
infrator
ingerir
inibido
inicial
inimigo
injetar
inocente
inodoro
inovador
inox
inquieto
inscrito
inseto
insistir
inspetor
instalar
insulto
intacto
integral
intimar
intocado
intriga
invasor
inverno
invicto
invocar
iogurte
iraniano
ironizar
irreal
irritado
isca
isento
isolado
isqueiro
italiano
janeiro
jangada
janta
jararaca
jardim
jarro
jasmim
jato
javali
jazida
jejum
joaninha
joelhada
jogador
joia
jornal
jorrar
jovem
juba
judeu
judoca
juiz
julgador
julho
jurado
jurista
juro
justa
labareda
laboral
lacre
lactante
ladrilho
lagarta
lagoa
laje
lamber
lamentar
laminar
lampejo
lanche
lapidar
lapso
laranja
lareira
largura
lasanha
lastro
lateral
latido
lavanda
lavoura
lavrador
laxante
lazer
lealdade
lebre
legado
legendar
legista
leigo
leiloar
leitura
lembrete
leme
lenhador
lentilha
leoa
lesma
leste
letivo
letreiro
levar
leveza
levitar
liberal
libido
liderar
ligar
ligeiro
limitar
limoeiro
limpador
linda
linear
linhagem
liquidez
listagem
lisura
litoral
livro
lixa
lixeira
locador
locutor
lojista
lombo
lona
longe
lontra
lorde
lotado
loteria
loucura
lousa
louvar
luar
lucidez
lucro
luneta
lustre
lutador
luva
macaco
macete
machado
macio
madeira
madrinha
magnata
magreza
maior
mais
malandro
malha
malote
maluco
mamilo
mamoeiro
mamute
manada
mancha
mandato
manequim
manhoso
manivela
manobrar
mansa
manter
manusear
mapeado
maquinar
marcador
maresia
marfim
margem
marinho
marmita
maroto
marquise
marreco
martelo
marujo
mascote
masmorra
massagem
mastigar
matagal
materno
matinal
matutar
maxilar
medalha
medida
medusa
megafone
meiga
melancia
melhor
membro
memorial
menino
menos
mensagem
mental
merecer
mergulho
mesada
mesclar
mesmo
mesquita
mestre
metade
meteoro
metragem
mexer
mexicano
micro
migalha
migrar
milagre
milenar
milhar
mimado
minerar
minhoca
ministro
minoria
miolo
mirante
mirtilo
misturar
mocidade
moderno
modular
moeda
moer
moinho
moita
moldura
moleza
molho
molinete
molusco
montanha
moqueca
morango
morcego
mordomo
morena
mosaico
mosquete
mostarda
motel
motim
moto
motriz
muda
muito
mulata
mulher
multar
mundial
munido
muralha
murcho
muscular
museu
musical
nacional
nadador
naja
namoro
narina
narrado
nascer
nativa
natureza
navalha
navegar
navio
neblina
nebuloso
negativa
negociar
negrito
nervoso
neta
neural
nevasca
nevoeiro
ninar
ninho
nitidez
nivelar
nobreza
noite
noiva
nomear
nominal
nordeste
nortear
notar
noticiar
noturno
novelo
novilho
novo
nublado
nudez
numeral
nupcial
nutrir
nuvem
obcecado
obedecer
objetivo
obrigado
obscuro
obstetra
obter
obturar
ocidente
ocioso
ocorrer
oculista
ocupado
ofegante
ofensiva
oferenda
oficina
ofuscado
ogiva
olaria
oleoso
olhar
oliveira
ombro
omelete
omisso
omitir
ondulado
oneroso
ontem
opcional
operador
oponente
oportuno
oposto
orar
orbitar
ordem
ordinal
orfanato
orgasmo
orgulho
oriental
origem
oriundo
orla
ortodoxo
orvalho
oscilar
ossada
osso
ostentar
otimismo
ousadia
outono
outubro
ouvido
ovelha
ovular
oxidar
oxigenar
pacato
paciente
pacote
pactuar
padaria
padrinho
pagar
pagode
painel
pairar
paisagem
palavra
palestra
palheta
palito
palmada
palpitar
pancada
panela
panfleto
panqueca
pantanal
papagaio
papelada
papiro
parafina
parcial
pardal
parede
partida
pasmo
passado
pastel
patamar
patente
patinar
patrono
paulada
pausar
peculiar
pedalar
pedestre
pediatra
pedra
pegada
peitoral
peixe
pele
pelicano
penca
pendurar
peneira
penhasco
pensador
pente
perceber
perfeito
pergunta
perito
permitir
perna
perplexo
persiana
pertence
peruca
pescado
pesquisa
pessoa
petiscar
piada
picado
piedade
pigmento
pilastra
pilhado
pilotar
pimenta
pincel
pinguim
pinha
pinote
pintar
pioneiro
pipoca
piquete
piranha
pires
pirueta
piscar
pistola
pitanga
pivete
planta
plaqueta
platina
plebeu
plumagem
pluvial
pneu
poda
poeira
poetisa
polegada
policiar
poluente
polvilho
pomar
pomba
ponderar
pontaria
populoso
porta
possuir
postal
pote
poupar
pouso
povoar
praia
prancha
prato
praxe
prece
predador
prefeito
premiar
prensar
preparar
presilha
pretexto
prevenir
prezar
primata
princesa
prisma
privado
processo
produto
profeta
proibido
projeto
prometer
propagar
prosa
protetor
provador
publicar
pudim
pular
pulmonar
pulseira
punhal
punir
pupilo
pureza
puxador
quadra
quantia
quarto
quase
quebrar
queda
queijo
quente
querido
quimono
quina
quiosque
rabanada
rabisco
rachar
racionar
radial
raiar
rainha
raio
raiva
rajada
ralado
ramal
ranger
ranhura
rapadura
rapel
rapidez
raposa
raquete
raridade
rasante
rascunho
rasgar
raspador
rasteira
rasurar
ratazana
ratoeira
realeza
reanimar
reaver
rebaixar
rebelde
rebolar
recado
recente
recheio
recibo
recordar
recrutar
recuar
rede
redimir
redonda
reduzida
reenvio
refinar
refletir
refogar
refresco
refugiar
regalia
regime
regra
reinado
reitor
rejeitar
relativo
remador
remendo
remorso
renovado
reparo
repelir
repleto
repolho
represa
repudiar
requerer
resenha
resfriar
resgatar
residir
resolver
respeito
ressaca
restante
resumir
retalho
reter
retirar
retomada
retratar
revelar
revisor
revolta
riacho
rica
rigidez
rigoroso
rimar
ringue
risada
risco
risonho
robalo
rochedo
rodada
rodeio
rodovia
roedor
roleta
romano
roncar
rosado
roseira
rosto
rota
roteiro
rotina
rotular
rouco
roupa
roxo
rubro
rugido
rugoso
ruivo
rumo
rupestre
russo
sabor
saciar
sacola
sacudir
sadio
safira
saga
sagrada
saibro
salada
saleiro
salgado
saliva
salpicar
salsicha
saltar
salvador
sambar
samurai
sanar
sanfona
sangue
sanidade
sapato
sarda
sargento
sarjeta
saturar
saudade
saxofone
sazonal
secar
secular
seda
sedento
sediado
sedoso
sedutor
segmento
segredo
segundo
seiva
seleto
selvagem
semanal
semente
senador
senhor
sensual
sentado
separado
sereia
seringa
serra
servo
setembro
setor
sigilo
silhueta
silicone
simetria
simpatia
simular
sinal
sincero
singular
sinopse
sintonia
sirene
siri
situado
soberano
sobra
socorro
sogro
soja
solda
soletrar
solteiro
sombrio
sonata
sondar
sonegar
sonhador
sono
soprano
soquete
sorrir
sorteio
sossego
sotaque
soterrar
sovado
sozinho
suavizar
subida
submerso
subsolo
subtrair
sucata
sucesso
suco
sudeste
sufixo
sugador
sugerir
sujeito
sulfato
sumir
suor
superior
suplicar
suposto
suprimir
surdina
surfista
surpresa
surreal
surtir
suspiro
sustento
tabela
tablete
tabuada
tacho
tagarela
talher
talo
talvez
tamanho
tamborim
tampa
tangente
tanto
tapar
tapioca
tardio
tarefa
tarja
tarraxa
tatuagem
taurino
taxativo
taxista
teatral
tecer
tecido
teclado
tedioso
teia
teimar
telefone
telhado
tempero
tenente
tensor
tentar
termal
terno
terreno
tese
tesoura
testado
teto
textura
texugo
tiara
tigela
tijolo
timbrar
timidez
tingido
tinteiro
tiragem
titular
toalha
tocha
tolerar
tolice
tomada
tomilho
tonel
tontura
topete
tora
torcido
torneio
torque
torrada
torto
tostar
touca
toupeira
toxina
trabalho
tracejar
tradutor
trafegar
trajeto
trama
trancar
trapo
traseiro
tratador
travar
treino
tremer
trepidar
trevo
triagem
tribo
triciclo
tridente
trilogia
trindade
triplo
triturar
triunfal
trocar
trombeta
trova
trunfo
truque
tubular
tucano
tudo
tulipa
tupi
turbo
turma
turquesa
tutelar
tutorial
uivar
umbigo
unha
unidade
uniforme
urologia
urso
urtiga
urubu
usado
usina
usufruir
vacina
vadiar
vagaroso
vaidoso
vala
valente
validade
valores
vantagem
vaqueiro
varanda
vareta
varrer
vascular
vasilha
vassoura
vazar
vazio
veado
vedar
vegetar
veicular
veleiro
velhice
veludo
vencedor
vendaval
venerar
ventre
verbal
verdade
vereador
vergonha
vermelho
verniz
versar
vertente
vespa
vestido
vetorial
viaduto
viagem
viajar
viatura
vibrador
videira
vidraria
viela
viga
vigente
vigiar
vigorar
vilarejo
vinco
vinheta
vinil
violeta
virada
virtude
visitar
visto
vitral
viveiro
vizinho
voador
voar
vogal
volante
voleibol
voltagem
volumoso
vontade
vulto
vuvuzela
xadrez
xarope
xeque
xeretar
xerife
xingar
zangado
zarpar
zebu
zelador
zombar
zoologia
zumbido`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/simplified-chinese.js
var wordlist8 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/spanish.js
var wordlist9 = `abaco
abdomen
abeja
abierto
abogado
abono
aborto
abrazo
abrir
abuelo
abuso
acabar
academia
acceso
accion
aceite
acelga
acento
aceptar
acido
aclarar
acne
acoger
acoso
activo
acto
actriz
actuar
acudir
acuerdo
acusar
adicto
admitir
adoptar
adorno
aduana
adulto
aereo
afectar
aficion
afinar
afirmar
agil
agitar
agonia
agosto
agotar
agregar
agrio
agua
agudo
aguila
aguja
ahogo
ahorro
aire
aislar
ajedrez
ajeno
ajuste
alacran
alambre
alarma
alba
album
alcalde
aldea
alegre
alejar
alerta
aleta
alfiler
alga
algodon
aliado
aliento
alivio
alma
almeja
almibar
altar
alteza
altivo
alto
altura
alumno
alzar
amable
amante
amapola
amargo
amasar
ambar
ambito
ameno
amigo
amistad
amor
amparo
amplio
ancho
anciano
ancla
andar
anden
anemia
angulo
anillo
animo
anis
anotar
antena
antiguo
antojo
anual
anular
anuncio
anadir
anejo
ano
apagar
aparato
apetito
apio
aplicar
apodo
aporte
apoyo
aprender
aprobar
apuesta
apuro
arado
arana
arar
arbitro
arbol
arbusto
archivo
arco
arder
ardilla
arduo
area
arido
aries
armonia
arnes
aroma
arpa
arpon
arreglo
arroz
arruga
arte
artista
asa
asado
asalto
ascenso
asegurar
aseo
asesor
asiento
asilo
asistir
asno
asombro
aspero
astilla
astro
astuto
asumir
asunto
atajo
ataque
atar
atento
ateo
atico
atleta
atomo
atraer
atroz
atun
audaz
audio
auge
aula
aumento
ausente
autor
aval
avance
avaro
ave
avellana
avena
avestruz
avion
aviso
ayer
ayuda
ayuno
azafran
azar
azote
azucar
azufre
azul
baba
babor
bache
bahia
baile
bajar
balanza
balcon
balde
bambu
banco
banda
bano
barba
barco
barniz
barro
bascula
baston
basura
batalla
bateria
batir
batuta
baul
bazar
bebe
bebida
bello
besar
beso
bestia
bicho
bien
bingo
blanco
bloque
blusa
boa
bobina
bobo
boca
bocina
boda
bodega
boina
bola
bolero
bolsa
bomba
bondad
bonito
bono
bonsai
borde
borrar
bosque
bote
botin
boveda
bozal
bravo
brazo
brecha
breve
brillo
brinco
brisa
broca
broma
bronce
brote
bruja
brusco
bruto
buceo
bucle
bueno
buey
bufanda
bufon
buho
buitre
bulto
burbuja
burla
burro
buscar
butaca
buzon
caballo
cabeza
cabina
cabra
cacao
cadaver
cadena
caer
cafe
caida
caiman
caja
cajon
cal
calamar
calcio
caldo
calidad
calle
calma
calor
calvo
cama
cambio
camello
camino
campo
cancer
candil
canela
canguro
canica
canto
cana
canon
caoba
caos
capaz
capitan
capote
captar
capucha
cara
carbon
carcel
careta
carga
carino
carne
carpeta
carro
carta
casa
casco
casero
caspa
castor
catorce
catre
caudal
causa
cazo
cebolla
ceder
cedro
celda
celebre
celoso
celula
cemento
ceniza
centro
cerca
cerdo
cereza
cero
cerrar
certeza
cesped
cetro
chacal
chaleco
champu
chancla
chapa
charla
chico
chiste
chivo
choque
choza
chuleta
chupar
ciclon
ciego
cielo
cien
cierto
cifra
cigarro
cima
cinco
cine
cinta
cipres
circo
ciruela
cisne
cita
ciudad
clamor
clan
claro
clase
clave
cliente
clima
clinica
cobre
coccion
cochino
cocina
coco
codigo
codo
cofre
coger
cohete
cojin
cojo
cola
colcha
colegio
colgar
colina
collar
colmo
columna
combate
comer
comida
comodo
compra
conde
conejo
conga
conocer
consejo
contar
copa
copia
corazon
corbata
corcho
cordon
corona
correr
coser
cosmos
costa
craneo
crater
crear
crecer
creido
crema
cria
crimen
cripta
crisis
cromo
cronica
croqueta
crudo
cruz
cuadro
cuarto
cuatro
cubo
cubrir
cuchara
cuello
cuento
cuerda
cuesta
cueva
cuidar
culebra
culpa
culto
cumbre
cumplir
cuna
cuneta
cuota
cupon
cupula
curar
curioso
curso
curva
cutis
dama
danza
dar
dardo
datil
deber
debil
decada
decir
dedo
defensa
definir
dejar
delfin
delgado
delito
demora
denso
dental
deporte
derecho
derrota
desayuno
deseo
desfile
desnudo
destino
desvio
detalle
detener
deuda
dia
diablo
diadema
diamante
diana
diario
dibujo
dictar
diente
dieta
diez
dificil
digno
dilema
diluir
dinero
directo
dirigir
disco
diseno
disfraz
diva
divino
doble
doce
dolor
domingo
don
donar
dorado
dormir
dorso
dos
dosis
dragon
droga
ducha
duda
duelo
dueno
dulce
duo
duque
durar
dureza
duro
ebano
ebrio
echar
eco
ecuador
edad
edicion
edificio
editor
educar
efecto
eficaz
eje
ejemplo
elefante
elegir
elemento
elevar
elipse
elite
elixir
elogio
eludir
embudo
emitir
emocion
empate
empeno
empleo
empresa
enano
encargo
enchufe
encia
enemigo
enero
enfado
enfermo
engano
enigma
enlace
enorme
enredo
ensayo
ensenar
entero
entrar
envase
envio
epoca
equipo
erizo
escala
escena
escolar
escribir
escudo
esencia
esfera
esfuerzo
espada
espejo
espia
esposa
espuma
esqui
estar
este
estilo
estufa
etapa
eterno
etica
etnia
evadir
evaluar
evento
evitar
exacto
examen
exceso
excusa
exento
exigir
exilio
existir
exito
experto
explicar
exponer
extremo
fabrica
fabula
fachada
facil
factor
faena
faja
falda
fallo
falso
faltar
fama
familia
famoso
faraon
farmacia
farol
farsa
fase
fatiga
fauna
favor
fax
febrero
fecha
feliz
feo
feria
feroz
fertil
fervor
festin
fiable
fianza
fiar
fibra
ficcion
ficha
fideo
fiebre
fiel
fiera
fiesta
figura
fijar
fijo
fila
filete
filial
filtro
fin
finca
fingir
finito
firma
flaco
flauta
flecha
flor
flota
fluir
flujo
fluor
fobia
foca
fogata
fogon
folio
folleto
fondo
forma
forro
fortuna
forzar
fosa
foto
fracaso
fragil
franja
frase
fraude
freir
freno
fresa
frio
frito
fruta
fuego
fuente
fuerza
fuga
fumar
funcion
funda
furgon
furia
fusil
futbol
futuro
gacela
gafas
gaita
gajo
gala
galeria
gallo
gamba
ganar
gancho
ganga
ganso
garaje
garza
gasolina
gastar
gato
gavilan
gemelo
gemir
gen
genero
genio
gente
geranio
gerente
germen
gesto
gigante
gimnasio
girar
giro
glaciar
globo
gloria
gol
golfo
goloso
golpe
goma
gordo
gorila
gorra
gota
goteo
gozar
grada
grafico
grano
grasa
gratis
grave
grieta
grillo
gripe
gris
grito
grosor
grua
grueso
grumo
grupo
guante
guapo
guardia
guerra
guia
guino
guion
guiso
guitarra
gusano
gustar
haber
habil
hablar
hacer
hacha
hada
hallar
hamaca
harina
haz
hazana
hebilla
hebra
hecho
helado
helio
hembra
herir
hermano
heroe
hervir
hielo
hierro
higado
higiene
hijo
himno
historia
hocico
hogar
hoguera
hoja
hombre
hongo
honor
honra
hora
hormiga
horno
hostil
hoyo
hueco
huelga
huerta
hueso
huevo
huida
huir
humano
humedo
humilde
humo
hundir
huracan
hurto
icono
ideal
idioma
idolo
iglesia
iglu
igual
ilegal
ilusion
imagen
iman
imitar
impar
imperio
imponer
impulso
incapaz
indice
inerte
infiel
informe
ingenio
inicio
inmenso
inmune
innato
insecto
instante
interes
intimo
intuir
inutil
invierno
ira
iris
ironia
isla
islote
jabali
jabon
jamon
jarabe
jardin
jarra
jaula
jazmin
jefe
jeringa
jinete
jornada
joroba
joven
joya
juerga
jueves
juez
jugador
jugo
juguete
juicio
junco
jungla
junio
juntar
jupiter
jurar
justo
juvenil
juzgar
kilo
koala
labio
lacio
lacra
lado
ladron
lagarto
lagrima
laguna
laico
lamer
lamina
lampara
lana
lancha
langosta
lanza
lapiz
largo
larva
lastima
lata
latex
latir
laurel
lavar
lazo
leal
leccion
leche
lector
leer
legion
legumbre
lejano
lengua
lento
lena
leon
leopardo
lesion
letal
letra
leve
leyenda
libertad
libro
licor
lider
lidiar
lienzo
liga
ligero
lima
limite
limon
limpio
lince
lindo
linea
lingote
lino
linterna
liquido
liso
lista
litera
litio
litro
llaga
llama
llanto
llave
llegar
llenar
llevar
llorar
llover
lluvia
lobo
locion
loco
locura
logica
logro
lombriz
lomo
lonja
lote
lucha
lucir
lugar
lujo
luna
lunes
lupa
lustro
luto
luz
maceta
macho
madera
madre
maduro
maestro
mafia
magia
mago
maiz
maldad
maleta
malla
malo
mama
mambo
mamut
manco
mando
manejar
manga
maniqui
manjar
mano
manso
manta
manana
mapa
maquina
mar
marco
marea
marfil
margen
marido
marmol
marron
martes
marzo
masa
mascara
masivo
matar
materia
matiz
matriz
maximo
mayor
mazorca
mecha
medalla
medio
medula
mejilla
mejor
melena
melon
memoria
menor
mensaje
mente
menu
mercado
merengue
merito
mes
meson
meta
meter
metodo
metro
mezcla
miedo
miel
miembro
miga
mil
milagro
militar
millon
mimo
mina
minero
minimo
minuto
miope
mirar
misa
miseria
misil
mismo
mitad
mito
mochila
mocion
moda
modelo
moho
mojar
molde
moler
molino
momento
momia
monarca
moneda
monja
monto
mono
morada
morder
moreno
morir
morro
morsa
mortal
mosca
mostrar
motivo
mover
movil
mozo
mucho
mudar
mueble
muela
muerte
muestra
mugre
mujer
mula
muleta
multa
mundo
muneca
mural
muro
musculo
museo
musgo
musica
muslo
nacar
nacion
nadar
naipe
naranja
nariz
narrar
nasal
natal
nativo
natural
nausea
naval
nave
navidad
necio
nectar
negar
negocio
negro
neon
nervio
neto
neutro
nevar
nevera
nicho
nido
niebla
nieto
ninez
nino
nitido
nivel
nobleza
noche
nomina
noria
norma
norte
nota
noticia
novato
novela
novio
nube
nuca
nucleo
nudillo
nudo
nuera
nueve
nuez
nulo
numero
nutria
oasis
obeso
obispo
objeto
obra
obrero
observar
obtener
obvio
oca
ocaso
oceano
ochenta
ocho
ocio
ocre
octavo
octubre
oculto
ocupar
ocurrir
odiar
odio
odisea
oeste
ofensa
oferta
oficio
ofrecer
ogro
oido
oir
ojo
ola
oleada
olfato
olivo
olla
olmo
olor
olvido
ombligo
onda
onza
opaco
opcion
opera
opinar
oponer
optar
optica
opuesto
oracion
orador
oral
orbita
orca
orden
oreja
organo
orgia
orgullo
oriente
origen
orilla
oro
orquesta
oruga
osadia
oscuro
osezno
oso
ostra
otono
otro
oveja
ovulo
oxido
oxigeno
oyente
ozono
pacto
padre
paella
pagina
pago
pais
pajaro
palabra
palco
paleta
palido
palma
paloma
palpar
pan
panal
panico
pantera
panuelo
papa
papel
papilla
paquete
parar
parcela
pared
parir
paro
parpado
parque
parrafo
parte
pasar
paseo
pasion
paso
pasta
pata
patio
patria
pausa
pauta
pavo
payaso
peaton
pecado
pecera
pecho
pedal
pedir
pegar
peine
pelar
peldano
pelea
peligro
pellejo
pelo
peluca
pena
pensar
penon
peon
peor
pepino
pequeno
pera
percha
perder
pereza
perfil
perico
perla
permiso
perro
persona
pesa
pesca
pesimo
pestana
petalo
petroleo
pez
pezuna
picar
pichon
pie
piedra
pierna
pieza
pijama
pilar
piloto
pimienta
pino
pintor
pinza
pina
piojo
pipa
pirata
pisar
piscina
piso
pista
piton
pizca
placa
plan
plata
playa
plaza
pleito
pleno
plomo
pluma
plural
pobre
poco
poder
podio
poema
poesia
poeta
polen
policia
pollo
polvo
pomada
pomelo
pomo
pompa
poner
porcion
portal
posada
poseer
posible
poste
potencia
potro
pozo
prado
precoz
pregunta
premio
prensa
preso
previo
primo
principe
prision
privar
proa
probar
proceso
producto
proeza
profesor
programa
prole
promesa
pronto
propio
proximo
prueba
publico
puchero
pudor
pueblo
puerta
puesto
pulga
pulir
pulmon
pulpo
pulso
puma
punto
punal
puno
pupa
pupila
pure
quedar
queja
quemar
querer
queso
quieto
quimica
quince
quitar
rabano
rabia
rabo
racion
radical
raiz
rama
rampa
rancho
rango
rapaz
rapido
rapto
rasgo
raspa
rato
rayo
raza
razon
reaccion
realidad
rebano
rebote
recaer
receta
rechazo
recoger
recreo
recto
recurso
red
redondo
reducir
reflejo
reforma
refran
refugio
regalo
regir
regla
regreso
rehen
reino
reir
reja
relato
relevo
relieve
relleno
reloj
remar
remedio
remo
rencor
rendir
renta
reparto
repetir
reposo
reptil
res
rescate
resina
respeto
resto
resumen
retiro
retorno
retrato
reunir
reves
revista
rey
rezar
rico
riego
rienda
riesgo
rifa
rigido
rigor
rincon
rinon
rio
riqueza
risa
ritmo
rito
rizo
roble
roce
rociar
rodar
rodeo
rodilla
roer
rojizo
rojo
romero
romper
ron
ronco
ronda
ropa
ropero
rosa
rosca
rostro
rotar
rubi
rubor
rudo
rueda
rugir
ruido
ruina
ruleta
rulo
rumbo
rumor
ruptura
ruta
rutina
sabado
saber
sabio
sable
sacar
sagaz
sagrado
sala
saldo
salero
salir
salmon
salon
salsa
salto
salud
salvar
samba
sancion
sandia
sanear
sangre
sanidad
sano
santo
sapo
saque
sardina
sarten
sastre
satan
sauna
saxofon
seccion
seco
secreto
secta
sed
seguir
seis
sello
selva
semana
semilla
senda
sensor
senal
senor
separar
sepia
sequia
ser
serie
sermon
servir
sesenta
sesion
seta
setenta
severo
sexo
sexto
sidra
siesta
siete
siglo
signo
silaba
silbar
silencio
silla
simbolo
simio
sirena
sistema
sitio
situar
sobre
socio
sodio
sol
solapa
soldado
soledad
solido
soltar
solucion
sombra
sondeo
sonido
sonoro
sonrisa
sopa
soplar
soporte
sordo
sorpresa
sorteo
sosten
sotano
suave
subir
suceso
sudor
suegra
suelo
sueno
suerte
sufrir
sujeto
sultan
sumar
superar
suplir
suponer
supremo
sur
surco
sureno
surgir
susto
sutil
tabaco
tabique
tabla
tabu
taco
tacto
tajo
talar
talco
talento
talla
talon
tamano
tambor
tango
tanque
tapa
tapete
tapia
tapon
taquilla
tarde
tarea
tarifa
tarjeta
tarot
tarro
tarta
tatuaje
tauro
taza
tazon
teatro
techo
tecla
tecnica
tejado
tejer
tejido
tela
telefono
tema
temor
templo
tenaz
tender
tener
tenis
tenso
teoria
terapia
terco
termino
ternura
terror
tesis
tesoro
testigo
tetera
texto
tez
tibio
tiburon
tiempo
tienda
tierra
tieso
tigre
tijera
tilde
timbre
timido
timo
tinta
tio
tipico
tipo
tira
tiron
titan
titere
titulo
tiza
toalla
tobillo
tocar
tocino
todo
toga
toldo
tomar
tono
tonto
topar
tope
toque
torax
torero
tormenta
torneo
toro
torpedo
torre
torso
tortuga
tos
tosco
toser
toxico
trabajo
tractor
traer
trafico
trago
traje
tramo
trance
trato
trauma
trazar
trebol
tregua
treinta
tren
trepar
tres
tribu
trigo
tripa
triste
triunfo
trofeo
trompa
tronco
tropa
trote
trozo
truco
trueno
trufa
tuberia
tubo
tuerto
tumba
tumor
tunel
tunica
turbina
turismo
turno
tutor
ubicar
ulcera
umbral
unidad
unir
universo
uno
untar
una
urbano
urbe
urgente
urna
usar
usuario
util
utopia
uva
vaca
vacio
vacuna
vagar
vago
vaina
vajilla
vale
valido
valle
valor
valvula
vampiro
vara
variar
varon
vaso
vecino
vector
vehiculo
veinte
vejez
vela
velero
veloz
vena
vencer
venda
veneno
vengar
venir
venta
venus
ver
verano
verbo
verde
vereda
verja
verso
verter
via
viaje
vibrar
vicio
victima
vida
video
vidrio
viejo
viernes
vigor
vil
villa
vinagre
vino
vinedo
violin
viral
virgo
virtud
visor
vispera
vista
vitamina
viudo
vivaz
vivero
vivir
vivo
volcan
volumen
volver
voraz
votar
voto
voz
vuelo
vulgar
yacer
yate
yegua
yema
yerno
yeso
yodo
yoga
yogur
zafiro
zanja
zapato
zarza
zona
zorro
zumo
zurdo`.split("\n");

// node_modules/@scure/bip39/esm/wordlists/traditional-chinese.js
var wordlist10 = `






























































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































































`.split("\n");

// node_modules/ox/_esm/core/Mnemonic.js
function random2(wordlist11, options = {}) {
  const { strength = 128 } = options;
  return generateMnemonic(wordlist11, strength);
}
function toHdKey(mnemonic, options = {}) {
  const { passphrase } = options;
  const seed = toSeed(mnemonic, { passphrase });
  return fromSeed(seed);
}
function toPrivateKey(mnemonic, options = {}) {
  const { path: path2 = path(), passphrase } = options;
  const hdKey = toHdKey(mnemonic, { passphrase }).derive(path2);
  if (options.as === "Bytes")
    return from(hdKey.privateKey);
  return hdKey.privateKey;
}
function toSeed(mnemonic, options = {}) {
  const { passphrase } = options;
  const seed = mnemonicToSeedSync(mnemonic, passphrase);
  if (options.as === "Hex")
    return toHex2(seed);
  return seed;
}
function validate7(mnemonic, wordlist11) {
  return validateMnemonic(mnemonic, wordlist11);
}

// node_modules/ox/_esm/core/PersonalMessage.js
var PersonalMessage_exports = {};
__export(PersonalMessage_exports, {
  encode: () => encode4,
  getSignPayload: () => getSignPayload2
});
function encode4(data) {
  const message = from2(data);
  return concat2(
    // Personal Sign Format: `0x19  "Ethereum Signed Message:\n"  message.length  message`
    "0x19",
    fromString2("Ethereum Signed Message:\n" + size2(message)),
    message
  );
}
function getSignPayload2(data) {
  return keccak2562(encode4(data));
}

// node_modules/ox/_esm/core/Provider.js
var Provider_exports = {};
__export(Provider_exports, {
  ChainDisconnectedError: () => ChainDisconnectedError2,
  DisconnectedError: () => DisconnectedError,
  IsUndefinedError: () => IsUndefinedError,
  ProviderRpcError: () => ProviderRpcError,
  UnauthorizedError: () => UnauthorizedError,
  UnsupportedMethodError: () => UnsupportedMethodError,
  UserRejectedRequestError: () => UserRejectedRequestError2,
  createEmitter: () => createEmitter2,
  from: () => from17,
  parseError: () => parseError2
});

// node_modules/ox/node_modules/eventemitter3/index.mjs
var import_index8 = __toESM(require_eventemitter32(), 1);

// node_modules/ox/_esm/core/RpcResponse.js
var RpcResponse_exports = {};
__export(RpcResponse_exports, {
  BaseError: () => BaseError6,
  InternalError: () => InternalError,
  InvalidInputError: () => InvalidInputError2,
  InvalidParamsError: () => InvalidParamsError,
  InvalidRequestError: () => InvalidRequestError,
  LimitExceededError: () => LimitExceededError,
  MethodNotFoundError: () => MethodNotFoundError,
  MethodNotSupportedError: () => MethodNotSupportedError,
  ParseError: () => ParseError,
  ResourceNotFoundError: () => ResourceNotFoundError,
  ResourceUnavailableError: () => ResourceUnavailableError,
  TransactionRejectedError: () => TransactionRejectedError,
  VersionNotSupportedError: () => VersionNotSupportedError,
  from: () => from16,
  parse: () => parse2,
  parseError: () => parseError
});
function from16(response, options = {}) {
  const { request } = options;
  return {
    ...response,
    id: response.id ?? (request == null ? void 0 : request.id),
    jsonrpc: response.jsonrpc ?? request.jsonrpc
  };
}
function parse2(response, options = {}) {
  const { raw = false } = options;
  const response_ = response;
  if (raw)
    return response;
  if (response_.error)
    throw parseError(response_.error);
  return response_.result;
}
function parseError(errorObject) {
  const errorObject_ = errorObject;
  const { code } = errorObject_;
  if (code === InternalError.code)
    return new InternalError(errorObject_);
  if (code === InvalidInputError2.code)
    return new InvalidInputError2(errorObject_);
  if (code === InvalidParamsError.code)
    return new InvalidParamsError(errorObject_);
  if (code === InvalidRequestError.code)
    return new InvalidRequestError(errorObject_);
  if (code === LimitExceededError.code)
    return new LimitExceededError(errorObject_);
  if (code === MethodNotFoundError.code)
    return new MethodNotFoundError(errorObject_);
  if (code === MethodNotSupportedError.code)
    return new MethodNotSupportedError(errorObject_);
  if (code === ParseError.code)
    return new ParseError(errorObject_);
  if (code === ResourceNotFoundError.code)
    return new ResourceNotFoundError(errorObject_);
  if (code === ResourceUnavailableError.code)
    return new ResourceUnavailableError(errorObject_);
  if (code === TransactionRejectedError.code)
    return new TransactionRejectedError(errorObject_);
  if (code === VersionNotSupportedError.code)
    return new VersionNotSupportedError(errorObject_);
  return new InternalError({
    data: errorObject_,
    message: errorObject_.message
  });
}
var BaseError6 = class extends Error {
  constructor(errorObject) {
    const { code, message, data } = errorObject;
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.BaseError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "data", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = code;
    this.data = data;
  }
};
var InvalidInputError2 = class _InvalidInputError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _InvalidInputError.code,
      data: parameters.data,
      message: parameters.message ?? "Missing or invalid parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32e3
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidInputError"
    });
  }
};
Object.defineProperty(InvalidInputError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32e3
});
var ResourceNotFoundError = class _ResourceNotFoundError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _ResourceNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not found."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceNotFoundError"
    });
  }
};
Object.defineProperty(ResourceNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32001
});
var ResourceUnavailableError = class _ResourceUnavailableError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _ResourceUnavailableError.code,
      data: parameters.data,
      message: parameters.message ?? "Requested resource not available."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32002
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ResourceUnavailableError"
    });
  }
};
Object.defineProperty(ResourceUnavailableError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32002
});
var TransactionRejectedError = class _TransactionRejectedError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _TransactionRejectedError.code,
      data: parameters.data,
      message: parameters.message ?? "Transaction creation failed."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32003
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.TransactionRejectedError"
    });
  }
};
Object.defineProperty(TransactionRejectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32003
});
var MethodNotSupportedError = class _MethodNotSupportedError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "Method is not implemented."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32004
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotSupportedError"
    });
  }
};
Object.defineProperty(MethodNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32004
});
var LimitExceededError = class _LimitExceededError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _LimitExceededError.code,
      data: parameters.data,
      message: parameters.message ?? "Rate limit exceeded."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32005
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.LimitExceededError"
    });
  }
};
Object.defineProperty(LimitExceededError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32005
});
var VersionNotSupportedError = class _VersionNotSupportedError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _VersionNotSupportedError.code,
      data: parameters.data,
      message: parameters.message ?? "JSON-RPC version not supported."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32006
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.VersionNotSupportedError"
    });
  }
};
Object.defineProperty(VersionNotSupportedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32006
});
var InvalidRequestError = class _InvalidRequestError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _InvalidRequestError.code,
      data: parameters.data,
      message: parameters.message ?? "Input is not a valid JSON-RPC request."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32600
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidRequestError"
    });
  }
};
Object.defineProperty(InvalidRequestError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32600
});
var MethodNotFoundError = class _MethodNotFoundError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _MethodNotFoundError.code,
      data: parameters.data,
      message: parameters.message ?? "Method does not exist."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32601
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.MethodNotFoundError"
    });
  }
};
Object.defineProperty(MethodNotFoundError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32601
});
var InvalidParamsError = class _InvalidParamsError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _InvalidParamsError.code,
      data: parameters.data,
      message: parameters.message ?? "Invalid method parameters."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32602
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InvalidParamsError"
    });
  }
};
Object.defineProperty(InvalidParamsError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32602
});
var InternalError = class _InternalError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _InternalError.code,
      data: parameters.data,
      message: parameters.message ?? "Internal JSON-RPC error."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32603
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.InternalError"
    });
  }
};
Object.defineProperty(InternalError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32603
});
var ParseError = class _ParseError extends BaseError6 {
  constructor(parameters = {}) {
    super({
      code: _ParseError.code,
      data: parameters.data,
      message: parameters.message ?? "Failed to parse JSON-RPC response."
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: -32700
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcResponse.ParseError"
    });
  }
};
Object.defineProperty(ParseError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: -32700
});

// node_modules/ox/_esm/core/Provider.js
var ProviderRpcError = class extends Error {
  constructor(code, message) {
    super(message);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "ProviderRpcError"
    });
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    });
    this.code = code;
    this.details = message;
  }
};
var UserRejectedRequestError2 = class extends ProviderRpcError {
  constructor({ message = "The user rejected the request." } = {}) {
    super(4001, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4001
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UserRejectedRequestError"
    });
  }
};
Object.defineProperty(UserRejectedRequestError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4001
});
var UnauthorizedError = class extends ProviderRpcError {
  constructor({ message = "The requested method and/or account has not been authorized by the user." } = {}) {
    super(4100, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4100
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnauthorizedError"
    });
  }
};
Object.defineProperty(UnauthorizedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4100
});
var UnsupportedMethodError = class extends ProviderRpcError {
  constructor({ message = "The provider does not support the requested method." } = {}) {
    super(4200, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4200
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.UnsupportedMethodError"
    });
  }
};
Object.defineProperty(UnsupportedMethodError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4200
});
var DisconnectedError = class extends ProviderRpcError {
  constructor({ message = "The provider is disconnected from all chains." } = {}) {
    super(4900, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4900
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.DisconnectedError"
    });
  }
};
Object.defineProperty(DisconnectedError, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4900
});
var ChainDisconnectedError2 = class extends ProviderRpcError {
  constructor({ message = "The provider is not connected to the requested chain." } = {}) {
    super(4901, message);
    Object.defineProperty(this, "code", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: 4901
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.ChainDisconnectedError"
    });
  }
};
Object.defineProperty(ChainDisconnectedError2, "code", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: 4901
});
function createEmitter2() {
  const emitter = new import_index8.default();
  return {
    get eventNames() {
      return emitter.eventNames.bind(emitter);
    },
    get listenerCount() {
      return emitter.listenerCount.bind(emitter);
    },
    get listeners() {
      return emitter.listeners.bind(emitter);
    },
    addListener: emitter.addListener.bind(emitter),
    emit: emitter.emit.bind(emitter),
    off: emitter.off.bind(emitter),
    on: emitter.on.bind(emitter),
    once: emitter.once.bind(emitter),
    removeAllListeners: emitter.removeAllListeners.bind(emitter),
    removeListener: emitter.removeListener.bind(emitter)
  };
}
function from17(provider, options = {}) {
  var _a2, _b;
  const { includeEvents = true } = options;
  if (!provider)
    throw new IsUndefinedError();
  return {
    ...includeEvents ? {
      on: (_a2 = provider.on) == null ? void 0 : _a2.bind(provider),
      removeListener: (_b = provider.removeListener) == null ? void 0 : _b.bind(provider)
    } : {},
    async request(args) {
      try {
        const result = await provider.request(args);
        if (result && typeof result === "object" && "jsonrpc" in result)
          return parse2(result);
        return result;
      } catch (error) {
        throw parseError2(error);
      }
    }
  };
}
function parseError2(errorObject) {
  const errorObject_ = errorObject;
  const error = parseError(errorObject_);
  if (error instanceof InternalError) {
    if (!error.data)
      return error;
    const { code } = error.data;
    if (code === DisconnectedError.code)
      return new DisconnectedError(errorObject_);
    if (code === ChainDisconnectedError2.code)
      return new ChainDisconnectedError2(errorObject_);
    if (code === UserRejectedRequestError2.code)
      return new UserRejectedRequestError2(errorObject_);
    if (code === UnauthorizedError.code)
      return new UnauthorizedError(errorObject_);
    if (code === UnsupportedMethodError.code)
      return new UnsupportedMethodError(errorObject_);
  }
  return error;
}
var IsUndefinedError = class extends BaseError2 {
  constructor() {
    super("`provider` is undefined.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Provider.IsUndefinedError"
    });
  }
};

// node_modules/ox/_esm/core/RpcSchema.js
var RpcSchema_exports = {};
__export(RpcSchema_exports, {
  from: () => from18
});
function from18() {
  return null;
}

// node_modules/ox/_esm/core/RpcRequest.js
var RpcRequest_exports = {};
__export(RpcRequest_exports, {
  createStore: () => createStore3,
  from: () => from19
});
function createStore3(options = {}) {
  let id3 = options.id ?? 0;
  return {
    prepare(options2) {
      return from19({
        id: id3++,
        ...options2
      });
    },
    get id() {
      return id3;
    }
  };
}
function from19(options) {
  return {
    ...options,
    jsonrpc: "2.0"
  };
}

// node_modules/ox/_esm/core/RpcTransport.js
var RpcTransport_exports = {};
__export(RpcTransport_exports, {
  HttpError: () => HttpError,
  MalformedResponseError: () => MalformedResponseError,
  fromHttp: () => fromHttp
});

// node_modules/ox/_esm/core/internal/promise.js
function withTimeout2(fn2, options) {
  const { errorInstance = new TimeoutError(), timeout, signal } = options;
  return new Promise((resolve, reject) => {
    ;
    (async () => {
      let timeoutId;
      try {
        const controller = new AbortController();
        if (timeout > 0)
          timeoutId = setTimeout(() => {
            if (signal) {
              controller.abort();
            } else {
              reject(errorInstance);
            }
          }, timeout);
        resolve(await fn2({ signal: controller.signal }));
      } catch (err) {
        if ((err == null ? void 0 : err.name) === "AbortError")
          reject(errorInstance);
        reject(err);
      } finally {
        clearTimeout(timeoutId);
      }
    })();
  });
}
var TimeoutError = class extends BaseError2 {
  constructor() {
    super("Operation timed out.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Promise.TimeoutError"
    });
  }
};

// node_modules/ox/_esm/core/internal/rpcTransport.js
function create3(transport, options_root) {
  const requestStore = createStore3();
  return {
    request: async ({ method, params }, options = {}) => {
      const body = requestStore.prepare({ method, params });
      const data = await transport.request(body, options);
      return parse2(data, {
        raw: options.raw ?? (options_root == null ? void 0 : options_root.raw)
      });
    }
  };
}

// node_modules/ox/_esm/core/RpcTransport.js
function fromHttp(url, options = {}) {
  return create3({
    async request(body_, options_) {
      const { fetchFn = options.fetchFn ?? fetch, fetchOptions: fetchOptions_ = options.fetchOptions, timeout = options.timeout ?? 1e4 } = options_;
      const body = JSON.stringify(body_);
      const fetchOptions = typeof fetchOptions_ === "function" ? await fetchOptions_(body_) : fetchOptions_;
      const response = await withTimeout2(({ signal }) => {
        const init2 = {
          ...fetchOptions,
          body,
          headers: {
            "Content-Type": "application/json",
            ...fetchOptions == null ? void 0 : fetchOptions.headers
          },
          method: (fetchOptions == null ? void 0 : fetchOptions.method) ?? "POST",
          signal: (fetchOptions == null ? void 0 : fetchOptions.signal) ?? (timeout > 0 ? signal : null)
        };
        const request = new Request(url, init2);
        return fetchFn(request);
      }, {
        timeout,
        signal: true
      });
      const data = await (async () => {
        var _a2;
        if ((_a2 = response.headers.get("Content-Type")) == null ? void 0 : _a2.startsWith("application/json"))
          return response.json();
        return response.text().then((data2) => {
          try {
            return JSON.parse(data2 || "{}");
          } catch (err) {
            if (response.ok)
              throw new MalformedResponseError({
                response: data2
              });
            return { error: data2 };
          }
        });
      })();
      if (!response.ok)
        throw new HttpError({
          body,
          details: JSON.stringify(data.error) ?? response.statusText,
          response,
          url
        });
      return data;
    }
  }, { raw: options.raw });
}
var HttpError = class extends BaseError2 {
  constructor({ body, details, response, url }) {
    super("HTTP request failed.", {
      details,
      metaMessages: [
        `Status: ${response.status}`,
        `URL: ${getUrl(url)}`,
        body ? `Body: ${JSON.stringify(body)}` : void 0
      ]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcTransport.HttpError"
    });
  }
};
var MalformedResponseError = class extends BaseError2 {
  constructor({ response }) {
    super("HTTP Response could not be parsed as JSON.", {
      metaMessages: [`Response: ${response}`]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "RpcTransport.MalformedResponseError"
    });
  }
};

// node_modules/ox/_esm/core/P256.js
var P256_exports = {};
__export(P256_exports, {
  getPublicKey: () => getPublicKey3,
  noble: () => noble3,
  randomPrivateKey: () => randomPrivateKey3,
  recoverPublicKey: () => recoverPublicKey2,
  sign: () => sign3,
  verify: () => verify3
});

// node_modules/@noble/curves/esm/p256.js
var Fp256 = Field(BigInt("0xffffffff00000001000000000000000000000000ffffffffffffffffffffffff"));
var CURVE_A = Fp256.create(BigInt("-3"));
var CURVE_B = BigInt("0x5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b");
var p256 = createCurve({
  a: CURVE_A,
  b: CURVE_B,
  Fp: Fp256,
  n: BigInt("0xffffffff00000000ffffffffffffffffbce6faada7179e84f3b9cac2fc632551"),
  Gx: BigInt("0x6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296"),
  Gy: BigInt("0x4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5"),
  h: BigInt(1),
  lowS: false
}, sha256);
var secp256r1 = p256;
var mapSWU = (() => mapToCurveSimpleSWU(Fp256, {
  A: CURVE_A,
  B: CURVE_B,
  Z: Fp256.create(BigInt("-10"))
}))();
var htf = (() => createHasher(secp256r1.ProjectivePoint, (scalars) => mapSWU(scalars[0]), {
  DST: "P256_XMD:SHA-256_SSWU_RO_",
  encodeDST: "P256_XMD:SHA-256_SSWU_NU_",
  p: Fp256.ORDER,
  m: 1,
  k: 128,
  expand: "xmd",
  hash: sha256
}))();
var hashToCurve = (() => htf.hashToCurve)();
var encodeToCurve = (() => htf.encodeToCurve)();

// node_modules/ox/_esm/core/P256.js
var noble3 = secp256r1;
function getPublicKey3(options) {
  const { privateKey } = options;
  const point = secp256r1.ProjectivePoint.fromPrivateKey(typeof privateKey === "string" ? privateKey.slice(2) : fromBytes(privateKey).slice(2));
  return from3(point);
}
function randomPrivateKey3(options = {}) {
  const { as: as2 = "Hex" } = options;
  const bytes = secp256r1.utils.randomPrivateKey();
  if (as2 === "Hex")
    return fromBytes(bytes);
  return bytes;
}
function recoverPublicKey2(options) {
  const { payload, signature } = options;
  const { r: r2, s: s2, yParity } = signature;
  const signature_ = new secp256r1.Signature(BigInt(r2), BigInt(s2)).addRecoveryBit(yParity);
  const payload_ = payload instanceof Uint8Array ? fromBytes(payload) : payload;
  const point = signature_.recoverPublicKey(payload_.substring(2));
  return from3(point);
}
function sign3(options) {
  const { extraEntropy: extraEntropy2 = extraEntropy, hash: hash8, payload, privateKey } = options;
  const { r: r2, s: s2, recovery } = secp256r1.sign(payload instanceof Uint8Array ? payload : fromHex2(payload), privateKey instanceof Uint8Array ? privateKey : fromHex2(privateKey), {
    extraEntropy: typeof extraEntropy2 === "boolean" ? extraEntropy2 : from2(extraEntropy2).slice(2),
    lowS: true,
    ...hash8 ? { prehash: true } : {}
  });
  return {
    r: r2,
    s: s2,
    yParity: recovery
  };
}
function verify3(options) {
  const { hash: hash8, payload, publicKey, signature } = options;
  return secp256r1.verify(signature, payload instanceof Uint8Array ? payload : fromHex2(payload), toHex3(publicKey).substring(2), ...hash8 ? [{ prehash: true, lowS: true }] : []);
}

// node_modules/ox/_esm/core/Siwe.js
var Siwe_exports = {};
__export(Siwe_exports, {
  InvalidMessageFieldError: () => InvalidMessageFieldError,
  createMessage: () => createMessage,
  domainRegex: () => domainRegex,
  generateNonce: () => generateNonce,
  ipRegex: () => ipRegex,
  isUri: () => isUri,
  localhostRegex: () => localhostRegex,
  nonceRegex: () => nonceRegex,
  parseMessage: () => parseMessage,
  prefixRegex: () => prefixRegex,
  schemeRegex: () => schemeRegex,
  suffixRegex: () => suffixRegex,
  validateMessage: () => validateMessage
});

// node_modules/ox/_esm/core/internal/uid.js
var size4 = 256;
var index3 = size4;
var buffer2;
function uid2(length2 = 11) {
  if (!buffer2 || index3 + length2 > size4 * 2) {
    buffer2 = "";
    index3 = 0;
    for (let i2 = 0; i2 < size4; i2++) {
      buffer2 += (256 + Math.random() * 256 | 0).toString(16).substring(1);
    }
  }
  return buffer2.substring(index3, index3++ + length2);
}

// node_modules/ox/_esm/core/Siwe.js
var domainRegex = /^([a-zA-Z0-9]([a-zA-Z0-9\-]{0,61}[a-zA-Z0-9])?\.)+[a-zA-Z]{2,}(:[0-9]{1,5})?$/;
var ipRegex = /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)(:[0-9]{1,5})?$/;
var localhostRegex = /^localhost(:[0-9]{1,5})?$/;
var nonceRegex = /^[a-zA-Z0-9]{8,}$/;
var schemeRegex = /^([a-zA-Z][a-zA-Z0-9+-.]*)$/;
var prefixRegex = /^(?:(?<scheme>[a-zA-Z][a-zA-Z0-9+-.]*):\/\/)?(?<domain>[a-zA-Z0-9+-.]*(?::[0-9]{1,5})?) (?:wants you to sign in with your Ethereum account:\n)(?<address>0x[a-fA-F0-9]{40})\n\n(?:(?<statement>.*)\n\n)?/;
var suffixRegex = /(?:URI: (?<uri>.+))\n(?:Version: (?<version>.+))\n(?:Chain ID: (?<chainId>\d+))\n(?:Nonce: (?<nonce>[a-zA-Z0-9]+))\n(?:Issued At: (?<issuedAt>.+))(?:\nExpiration Time: (?<expirationTime>.+))?(?:\nNot Before: (?<notBefore>.+))?(?:\nRequest ID: (?<requestId>.+))?/;
function createMessage(value) {
  const { chainId, domain, expirationTime, issuedAt = /* @__PURE__ */ new Date(), nonce, notBefore, requestId, resources, scheme, uri, version: version7 } = value;
  {
    if (chainId !== Math.floor(chainId))
      throw new InvalidMessageFieldError({
        field: "chainId",
        metaMessages: [
          "- Chain ID must be a EIP-155 chain ID.",
          "- See https://eips.ethereum.org/EIPS/eip-155",
          "",
          `Provided value: ${chainId}`
        ]
      });
    if (!(domainRegex.test(domain) || ipRegex.test(domain) || localhostRegex.test(domain)))
      throw new InvalidMessageFieldError({
        field: "domain",
        metaMessages: [
          "- Domain must be an RFC 3986 authority.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${domain}`
        ]
      });
    if (!nonceRegex.test(nonce))
      throw new InvalidMessageFieldError({
        field: "nonce",
        metaMessages: [
          "- Nonce must be at least 8 characters.",
          "- Nonce must be alphanumeric.",
          "",
          `Provided value: ${nonce}`
        ]
      });
    if (!isUri(uri))
      throw new InvalidMessageFieldError({
        field: "uri",
        metaMessages: [
          "- URI must be a RFC 3986 URI referring to the resource that is the subject of the signing.",
          "- See https://www.rfc-editor.org/rfc/rfc3986",
          "",
          `Provided value: ${uri}`
        ]
      });
    if (version7 !== "1")
      throw new InvalidMessageFieldError({
        field: "version",
        metaMessages: [
          "- Version must be '1'.",
          "",
          `Provided value: ${version7}`
        ]
      });
    if (scheme && !schemeRegex.test(scheme))
      throw new InvalidMessageFieldError({
        field: "scheme",
        metaMessages: [
          "- Scheme must be an RFC 3986 URI scheme.",
          "- See https://www.rfc-editor.org/rfc/rfc3986#section-3.1",
          "",
          `Provided value: ${scheme}`
        ]
      });
    const statement2 = value.statement;
    if (statement2 == null ? void 0 : statement2.includes("\n"))
      throw new InvalidMessageFieldError({
        field: "statement",
        metaMessages: [
          "- Statement must not include '\\n'.",
          "",
          `Provided value: ${statement2}`
        ]
      });
  }
  const address = from4(value.address, { checksum: true });
  const origin2 = (() => {
    if (scheme)
      return `${scheme}://${domain}`;
    return domain;
  })();
  const statement = (() => {
    if (!value.statement)
      return "";
    return `${value.statement}
`;
  })();
  const prefix = `${origin2} wants you to sign in with your Ethereum account:
${address}

${statement}`;
  let suffix = `URI: ${uri}
Version: ${version7}
Chain ID: ${chainId}
Nonce: ${nonce}
Issued At: ${issuedAt.toISOString()}`;
  if (expirationTime)
    suffix += `
Expiration Time: ${expirationTime.toISOString()}`;
  if (notBefore)
    suffix += `
Not Before: ${notBefore.toISOString()}`;
  if (requestId)
    suffix += `
Request ID: ${requestId}`;
  if (resources) {
    let content = "\nResources:";
    for (const resource of resources) {
      if (!isUri(resource))
        throw new InvalidMessageFieldError({
          field: "resources",
          metaMessages: [
            "- Every resource must be a RFC 3986 URI.",
            "- See https://www.rfc-editor.org/rfc/rfc3986",
            "",
            `Provided value: ${resource}`
          ]
        });
      content += `
- ${resource}`;
    }
    suffix += content;
  }
  return `${prefix}
${suffix}`;
}
function generateNonce() {
  return uid2(96);
}
function isUri(value) {
  if (/[^a-z0-9\:\/\?\#\[\]\@\!\$\&\'\(\)\*\+\,\;\=\.\-\_\~\%]/i.test(value))
    return false;
  if (/%[^0-9a-f]/i.test(value))
    return false;
  if (/%[0-9a-f](:?[^0-9a-f]|$)/i.test(value))
    return false;
  const splitted = splitUri(value);
  const scheme = splitted[1];
  const authority = splitted[2];
  const path2 = splitted[3];
  const query = splitted[4];
  const fragment = splitted[5];
  if (!((scheme == null ? void 0 : scheme.length) && path2 && path2.length >= 0))
    return false;
  if (authority == null ? void 0 : authority.length) {
    if (!(path2.length === 0 || /^\//.test(path2)))
      return false;
  } else {
    if (/^\/\//.test(path2))
      return false;
  }
  if (!/^[a-z][a-z0-9\+\-\.]*$/.test(scheme.toLowerCase()))
    return false;
  let out = "";
  out += `${scheme}:`;
  if (authority == null ? void 0 : authority.length)
    out += `//${authority}`;
  out += path2;
  if (query == null ? void 0 : query.length)
    out += `?${query}`;
  if (fragment == null ? void 0 : fragment.length)
    out += `#${fragment}`;
  return out;
}
function splitUri(value) {
  return value.match(/(?:([^:\/?#]+):)?(?:\/\/([^\/?#]*))?([^?#]*)(?:\?([^#]*))?(?:#(.*))?/);
}
function parseMessage(message) {
  var _a2, _b, _c2;
  const { scheme, statement, ...prefix } = ((_a2 = message.match(prefixRegex)) == null ? void 0 : _a2.groups) ?? {};
  const { chainId, expirationTime, issuedAt, notBefore, requestId, ...suffix } = ((_b = message.match(suffixRegex)) == null ? void 0 : _b.groups) ?? {};
  const resources = (_c2 = message.split("Resources:")[1]) == null ? void 0 : _c2.split("\n- ").slice(1);
  return {
    ...prefix,
    ...suffix,
    ...chainId ? { chainId: Number(chainId) } : {},
    ...expirationTime ? { expirationTime: new Date(expirationTime) } : {},
    ...issuedAt ? { issuedAt: new Date(issuedAt) } : {},
    ...notBefore ? { notBefore: new Date(notBefore) } : {},
    ...requestId ? { requestId } : {},
    ...resources ? { resources } : {},
    ...scheme ? { scheme } : {},
    ...statement ? { statement } : {}
  };
}
function validateMessage(value) {
  const { address, domain, message, nonce, scheme, time: time2 = /* @__PURE__ */ new Date() } = value;
  if (domain && message.domain !== domain)
    return false;
  if (nonce && message.nonce !== nonce)
    return false;
  if (scheme && message.scheme !== scheme)
    return false;
  if (message.expirationTime && time2 >= message.expirationTime)
    return false;
  if (message.notBefore && time2 < message.notBefore)
    return false;
  try {
    if (!message.address)
      return false;
    if (address && !isEqual2(message.address, address))
      return false;
  } catch {
    return false;
  }
  return true;
}
var InvalidMessageFieldError = class extends BaseError2 {
  constructor(parameters) {
    const { field, metaMessages } = parameters;
    super(`Invalid Sign-In with Ethereum message field "${field}".`, {
      metaMessages
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Siwe.InvalidMessageFieldError"
    });
  }
};

// node_modules/ox/_esm/core/StateOverrides.js
var StateOverrides_exports = {};
__export(StateOverrides_exports, {
  fromRpc: () => fromRpc8,
  toRpc: () => toRpc8
});
function fromRpc8(rpcStateOverrides) {
  const stateOverrides = {};
  for (const [address, accountOverridesRpc] of Object.entries(rpcStateOverrides)) {
    const accountOverrides = {};
    if (accountOverridesRpc.balance)
      accountOverrides.balance = BigInt(accountOverridesRpc.balance);
    if (accountOverridesRpc.code)
      accountOverrides.code = accountOverridesRpc.code;
    if (accountOverridesRpc.movePrecompileToAddress)
      accountOverrides.movePrecompileToAddress = accountOverridesRpc.movePrecompileToAddress;
    if (accountOverridesRpc.nonce)
      accountOverrides.nonce = BigInt(accountOverridesRpc.nonce);
    if (accountOverridesRpc.state)
      accountOverrides.state = accountOverridesRpc.state;
    if (accountOverridesRpc.stateDiff)
      accountOverrides.stateDiff = accountOverridesRpc.stateDiff;
    stateOverrides[address] = accountOverrides;
  }
  return stateOverrides;
}
function toRpc8(stateOverrides) {
  const rpcStateOverrides = {};
  for (const [address, accountOverrides] of Object.entries(stateOverrides)) {
    const accountOverridesRpc = {};
    if (typeof accountOverrides.balance === "bigint")
      accountOverridesRpc.balance = fromNumber2(accountOverrides.balance);
    if (accountOverrides.code)
      accountOverridesRpc.code = accountOverrides.code;
    if (accountOverrides.movePrecompileToAddress)
      accountOverridesRpc.movePrecompileToAddress = accountOverrides.movePrecompileToAddress;
    if (typeof accountOverrides.nonce === "bigint")
      accountOverridesRpc.nonce = fromNumber2(accountOverrides.nonce);
    if (accountOverrides.state)
      accountOverridesRpc.state = accountOverrides.state;
    if (accountOverrides.stateDiff)
      accountOverridesRpc.stateDiff = accountOverrides.stateDiff;
    rpcStateOverrides[address] = accountOverridesRpc;
  }
  return rpcStateOverrides;
}

// node_modules/ox/_esm/core/TransactionEnvelope.js
var TransactionEnvelope_exports = {};
__export(TransactionEnvelope_exports, {
  FeeCapTooHighError: () => FeeCapTooHighError2,
  GasPriceTooHighError: () => GasPriceTooHighError,
  InvalidChainIdError: () => InvalidChainIdError2,
  InvalidSerializedError: () => InvalidSerializedError,
  TipAboveFeeCapError: () => TipAboveFeeCapError2
});

// node_modules/ox/_esm/core/Value.js
var Value_exports = {};
__export(Value_exports, {
  InvalidDecimalNumberError: () => InvalidDecimalNumberError,
  exponents: () => exponents,
  format: () => format5,
  formatEther: () => formatEther,
  formatGwei: () => formatGwei,
  from: () => from20,
  fromEther: () => fromEther,
  fromGwei: () => fromGwei
});
var exponents = {
  wei: 0,
  gwei: 9,
  szabo: 12,
  finney: 15,
  ether: 18
};
function format5(value, decimals = 0) {
  let display = value.toString();
  const negative = display.startsWith("-");
  if (negative)
    display = display.slice(1);
  display = display.padStart(decimals, "0");
  let [integer, fraction] = [
    display.slice(0, display.length - decimals),
    display.slice(display.length - decimals)
  ];
  fraction = fraction.replace(/(0+)$/, "");
  return `${negative ? "-" : ""}${integer || "0"}${fraction ? `.${fraction}` : ""}`;
}
function formatEther(wei, unit = "wei") {
  return format5(wei, exponents.ether - exponents[unit]);
}
function formatGwei(wei, unit = "wei") {
  return format5(wei, exponents.gwei - exponents[unit]);
}
function from20(value, decimals = 0) {
  if (!/^(-?)([0-9]*)\.?([0-9]*)$/.test(value))
    throw new InvalidDecimalNumberError({ value });
  let [integer = "", fraction = "0"] = value.split(".");
  const negative = integer.startsWith("-");
  if (negative)
    integer = integer.slice(1);
  fraction = fraction.replace(/(0+)$/, "");
  if (decimals === 0) {
    if (Math.round(Number(`.${fraction}`)) === 1)
      integer = `${BigInt(integer) + 1n}`;
    fraction = "";
  } else if (fraction.length > decimals) {
    const [left, unit, right] = [
      fraction.slice(0, decimals - 1),
      fraction.slice(decimals - 1, decimals),
      fraction.slice(decimals)
    ];
    const rounded2 = Math.round(Number(`${unit}.${right}`));
    if (rounded2 > 9)
      fraction = `${BigInt(left) + BigInt(1)}0`.padStart(left.length + 1, "0");
    else
      fraction = `${left}${rounded2}`;
    if (fraction.length > decimals) {
      fraction = fraction.slice(1);
      integer = `${BigInt(integer) + 1n}`;
    }
    fraction = fraction.slice(0, decimals);
  } else {
    fraction = fraction.padEnd(decimals, "0");
  }
  return BigInt(`${negative ? "-" : ""}${integer}${fraction}`);
}
function fromEther(ether, unit = "wei") {
  return from20(ether, exponents.ether - exponents[unit]);
}
function fromGwei(gwei, unit = "wei") {
  return from20(gwei, exponents.gwei - exponents[unit]);
}
var InvalidDecimalNumberError = class extends BaseError2 {
  constructor({ value }) {
    super(`Value \`${value}\` is not a valid decimal number.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "Value.InvalidDecimalNumberError"
    });
  }
};

// node_modules/ox/_esm/core/TransactionEnvelope.js
var FeeCapTooHighError2 = class extends BaseError2 {
  constructor({ feeCap } = {}) {
    super(`The fee cap (\`maxFeePerGas\`/\`maxPriorityFeePerGas\`${feeCap ? ` = ${formatGwei(feeCap)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.FeeCapTooHighError"
    });
  }
};
var GasPriceTooHighError = class extends BaseError2 {
  constructor({ gasPrice } = {}) {
    super(`The gas price (\`gasPrice\`${gasPrice ? ` = ${formatGwei(gasPrice)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.GasPriceTooHighError"
    });
  }
};
var InvalidChainIdError2 = class extends BaseError2 {
  constructor({ chainId }) {
    super(typeof chainId !== "undefined" ? `Chain ID "${chainId}" is invalid.` : "Chain ID is invalid.");
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidChainIdError"
    });
  }
};
var InvalidSerializedError = class extends BaseError2 {
  constructor({ attributes, serialized, type: type6 }) {
    const missing = Object.entries(attributes).map(([key, value]) => typeof value === "undefined" ? key : void 0).filter(Boolean);
    super(`Invalid serialized transaction of type "${type6}" was provided.`, {
      metaMessages: [
        `Serialized Transaction: "${serialized}"`,
        missing.length > 0 ? `Missing Attributes: ${missing.join(", ")}` : ""
      ].filter(Boolean)
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.InvalidSerializedError"
    });
  }
};
var TipAboveFeeCapError2 = class extends BaseError2 {
  constructor({ maxPriorityFeePerGas, maxFeePerGas } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${maxPriorityFeePerGas ? ` = ${formatGwei(maxPriorityFeePerGas)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${maxFeePerGas ? ` = ${formatGwei(maxFeePerGas)} gwei` : ""}).`
    ].join("\n"));
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TransactionEnvelope.TipAboveFeeCapError"
    });
  }
};

// node_modules/ox/_esm/core/TransactionEnvelopeLegacy.js
var TransactionEnvelopeLegacy_exports = {};
__export(TransactionEnvelopeLegacy_exports, {
  assert: () => assert3,
  deserialize: () => deserialize2,
  from: () => from21,
  getSignPayload: () => getSignPayload3,
  hash: () => hash3,
  serialize: () => serialize2,
  toRpc: () => toRpc9,
  type: () => type,
  validate: () => validate8
});
var type = "legacy";
function assert3(envelope) {
  const { chainId, gasPrice, to: to4 } = envelope;
  if (to4)
    assert(to4, { strict: false });
  if (typeof chainId !== "undefined" && chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
function deserialize2(serialized) {
  const tuple = toHex4(serialized);
  const [nonce, gasPrice, gas, to4, value, data, chainIdOrV_, r2, s2] = tuple;
  if (!(tuple.length === 6 || tuple.length === 9))
    throw new InvalidSerializedError({
      attributes: {
        nonce,
        gasPrice,
        gas,
        to: to4,
        value,
        data,
        ...tuple.length > 6 ? {
          v: chainIdOrV_,
          r: r2,
          s: s2
        } : {}
      },
      serialized,
      type
    });
  const transaction = {
    type
  };
  if (validate2(to4) && to4 !== "0x")
    transaction.to = to4;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (tuple.length === 6)
    return transaction;
  const chainIdOrV = validate2(chainIdOrV_) && chainIdOrV_ !== "0x" ? Number(chainIdOrV_) : 0;
  if (s2 === "0x" && r2 === "0x") {
    if (chainIdOrV > 0)
      transaction.chainId = Number(chainIdOrV);
    return transaction;
  }
  const v2 = chainIdOrV;
  const chainId = Math.floor((v2 - 35) / 2);
  if (chainId > 0)
    transaction.chainId = chainId;
  else if (v2 !== 27 && v2 !== 28)
    throw new InvalidVError({ value: v2 });
  transaction.yParity = vToYParity(v2);
  transaction.v = v2;
  transaction.s = s2 === "0x" ? 0n : BigInt(s2);
  transaction.r = r2 === "0x" ? 0n : BigInt(r2);
  assert3(transaction);
  return transaction;
}
function from21(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize2(envelope) : envelope;
  assert3(envelope_);
  const signature_ = (() => {
    if (!signature)
      return {};
    const s2 = from10(signature);
    s2.v = yParityToV(s2.yParity);
    return s2;
  })();
  return {
    ...envelope_,
    ...signature_,
    type: "legacy"
  };
}
function getSignPayload3(envelope) {
  return hash3(envelope, { presign: true });
}
function hash3(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize2({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize2(envelope, options = {}) {
  const { chainId = 0, gas, data, input, nonce, to: to4, value, gasPrice } = envelope;
  assert3(envelope);
  let serialized = [
    nonce ? fromNumber2(nonce) : "0x",
    gasPrice ? fromNumber2(gasPrice) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to4 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? input ?? "0x"
  ];
  const signature = (() => {
    if (options.signature)
      return {
        r: options.signature.r,
        s: options.signature.s,
        v: yParityToV(options.signature.yParity)
      };
    if (typeof envelope.r === "undefined" || typeof envelope.s === "undefined")
      return void 0;
    return {
      r: envelope.r,
      s: envelope.s,
      v: envelope.v
    };
  })();
  if (signature) {
    const v2 = (() => {
      if (signature.v >= 35) {
        const inferredChainId = Math.floor((signature.v - 35) / 2);
        if (inferredChainId > 0)
          return signature.v;
        return 27 + (signature.v === 35 ? 0 : 1);
      }
      if (chainId > 0)
        return chainId * 2 + 35 + signature.v - 27;
      const v3 = 27 + (signature.v === 27 ? 0 : 1);
      if (signature.v !== v3)
        throw new InvalidVError({ value: signature.v });
      return v3;
    })();
    serialized = [
      ...serialized,
      fromNumber2(v2),
      signature.r === 0n ? "0x" : trimLeft(fromNumber2(signature.r)),
      signature.s === 0n ? "0x" : trimLeft(fromNumber2(signature.s))
    ];
  } else if (chainId > 0)
    serialized = [...serialized, fromNumber2(chainId), "0x", "0x"];
  return fromHex3(serialized);
}
function toRpc9(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: typeof envelope.chainId === "number" ? fromNumber2(envelope.chainId) : void 0,
    data: envelope.data ?? envelope.input,
    type: "0x0",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber2(envelope.gasPrice) } : {},
    ...signature ? {
      ...toRpc2(signature),
      v: signature.yParity === 0 ? "0x1b" : "0x1c"
    } : {}
  };
}
function validate8(envelope) {
  try {
    assert3(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip1559.js
var TransactionEnvelopeEip1559_exports = {};
__export(TransactionEnvelopeEip1559_exports, {
  assert: () => assert4,
  deserialize: () => deserialize3,
  from: () => from22,
  getSignPayload: () => getSignPayload4,
  hash: () => hash4,
  serialize: () => serialize3,
  serializedType: () => serializedType,
  toRpc: () => toRpc10,
  type: () => type2,
  validate: () => validate9
});
var serializedType = "0x02";
var type2 = "eip1559";
function assert4(envelope) {
  const { chainId, maxPriorityFeePerGas, maxFeePerGas, to: to4 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (to4)
    assert(to4, { strict: false });
  if (maxFeePerGas && BigInt(maxFeePerGas) > 2n ** 256n - 1n)
    throw new FeeCapTooHighError2({ feeCap: maxFeePerGas });
  if (maxPriorityFeePerGas && maxFeePerGas && maxPriorityFeePerGas > maxFeePerGas)
    throw new TipAboveFeeCapError2({
      maxFeePerGas,
      maxPriorityFeePerGas
    });
}
function deserialize3(serialized) {
  const transactionArray = toHex4(slice2(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to4, value, data, accessList, yParity, r2, s2] = transactionArray;
  if (!(transactionArray.length === 9 || transactionArray.length === 12))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to4,
        value,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r2,
          s: s2
        } : {}
      },
      serialized,
      type: type2
    });
  let transaction = {
    chainId: Number(chainId),
    type: type2
  };
  if (validate2(to4) && to4 !== "0x")
    transaction.to = to4;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  const signature = r2 && s2 && yParity ? fromTuple([yParity, r2, s2]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert4(transaction);
  return transaction;
}
function from22(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize3(envelope) : envelope;
  assert4(envelope_);
  return {
    ...envelope_,
    ...signature ? from10(signature) : {},
    type: "eip1559"
  };
}
function getSignPayload4(envelope) {
  return hash4(envelope, { presign: true });
}
function hash4(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize3({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize3(envelope, options = {}) {
  const { chainId, gas, nonce, to: to4, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert4(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to4 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat2(serializedType, fromHex3(serialized));
}
function toRpc10(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    type: "0x2",
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber2(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? {
      maxPriorityFeePerGas: fromNumber2(envelope.maxPriorityFeePerGas)
    } : {},
    ...signature ? toRpc2(signature) : {}
  };
}
function validate9(envelope) {
  try {
    assert4(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip2930.js
var TransactionEnvelopeEip2930_exports = {};
__export(TransactionEnvelopeEip2930_exports, {
  assert: () => assert5,
  deserialize: () => deserialize4,
  from: () => from23,
  getSignPayload: () => getSignPayload5,
  hash: () => hash5,
  serialize: () => serialize4,
  serializedType: () => serializedType2,
  toRpc: () => toRpc11,
  type: () => type3,
  validate: () => validate10
});
var serializedType2 = "0x01";
var type3 = "eip2930";
function assert5(envelope) {
  const { chainId, gasPrice, to: to4 } = envelope;
  if (chainId <= 0)
    throw new InvalidChainIdError2({ chainId });
  if (to4)
    assert(to4, { strict: false });
  if (gasPrice && BigInt(gasPrice) > 2n ** 256n - 1n)
    throw new GasPriceTooHighError({ gasPrice });
}
function deserialize4(serialized) {
  const transactionArray = toHex4(slice2(serialized, 1));
  const [chainId, nonce, gasPrice, gas, to4, value, data, accessList, yParity, r2, s2] = transactionArray;
  if (!(transactionArray.length === 8 || transactionArray.length === 11))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        gasPrice,
        gas,
        to: to4,
        value,
        data,
        accessList,
        ...transactionArray.length > 8 ? {
          yParity,
          r: r2,
          s: s2
        } : {}
      },
      serialized,
      type: type3
    });
  let transaction = {
    chainId: Number(chainId),
    type: type3
  };
  if (validate2(to4) && to4 !== "0x")
    transaction.to = to4;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(gasPrice) && gasPrice !== "0x")
    transaction.gasPrice = BigInt(gasPrice);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  const signature = r2 && s2 && yParity ? fromTuple([yParity, r2, s2]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert5(transaction);
  return transaction;
}
function from23(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize4(envelope) : envelope;
  assert5(envelope_);
  return {
    ...envelope_,
    ...signature ? from10(signature) : {},
    type: "eip2930"
  };
}
function getSignPayload5(envelope) {
  return hash5(envelope, { presign: true });
}
function hash5(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize4({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize4(envelope, options = {}) {
  const { chainId, gas, data, input, nonce, to: to4, value, accessList, gasPrice } = envelope;
  assert5(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    gasPrice ? fromNumber2(gasPrice) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to4 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat2("0x01", fromHex3(serialized));
}
function toRpc11(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.gasPrice === "bigint" ? { gasPrice: fromNumber2(envelope.gasPrice) } : {},
    type: "0x1",
    ...signature ? toRpc2(signature) : {}
  };
}
function validate10(envelope) {
  try {
    assert5(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip4844.js
var TransactionEnvelopeEip4844_exports = {};
__export(TransactionEnvelopeEip4844_exports, {
  assert: () => assert6,
  deserialize: () => deserialize5,
  from: () => from24,
  getSignPayload: () => getSignPayload6,
  hash: () => hash6,
  serialize: () => serialize5,
  serializedType: () => serializedType3,
  toRpc: () => toRpc12,
  type: () => type4,
  validate: () => validate11
});
var serializedType3 = "0x03";
var type4 = "eip4844";
function assert6(envelope) {
  const { blobVersionedHashes } = envelope;
  if (blobVersionedHashes) {
    if (blobVersionedHashes.length === 0)
      throw new EmptyBlobVersionedHashesError();
    for (const hash8 of blobVersionedHashes) {
      const size5 = size2(hash8);
      const version7 = toNumber(slice2(hash8, 0, 1));
      if (size5 !== 32)
        throw new InvalidVersionedHashSizeError({ hash: hash8, size: size5 });
      if (version7 !== versionedHashVersion)
        throw new InvalidVersionedHashVersionError({
          hash: hash8,
          version: version7
        });
    }
  }
  assert4(envelope);
}
function deserialize5(serialized) {
  const transactionOrWrapperArray = toHex4(slice2(serialized, 1));
  const hasNetworkWrapper = transactionOrWrapperArray.length === 4;
  const transactionArray = hasNetworkWrapper ? transactionOrWrapperArray[0] : transactionOrWrapperArray;
  const wrapperArray = hasNetworkWrapper ? transactionOrWrapperArray.slice(1) : [];
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to4, value, data, accessList, maxFeePerBlobGas, blobVersionedHashes, yParity, r2, s2] = transactionArray;
  const [blobs, commitments, proofs] = wrapperArray;
  if (!(transactionArray.length === 11 || transactionArray.length === 14))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to4,
        value,
        data,
        accessList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r2,
          s: s2
        } : {}
      },
      serialized,
      type: type4
    });
  let transaction = {
    blobVersionedHashes,
    chainId: Number(chainId),
    type: type4
  };
  if (validate2(to4) && to4 !== "0x")
    transaction.to = to4;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(maxFeePerBlobGas) && maxFeePerBlobGas !== "0x")
    transaction.maxFeePerBlobGas = BigInt(maxFeePerBlobGas);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if ((accessList == null ? void 0 : accessList.length) !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  if (blobs && commitments && proofs)
    transaction.sidecars = toSidecars(blobs, {
      commitments,
      proofs
    });
  const signature = r2 && s2 && yParity ? fromTuple([yParity, r2, s2]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert6(transaction);
  return transaction;
}
function from24(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize5(envelope) : envelope;
  assert6(envelope_);
  return {
    ...envelope_,
    ...signature ? from10(signature) : {},
    type: "eip4844"
  };
}
function getSignPayload6(envelope) {
  return hash6(envelope, { presign: true });
}
function hash6(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize5({
    ...envelope,
    ...presign ? {
      sidecars: void 0,
      r: void 0,
      s: void 0,
      yParity: void 0,
      v: void 0
    } : {}
  }));
}
function serialize5(envelope, options = {}) {
  const { blobVersionedHashes, chainId, gas, nonce, to: to4, value, maxFeePerBlobGas, maxFeePerGas, maxPriorityFeePerGas, accessList, data } = envelope;
  assert6(envelope);
  const accessTupleList = toTupleList(accessList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to4 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? "0x",
    accessTupleList,
    maxFeePerBlobGas ? fromNumber2(maxFeePerBlobGas) : "0x",
    blobVersionedHashes ?? [],
    ...signature ? toTuple(signature) : []
  ];
  const sidecars = options.sidecars || envelope.sidecars;
  const blobs = [];
  const commitments = [];
  const proofs = [];
  if (sidecars)
    for (let i2 = 0; i2 < sidecars.length; i2++) {
      const { blob, commitment, proof } = sidecars[i2];
      blobs.push(blob);
      commitments.push(commitment);
      proofs.push(proof);
    }
  return concat2("0x03", sidecars ? (
    // If sidecars are provided, envelope turns into a "network wrapper":
    fromHex3([serialized, blobs, commitments, proofs])
  ) : (
    // Otherwise, standard envelope is used:
    fromHex3(serialized)
  ));
}
function toRpc12(envelope) {
  const signature = extract2(envelope);
  return {
    ...envelope,
    chainId: fromNumber2(envelope.chainId),
    data: envelope.data ?? envelope.input,
    ...typeof envelope.gas === "bigint" ? { gas: fromNumber2(envelope.gas) } : {},
    ...typeof envelope.nonce === "bigint" ? { nonce: fromNumber2(envelope.nonce) } : {},
    ...typeof envelope.value === "bigint" ? { value: fromNumber2(envelope.value) } : {},
    ...typeof envelope.maxFeePerBlobGas === "bigint" ? { maxFeePerBlobGas: fromNumber2(envelope.maxFeePerBlobGas) } : {},
    ...typeof envelope.maxFeePerGas === "bigint" ? { maxFeePerGas: fromNumber2(envelope.maxFeePerGas) } : {},
    ...typeof envelope.maxPriorityFeePerGas === "bigint" ? { maxPriorityFeePerGas: fromNumber2(envelope.maxPriorityFeePerGas) } : {},
    type: "0x3",
    ...signature ? toRpc2(signature) : {}
  };
}
function validate11(envelope) {
  try {
    assert6(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionEnvelopeEip7702.js
var TransactionEnvelopeEip7702_exports = {};
__export(TransactionEnvelopeEip7702_exports, {
  assert: () => assert7,
  deserialize: () => deserialize6,
  from: () => from25,
  getSignPayload: () => getSignPayload7,
  hash: () => hash7,
  serialize: () => serialize6,
  serializedType: () => serializedType4,
  type: () => type5,
  validate: () => validate12
});
var serializedType4 = "0x04";
var type5 = "eip7702";
function assert7(envelope) {
  const { authorizationList } = envelope;
  if (authorizationList) {
    for (const authorization of authorizationList) {
      const { address, chainId } = authorization;
      if (address)
        assert(address, { strict: false });
      if (Number(chainId) < 0)
        throw new InvalidChainIdError2({ chainId });
    }
  }
  assert4(envelope);
}
function deserialize6(serialized) {
  const transactionArray = toHex4(slice2(serialized, 1));
  const [chainId, nonce, maxPriorityFeePerGas, maxFeePerGas, gas, to4, value, data, accessList, authorizationList, yParity, r2, s2] = transactionArray;
  if (!(transactionArray.length === 10 || transactionArray.length === 13))
    throw new InvalidSerializedError({
      attributes: {
        chainId,
        nonce,
        maxPriorityFeePerGas,
        maxFeePerGas,
        gas,
        to: to4,
        value,
        data,
        accessList,
        authorizationList,
        ...transactionArray.length > 9 ? {
          yParity,
          r: r2,
          s: s2
        } : {}
      },
      serialized,
      type: type5
    });
  let transaction = {
    chainId: Number(chainId),
    type: type5
  };
  if (validate2(to4) && to4 !== "0x")
    transaction.to = to4;
  if (validate2(gas) && gas !== "0x")
    transaction.gas = BigInt(gas);
  if (validate2(data) && data !== "0x")
    transaction.data = data;
  if (validate2(nonce) && nonce !== "0x")
    transaction.nonce = BigInt(nonce);
  if (validate2(value) && value !== "0x")
    transaction.value = BigInt(value);
  if (validate2(maxFeePerGas) && maxFeePerGas !== "0x")
    transaction.maxFeePerGas = BigInt(maxFeePerGas);
  if (validate2(maxPriorityFeePerGas) && maxPriorityFeePerGas !== "0x")
    transaction.maxPriorityFeePerGas = BigInt(maxPriorityFeePerGas);
  if (accessList.length !== 0 && accessList !== "0x")
    transaction.accessList = fromTupleList(accessList);
  if (authorizationList !== "0x")
    transaction.authorizationList = fromTupleList2(authorizationList);
  const signature = r2 && s2 && yParity ? fromTuple([yParity, r2, s2]) : void 0;
  if (signature)
    transaction = {
      ...transaction,
      ...signature
    };
  assert7(transaction);
  return transaction;
}
function from25(envelope, options = {}) {
  const { signature } = options;
  const envelope_ = typeof envelope === "string" ? deserialize6(envelope) : envelope;
  assert7(envelope_);
  return {
    ...envelope_,
    ...signature ? from10(signature) : {},
    type: "eip7702"
  };
}
function getSignPayload7(envelope) {
  return hash7(envelope, { presign: true });
}
function hash7(envelope, options = {}) {
  const { presign } = options;
  return keccak2562(serialize6({
    ...envelope,
    ...presign ? {
      r: void 0,
      s: void 0,
      yParity: void 0
    } : {}
  }));
}
function serialize6(envelope, options = {}) {
  const { authorizationList, chainId, gas, nonce, to: to4, value, maxFeePerGas, maxPriorityFeePerGas, accessList, data, input } = envelope;
  assert7(envelope);
  const accessTupleList = toTupleList(accessList);
  const authorizationTupleList = toTupleList2(authorizationList);
  const signature = extract2(options.signature || envelope);
  const serialized = [
    fromNumber2(chainId),
    nonce ? fromNumber2(nonce) : "0x",
    maxPriorityFeePerGas ? fromNumber2(maxPriorityFeePerGas) : "0x",
    maxFeePerGas ? fromNumber2(maxFeePerGas) : "0x",
    gas ? fromNumber2(gas) : "0x",
    to4 ?? "0x",
    value ? fromNumber2(value) : "0x",
    data ?? input ?? "0x",
    accessTupleList,
    authorizationTupleList,
    ...signature ? toTuple(signature) : []
  ];
  return concat2(serializedType4, fromHex3(serialized));
}
function validate12(envelope) {
  try {
    assert7(envelope);
    return true;
  } catch {
    return false;
  }
}

// node_modules/ox/_esm/core/TransactionReceipt.js
var TransactionReceipt_exports = {};
__export(TransactionReceipt_exports, {
  fromRpc: () => fromRpc9,
  fromRpcStatus: () => fromRpcStatus,
  fromRpcType: () => fromRpcType2,
  toRpc: () => toRpc13,
  toRpcStatus: () => toRpcStatus,
  toRpcType: () => toRpcType2
});
var fromRpcStatus = {
  "0x0": "reverted",
  "0x1": "success"
};
var toRpcStatus = {
  reverted: "0x0",
  success: "0x1"
};
var fromRpcType2 = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
var toRpcType2 = {
  legacy: "0x0",
  eip2930: "0x1",
  eip1559: "0x2",
  eip4844: "0x3",
  eip7702: "0x4"
};
function fromRpc9(receipt) {
  if (!receipt)
    return null;
  return {
    ...receipt,
    blobGasPrice: receipt.blobGasPrice ? BigInt(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? BigInt(receipt.blobGasUsed) : void 0,
    blockNumber: BigInt(receipt.blockNumber ?? 0n),
    cumulativeGasUsed: BigInt(receipt.cumulativeGasUsed ?? 0n),
    effectiveGasPrice: BigInt(receipt.effectiveGasPrice ?? 0n),
    gasUsed: BigInt(receipt.gasUsed ?? 0n),
    logs: receipt.logs.map((log) => fromRpc7(log, { pending: false })),
    status: fromRpcStatus[receipt.status],
    transactionIndex: Number(receipt.transactionIndex ?? 0),
    type: fromRpcType2[receipt.type] || receipt.type
  };
}
function toRpc13(receipt) {
  return {
    blobGasPrice: receipt.blobGasPrice ? fromNumber2(receipt.blobGasPrice) : void 0,
    blobGasUsed: receipt.blobGasUsed ? fromNumber2(receipt.blobGasUsed) : void 0,
    blockHash: receipt.blockHash,
    blockNumber: fromNumber2(receipt.blockNumber),
    contractAddress: receipt.contractAddress,
    cumulativeGasUsed: fromNumber2(receipt.cumulativeGasUsed),
    effectiveGasPrice: fromNumber2(receipt.effectiveGasPrice),
    from: receipt.from,
    gasUsed: fromNumber2(receipt.gasUsed),
    logs: receipt.logs.map(toRpc7),
    logsBloom: receipt.logsBloom,
    root: receipt.root,
    status: toRpcStatus[receipt.status],
    to: receipt.to,
    transactionHash: receipt.transactionHash,
    transactionIndex: fromNumber2(receipt.transactionIndex),
    type: toRpcType2[receipt.type] ?? receipt.type
  };
}

// node_modules/ox/_esm/core/TransactionRequest.js
var TransactionRequest_exports = {};
__export(TransactionRequest_exports, {
  toRpc: () => toRpc14
});
function toRpc14(request) {
  const request_rpc = {};
  if (typeof request.accessList !== "undefined")
    request_rpc.accessList = request.accessList;
  if (typeof request.authorizationList !== "undefined")
    request_rpc.authorizationList = toRpcList(request.authorizationList);
  if (typeof request.blobVersionedHashes !== "undefined")
    request_rpc.blobVersionedHashes = request.blobVersionedHashes;
  if (typeof request.blobs !== "undefined")
    request_rpc.blobs = request.blobs;
  if (typeof request.chainId !== "undefined")
    request_rpc.chainId = fromNumber2(request.chainId);
  if (typeof request.data !== "undefined") {
    request_rpc.data = request.data;
    request_rpc.input = request.data;
  } else if (typeof request.input !== "undefined") {
    request_rpc.data = request.input;
    request_rpc.input = request.input;
  }
  if (typeof request.from !== "undefined")
    request_rpc.from = request.from;
  if (typeof request.gas !== "undefined")
    request_rpc.gas = fromNumber2(request.gas);
  if (typeof request.gasPrice !== "undefined")
    request_rpc.gasPrice = fromNumber2(request.gasPrice);
  if (typeof request.maxFeePerBlobGas !== "undefined")
    request_rpc.maxFeePerBlobGas = fromNumber2(request.maxFeePerBlobGas);
  if (typeof request.maxFeePerGas !== "undefined")
    request_rpc.maxFeePerGas = fromNumber2(request.maxFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber2(request.maxPriorityFeePerGas);
  if (typeof request.maxPriorityFeePerGas !== "undefined")
    request_rpc.maxPriorityFeePerGas = fromNumber2(request.maxPriorityFeePerGas);
  if (typeof request.nonce !== "undefined")
    request_rpc.nonce = fromNumber2(request.nonce);
  if (typeof request.to !== "undefined")
    request_rpc.to = request.to;
  if (typeof request.type !== "undefined")
    request_rpc.type = request.type;
  if (typeof request.value !== "undefined")
    request_rpc.value = fromNumber2(request.value);
  return request_rpc;
}

// node_modules/ox/_esm/core/TypedData.js
var TypedData_exports = {};
__export(TypedData_exports, {
  BytesSizeMismatchError: () => BytesSizeMismatchError,
  InvalidDomainError: () => InvalidDomainError,
  InvalidPrimaryTypeError: () => InvalidPrimaryTypeError,
  InvalidStructTypeError: () => InvalidStructTypeError,
  assert: () => assert8,
  domainSeparator: () => domainSeparator,
  encode: () => encode5,
  encodeData: () => encodeData,
  encodeField: () => encodeField,
  encodeType: () => encodeType,
  extractEip712DomainTypes: () => extractEip712DomainTypes,
  findTypeDependencies: () => findTypeDependencies,
  getSignPayload: () => getSignPayload8,
  hashDomain: () => hashDomain,
  hashStruct: () => hashStruct,
  hashType: () => hashType,
  serialize: () => serialize7,
  validate: () => validate13
});
function assert8(value) {
  const { domain, message, primaryType, types: types3 } = value;
  const validateData = (struct, data) => {
    for (const param of struct) {
      const { name, type: type6 } = param;
      const value2 = data[name];
      const integerMatch = type6.match(integerRegex);
      if (integerMatch && (typeof value2 === "number" || typeof value2 === "bigint")) {
        const [, base3, size_] = integerMatch;
        fromNumber2(value2, {
          signed: base3 === "int",
          size: Number.parseInt(size_ ?? "") / 8
        });
      }
      if (type6 === "address" && typeof value2 === "string" && !validate4(value2))
        throw new InvalidAddressError2({
          address: value2,
          cause: new InvalidInputError()
        });
      const bytesMatch = type6.match(bytesRegex);
      if (bytesMatch) {
        const [, size5] = bytesMatch;
        if (size5 && size2(value2) !== Number.parseInt(size5))
          throw new BytesSizeMismatchError({
            expectedSize: Number.parseInt(size5),
            givenSize: size2(value2)
          });
      }
      const struct2 = types3[type6];
      if (struct2) {
        validateReference(type6);
        validateData(struct2, value2);
      }
    }
  };
  if (types3.EIP712Domain && domain) {
    if (typeof domain !== "object")
      throw new InvalidDomainError({ domain });
    validateData(types3.EIP712Domain, domain);
  }
  if (primaryType !== "EIP712Domain") {
    if (types3[primaryType])
      validateData(types3[primaryType], message);
    else
      throw new InvalidPrimaryTypeError({ primaryType, types: types3 });
  }
}
function domainSeparator(domain) {
  return hashDomain({
    domain
  });
}
function encode5(value) {
  const { domain = {}, message, primaryType } = value;
  const types3 = {
    EIP712Domain: extractEip712DomainTypes(domain),
    ...value.types
  };
  assert8({
    domain,
    message,
    primaryType,
    types: types3
  });
  const parts = ["0x19", "0x01"];
  if (domain)
    parts.push(hashDomain({
      domain,
      types: types3
    }));
  if (primaryType !== "EIP712Domain")
    parts.push(hashStruct({
      data: message,
      primaryType,
      types: types3
    }));
  return concat2(...parts);
}
function encodeType(value) {
  const { primaryType, types: types3 } = value;
  let result = "";
  const unsortedDeps = findTypeDependencies({ primaryType, types: types3 });
  unsortedDeps.delete(primaryType);
  const deps = [primaryType, ...Array.from(unsortedDeps).sort()];
  for (const type6 of deps) {
    result += `${type6}(${(types3[type6] ?? []).map(({ name, type: t2 }) => `${t2} ${name}`).join(",")})`;
  }
  return result;
}
function extractEip712DomainTypes(domain) {
  return [
    typeof (domain == null ? void 0 : domain.name) === "string" && { name: "name", type: "string" },
    (domain == null ? void 0 : domain.version) && { name: "version", type: "string" },
    typeof (domain == null ? void 0 : domain.chainId) === "number" && {
      name: "chainId",
      type: "uint256"
    },
    (domain == null ? void 0 : domain.verifyingContract) && {
      name: "verifyingContract",
      type: "address"
    },
    (domain == null ? void 0 : domain.salt) && { name: "salt", type: "bytes32" }
  ].filter(Boolean);
}
function getSignPayload8(value) {
  return keccak2562(encode5(value));
}
function hashDomain(value) {
  const { domain, types: types3 } = value;
  return hashStruct({
    data: domain,
    primaryType: "EIP712Domain",
    types: {
      ...types3,
      EIP712Domain: (types3 == null ? void 0 : types3.EIP712Domain) || extractEip712DomainTypes(domain)
    }
  });
}
function hashStruct(value) {
  const { data, primaryType, types: types3 } = value;
  const encoded = encodeData({
    data,
    primaryType,
    types: types3
  });
  return keccak2562(encoded);
}
function serialize7(value) {
  const { domain: domain_, message: message_, primaryType, types: types3 } = value;
  const normalizeData = (struct, value2) => {
    const data = { ...value2 };
    for (const param of struct) {
      const { name, type: type6 } = param;
      if (type6 === "address")
        data[name] = data[name].toLowerCase();
    }
    return data;
  };
  const domain = (() => {
    if (!domain_)
      return {};
    const type6 = types3.EIP712Domain ?? extractEip712DomainTypes(domain_);
    return normalizeData(type6, domain_);
  })();
  const message = (() => {
    if (primaryType === "EIP712Domain")
      return void 0;
    if (!types3[primaryType])
      return {};
    return normalizeData(types3[primaryType], message_);
  })();
  return stringify({ domain, message, primaryType, types: types3 }, (_2, value2) => {
    if (typeof value2 === "bigint")
      return value2.toString();
    return value2;
  });
}
function validate13(value) {
  try {
    assert8(value);
    return true;
  } catch {
    return false;
  }
}
var BytesSizeMismatchError = class extends BaseError2 {
  constructor({ expectedSize, givenSize }) {
    super(`Expected bytes${expectedSize}, got bytes${givenSize}.`);
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.BytesSizeMismatchError"
    });
  }
};
var InvalidDomainError = class extends BaseError2 {
  constructor({ domain }) {
    super(`Invalid domain "${stringify(domain)}".`, {
      metaMessages: ["Must be a valid EIP-712 domain."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidDomainError"
    });
  }
};
var InvalidPrimaryTypeError = class extends BaseError2 {
  constructor({ primaryType, types: types3 }) {
    super(`Invalid primary type \`${primaryType}\` must be one of \`${JSON.stringify(Object.keys(types3))}\`.`, {
      metaMessages: ["Check that the primary type is a key in `types`."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidPrimaryTypeError"
    });
  }
};
var InvalidStructTypeError = class extends BaseError2 {
  constructor({ type: type6 }) {
    super(`Struct type "${type6}" is invalid.`, {
      metaMessages: ["Struct type must not be a Solidity type."]
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "TypedData.InvalidStructTypeError"
    });
  }
};
function encodeData(value) {
  const { data, primaryType, types: types3 } = value;
  const encodedTypes = [{ type: "bytes32" }];
  const encodedValues = [hashType({ primaryType, types: types3 })];
  for (const field of types3[primaryType] ?? []) {
    const [type6, value2] = encodeField({
      types: types3,
      name: field.name,
      type: field.type,
      value: data[field.name]
    });
    encodedTypes.push(type6);
    encodedValues.push(value2);
  }
  return encode(encodedTypes, encodedValues);
}
function hashType(value) {
  const { primaryType, types: types3 } = value;
  const encodedHashType = fromString2(encodeType({ primaryType, types: types3 }));
  return keccak2562(encodedHashType);
}
function encodeField(properties) {
  let { types: types3, name, type: type6, value } = properties;
  if (types3[type6] !== void 0)
    return [
      { type: "bytes32" },
      keccak2562(encodeData({ data: value, primaryType: type6, types: types3 }))
    ];
  if (type6 === "bytes") {
    const prepend = value.length % 2 ? "0" : "";
    value = `0x${prepend + value.slice(2)}`;
    return [{ type: "bytes32" }, keccak2562(value, { as: "Hex" })];
  }
  if (type6 === "string")
    return [
      { type: "bytes32" },
      keccak2562(fromString(value), { as: "Hex" })
    ];
  if (type6.lastIndexOf("]") === type6.length - 1) {
    const parsedType = type6.slice(0, type6.lastIndexOf("["));
    const typeValuePairs = value.map((item) => encodeField({
      name,
      type: parsedType,
      types: types3,
      value: item
    }));
    return [
      { type: "bytes32" },
      keccak2562(encode(typeValuePairs.map(([t2]) => t2), typeValuePairs.map(([, v2]) => v2)))
    ];
  }
  return [{ type: type6 }, value];
}
function findTypeDependencies(value, results2 = /* @__PURE__ */ new Set()) {
  const { primaryType: primaryType_, types: types3 } = value;
  const match = primaryType_.match(/^\w*/u);
  const primaryType = match == null ? void 0 : match[0];
  if (results2.has(primaryType) || types3[primaryType] === void 0)
    return results2;
  results2.add(primaryType);
  for (const field of types3[primaryType])
    findTypeDependencies({ primaryType: field.type, types: types3 }, results2);
  return results2;
}
function validateReference(type6) {
  if (type6 === "address" || type6 === "bool" || type6 === "string" || type6.startsWith("bytes") || type6.startsWith("uint") || type6.startsWith("int"))
    throw new InvalidStructTypeError({ type: type6 });
}

// node_modules/ox/_esm/core/ValidatorData.js
var ValidatorData_exports = {};
__export(ValidatorData_exports, {
  encode: () => encode6,
  getSignPayload: () => getSignPayload9
});
function encode6(value) {
  const { data, validator } = value;
  return concat2(
    // Validator Data Format: `0x19  0x00  <intended validator address>  <data to sign>`
    "0x19",
    "0x00",
    validator,
    from2(data)
  );
}
function getSignPayload9(value) {
  return keccak2562(encode6(value));
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var WebAuthnP256_exports = {};
__export(WebAuthnP256_exports, {
  CredentialCreationFailedError: () => CredentialCreationFailedError,
  CredentialRequestFailedError: () => CredentialRequestFailedError,
  createChallenge: () => createChallenge,
  createCredential: () => createCredential,
  getAuthenticatorData: () => getAuthenticatorData,
  getClientDataJSON: () => getClientDataJSON,
  getCredentialCreationOptions: () => getCredentialCreationOptions,
  getCredentialRequestOptions: () => getCredentialRequestOptions,
  getSignPayload: () => getSignPayload10,
  sign: () => sign4,
  verify: () => verify4
});

// node_modules/ox/_esm/core/internal/webauthn.js
function parseAsn1Signature(bytes) {
  const r_start = bytes[4] === 0 ? 5 : 4;
  const r_end = r_start + 32;
  const s_start = bytes[r_end + 2] === 0 ? r_end + 3 : r_end + 2;
  const r2 = BigInt(fromBytes(bytes.slice(r_start, r_end)));
  const s2 = BigInt(fromBytes(bytes.slice(s_start)));
  return {
    r: r2,
    s: s2 > p256.CURVE.n / 2n ? p256.CURVE.n - s2 : s2
  };
}
async function parseCredentialPublicKey(response) {
  try {
    const publicKeyBuffer = response.getPublicKey();
    if (!publicKeyBuffer)
      throw new CredentialCreationFailedError();
    const publicKeyBytes = new Uint8Array(publicKeyBuffer);
    const cryptoKey = await crypto.subtle.importKey("spki", new Uint8Array(publicKeyBytes), {
      name: "ECDSA",
      namedCurve: "P-256",
      hash: "SHA-256"
    }, true, ["verify"]);
    const publicKey = new Uint8Array(await crypto.subtle.exportKey("raw", cryptoKey));
    return from3(publicKey);
  } catch (error) {
    if (error.message !== "Permission denied to access object")
      throw error;
    const data = new Uint8Array(response.attestationObject);
    const coordinateLength = 32;
    const cborPrefix = 88;
    const findStart = (key) => {
      const coordinate = new Uint8Array([key, cborPrefix, coordinateLength]);
      for (let i2 = 0; i2 < data.length - coordinate.length; i2++)
        if (coordinate.every((byte, j3) => data[i2 + j3] === byte))
          return i2 + coordinate.length;
      throw new CredentialCreationFailedError();
    };
    const xStart = findStart(33);
    const yStart = findStart(34);
    return from3(new Uint8Array([
      4,
      ...data.slice(xStart, xStart + coordinateLength),
      ...data.slice(yStart, yStart + coordinateLength)
    ]));
  }
}

// node_modules/ox/_esm/core/WebAuthnP256.js
var createChallenge = Uint8Array.from([
  105,
  171,
  180,
  181,
  160,
  222,
  75,
  198,
  42,
  42,
  32,
  31,
  141,
  37,
  186,
  233
]);
async function createCredential(options) {
  const { createFn = window.navigator.credentials.create.bind(window.navigator.credentials), ...rest } = options;
  const creationOptions = getCredentialCreationOptions(rest);
  try {
    const credential = await createFn(creationOptions);
    if (!credential)
      throw new CredentialCreationFailedError();
    const response = credential.response;
    const publicKey = await parseCredentialPublicKey(response);
    return {
      id: credential.id,
      publicKey,
      raw: credential
    };
  } catch (error) {
    throw new CredentialCreationFailedError({
      cause: error
    });
  }
}
function getAuthenticatorData(options = {}) {
  const { flag = 5, rpId = window.location.hostname, signCount = 0 } = options;
  const rpIdHash = sha2563(fromString2(rpId));
  const flag_bytes = fromNumber2(flag, { size: 1 });
  const signCount_bytes = fromNumber2(signCount, { size: 4 });
  return concat2(rpIdHash, flag_bytes, signCount_bytes);
}
function getClientDataJSON(options) {
  const { challenge, crossOrigin = false, extraClientData, origin: origin2 = window.location.origin } = options;
  return JSON.stringify({
    type: "webauthn.get",
    challenge: fromHex6(challenge, { url: true, pad: false }),
    origin: origin2,
    crossOrigin,
    ...extraClientData
  });
}
function getCredentialCreationOptions(options) {
  const { attestation = "none", authenticatorSelection = {
    residentKey: "preferred",
    requireResidentKey: false,
    userVerification: "required"
  }, challenge = createChallenge, excludeCredentialIds, name: name_, rp = {
    id: window.location.hostname,
    name: window.document.title
  }, user, extensions } = options;
  const name = (user == null ? void 0 : user.name) ?? name_;
  return {
    publicKey: {
      attestation,
      authenticatorSelection,
      challenge,
      ...excludeCredentialIds ? {
        excludeCredentials: excludeCredentialIds == null ? void 0 : excludeCredentialIds.map((id3) => ({
          id: toBytes8(id3),
          type: "public-key"
        }))
      } : {},
      pubKeyCredParams: [
        {
          type: "public-key",
          alg: -7
          // p256
        }
      ],
      rp,
      user: {
        id: (user == null ? void 0 : user.id) ?? keccak2562(fromString(name), { as: "Bytes" }),
        name,
        displayName: (user == null ? void 0 : user.displayName) ?? name
      },
      extensions
    }
  };
}
function getCredentialRequestOptions(options) {
  const { credentialId, challenge, rpId = window.location.hostname, userVerification = "required" } = options;
  return {
    publicKey: {
      ...credentialId ? {
        allowCredentials: [
          {
            id: toBytes8(credentialId),
            type: "public-key"
          }
        ]
      } : {},
      challenge: fromHex2(challenge),
      rpId,
      userVerification
    }
  };
}
function getSignPayload10(options) {
  const { challenge, crossOrigin, extraClientData, flag, origin: origin2, rpId, signCount, userVerification = "required" } = options;
  const authenticatorData = getAuthenticatorData({
    flag,
    rpId,
    signCount
  });
  const clientDataJSON = getClientDataJSON({
    challenge,
    crossOrigin,
    extraClientData,
    origin: origin2
  });
  const clientDataJSONHash = sha2563(fromString2(clientDataJSON));
  const challengeIndex = clientDataJSON.indexOf('"challenge"');
  const typeIndex = clientDataJSON.indexOf('"type"');
  const metadata = {
    authenticatorData,
    clientDataJSON,
    challengeIndex,
    typeIndex,
    userVerificationRequired: userVerification === "required"
  };
  const payload = concat2(authenticatorData, clientDataJSONHash);
  return { metadata, payload };
}
async function sign4(options) {
  const { getFn = window.navigator.credentials.get.bind(window.navigator.credentials), ...rest } = options;
  const requestOptions = getCredentialRequestOptions(rest);
  try {
    const credential = await getFn(requestOptions);
    if (!credential)
      throw new CredentialRequestFailedError();
    const response = credential.response;
    const clientDataJSON = String.fromCharCode(...new Uint8Array(response.clientDataJSON));
    const challengeIndex = clientDataJSON.indexOf('"challenge"');
    const typeIndex = clientDataJSON.indexOf('"type"');
    const signature = parseAsn1Signature(new Uint8Array(response.signature));
    return {
      metadata: {
        authenticatorData: fromBytes(new Uint8Array(response.authenticatorData)),
        clientDataJSON,
        challengeIndex,
        typeIndex,
        userVerificationRequired: requestOptions.publicKey.userVerification === "required"
      },
      signature,
      raw: credential
    };
  } catch (error) {
    throw new CredentialRequestFailedError({
      cause: error
    });
  }
}
function verify4(options) {
  const { challenge, hash: hash8 = true, metadata, publicKey, signature } = options;
  const { authenticatorData, challengeIndex, clientDataJSON, typeIndex, userVerificationRequired } = metadata;
  const authenticatorDataBytes = fromHex2(authenticatorData);
  if (authenticatorDataBytes.length < 37)
    return false;
  const flag = authenticatorDataBytes[32];
  if ((flag & 1) !== 1)
    return false;
  if (userVerificationRequired && (flag & 4) !== 4)
    return false;
  if ((flag & 8) !== 8 && (flag & 16) === 16)
    return false;
  const type6 = '"type":"webauthn.get"';
  if (type6 !== clientDataJSON.slice(Number(typeIndex), type6.length + 1))
    return false;
  const match = clientDataJSON.slice(Number(challengeIndex)).match(/^"challenge":"(.*?)"/);
  if (!match)
    return false;
  const [_2, challenge_extracted] = match;
  if (fromBytes(toBytes8(challenge_extracted)) !== challenge)
    return false;
  const clientDataJSONHash = sha2563(fromString(clientDataJSON), {
    as: "Bytes"
  });
  const payload = concat(authenticatorDataBytes, clientDataJSONHash);
  return verify3({
    hash: hash8,
    payload,
    publicKey,
    signature
  });
}
var CredentialCreationFailedError = class extends BaseError2 {
  constructor({ cause } = {}) {
    super("Failed to create credential.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialCreationFailedError"
    });
  }
};
var CredentialRequestFailedError = class extends BaseError2 {
  constructor({ cause } = {}) {
    super("Failed to request credential.", {
      cause
    });
    Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "WebAuthnP256.CredentialRequestFailedError"
    });
  }
};

// node_modules/ox/_esm/core/WebCryptoP256.js
var WebCryptoP256_exports = {};
__export(WebCryptoP256_exports, {
  createKeyPair: () => createKeyPair,
  sign: () => sign5,
  verify: () => verify5
});
async function createKeyPair(options = {}) {
  const { extractable = false } = options;
  const keypair = await globalThis.crypto.subtle.generateKey({
    name: "ECDSA",
    namedCurve: "P-256"
  }, extractable, ["sign", "verify"]);
  const publicKey_raw = await globalThis.crypto.subtle.exportKey("raw", keypair.publicKey);
  const publicKey = from3(new Uint8Array(publicKey_raw));
  return {
    privateKey: keypair.privateKey,
    publicKey
  };
}
async function sign5(options) {
  const { payload, privateKey } = options;
  const signature = await globalThis.crypto.subtle.sign({
    name: "ECDSA",
    hash: "SHA-256"
  }, privateKey, from(payload));
  const signature_bytes = fromArray(new Uint8Array(signature));
  const r2 = toBigInt(slice(signature_bytes, 0, 32));
  let s2 = toBigInt(slice(signature_bytes, 32, 64));
  if (s2 > p256.CURVE.n / 2n)
    s2 = p256.CURVE.n - s2;
  return { r: r2, s: s2 };
}
async function verify5(options) {
  const { payload, signature } = options;
  const publicKey = await globalThis.crypto.subtle.importKey("raw", toBytes4(options.publicKey), { name: "ECDSA", namedCurve: "P-256" }, true, ["verify"]);
  return await globalThis.crypto.subtle.verify({
    name: "ECDSA",
    hash: "SHA-256"
  }, publicKey, concat(fromNumber(signature.r), fromNumber(signature.s)), from(payload));
}

// node_modules/ox/_esm/core/internal/ens.js
function unwrapLabelhash(label) {
  if (label.length !== 66)
    return null;
  if (label.indexOf("[") !== 0)
    return null;
  if (label.indexOf("]") !== 65)
    return null;
  const hash8 = `0x${label.slice(1, 65)}`;
  if (!validate2(hash8, { strict: true }))
    return null;
  return hash8;
}

// node_modules/ox/_esm/core/Ens.js
function labelhash(label) {
  const result = new Uint8Array(32).fill(0);
  if (!label)
    return fromBytes(result);
  return unwrapLabelhash(label) || keccak2562(fromString2(label));
}
function namehash(name) {
  let result = new Uint8Array(32).fill(0);
  if (!name)
    return fromBytes(result);
  const labels = name.split(".");
  for (let i2 = labels.length - 1; i2 >= 0; i2 -= 1) {
    const hashFromEncodedLabel = unwrapLabelhash(labels[i2]);
    const hashed = hashFromEncodedLabel ? fromHex2(hashFromEncodedLabel) : keccak2562(fromString(labels[i2]), { as: "Bytes" });
    result = keccak2562(concat(result, hashed), { as: "Bytes" });
  }
  return fromBytes(result);
}
function normalize3(name) {
  return ens_normalize(name);
}

// node_modules/viem/_esm/utils/ens/normalize.js
function normalize4(name) {
  return normalize3(name);
}

// node_modules/react-use-measure/dist/index.js
var import_react68 = __toESM(require_react());
function g2(n2, t2) {
  let o2;
  return (...i2) => {
    window.clearTimeout(o2), o2 = window.setTimeout(() => n2(...i2), t2);
  };
}
function j2({ debounce: n2, scroll: t2, polyfill: o2, offsetSize: i2 } = { debounce: 0, scroll: false, offsetSize: false }) {
  const a3 = o2 || (typeof window == "undefined" ? class {
  } : window.ResizeObserver);
  if (!a3) throw new Error("This browser does not support ResizeObserver out of the box. See: https://github.com/react-spring/react-use-measure/#resize-observer-polyfills");
  const [c3, h] = (0, import_react68.useState)({ left: 0, top: 0, width: 0, height: 0, bottom: 0, right: 0, x: 0, y: 0 }), e2 = (0, import_react68.useRef)({ element: null, scrollContainers: null, resizeObserver: null, lastBounds: c3, orientationHandler: null }), d2 = n2 ? typeof n2 == "number" ? n2 : n2.scroll : null, f3 = n2 ? typeof n2 == "number" ? n2 : n2.resize : null, w2 = (0, import_react68.useRef)(false);
  (0, import_react68.useEffect)(() => (w2.current = true, () => void (w2.current = false)));
  const [z3, m3, s2] = (0, import_react68.useMemo)(() => {
    const r2 = () => {
      if (!e2.current.element) return;
      const { left: y2, top: C2, width: H3, height: O2, bottom: S2, right: x2, x: B2, y: R2 } = e2.current.element.getBoundingClientRect(), l3 = { left: y2, top: C2, width: H3, height: O2, bottom: S2, right: x2, x: B2, y: R2 };
      e2.current.element instanceof HTMLElement && i2 && (l3.height = e2.current.element.offsetHeight, l3.width = e2.current.element.offsetWidth), Object.freeze(l3), w2.current && !D2(e2.current.lastBounds, l3) && h(e2.current.lastBounds = l3);
    };
    return [r2, f3 ? g2(r2, f3) : r2, d2 ? g2(r2, d2) : r2];
  }, [h, i2, d2, f3]);
  function v2() {
    e2.current.scrollContainers && (e2.current.scrollContainers.forEach((r2) => r2.removeEventListener("scroll", s2, true)), e2.current.scrollContainers = null), e2.current.resizeObserver && (e2.current.resizeObserver.disconnect(), e2.current.resizeObserver = null), e2.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", e2.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", e2.current.orientationHandler));
  }
  function b4() {
    e2.current.element && (e2.current.resizeObserver = new a3(s2), e2.current.resizeObserver.observe(e2.current.element), t2 && e2.current.scrollContainers && e2.current.scrollContainers.forEach((r2) => r2.addEventListener("scroll", s2, { capture: true, passive: true })), e2.current.orientationHandler = () => {
      s2();
    }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", e2.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", e2.current.orientationHandler));
  }
  const L2 = (r2) => {
    !r2 || r2 === e2.current.element || (v2(), e2.current.element = r2, e2.current.scrollContainers = E2(r2), b4());
  };
  return X2(s2, !!t2), W2(m3), (0, import_react68.useEffect)(() => {
    v2(), b4();
  }, [t2, s2, m3]), (0, import_react68.useEffect)(() => v2, []), [L2, c3, z3];
}
function W2(n2) {
  (0, import_react68.useEffect)(() => {
    const t2 = n2;
    return window.addEventListener("resize", t2), () => void window.removeEventListener("resize", t2);
  }, [n2]);
}
function X2(n2, t2) {
  (0, import_react68.useEffect)(() => {
    if (t2) {
      const o2 = n2;
      return window.addEventListener("scroll", o2, { capture: true, passive: true }), () => void window.removeEventListener("scroll", o2, true);
    }
  }, [n2, t2]);
}
function E2(n2) {
  const t2 = [];
  if (!n2 || n2 === document.body) return t2;
  const { overflow: o2, overflowX: i2, overflowY: a3 } = window.getComputedStyle(n2);
  return [o2, i2, a3].some((c3) => c3 === "auto" || c3 === "scroll") && t2.push(n2), [...t2, ...E2(n2.parentElement)];
}
var k2 = ["x", "y", "top", "bottom", "left", "right", "width", "height"];
var D2 = (n2, t2) => k2.every((o2) => n2[o2] === t2[o2]);

// node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
var MapShim = function() {
  if (typeof Map !== "undefined") {
    return Map;
  }
  function getIndex(arr, key) {
    var result = -1;
    arr.some(function(entry, index5) {
      if (entry[0] === key) {
        result = index5;
        return true;
      }
      return false;
    });
    return result;
  }
  return (
    /** @class */
    function() {
      function class_1() {
        this.__entries__ = [];
      }
      Object.defineProperty(class_1.prototype, "size", {
        /**
         * @returns {boolean}
         */
        get: function() {
          return this.__entries__.length;
        },
        enumerable: true,
        configurable: true
      });
      class_1.prototype.get = function(key) {
        var index5 = getIndex(this.__entries__, key);
        var entry = this.__entries__[index5];
        return entry && entry[1];
      };
      class_1.prototype.set = function(key, value) {
        var index5 = getIndex(this.__entries__, key);
        if (~index5) {
          this.__entries__[index5][1] = value;
        } else {
          this.__entries__.push([key, value]);
        }
      };
      class_1.prototype.delete = function(key) {
        var entries = this.__entries__;
        var index5 = getIndex(entries, key);
        if (~index5) {
          entries.splice(index5, 1);
        }
      };
      class_1.prototype.has = function(key) {
        return !!~getIndex(this.__entries__, key);
      };
      class_1.prototype.clear = function() {
        this.__entries__.splice(0);
      };
      class_1.prototype.forEach = function(callback, ctx) {
        if (ctx === void 0) {
          ctx = null;
        }
        for (var _i2 = 0, _a2 = this.__entries__; _i2 < _a2.length; _i2++) {
          var entry = _a2[_i2];
          callback.call(ctx, entry[1], entry[0]);
        }
      };
      return class_1;
    }()
  );
}();
var isBrowser2 = typeof window !== "undefined" && typeof document !== "undefined" && window.document === document;
var global$1 = function() {
  if (typeof global !== "undefined" && global.Math === Math) {
    return global;
  }
  if (typeof self !== "undefined" && self.Math === Math) {
    return self;
  }
  if (typeof window !== "undefined" && window.Math === Math) {
    return window;
  }
  return Function("return this")();
}();
var requestAnimationFrame$1 = function() {
  if (typeof requestAnimationFrame === "function") {
    return requestAnimationFrame.bind(global$1);
  }
  return function(callback) {
    return setTimeout(function() {
      return callback(Date.now());
    }, 1e3 / 60);
  };
}();
var trailingTimeout = 2;
function throttle(callback, delay2) {
  var leadingCall = false, trailingCall = false, lastCallTime = 0;
  function resolvePending() {
    if (leadingCall) {
      leadingCall = false;
      callback();
    }
    if (trailingCall) {
      proxy2();
    }
  }
  function timeoutCallback() {
    requestAnimationFrame$1(resolvePending);
  }
  function proxy2() {
    var timeStamp = Date.now();
    if (leadingCall) {
      if (timeStamp - lastCallTime < trailingTimeout) {
        return;
      }
      trailingCall = true;
    } else {
      leadingCall = true;
      trailingCall = false;
      setTimeout(timeoutCallback, delay2);
    }
    lastCallTime = timeStamp;
  }
  return proxy2;
}
var REFRESH_DELAY = 20;
var transitionKeys = ["top", "right", "bottom", "left", "width", "height", "size", "weight"];
var mutationObserverSupported = typeof MutationObserver !== "undefined";
var ResizeObserverController = (
  /** @class */
  function() {
    function ResizeObserverController2() {
      this.connected_ = false;
      this.mutationEventsAdded_ = false;
      this.mutationsObserver_ = null;
      this.observers_ = [];
      this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
      this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    ResizeObserverController2.prototype.addObserver = function(observer) {
      if (!~this.observers_.indexOf(observer)) {
        this.observers_.push(observer);
      }
      if (!this.connected_) {
        this.connect_();
      }
    };
    ResizeObserverController2.prototype.removeObserver = function(observer) {
      var observers3 = this.observers_;
      var index5 = observers3.indexOf(observer);
      if (~index5) {
        observers3.splice(index5, 1);
      }
      if (!observers3.length && this.connected_) {
        this.disconnect_();
      }
    };
    ResizeObserverController2.prototype.refresh = function() {
      var changesDetected = this.updateObservers_();
      if (changesDetected) {
        this.refresh();
      }
    };
    ResizeObserverController2.prototype.updateObservers_ = function() {
      var activeObservers = this.observers_.filter(function(observer) {
        return observer.gatherActive(), observer.hasActive();
      });
      activeObservers.forEach(function(observer) {
        return observer.broadcastActive();
      });
      return activeObservers.length > 0;
    };
    ResizeObserverController2.prototype.connect_ = function() {
      if (!isBrowser2 || this.connected_) {
        return;
      }
      document.addEventListener("transitionend", this.onTransitionEnd_);
      window.addEventListener("resize", this.refresh);
      if (mutationObserverSupported) {
        this.mutationsObserver_ = new MutationObserver(this.refresh);
        this.mutationsObserver_.observe(document, {
          attributes: true,
          childList: true,
          characterData: true,
          subtree: true
        });
      } else {
        document.addEventListener("DOMSubtreeModified", this.refresh);
        this.mutationEventsAdded_ = true;
      }
      this.connected_ = true;
    };
    ResizeObserverController2.prototype.disconnect_ = function() {
      if (!isBrowser2 || !this.connected_) {
        return;
      }
      document.removeEventListener("transitionend", this.onTransitionEnd_);
      window.removeEventListener("resize", this.refresh);
      if (this.mutationsObserver_) {
        this.mutationsObserver_.disconnect();
      }
      if (this.mutationEventsAdded_) {
        document.removeEventListener("DOMSubtreeModified", this.refresh);
      }
      this.mutationsObserver_ = null;
      this.mutationEventsAdded_ = false;
      this.connected_ = false;
    };
    ResizeObserverController2.prototype.onTransitionEnd_ = function(_a2) {
      var _b = _a2.propertyName, propertyName = _b === void 0 ? "" : _b;
      var isReflowProperty = transitionKeys.some(function(key) {
        return !!~propertyName.indexOf(key);
      });
      if (isReflowProperty) {
        this.refresh();
      }
    };
    ResizeObserverController2.getInstance = function() {
      if (!this.instance_) {
        this.instance_ = new ResizeObserverController2();
      }
      return this.instance_;
    };
    ResizeObserverController2.instance_ = null;
    return ResizeObserverController2;
  }()
);
var defineConfigurable = function(target, props) {
  for (var _i2 = 0, _a2 = Object.keys(props); _i2 < _a2.length; _i2++) {
    var key = _a2[_i2];
    Object.defineProperty(target, key, {
      value: props[key],
      enumerable: false,
      writable: false,
      configurable: true
    });
  }
  return target;
};
var getWindowOf = function(target) {
  var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
  return ownerGlobal || global$1;
};
var emptyRect = createRectInit(0, 0, 0, 0);
function toFloat(value) {
  return parseFloat(value) || 0;
}
function getBordersSize(styles2) {
  var positions = [];
  for (var _i2 = 1; _i2 < arguments.length; _i2++) {
    positions[_i2 - 1] = arguments[_i2];
  }
  return positions.reduce(function(size5, position) {
    var value = styles2["border-" + position + "-width"];
    return size5 + toFloat(value);
  }, 0);
}
function getPaddings(styles2) {
  var positions = ["top", "right", "bottom", "left"];
  var paddings = {};
  for (var _i2 = 0, positions_1 = positions; _i2 < positions_1.length; _i2++) {
    var position = positions_1[_i2];
    var value = styles2["padding-" + position];
    paddings[position] = toFloat(value);
  }
  return paddings;
}
function getSVGContentRect(target) {
  var bbox = target.getBBox();
  return createRectInit(0, 0, bbox.width, bbox.height);
}
function getHTMLElementContentRect(target) {
  var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
  if (!clientWidth && !clientHeight) {
    return emptyRect;
  }
  var styles2 = getWindowOf(target).getComputedStyle(target);
  var paddings = getPaddings(styles2);
  var horizPad = paddings.left + paddings.right;
  var vertPad = paddings.top + paddings.bottom;
  var width = toFloat(styles2.width), height = toFloat(styles2.height);
  if (styles2.boxSizing === "border-box") {
    if (Math.round(width + horizPad) !== clientWidth) {
      width -= getBordersSize(styles2, "left", "right") + horizPad;
    }
    if (Math.round(height + vertPad) !== clientHeight) {
      height -= getBordersSize(styles2, "top", "bottom") + vertPad;
    }
  }
  if (!isDocumentElement(target)) {
    var vertScrollbar = Math.round(width + horizPad) - clientWidth;
    var horizScrollbar = Math.round(height + vertPad) - clientHeight;
    if (Math.abs(vertScrollbar) !== 1) {
      width -= vertScrollbar;
    }
    if (Math.abs(horizScrollbar) !== 1) {
      height -= horizScrollbar;
    }
  }
  return createRectInit(paddings.left, paddings.top, width, height);
}
var isSVGGraphicsElement = function() {
  if (typeof SVGGraphicsElement !== "undefined") {
    return function(target) {
      return target instanceof getWindowOf(target).SVGGraphicsElement;
    };
  }
  return function(target) {
    return target instanceof getWindowOf(target).SVGElement && typeof target.getBBox === "function";
  };
}();
function isDocumentElement(target) {
  return target === getWindowOf(target).document.documentElement;
}
function getContentRect(target) {
  if (!isBrowser2) {
    return emptyRect;
  }
  if (isSVGGraphicsElement(target)) {
    return getSVGContentRect(target);
  }
  return getHTMLElementContentRect(target);
}
function createReadOnlyRect(_a2) {
  var x2 = _a2.x, y2 = _a2.y, width = _a2.width, height = _a2.height;
  var Constr = typeof DOMRectReadOnly !== "undefined" ? DOMRectReadOnly : Object;
  var rect = Object.create(Constr.prototype);
  defineConfigurable(rect, {
    x: x2,
    y: y2,
    width,
    height,
    top: y2,
    right: x2 + width,
    bottom: height + y2,
    left: x2
  });
  return rect;
}
function createRectInit(x2, y2, width, height) {
  return { x: x2, y: y2, width, height };
}
var ResizeObservation = (
  /** @class */
  function() {
    function ResizeObservation2(target) {
      this.broadcastWidth = 0;
      this.broadcastHeight = 0;
      this.contentRect_ = createRectInit(0, 0, 0, 0);
      this.target = target;
    }
    ResizeObservation2.prototype.isActive = function() {
      var rect = getContentRect(this.target);
      this.contentRect_ = rect;
      return rect.width !== this.broadcastWidth || rect.height !== this.broadcastHeight;
    };
    ResizeObservation2.prototype.broadcastRect = function() {
      var rect = this.contentRect_;
      this.broadcastWidth = rect.width;
      this.broadcastHeight = rect.height;
      return rect;
    };
    return ResizeObservation2;
  }()
);
var ResizeObserverEntry = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserverEntry2(target, rectInit) {
      var contentRect = createReadOnlyRect(rectInit);
      defineConfigurable(this, { target, contentRect });
    }
    return ResizeObserverEntry2;
  }()
);
var ResizeObserverSPI = (
  /** @class */
  function() {
    function ResizeObserverSPI2(callback, controller, callbackCtx) {
      this.activeObservations_ = [];
      this.observations_ = new MapShim();
      if (typeof callback !== "function") {
        throw new TypeError("The callback provided as parameter 1 is not a function.");
      }
      this.callback_ = callback;
      this.controller_ = controller;
      this.callbackCtx_ = callbackCtx;
    }
    ResizeObserverSPI2.prototype.observe = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (observations.has(target)) {
        return;
      }
      observations.set(target, new ResizeObservation(target));
      this.controller_.addObserver(this);
      this.controller_.refresh();
    };
    ResizeObserverSPI2.prototype.unobserve = function(target) {
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      if (typeof Element === "undefined" || !(Element instanceof Object)) {
        return;
      }
      if (!(target instanceof getWindowOf(target).Element)) {
        throw new TypeError('parameter 1 is not of type "Element".');
      }
      var observations = this.observations_;
      if (!observations.has(target)) {
        return;
      }
      observations.delete(target);
      if (!observations.size) {
        this.controller_.removeObserver(this);
      }
    };
    ResizeObserverSPI2.prototype.disconnect = function() {
      this.clearActive();
      this.observations_.clear();
      this.controller_.removeObserver(this);
    };
    ResizeObserverSPI2.prototype.gatherActive = function() {
      var _this = this;
      this.clearActive();
      this.observations_.forEach(function(observation) {
        if (observation.isActive()) {
          _this.activeObservations_.push(observation);
        }
      });
    };
    ResizeObserverSPI2.prototype.broadcastActive = function() {
      if (!this.hasActive()) {
        return;
      }
      var ctx = this.callbackCtx_;
      var entries = this.activeObservations_.map(function(observation) {
        return new ResizeObserverEntry(observation.target, observation.broadcastRect());
      });
      this.callback_.call(ctx, entries, ctx);
      this.clearActive();
    };
    ResizeObserverSPI2.prototype.clearActive = function() {
      this.activeObservations_.splice(0);
    };
    ResizeObserverSPI2.prototype.hasActive = function() {
      return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI2;
  }()
);
var observers2 = typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : new MapShim();
var ResizeObserver2 = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResizeObserver3(callback) {
      if (!(this instanceof ResizeObserver3)) {
        throw new TypeError("Cannot call a class as a function.");
      }
      if (!arguments.length) {
        throw new TypeError("1 argument required, but only 0 present.");
      }
      var controller = ResizeObserverController.getInstance();
      var observer = new ResizeObserverSPI(callback, controller, this);
      observers2.set(this, observer);
    }
    return ResizeObserver3;
  }()
);
[
  "observe",
  "unobserve",
  "disconnect"
].forEach(function(method) {
  ResizeObserver2.prototype[method] = function() {
    var _a2;
    return (_a2 = observers2.get(this))[method].apply(_a2, arguments);
  };
});
var index4 = function() {
  if (typeof global$1.ResizeObserver !== "undefined") {
    return global$1.ResizeObserver;
  }
  return ResizeObserver2;
}();
var ResizeObserver_es_default = index4;

// node_modules/connectkit/build/index.es.js
var import_qrcode = __toESM(require_browser());

// node_modules/react-transition-state/dist/index.es.js
var import_react69 = __toESM(require_react());
var PRE_ENTER = 0;
var ENTERING = 1;
var ENTERED = 2;
var PRE_EXIT = 3;
var EXITING = 4;
var EXITED = 5;
var UNMOUNTED = 6;
var STATES = ["preEnter", "entering", "entered", "preExit", "exiting", "exited", "unmounted"];
var startOrEnd = function startOrEnd2(unmounted) {
  return unmounted ? UNMOUNTED : EXITED;
};
var updateState = function updateState2(state, setState, latestState, timeoutId, onChange) {
  clearTimeout(timeoutId.current);
  setState(state);
  latestState.current = state;
  onChange && onChange({
    state: STATES[state]
  });
};
var useTransition = function useTransition2(_temp) {
  var _ref = _temp === void 0 ? {} : _temp, _ref$enter = _ref.enter, enter = _ref$enter === void 0 ? true : _ref$enter, _ref$exit = _ref.exit, exit = _ref$exit === void 0 ? true : _ref$exit, preEnter = _ref.preEnter, preExit = _ref.preExit, timeout = _ref.timeout, initialEntered = _ref.initialEntered, mountOnEnter = _ref.mountOnEnter, unmountOnExit = _ref.unmountOnExit, onChange = _ref.onChange;
  var _useState = (0, import_react69.useState)(initialEntered ? ENTERED : startOrEnd(mountOnEnter)), state = _useState[0], setState = _useState[1];
  var latestState = (0, import_react69.useRef)(state);
  var timeoutId = (0, import_react69.useRef)();
  var enterTimeout, exitTimeout;
  if (typeof timeout === "object") {
    enterTimeout = timeout.enter;
    exitTimeout = timeout.exit;
  } else {
    enterTimeout = exitTimeout = timeout;
  }
  var endTransition = (0, import_react69.useCallback)(function() {
    var newState;
    switch (latestState.current) {
      case ENTERING:
      case PRE_ENTER:
        newState = ENTERED;
        break;
      case EXITING:
      case PRE_EXIT:
        newState = startOrEnd(unmountOnExit);
        break;
    }
    if (newState !== void 0) {
      updateState(newState, setState, latestState, timeoutId, onChange);
    }
  }, [onChange, unmountOnExit]);
  var toggle = (0, import_react69.useCallback)(function(toEnter) {
    var transitState = function transitState2(newState) {
      updateState(newState, setState, latestState, timeoutId, onChange);
      switch (newState) {
        case ENTERING:
          if (enterTimeout >= 0) timeoutId.current = setTimeout(endTransition, enterTimeout);
          break;
        case EXITING:
          if (exitTimeout >= 0) timeoutId.current = setTimeout(endTransition, exitTimeout);
          break;
        case PRE_ENTER:
        case PRE_EXIT:
          timeoutId.current = setTimeout(function() {
            return transitState2(newState + 1);
          }, 0);
          break;
      }
    };
    var enterStage = latestState.current <= ENTERED;
    if (typeof toEnter !== "boolean") toEnter = !enterStage;
    if (toEnter) {
      if (!enterStage) {
        transitState(enter ? preEnter ? PRE_ENTER : ENTERING : ENTERED);
      }
    } else {
      if (enterStage) {
        transitState(exit ? preExit ? PRE_EXIT : EXITING : startOrEnd(unmountOnExit));
      }
    }
  }, [endTransition, onChange, enter, exit, preEnter, preExit, enterTimeout, exitTimeout, unmountOnExit]);
  (0, import_react69.useEffect)(function() {
    return function() {
      return clearTimeout(timeoutId.current);
    };
  }, []);
  return [STATES[state], toggle, endTransition];
};

// node_modules/connectkit/build/index.es.js
var types2 = Object.freeze({
  __proto__: null
});
var defaultConnectors = ({ app, walletConnectProjectId, coinbaseWalletPreference, enableFamily, familyOptions }) => {
  const hasAllAppData = app.name && app.icon && app.description && app.url;
  const shouldUseSafeConnector = !(typeof window === "undefined") && (window === null || window === void 0 ? void 0 : window.parent) !== window;
  const connectors = enableFamily ? [familyAccountsConnector(familyOptions)] : [];
  if (shouldUseSafeConnector) {
    connectors.push(safe({
      allowedDomains: [/gnosis-safe.io$/, /app.safe.global$/]
    }));
  }
  connectors.push(injected({ target: "metaMask" }), coinbaseWallet({
    appName: app.name,
    appLogoUrl: app.icon,
    overrideIsMetaMask: false,
    preference: coinbaseWalletPreference
  }));
  if (walletConnectProjectId) {
    connectors.push(walletConnect({
      showQrModal: false,
      projectId: walletConnectProjectId,
      metadata: hasAllAppData ? {
        name: app.name,
        description: app.description,
        url: app.url,
        icons: [app.icon]
      } : void 0
    }));
  }
  return connectors;
};
var globalAppName;
var globalAppIcon;
var getAppName = () => globalAppName;
var getAppIcon = () => globalAppIcon;
var defaultConfig = ({ appName = "ConnectKit", appIcon, appDescription, appUrl, walletConnectProjectId, coinbaseWalletPreference, chains = [mainnet, polygon, optimism, arbitrum], client, enableFamily = true, familyOptions, ...props }) => {
  var _a2, _b;
  globalAppName = appName;
  if (appIcon)
    globalAppIcon = appIcon;
  const transports = (_a2 = props === null || props === void 0 ? void 0 : props.transports) !== null && _a2 !== void 0 ? _a2 : Object.fromEntries(chains.map((chain2) => [chain2.id, http()]));
  const connectors = (_b = props === null || props === void 0 ? void 0 : props.connectors) !== null && _b !== void 0 ? _b : defaultConnectors({
    app: {
      name: appName,
      icon: appIcon,
      description: appDescription,
      url: appUrl
    },
    walletConnectProjectId,
    coinbaseWalletPreference,
    enableFamily,
    familyOptions
  });
  const config = {
    ...props,
    chains,
    connectors,
    transports
  };
  return config;
};
var isWalletInstalled = (name) => {
  if (typeof window === "undefined")
    return false;
  const { ethereum } = window;
  return !!((ethereum === null || ethereum === void 0 ? void 0 : ethereum[`is${name}`]) || (ethereum === null || ethereum === void 0 ? void 0 : ethereum.providers) && (ethereum === null || ethereum === void 0 ? void 0 : ethereum.providers.find((provider) => provider === null || provider === void 0 ? void 0 : provider[`is${name}`])));
};
var isFamily = () => isWalletInstalled("Family");
var isPhantom = () => isWalletInstalled("Phantom");
var isArgent = () => isWalletInstalled("Argent");
var isSafe = () => isWalletInstalled("Safe");
var Mock = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)"
}, children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20.5611 8.12948C21.0082 7.90729 21.5007 7.79167 22 7.79167C22.4993 7.79167 22.9919 7.90729 23.439 8.12948L23.4408 8.1304L33.0387 12.9293C33.577 13.197 34.031 13.61 34.3478 14.121C34.6649 14.6323 34.833 15.2218 34.8333 15.8234V27.2595C34.833 27.8611 34.6649 28.4511 34.3478 28.9624C34.031 29.4733 33.578 29.8858 33.0398 30.1535L23.4411 34.9528C22.9919 35.1775 22.4963 35.2947 21.994 35.2947C21.4918 35.2947 20.9964 35.1777 20.5472 34.9529L10.9475 30.1531L10.9452 30.1519C10.4071 29.8808 9.95535 29.4646 9.6411 28.9504C9.32739 28.437 9.16312 27.8464 9.16673 27.2448L9.16675 27.2417L10.0004 27.2475H9.16673V27.2448V15.8239C9.16705 15.2223 9.33518 14.6322 9.65222 14.121C9.96906 13.61 10.4221 13.1976 10.9604 12.9298L20.5592 8.1304L20.5611 8.12948ZM21.3031 9.62267L11.8706 14.3389L22 19.4036L32.1294 14.3389L22.697 9.62267C22.4806 9.51531 22.2416 9.45905 22 9.45905C21.7585 9.45905 21.5194 9.51534 21.3031 9.62267ZM10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241ZM22.8337 33.3923L32.2967 28.6608C32.5576 28.5312 32.7772 28.3313 32.9308 28.0836C33.0844 27.836 33.1658 27.5504 33.166 27.259V15.8243C33.1659 15.7786 33.1639 15.7331 33.1599 15.6878L22.8337 20.8509V33.3923Z", fill: "url(#paint0_linear_3546_7073)" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241Z", fill: "url(#paint1_linear_3546_7073)", fillOpacity: "0.3" }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_3546_7073", x1: "22", y1: "7.79167", x2: "22", y2: "35.2947", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "white" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "white", stopOpacity: "0.7" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint1_linear_3546_7073", x1: "22", y1: "7.79167", x2: "22", y2: "35.2947", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "white" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "white", stopOpacity: "0.7" })] })] })] });
var Injected = ({ ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M15.6505 3.64041C15.6501 3.64062 15.6497 3.64083 15.6493 3.64103L6.05165 8.43985L16.2501 13.5391L26.4484 8.43987L16.8508 3.64103C16.8504 3.64083 16.85 3.64063 16.8496 3.64043C16.6632 3.54806 16.458 3.5 16.25 3.5C16.042 3.5 15.8369 3.54806 15.6505 3.64041ZM28 10.4592L17.5001 15.7091L17.5 28.5205L27.248 23.6465L27.2508 23.6452C27.4757 23.5334 27.665 23.3611 27.7973 23.1477C27.9297 22.9342 27.9999 22.6881 28 22.4369V10.4592ZM15 28.527L15.0001 15.7091L4.50006 10.4591V22.4333C4.49831 22.6849 4.56687 22.9319 4.69807 23.1466C4.82896 23.3608 5.01696 23.5342 5.24095 23.6475C5.24148 23.6477 5.242 23.648 5.24253 23.6483L15 28.527ZM14.5207 31.0824L4.12104 25.8826L4.11759 25.8809C3.47681 25.558 2.93902 25.0625 2.56486 24.4502C2.19154 23.8394 1.99597 23.1365 2.00006 22.4207V10.0486C2.00044 9.33234 2.20062 8.62972 2.5781 8.021C2.95529 7.41274 3.49457 6.92167 4.13537 6.60291C4.13585 6.60267 4.13633 6.60243 4.13681 6.60219L14.534 1.40359L14.5368 1.40221C15.0692 1.13767 15.6556 1 16.25 1C16.8445 1 17.4309 1.13767 17.9633 1.40221L17.966 1.40358L28.3633 6.60219C28.3638 6.60245 28.3643 6.6027 28.3648 6.60295C29.0055 6.92171 29.5448 7.41276 29.922 8.021C30.2994 8.62973 30.4996 9.33168 30.5 10.0479V22.4376C30.4996 23.1538 30.2994 23.8565 29.922 24.4652C29.5448 25.0734 29.0056 25.5644 28.365 25.8831C28.3644 25.8834 28.3638 25.8837 28.3633 25.884L17.9664 31.0824C17.9663 31.0825 17.9665 31.0824 17.9664 31.0824C17.4316 31.3499 16.8415 31.4894 16.2435 31.4894C15.6455 31.4894 15.0554 31.3499 14.5207 31.0824C14.5205 31.0824 14.5208 31.0825 14.5207 31.0824Z", fill: "#CCCCCC" }) });
var WalletConnect = ({ background = false, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: background ? { background: "var(--ck-brand-walletConnect)" } : void 0, children: (0, import_jsx_runtime.jsx)("path", { d: "M9.58818 11.8556C13.1293 8.31442 18.8706 8.31442 22.4117 11.8556L22.8379 12.2818C23.015 12.4588 23.015 12.7459 22.8379 12.9229L21.3801 14.3808C21.2915 14.4693 21.148 14.4693 21.0595 14.3808L20.473 13.7943C18.0026 11.3239 13.9973 11.3239 11.5269 13.7943L10.8989 14.4223C10.8104 14.5109 10.6668 14.5109 10.5783 14.4223L9.12041 12.9645C8.94336 12.7875 8.94336 12.5004 9.12041 12.3234L9.58818 11.8556ZM25.4268 14.8706L26.7243 16.1682C26.9013 16.3452 26.9013 16.6323 26.7243 16.8093L20.8737 22.6599C20.6966 22.8371 20.4096 22.8371 20.2325 22.6599L16.0802 18.5076C16.0359 18.4634 15.9641 18.4634 15.9199 18.5076L11.7675 22.6599C11.5905 22.8371 11.3034 22.8371 11.1264 22.66C11.1264 22.66 11.1264 22.6599 11.1264 22.6599L5.27561 16.8092C5.09856 16.6322 5.09856 16.3451 5.27561 16.168L6.57313 14.8706C6.75019 14.6934 7.03726 14.6934 7.21431 14.8706L11.3668 19.023C11.411 19.0672 11.4828 19.0672 11.5271 19.023L15.6793 14.8706C15.8563 14.6934 16.1434 14.6934 16.3205 14.8706L20.473 19.023C20.5172 19.0672 20.589 19.0672 20.6332 19.023L24.7856 14.8706C24.9627 14.6935 25.2498 14.6935 25.4268 14.8706Z", fill: background ? "white" : "var(--ck-brand-walletConnect)" }) });
var MetaMask = ({ background = false, ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, style: background ? {
  background: "linear-gradient(0deg, var(--ck-brand-metamask-12), var(--ck-brand-metamask-11))",
  borderRadius: "27.5%"
} : void 0, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { d: "M27.2684 4.03027L17.5018 11.2841L19.3079 7.00442L27.2684 4.03027Z", fill: "var(--ck-brand-metamask-02)", stroke: "var(--ck-brand-metamask-02)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M4.7218 4.03027L14.4099 11.3528L12.6921 7.00442L4.7218 4.03027Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M23.7544 20.8438L21.1532 24.8289L26.7187 26.3602L28.3187 20.9321L23.7544 20.8438Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M3.69104 20.9321L5.28117 26.3602L10.8467 24.8289L8.24551 20.8438L3.69104 20.9321Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.5327 14.1108L8.98181 16.4568L14.5081 16.7022L14.3117 10.7637L10.5327 14.1108Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M21.4576 14.1111L17.6295 10.6953L17.5018 16.7025L23.0182 16.4571L21.4576 14.1111Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.8469 24.8292L14.1647 23.2096L11.2984 20.9717L10.8469 24.8292Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M17.8257 23.2096L21.1531 24.8292L20.6918 20.9717L17.8257 23.2096Z", fill: "var(--ck-brand-metamask-08)", stroke: "var(--ck-brand-metamask-08)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M21.1531 24.8296L17.8257 23.21L18.0906 25.3793L18.0612 26.2921L21.1531 24.8296Z", fill: "var(--ck-brand-metamask-06)", stroke: "var(--ck-brand-metamask-06)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.8469 24.8296L13.9388 26.2921L13.9192 25.3793L14.1647 23.21L10.8469 24.8296Z", fill: "var(--ck-brand-metamask-06)", stroke: "var(--ck-brand-metamask-06)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M13.9877 19.5389L11.2196 18.7242L13.1729 17.8311L13.9877 19.5389Z", fill: "var(--ck-brand-metamask-09)", stroke: "var(--ck-brand-metamask-09)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M18.0023 19.5389L18.8171 17.8311L20.7802 18.7242L18.0023 19.5389Z", fill: "var(--ck-brand-metamask-09)", stroke: "var(--ck-brand-metamask-09)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.8468 24.8289L11.3179 20.8438L8.24561 20.9321L10.8468 24.8289Z", fill: "var(--ck-brand-metamask-03)", stroke: "var(--ck-brand-metamask-03)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M20.6821 20.8438L21.1532 24.8289L23.7544 20.9321L20.6821 20.8438Z", fill: "var(--ck-brand-metamask-03)", stroke: "var(--ck-brand-metamask-03)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M23.0182 16.4565L17.5018 16.7019L18.0122 19.5387L18.827 17.8308L20.7902 18.7239L23.0182 16.4565Z", fill: "var(--ck-brand-metamask-03)", stroke: "var(--ck-brand-metamask-03)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M11.2198 18.7239L13.1829 17.8308L13.9878 19.5387L14.5081 16.7019L8.98181 16.4565L11.2198 18.7239Z", fill: "var(--ck-brand-metamask-03)", stroke: "var(--ck-brand-metamask-03)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M8.98181 16.4565L11.2983 20.9718L11.2198 18.7239L8.98181 16.4565Z", fill: "var(--ck-brand-metamask-10)", stroke: "var(--ck-brand-metamask-10)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M20.7901 18.7239L20.6919 20.9718L23.0181 16.4565L20.7901 18.7239Z", fill: "var(--ck-brand-metamask-10)", stroke: "var(--ck-brand-metamask-10)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M14.508 16.7021L13.9878 19.5389L14.6356 22.886L14.7828 18.4788L14.508 16.7021Z", fill: "var(--ck-brand-metamask-10)", stroke: "var(--ck-brand-metamask-10)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M17.5017 16.7021L17.2367 18.4689L17.3545 22.886L18.0121 19.5389L17.5017 16.7021Z", fill: "var(--ck-brand-metamask-10)", stroke: "var(--ck-brand-metamask-10)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M18.0121 19.5388L17.3545 22.886L17.8257 23.2099L20.6918 20.972L20.79 18.7241L18.0121 19.5388Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M11.2196 18.7241L11.2981 20.972L14.1644 23.2099L14.6355 22.886L13.9877 19.5388L11.2196 18.7241Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M18.0615 26.2917L18.0908 25.3788L17.8455 25.1628H14.145L13.9192 25.3788L13.9388 26.2917L10.8469 24.8291L11.9267 25.7126L14.1155 27.234H17.875L20.0736 25.7126L21.1533 24.8291L18.0615 26.2917Z", fill: "var(--ck-brand-metamask-07)", stroke: "var(--ck-brand-metamask-07)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M17.8258 23.2096L17.3546 22.8857H14.6357L14.1646 23.2096L13.9191 25.379L14.1449 25.163H17.8454L18.0907 25.379L17.8258 23.2096Z", fill: "var(--ck-brand-metamask-04)", stroke: "var(--ck-brand-metamask-04)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M27.6806 11.7552L28.5149 7.75041L27.2683 4.03027L17.8257 11.0387L21.4575 14.1109L26.591 15.6128L27.7296 14.2876L27.2389 13.9342L28.0241 13.2178L27.4156 12.7465L28.2007 12.1478L27.6806 11.7552Z", fill: "var(--ck-brand-metamask-05)", stroke: "var(--ck-brand-metamask-05)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M3.48486 7.75041L4.3192 11.7552L3.78916 12.1478L4.57441 12.7465L3.97566 13.2178L4.7609 13.9342L4.27012 14.2876L5.39892 15.6128L10.5325 14.1109L14.1644 11.0387L4.72164 4.03027L3.48486 7.75041Z", fill: "var(--ck-brand-metamask-05)", stroke: "var(--ck-brand-metamask-05)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M26.591 15.6122L21.4575 14.1104L23.0181 16.4564L20.6919 20.9716L23.7544 20.9323H28.3186L26.591 15.6122Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.5326 14.1104L5.39897 15.6122L3.69104 20.9323H8.24551L11.2982 20.9716L8.98168 16.4564L10.5326 14.1104Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M17.5018 16.7018L17.8258 11.0381L19.3177 7.00391H12.6921L14.1645 11.0381L14.5081 16.7018L14.6258 18.4883L14.6356 22.8856H17.3546L17.3742 18.4883L17.5018 16.7018Z", fill: "var(--ck-brand-metamask-01)", stroke: "var(--ck-brand-metamask-01)", strokeWidth: "0.269931", strokeLinecap: "round", strokeLinejoin: "round" })] });
var Coinbase = ({ background = false, ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("circle", { cx: "10", cy: "10", r: "10", fill: "var(--ck-brand-coinbaseWallet)" }), background && (0, import_jsx_runtime.jsx)("rect", { rx: "27%", width: "20", height: "20", fill: "var(--ck-brand-coinbaseWallet)" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.0001 17C13.8661 17 17.0001 13.866 17.0001 10C17.0001 6.13401 13.8661 3 10.0001 3C6.13413 3 3.00012 6.13401 3.00012 10C3.00012 13.866 6.13413 17 10.0001 17ZM8.25012 7.71429C7.95427 7.71429 7.71441 7.95414 7.71441 8.25V11.75C7.71441 12.0459 7.95427 12.2857 8.25012 12.2857H11.7501C12.046 12.2857 12.2858 12.0459 12.2858 11.75V8.25C12.2858 7.95414 12.046 7.71429 11.7501 7.71429H8.25012Z", fill: "white" })] });
var FamilyAccount = () => (0, import_jsx_runtime.jsxs)("svg", { width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("rect", { width: "88", height: "88", fill: "var(--ck-family-accounts-brand)" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M69.3985 17.8729C71.1916 19.6658 72.1993 22.0974 72.2 24.633C72.2023 26.8681 71.4164 29.0324 69.9804 30.7453C68.5444 32.4582 66.5504 33.61 64.349 33.998V34.1876C66.5344 34.6137 68.5036 35.7864 69.9194 37.5047C71.3351 39.223 72.1093 41.3801 72.1093 43.6064C72.1093 45.8327 71.3351 47.9898 69.9194 49.7081C68.5036 51.4264 66.5344 52.5991 64.349 53.0252V53.2134C66.6856 53.6659 68.7701 54.972 70.1962 56.8773C71.6224 58.7825 72.2881 61.1504 72.0635 63.5196C71.839 65.8888 70.7404 68.0896 68.9817 69.6931C67.223 71.2966 64.9303 72.188 62.5502 72.1935C57.9579 72.1935 54.0768 68.8855 53.1774 64.5316H52.9408C52.512 66.6983 51.3421 68.6482 49.632 70.0464C47.9219 71.4445 45.7783 72.2037 43.5693 72.1935C38.977 72.1935 35.0959 68.8855 34.1965 64.5316H33.9599C33.6143 66.2325 32.8128 67.8076 31.641 69.0882C30.4693 70.3688 28.9715 71.3069 27.3077 71.8021C25.644 72.2973 23.8769 72.3309 22.1955 71.8995C20.5141 71.468 18.9816 70.5877 17.7619 69.3526C16.5423 68.1175 15.6813 66.5741 15.2711 64.8876C14.861 63.201 14.917 61.4347 15.4333 59.7776C15.9496 58.1204 16.9067 56.6347 18.2022 55.4795C19.4977 54.3242 21.083 53.5428 22.7884 53.2188V53.0306C20.603 52.6045 18.6337 51.4318 17.218 49.7135C15.8022 47.9952 15.0281 45.8381 15.0281 43.6118C15.0281 41.3854 15.8022 39.2284 17.218 37.5101C18.6337 35.7917 20.603 34.6191 22.7884 34.1929V34.0034C21.0847 33.6728 19.5027 32.8862 18.2109 31.7274C16.9192 30.5685 15.9661 29.081 15.4533 27.4232C14.9405 25.7655 14.8871 23.9996 15.299 22.3139C15.7108 20.6283 16.5723 19.0859 17.7918 17.8512C19.0112 16.6166 20.5429 15.7359 22.2235 15.3031C23.9041 14.8703 25.6706 14.9015 27.3348 15.3935C28.9991 15.8855 30.4986 16.8198 31.6736 18.0968C32.8486 19.3738 33.655 20.9457 34.007 22.6449H34.2436C34.6954 20.4915 35.8758 18.5596 37.5858 17.1748C39.2958 15.79 41.431 15.0369 43.6315 15.0425C45.832 15.048 47.9634 15.8118 49.6665 17.2052C51.3695 18.5985 52.5402 20.5363 52.9811 22.692H53.2178C54.1682 18.3381 57.9996 15.0246 62.6376 15.0717C65.1735 15.0724 67.6053 16.08 69.3985 17.8729ZM31.9823 29.5165C30.2472 29.5165 28.8497 30.9389 28.8758 32.6738C28.9236 35.8456 28.9876 40.7732 28.9876 44.421C28.9876 48.0656 28.9237 52.9878 28.8759 56.1599C28.8498 57.8992 30.2516 59.3256 31.9912 59.3256H55.6872C57.4267 59.3256 58.8286 57.8992 58.8024 56.1599C58.7546 52.9878 58.6908 48.0656 58.6908 44.421C58.6908 40.7732 58.7547 35.8456 58.8025 32.6738C58.8287 30.9389 57.433 29.5165 55.6979 29.5165L31.9823 29.5165Z", fill: "white" })] });
var Family = ({ ...props }) => {
  const img = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAALQAAAC0CAYAAAA9zQYyAAABQGlDQ1BzUDNDAAB4nGNgYHyQk5xbzKLAwJCbV1IU5O6kEBEZpcD+iIGZQYSBk4GPQTYxubjAN9gthAEIihPLi5NLinIYUMC3awyMIPqybkZiXopc+xz3pvOzD4rlWyascy2VY8APuFJSi5OB9B8gVkkuKCphYGAEuoZBqbykAMR2AbJFkjMSU4DsCCBbpwjoQCC7BSSeDmHPALGTIOw1IHZRSJAzkH0AyFZIR2InIbFzc0qToW4AuZ4nNS80GEhzALEMQzFDAIMxgzMONWxgNc5AaMCgCAov9HAoTjM2gujicWJgYL33//9nVQYG9skMDH8n/P//e+H////8GBiYZzEwHBBB6G++z8Bgux/EQoh5AfkbzYHBtBUhpmHBwCDIxcBwoqIgsSgRLMQMxExpmQwMn5YzMPBGMjAIXwDqiQYAOQZcLsEClb4AAGmfSURBVHgB1b0J1G3HVR6497n3/98o6Q0anubBludJeAiTbYwd2gGC6UACBFZY7gVNB3CaJEB3VhbQhNW9OtDQkAYSIOkEGhJCGJrEBGzJkrEsT7Jky5JszXrSexqf3qw3/v891TXsvWvvferce/8nyabrvfPfc+rUqdq166u9d+06pwrP+/CHA3AI8RQRmqFxbyRliVdpcSQ9jj27IASwdAVHVxi7l65hcZAn6NlFdOOce4vCgB5Fc5iXdiN1abSFP1/2PrRoUtiYR/Oy9C9Tr7EwNVc4pwojTDFxC0CMI2nH8hwlhX4D5ZOvWwzy9cHlS8FlzhfwZNlyDN2pPlSXwT0VAtd7yTL8+SDuHOvCzzKdyOButIeuj6HfpTXtu8Ew3WD6NpjnALnFuI1IPB9GK0n5ZiCM9H4GyTJhLqAX1GHZMoJK70Etp0tK4nlhLqBfQF08CFnAgPrN8SHMz0N1YmjluYGwNKDnSeV5DEOnttHnpZ7fKBDyuWJWUHnKqWLUsgyaJ4WbjT2nDv56TCWL6gaw0vklrAv/vpD2mNcWrTpAI00+H9G0G5XWU/1gs8fBSCM1gMq/Y/d9BzD3WiqUpS4zQakyBkDQ6k7HQ5uZi4CgQepphJE66DiuC9PM57lcpsU1auA6Ul1Q1S399o6mF1qXFDq5NbyHqi7QoBmZ5wp8wdn+3G6o6qifRV0vQ3QtbxGwPUbT+RSXeEj/NiUyqQwP5BaIOw8Gl94HAwTKS0viXkk1fejeru02k2+jrNb1gE7d4GA7YwtEYYEtHyhN0HWh6/Q7AQV4bmidPwzDaF00rbpdGnHQqI+vh26LoPjNdQCi3XeAlL7zcaA6g5PYCDBqMup70xahvpK2DkMACmjVvc4904EFApL08dJgAAxVUX3OTEIlFcYYigooPi9fZ0nPtCj6fKPr+2MSD+fUARzNDBCJ0yBR9ZT6qjKC8jRImcxfvuf4b84pLXBdsG1bG94pLSL00i0taHpdP4rv6XnoOiut1aDSaCyYI3AV7aM29KAyc1QwNqSyZ5gHdEcM7kbyaAXfmOYg5vaF2MrQxCzFGFZ3Oj9dH98xPc263t0YQKAdPCA0CHxn1CDo+Z4ysSQvrovTPjkksHCdoLYDtOpCaY3AAZgvYBjABFShWdGfjs7VKcepugSiS3dK/6vt80HHUnVfalA4b2CHDROCG1uDmM87dd4Cgy5HiG1I2OB6uwEC9VhOhxosytZrSSAg2nU9dZ2wRT+MaB+mXwdtd7pD6qJA3ENtQCOxAYZ2d6M+Y3w2dQEL9rntQXXSAGOaO2f+zcACGZVwMRJZ5QtULxE+/OvKHAvTFhMs7bZx5XyOVNZg7kAxT0nkTkmNVNFunoRz6rZXKi4xxvR2YhoDm5ntJRxxroJhBMQtIHe+vj6e8muBTMwKJgFqg/eUV0/8aNWnWRfn/QBV/gDUrh2w0Un9PZMv063axEtfXxehn/JhgdNzHRoDQM2fWiU12Hb3OMyV0K3KeDAbadUA8AQsIDqVRqS1VndOOoCuWCBmIavgdE0MI/D2JCl61eAi7RSYWVWO1Rddp9QN7evQAnk5tJyRUgemknQ6rgMfyozyoNHqfTDo1PWAtkQWuhttxveB6lDqpWtQz7XG0HTqw8fNFF3mOWU+5eKcRNYSG6AN6qk2wNHZKWJPkgqQHstSFZxUpvOJZhTlNaHryQig828AwBFzoFQ0MQ8ziDOYMTGhJ6akhq+gnjGoYWjD8YBEQK0GFbrjAYyD2AAhd6KSFQNZQBCcOMDaTj1wfahjgjU5pB7U2B1UbcPqfCDJuC6qzYxWTPGR3xPTBqm9dD1R6gLAHdO2SSDaU6MJX/u+CA3XMWdES0edk6UzUr14nNDxs/QrfnPlANBSnmkKCsNTQ6gGk+r1A3uR47ykggrmibrWcRbQLOGGErEVqkRT6jjm2qtG5/MJAXwGwajApunhB0QODFrTtECd03VWwmk+1QqEobnBEjrTXkDOkjkBYUIgSHGmkyIaST/wCuCQnk4ETW2TBOSBSei1UkMDcJlFkBBPu0mhnwA6I3BO0nlMs574SrydoRt7Qe0A2VRRYDbjKIVRI6kpvpgcaJWjrkCnC8Wh50I3rkhhdT1RQJ5AZaIBNjZUdqOHDtSub2xEB+5YTpSQM2ApUk0PaA0wEF3Du/qBBcBE1Vnbn1wXAKtxuNzg6qCBrTtlp0FO5Zl0YMHMdeBfDUoteSe+ftxhVVov3TWPQNOv24bbIZ33SaOU81mU4h1pmBkdPEBE6rg6yLgIQAb1fvAbPF0UN5hY0b3GxI+AWYOXwTzRYCYglHN7TzPQgDoUM0QTUCUrSzEl4bCaGTOodhoDPEvr9Gwo5kp+tsOB71ZLpPpb6DYN7+qLyBpJaRwYDqiCrouugx8HxLqzNJ5BBbnutMYT4iUoCYNkBhWTCJrmoBU0heaJ/Or2BlUbMjWAgdww9aCAWOoQUnukMgjY8VgHEBM3g5qvCcAz6vxsZg0EkBIOmsfW5OCEKpGW2PMkM/fwdD51gJ4OAA71GfRmS2oAa9MOJxpIMkOpeJZiufGKqVFUNWSmiS2HKObKhJiuxw8AUMtnerDS5U2nOh6gdMD1YL5hFZYChfpbxwDa/scMBLYnRf1C6aCdgF55CAhMpmWx2vBm4Ad2LMNAnrTa1LW/RkVQvz0SqEmbzLDSOyOAI4E4CyqlTGYAYusz9tiG7uhX28/efQsNoFsJ7aTVIjNDwAkV2CsUxyCepgEIn9MzU8VII6mBTZxu0Mm4LxZgFk9HH9hOLoydEUNnGeCJjpAlQxo4zrB6C/TslkhodLYmWM1R60qgRjAdskq5CuiuYkB0pAZzoQVIqiHVAXPdZoE7axBg8AAraFDTL41ATVsyLRMPaAJz4k+HOJDURZr7+tiKsJZhM7AnwTIjzZN+14nvqdz19BsHjetprBH6iq0krWO8ES5OUouzAut7MQxs78qbagaAIV7hSR2+FwuDSBJPiTHTzsalgqY0us73FSgK07vCQG0OKsIDeQuyT0M1fC82clFjEwZ1aphQ8u9j3myKGFCr+gFJBRiRVtV0AiPhJtToDPTKJwvu5KGRupBUyx0T2EYO1VSCamumDjkDZUqxlA7VG1AHuEPtqr0YRiKHInSqhq0dtQ7WM+VO42DtlCylCdgzoT+QidFl4dLFmGw/0zQ3BvqNQM64i/HrDNqgXsrCOkcR9GA4uPc7FKiH73JQZtq3DNBQXQrMGsgGxJHQBOQVD/RScJVwWCUgWEEjhBYGBlHB1b5ij0Yqm+w1sTeBwIDk4bAN4AdTnZNqbFMycLWZNAUwEk1AQLDNT5PNL1PtSH+oSPbozUgDyYAqJliPfzU41sksYcnNklGm+509WQFNNjSoekDxykwRlLSm9KFAll18bIYBtbuRNsjjGDVucQIl//ZdHiCugRWWeZzUB4lc122OzMnqj0elVVEBHxRd1YbGxswSWneOPrRknjgJzQBeSQXEXlriC4jzgWAGi2xf8UBjU6zohaurcPnmzXDhpk2wfTrN6VJYiww4urYGz545HY8z8FQ8nl9fJ3VTGmad6ElgTnlP2FOAIICBUAEFaAFQzQ0w9r4e3IrXgyVYKEp4c6J902a4YssW2BXrcIGifT0mObJ2Fg6ePQvPpuP0aTg163MjBCqnF7o7GkwFMg0YLKTaMZCEZ5+8FUwMYgxBBniTGDPpap0Sz/PAkbr6aqR9T+T3ZYnvkfYdK6uwQoPztShNj6yvwcHI70OR/wfi71oocnKSNVDRmKklspuuLzRnV12H1L4I1P0K3mKesZoQLRAxwQCgvl0Itl49COKNIBLhBM5tJ+2Lbb+z9zUXScUgJRBHBqxgjVtByEcBeKxsVwBfGFmBsDsy7y07dsDrLjgfrti61fiijXoBG1Lc/pOn4LaDB+ELR4/CExHoE6h2bx6ksInCg8v0r3MAgDqZoDutsZs7HhBSJ8y9IsDO1RV4285d8MZI+1WRdmjQPhYeO3kSPnv4MNx97Dg8d/ZMAW/uOB3Z0oX2DBJkSVht7p5MFxYG0oaBtARWLcJ1wcD+4BA73Ap89a6d8NadO+G6bduk8y0KqaxHnj8Bdx45DPcePw6HI8iZ71nDTAqPOnLfFewEKLosZDv6LCIBtmfXjwCbQd0pHgplJJmDaT9Kt+MjHwk8KzaQ0NAYAPJvNicSgK1kLkeXpfCKiqu2NKu3ItleFpn4zgsvhOu3b4ctkwm8kHB6NovgOJLB/cCJE1k6BG50UDNxoQ5okMSz7rzae6HtzokAuaS7LoL37ZH2V5+3HbZON/w1mwlnorS668hR+EwE94PPP0/mRPWArIdgBl3F2xGMXz6HUA2PjqU0qAF3KGB/VaT5a3ftjkDeAdsi7QHOPSS+fz7Sfnuk/eHIdx6j5MkUoj0da3Tocx233vO9XsxGGUuE6n/n+vo3FLOpvDMCWrtl6mDASWMA671g4HYKzPE+S+gVksgrnQI0VKYmc+JvXroHXhGBPO06eDFDqmgCx588+SQ8dupUUUuIakDGDAABM1uKqEAsPmg2LWg0tCNKte+96kp4RQRFt6REWzakBrvv+PPwB/v3Z9Ok0A7i1eBJojqrCKJ1St1BNA2bUEDSOMTEF0VT4u9ccTm8MWrDTS8y35O34gtHj8EHn34q0r5WXHohmYAgIE6/ZxuA1qBOgF4nQK+HOljWM6UMaDZD+Bp33Xxz0CaHnhmc52NOYNbSeVWBd8VdywCQ7Ll3XXQRvOfii7JkaIWNSosxSCVb+2PPHYQ/fvIJksQo7wME9aAfQ0xATUJAsTETs1L811+4G755z55RbfJi0v6JSPtHDhwgW5VnRosZUj02QTSOJyKra3LzrcZn3x35/k2XXAI7VlfgpaT9yNnE9+ci7c/KmCWZSwLoBFqwYD4bO0MaNM76XtLMwIGaB8TpnREqS795mTvurltuCaJuQzBvvlW7y87wMWjT+aoyMzKQs6nRxQFGBfOUpNv2CIIkHb4q2msvBkOXZfDnjhyB33p0b2Za1j7Kfg5gvTnFi6EnWbJ+jwDu4G9dfjm8ddcu+HLSfmek/T/t2x8HjzOlaQqoxdMR9Dsiyk/bFzAngfM9V14B74yA/nLRnvL89KFD8B8j7Wtk+qUB4zowgIskzucB5HyNJHO6z+aKMT+CMrNC48MHA2iwgz8D6K4TG9hIZgEzCLg3sX0NNOqMBe6Oqu6HrrsWLo+j/40GPSgcY+BY4LTPxFH5P7/vfng+AmNKkpols6TDAuKJPFsAcX40MX7k5S+Di6IHwOcbXkKaOSTT41cfeih6SNbFF6xfudQ0VDdnAcN5UYj841dcD5cpvnvazoXmscGuj9sXTb5/8eBDcCJ1yA5zR0yS+GwC9qzPQD4DUCV1qCA+21vTQ3zxLVDT0XkwyygZ3bsWQC4eBOuLJjuT/bJTSsv2cpIS26YT+B8jIOaBOcw5ACzzwxLpfdqLIxj/yateCTsjLezDLrOWoUz6xCN1wNUcTxM+8cGdEcwfePnLDZiXpWEjNM9Lm9x/P3jttdF2n+aIRHv2HvFv5j/Vg/hfbP0p/Nj1L4dLI99btL0QmmHJuOS+/PFXviK6AKcZC0lIVCFZvDlm4goAzNt/+gDCKGITsymY2Vk5x6HbLoOYZv8Q0cyUsSuLz6eB3paKPWwaH/yxCIjdDhAA4yB8oWEsz+TT/tFIy7YotbJ/FoqfXA9icx1K14etUdP8wHXXRdpXR8v5ctCdQgLlD0RQbyVbMQsNHnhD0pQdTV4V03FTbKvUEa9wbkRd1osdxvJMwuSHIh+3RH5mUCczKJDQwzp/IJNYIRiBarCovEwcPE6rVG4k4BlCfmlHu4D8Sy/sh8xqi1Tf9111VXTUb5HWCvqAL++RQmrg74r2JKT3B/o+D/hEYkDxj2fAxOM7or1/6ZbN0lhfrqMfof2yrVvgu6++Kr8TAQQMkWpQ/L1pliIB5TuvuCLWdcuXnfYW3SlcRXzPcQqU5lVWsO/PdAp7nZPMgxluCnV4pG1JgIGETrf1K5R62rcQRUzNPE1+xB7ee8nF0c+5SzLVFQwNTmuwvxghjFy/OQ7s3hcHeOkLizRb1ZG0Tu8cYF80y7suvhjeSIPXVj4vEomjYYz2115wAXxDpC3RWKamifaYgGl/T/RkfG30j4/l81LS7vPX52+LfH9XpCthIwuTAFkay3Q8VN8/v5ZbDmhaDC1wdwMgq0FhzdD2EHnHFqDOygHbL2UgtXtlJYOCy9Ijz6B+5RysGmkBeyMNEUae4eu3RffbxXGKOvFWXm/MXoEeLki077lk8Py5gOFcaB4rj8+/Mfrvz4/2cT8rHbC8OlDAvCvOuL7z4osG+W2E9hdCcyten39LpP3S1U3lDUEynXhsVj+WAPNujFgIjEXKK3umDCaR3zdBaAE7hQ6UkR7Um1dQ3+LStk5ShcmX+LejykvA4AoxOMNYhdGCXqQ6Abtn6Q3LHbAgPvnA33fl5TCLo+9AhfDvt0Xa03sNPh9Ysuxl6Fg2bav8RNu3RA2TrvI3lUR3mtj45ssugy1q5u/FouNc+Qzu/LyIif82mnKJ1uyfCEraOiBrSZzGb4IxJZH1dQG2KlQjXq7pqvYO/Uph8QTwb5J2aaYnzf69Kc5E+RoGOg/+gJGggM00eft7meAZy9evjur7+jjb10dQJ2CvR4l37bbtMf78QVqfz5crjJX/hl074cpol84izcl0Sr9Xb9sGN+zeJWm/krTPK+/1ke/plYdEM7/fzC9KCZC1V0OeVBIZrEbnIINCbTvbN++GtrQBNhFUZqSi37CfwTuiAz+5YzJTcQnGkgTmY9DjvfSmZzY6uHRF5uPN0aY7G8GcfaKR9q+O6ppnE33ar/QB7vyrI5+TPbq2Pst1+Np43QLyV5pWH59ej/jr0aRLUrr40QO9C88vMhG20L71yVhMQeNUBzOZrxN7/Egvol+2oXMhGVTllcH0rsCbd9XB1DKAA1eWGRx6JKrE6MySdm+hNCPlJkm3ParB9HLQjmjbXRslNkC7cb5SoQWQFF5NLxYl2tNk1us03+ErS/uA38Eerzv/fNgZ+Z60S5bSYSg8BWuUZwuT4OI6j3C9iqjpHfyk8QNW8Zu+8k3S+YZoamzuJpaZDqCtwd4ouAFGvR+BEjMjFqVtSY80A/raHTvh9NpaNjW2OvtT/4LLw9/zYUEfW5i2Va4+ki39mgt2RNrX4U27d2fJt0g6Amyc5jAvrQYqzOlMzgmQbOmviTRnKd0HSay/jClvWllvhuDVu+1kzDdyQ//1lCGpB21upJ6WiHt7GmEzfaqiwgBo91h9T38q5cOoaYJDcoNKp6vg6bkhejwSU18f7U//OuY8UMwDzyIwLpMWRtLo+K+6KJlM6/CGSPsi8J4rzfk6WN7XT9nASqAlAueb3HjrNAaQdesIECZbusWYRBwvrJgcPBhEhwh1qW1oLUoLcPpsbqR3Oa7Zus2+orlMMOIYqKcOogwdfHPgs2ZzREVpid2i6Yrt2+DKaGpcFgcqPixdh69QuChO/FwaeZ7q4MMLpd0IHGXmedNg9Hn368PLIs83T8qSDcnlmIM1ksupLgRdMu2hQ2wsY8CJWnlnFcCfvDCxxXZOg5Mr4/RsNufnSEU5H6slMasPrmyowPb0ttKaHsGnrYehfLz7/a98BWyaTJqS8K9K8OSn8+Si++HXvUZo1/LmnGhXHb8lCJfOM7QvjQ0cC0gfdtx19BgNxIORXg0cm3P5rhBqvQfvcmAjgzCH2rKEVcgumEs2bR6kNwM2fQ5O/XFd+grQfA9hYBer7IRWbUMbApwo8WYIh0u3DT+d+qsEZg7ebEjh4q1bBvc3Srsx/RAA8RyedXlou9nPMbBQ27N5c563KFI6qDqotwiDbetyUgnUpE45A6uiw8iKlvy5ePksP3+wG4BeVezzSygepIqmltC00tql5xNDiQNry+LQeQ7UFXeKAYeGQUu8ZVTruaSFBenH6FgE2IV0NDr9WN4BRm4w/9Hauj5/LZUlPQmqHXFwuN6XGc8cJ5KvpA668jqP0OZANTmCRwC6HqJBXpbVKgPR4ktMZsfO6LIbY0aABpBhhOkuk7JiZTud1BXbWTSqpeq0iJBmXxsN55J2o+mXSQtz0hqgIcylKbQyGbFpwlhGMJBBtU2gzNjmla7y6wdxcIjsqXEfwQawcxojKqR+A4X606QqDyxYaPlXypzX880zVfHgT96NdG5wtRJllmVogkrw5/Ix74gEIddKEyXWQqg2dtBV9OmXCBtI+pKl3UhoDZxxUVqvQkbas4X3VnwrTQrJbzyjl9nSnbqVSC2B1zSEUZpraVO9ZpgRYnrWAvVqOQRqqMtQycIuDTUwhmvd+42QNBfjjGlpHNTPeomsymxJa/ldwgTxfWHs2WUat5UNwNDEOJfgeYwNXrQGS0IDQ2OJCmi54mmw5myNSD/5S3bCDkthvY43Y80WhgYAemZX1uXwRJjtD/ggiSrrytFUJS9Ntdb3g3zsicqfajSo7AgnWjakUV9OOiMo6Y3OjgtOKyiEaknuA7rGsDcd6apcHwZAddoE5jy7LMq9jdx8BNtpuYFawqiBfwFmq6eH8WLzvfTuD+Mnf4zc1wWBAjWG4C/Ubwh9EEB7kMivNkEALLAlU6xfIMfrQ2fOwrygwWKkMcVBsCCE0KDNSxmVN5Fd74V2A+j7Uvw825oBho1ygorXtGObJtN/VL76PuCweB1QlTsgtQHkwQCYCup7MJqMXzBbpKX0SQAYdGauc3BpMAyzPr6+Jt9FzqROdUGg1rs9GZshGHwyn6ZjBGu+lAWoSwHF7KjL2aaIQIXuP3lCAGEc8uAq54HrCmaws1aQ4FoX1X2fDUtIkZbqIS2dg6s8qvOA7lmwwJdrBa65aVs0jKQfpNW9YSRt0M+4zqo7aRPgUPntaWNBpNtM918tBExnVcW0tG+i8eDpM/myeMxC9p7NNNbQdSLXiX2Y2loHVwt+URTM7J9soQCgtkwL8PCxYzZ3lrrQICLYiqP8aUgc5rCTKMF3UXAA1M/qcnF4v2VqoEqLwdanNXtViXb5jkk8Fy9pcTytpFEAb3ouNPhCOy8BH47w3AHID/SDa191a3BtOmX9gX0nnidMlQ8VeACY41AJR6jxY9u7pTynLL7NGryZWDRiP73SVwqoawLnRbiB4xAeTUtYETe0lOW6hFYtVY8HJ0m1JNeSkxvJ8XyYt6LBgEpJHANULdl0owebdlAejv9ii8hGPSUtzEkHVnJL3Rp5SRZhPEsxl9x90xah/SxHDPgPDUHUCEWDB7jr0GGpOO/XUsZpYCS0frfHrO+dC6x77ph3OXSFmkcI5uWU+hJRaeWT6zP40tGjlWBVcZM5MyOoHti6Vs9YOmqcgF3HaSkL4xJSD/JETTcaEjXQwdWlBdRBy4/ELUqLjfLcuQGzT9voOIYVaNvItEGjOAN0V2xwYNHtxGj05Dx8/Hgcd52Bmiw4XLmX0EKbxRrYHYQxTquKgj3MwuEApJbLikS3PP1UW2L6YlABERxjW+USsz1t6PI22l9JNX101H99fOvFG7nm3wD23V2+9s/jgrRjecNIOWP0wkjeisd8H4iPqPjX7Bz+NrWFFgAtkOnnTMBKiw4f3L+/rBFNpq3BWAB5+V+RaPvpYGYo1Hc5Br0xhCaIZcX5YFe+LEtsdfCnjz1e1mv2EgOlzLoCaF/j+De4Hu4ldx+cNACwkhpUgxIgOK2Ol3vQAAo4oIzdw0baMPIcNs7DAqAvQ4dLq4OPF0VsUNEGS4ARgOs2ChbUrUOeDWDGYQkjH3v6aUCqgDYtZgrIjDcWnB6bPgxXS5TBoAO3KhChuurqCv8F1M+cOg23PPkUfOtVV7KWg3pSOaMlMmgm4zDeMFeBeHRgFm8eiAPUX/uvN8Itd98Ljzz9bHmJnAYdQHUCfW5Y0GKVC75OX4GAjgGI6pdGl3yetNLVl1wE3/yWr4L3//V3wJ6dO5qg5mphcKBs1FU/Y9pUxfPGR3oskU4/8sST0YlwHLZu2SQTI7LhKNTtLVodRM65/VT81NOq24l3nLITLOU9Dl54G4mxefPytIfKpIM/2/84vPuyS2HTpLG6KDa4xyBtiASHU0D9S8/pdk2ndzyyF3783/4ePPzMgbL1wuoq1YfBqlbsDB7AwXSa5cKLhWzceCqsMSztUF3n866k2H/4KPzGh2+Gm+66B37m7/4teMdrXmUpZyk6B+iDENrxnkYvqz74+OMZK2kfFiD8yC6yAAN7uXo6lM0DNk0Kxm3H6omEtAUwsi8aRUqXtdgrqvKn5t0EbjvwLHzi2WfhGy+9rPoudal8GhYzh/2ixdNimSRpCPgp7dNHjsBP/s5/gMfi6HnTls3QTTrgr9eFKUEDur3Y4cbDQMYtkR4b58uHgmVU1ygS0KwBR+Ixz8LF2ZS9Bw/Bz/z7P4Y/+MkPwIXnn2coCiOdOYTlu62ZA9BgJto+9tRTcMfBg9CtTq0NjTwwrGt56y9jqmljcaf5YTYNkiZBNhXQVLIAuSxAy4tts0rJ2wuThJ5EUP/SPXfDDbt25w9PTd6qsAANldaQ0uLvbIlrVaf08zt/eVtssCOwGsE8XZlGQE/iDVkCR9nwQWyxcnPcLvurGgyUFS9kKwoAMMsApO/30nINa2uwL0rrf/Whm+Gn/vb7hnVWPAdoyqMBDUGZE14ia1v+udOn4dfv/SL0Xfr6e5K1esDi/O1J89e9cJwLD6qQLQJMVZqk8HSebPAyJEAFcJbUNKuTpTP9TiKAJtMJPB5nDX/v4YfgR1/zWjOy1p0GWtKAJQHdN+mGnXLA2Q994V6YblqBlc2bIh0rmR7eT4VHzWIfkqQmWQ3a1Pr/Q/DbaeQ4GvnJFhRpu7wcn+od22wWB+y5k5+FW+970OQnPGAB4u61QmgkYsmsaWP6/t9H98IXo2t38+bV3DbscgoaxIRP3oexVtjZlp4W0CaH2BlhUEGZfqSK9iSlda8pNkiXiVxJ77hGSfDvHnwQrty2Hb7tqqsNogNn7mgzQlqBGHUicNJApU/k7z9yDFY2rWa7eZpWbsoSgF5L5IKdk1zAremDNsMcKXNDeInSChFOl5PlXPmFtF5cR1I7DeLTNlhpQ6J4/vjhozUrJYb1Ng/6RGNA32e6/edP3u34l3Eg+Cv33AMrqyswjeOrpM2hKwLH+J8DezawmhoIRuhUPljMmlFbq8FEMoeqzvI0JZQtEpAkXsZzUh1RVCdCp2m9iPUz8M/uvANu2L0brti2XTJHpdKQKiGMUi1rOr+Xzq4XiPaJHapLpkZaS3lazA1WU9zri7M+iATQqkyX5XnDHaf1vgNAm4e1OkPI6mLQp9WFjKBd6hwqoHl5NqzGdH5c9u7uijadRFCtr88smMGaFyw4vAbVNDNtehZVDgXmJ54/AT/56U+RwEuAnkRaJlmjyN7lAOKA6D0tMAR0K24KDZ7lc2r0uksnmvqwlObBGm+VkBmWiY5Xqz2cOXMWvufmm+DfvvNdcP35F9AmkZYo6fTEiWDfQm2/3O2AzDSD9Ppim+XdmEKdgSrbKBd7LZUle3SEYkblvLyNpKSSLns0YCsNbjytL9NlgQElNQOnjHOwbBQPdQHxkjDfibwJNOZB40vWRQlQwljZNVp2/3XWAS/X9cSJk/C9N90EZ2K61diRVnhsk9sIaG9G/R50FTS8G5h8Fui0g6Y5hc7c1IMk0lu5PtTVOHPvpzbraEQik6E/nRbTI1XgWLTb/v7Hb4UHjx6pPVcfjpONCaAB4b5Ckm9Z4zcDOm+yQwxjpuV9s9PCuVi2HS4b8WBNg/W8z3sFduZ+jW/FdYP82mnxHNI6OmIdNK25LnIfch3T/bQ7a+nENW1S8XkgNumsKefaQeJY7atGD475DH7pXJTggcOH4e/d9JG8WedqBHI6knTuJp3gSBcZNB3KzNCf/8EgroYpqFGwF0b1RR0U/SNTkYhkhvB+00XChdz5yzYDsBIonwDPnj0N33fLzfBPb/gq+JtXX2PVujNDRFqHBoCVamtpZt2oxT/Oe/uhbFzJEkBLAlMO+g7TkK7YkKI6rWHkBtKCq5BPjzpLvbBmbT9eLVb+kOTgvbtzW3WlA4ArqmVe6JccXbOZKqA7v3HfPvi5z34Wjsfx1OYo2FbjuCZJ5zJQ74rggerVYJdw0fb1qyiRcoxB3wkVhqfMS6cxABrXtQdVYHPv7aUiJbfiwpvStG5B5um1s/Czd3wWnj55Er7r5dfDedGW0iZIAMs548NWNKBOr86RmUEHsIQOxcyozvsuL2ySpTiZF1rFNqXPWMAN3NtI2kacviQuS4fmMb0AHRU/gDs6zR1QR2cV7sHMJsigo3s6sJobYi/H4+jZM/DnceLkf7/jzuzx2kxATho7gVkPTGWvcuqsUi7jF2AgtT1PNG3NhWYM0whY+VyjP5SlDMoItPai6oHA7P7tphORGskaOLO2Dr9y793wx48+Aj/+hhvgXXmd48qcAahYuIVKQ3A0GymtGhDZrMh7pPO0Kt3vOqG9NCC9P0CACE1mgJK6MB40gWGDaeflrdIiEYNQec03i2sVqRN38tyMUicu9L6OVDc2LTy4USdDa1boLD7zzDPwC5+7Ex46djSCeKVI5vg7mRavBsrYpjzBZoN0Iqz1GJC3iJfQeJdDp8fGRVCMqB8nltlEFv/lHY+ySHXeeWVSV2fn7eGeOnUK/sFtH4M3X3gRfHeU1u+4LC0yPjHdrSWB5VqBWDc0qywg27MyivbHBm1ysJkSiO7CgaDz9CDrGvdAXaOLgzlpfZqxMJJ3BXX1bBThwa634oPONjPUmThklU6SmkVgUHQEHQfz+1paV+NjTz4Bf/rww3BrnAVcjUJsS5TKCcjpSJIZp8WrUex3EiAde6CoDEQZ2LIlUDRkQ8DAkK0pND/B4i/BRb2PqMNSKGWJaGbeOJ8M7OzIR7OBZ1p+ay322LsOH4Q7Pvks7Nq0Cb7lqmuixL4Krt+xE7bweyCKaiEFhxI7aNpp8ANYJDX7oYsqq1+r16lV8lMj2spR+lbdze+8+EVpF8VBlYrlHBWJhSPsnWHPQpXQJR3PFmY3a+Jbj9U+cNXrnYT2gQVJAvEjcYLkxsf2ws37H4f90S2XgLs1zgGsxl82MVaS63SiwUzg7IY7+labWZXnGTF2j8LiHde70rih2TDV7uGepCdoGHCFoR1lR5t2pj3Bk786VnatW4Nj62vwOw98CX73/i/Ba3buhn90w1vgDbsvqiNrxUwPbFR08UieX/EKaNcRoW+L6QWroDoGCkAss+iLHlAdRvcwGArPSh89q0yKuWkBqixqgUp5BWyfIdrJHu0oF9GgCNVTRav29B2aF314QoNp4l8Wavprnk8+9QT89r33wL0HD8GZfj0DN5sWUwZx8WQkTxeqyZMwUDGoOiWohgzDSoYhL8zkBJ2bdzncyGIYjLejlCIOfCWpAar3gPPN7xbQQjRp0iNJ6TWoWy3vXtkEb9+zB959xVVw+bbzYOvU7ketgc2VNUKVkYEgHpcisrC6nGQQRINazZScB6qBUjD15iv28zINoOJ1lNYYAezNABbYtmrtvJstQhJX92jdgUHbp2xeUHygjh+g0q5DaERw3F+79DJ444UXw31Ru378ySfh9gPPwoEzp2ETSeTslovnub3JfVqkcjUltMYx5xCknaB5rhpd45TOp55BzaCYY0ZlWlwEqC48oJdlggKNPE47amUvCMCrdu2CvxHt57dGBq120/rJTbDMNLadizNMR6RBBw9AFHjp+WK/seYJkl0gaVwYr9A3KKZVeDv5RtLOS18lGLi6IzC1JZq0ZrruCuDZwigdPNW9LLnVXGc5VPzojqabPGmArdE2fsvFe+Ctl+yBY2tn4IuHDsGH9u+HLx47UvaLx/IFk3QiZRoZ/57vwFxRb+uKhaBxOORgc1CIMGSp//5uUJBIarAtpVpCppbjvws3b4YfuO56+Gu7L8r3+c0q8I/6iwaILT1l4oBGSQPnuwGG0Kt8mxnwCAohoKU1UqfR/dkIEh8C2nuhLRPqPTRpAXU60g3iuAikPVhSS2yFeadJwWreZN50ltRgAayBDfqaeMUvqp2/ugm+bs+l8DUR3HceOgD/5oEH4bkIcp223XnRMQGbKVuxHmqcxvih7RMoX4KjtAC9DxCKqYE4LE5G3iqa7dfEsbQo33dffS18xxVX5+18jUTW57XWVkUH27HBVaA0ElKjkfM+qA7lXtDGvN1mLSuHLpjy0XGnIdeqUBkJvt04Lc5J65WgScPI5tC18iquVQSe8QVaSCYR0NkJCmJN0/8cwChvXo+QvSkyEI0Rb4ua9g07d8EfRz/0H+57nFZUqsANHQg2mnWngpDOMVRXKig8tviSzo0fuiWZwT3APbxcl0LQi3+XSa5U/HNe9Fz85KtfBW+Jg76UfBbA+D39wSG430ERWrqWjRXJBYRgjewuI0kkMNh69I1M2xgdioA5WG4+Pf+uLdvWm7UcKhMABCXycr1ko1qVToPSXgbAI4JEYYmAVuLLuiwwCJtjO3/ftdfB1du3wa8/9CAcm/W84WWdETb2L/+xqo5BDXpQDvP5JyYHKoNbZ8T3cCQbrBlAVYzCk/IhQBxa74l+yZ97zevg2q3bq2sogJHQ5hdqJtzJW0HUpLRbJ35osaeNnletzVIJQEkr1zkVHca8Gr0HTg8uEN1G1CxoLq4o6t+guF7Kqnv1odDGg+L8YlJP2qthjgXNE1ASWl3Ly0hhKGR6dfH2iy6BK7Zug5+OHpEDZ8/mWWQ2c7Rg5NP0spVwQN8DaJsc4kWisQ+03HZa2rLNxSYGQEOKq/cJlE0UmNXx2Uuib/J/ffUb4OqtWwXM/QiY5V3cMGS0x1MLQ0H21sU8wma3ox4to3JXFcb1ogvZzRbAlaFB6wE8L8zrjc30uDBv3dSIxUmHZD4hMUrkS1fbMGutbC90xQ5HrPxXgsT4oYPjf2WjlMPP8cJDoO6njUx//g1vhH941+fhUHTN5o29lamErYqhh7Adh4jJYdxc5bmpj5BfY0JY6YagdpNlVQcsjOoL88npeX5k3v/5ujfl7SqCA7Ps5qWYKcwYntbrUM+Hn2WhSCdWbahsONMiHM8vOoogx0Wy8q9EQP4rAGBxE2rHEMFdUvNsXK5zN7/niI8elHRW9yQdHR1Ld/plMi7dvAV+IYL6A5//HDyfHOFsCmqLAEBwlalDmnFW5UubaPeyEr4pzH2XgxM2l8BqPUeABQJzGgD+WJzW3hPB3Dsga6kMYNWbzm8ecaH1y7NRWkJDxbKWLEkqB6xAyA6+vkqA+XyBNuJH9eNI/EbyCPayaht1M3tVwlDFSGU64g00KyhtElyxaCV15k8Q2ZGD2NRKg/KA8cotW+GHr3sZ/MJDD2QTlN/HblW9OFpxXvVH443JYfdVrg/o32GoAxEkRCbpnDYRev+VV8G74qh3RvyVjx6DVW0M5EWgboGMn5FBEBKQlaRm+rVG4YmXOmaszn+v4kYDLhGvicZzzMPFockbQcxBJYmLAGqMfZBMDuyabjvdETS4fZPoTkpkiCFhNn2C2jbfFN16Xzp+DP746afyhBroBQO5h5hCQMZvdWIsGHb4ybHpUjzGsXviECKi6POmWRkEfssll8rdwYaNAYy7bOA6WzJ47PCAkO3o8oEsyzOa9JFrkPNiawcY2GV/BUMFNO+HbU3A6glRTwhgqKPzx6lKW0q2MJwTGITgzBBqQ7HulPmhxeh/d821cMtzB+Bw3xfes7YIunbBncHgeuzeYFs3YRS0TArbOwYVTPZzP4vM6OEfvex62B0d7t7UGAAbykyWH1mbQzEPYHhuAzUUSSFtS/M1H2VNiI4kujs6d+jnx9K37p1zWlycdkA/A6Q8i4Zm7uz10zTWUF4ocOgd7+e1j1l2IKhz/RuP7ZMV+J+vfxX0eQfZWRlrkVoWM4qaUVNWh3fYanH5nXrjXJ4USVWnseug0Kk9ILdJktDRvnjz+RfAW3fstBUMbXNDshgisxmkh/ruyT/80g37rrCtU8oFWXjKLBHN5gtONh+oPj3kay2LPAtBO283nFY3Zn15B3X7gDSRekYzQ8kxPRWKlS8esADtpgijF8N0rOwkwvHzzXHi5TXbt8M9J54v73uI6w0sr5qmQgAzsYI4tKFReTcqb9BkI7OFRtgr1RbKyjzrsxm8N/ofJzQL6D9Pp6SGgWBya7d/UCUX26kt1QXELK2okYMbrVRgFy8I22KoO3cj4AbMkRczLbbSq9E+irnU0W8gs4C4xun5fWQ2O8AKFD43g/URAHuQ61WuUnHyNT/3XSjaOEpR+PZLL4e77v9iERSqg5VHEDS6ZfYwODMDcWCC1IkVIcy95Ic1XoM5AMggsDCgz+bGZdF2/oY4EBQprA5tZoxJZ31vDNj6XkuSAgNUg5pEmbz8wxKM/LPS4AttaNUxXtKgy7Fl6rZiQAfVGUVrsqKiNmKbuZoxEzCZqnWcA6g5AU0WtinlW/4LfcEB1inzBOqv3r0bLlxZhYNRAOYPQeT9GX7jztY7SAGqrEZbdbBsUGq5UkvgTqYGSee377oQtqaPIIP+LB2Mm24emD0zlr2WjpDaU+xFqIMOusZO2dHs1tMLRstX41jvdapzmOdHDnTn89Jj49rRhnw+llbFo7qHavwQlLEs0hnB2MEBqubTkhX8NcC4hg1Drcn5azxcsLIC3xy9HrM05upDNbnE1aILC0uLkMUv+EOVxmikcwDRDInYtHliNPT/mz17bCXCEMQtZkAjDnWcEqymyugliGtoMTPUr5zSm2qctndpPTGtc4ChzD7XtO5ap0V3L5/yC0n0joShHVUm5rrUtX7eVJONfZQMYSg8WjS2Qu8S6OWY33HRRfBvHtsLOOlLpx18V1d/gzIFw5zy7KZBriba3PDACvKbattnQG+NRL32vAvs5Ik2ORxj5klnVRTRB1Vz+oQaBB3NGKRGS+9Dd0oJyeCKPkmCMnUcnA0HG7B9XfHzQ9hY1rggr/rKXnnpCrlRsIKgY3OEHhETjNfm8HlqQamiF5LiyAoj0lyPn14dsXJB1ObHI3Y6Ze4FJbwG5bNpOBKmJoE/x0Ym6CrN3o1I1FVxNihIPAzUmSbOMyHYrEcFjA4BGpJf1KlSxYoZuQzj1cAqybsRCb1IDPm0sGR6nXaZMlxDy/MdGmbkAS91Ho378kxXPUHs6XBFDMqcd3+cTPMrOLCkwuuiR+y2o4dpJ1l6E3IseHzqXwplYqUlnRq1rMCriM5xaZnWKH6v2LRlkFayCENmhJFffW56Png6hs9l6sh2lKqoypeGxkGvL14P+hpPNXTpAG06TJpavPyMpZVztGXk5yhikNbRUYuiiSKPA9brA8mgvt6RASSozgADb9QYqNHdGhM62toRgUeRaUq8P3woC0R24dVdrtCqaHFV4qBcvh68D+0TDRpGIbMuHl4k9OVbNksluIB+RDpr4C8bWkJs8LwaELHZUdIRc9jNhUoasBpOL3KEKqnH+AKN61Zj4pxrXPD8vLRyHqrJkZtYOX+T1yC9KoryDVa5F7ind50BO7fJAMwAoxLcn7faJwV245mBJ52nwWGfPWRBFv0Z9GgYCscxwSFbUjCDEGqeY8xmKc1M6DMxPVyc3qijAoNmDljmhEa+LWAjjEvqUQZifTFJv/OLyn6uJgY/UtaHkI/vEIcEtK49sQDj4mtR5TaSFlx6+hAY5X4BhJga7JqmRkWZfOqaoIQl4lokzrsXGkcK50+nWRim9+YnQZfB4MGBK9CU5ezp5tt23r2XgRPql9wazGn5liyho4djhQcZyPdcviPXY20ZYAhkfz54hiUzYm04ig+6p2p9T/H5o1pwlQdoistip4Zx0Zry7lRaiVwi30Vp+TrU2V3UqMlx/N5KAQfS8g252syjFhe57VqdGRptRTxsC5eaxC+DwaRO0xp7PUvoOEwPk6pNQGEPsfqdEcwYQYfhV9+ukUKw0XI7aNWhP3+d36vDkBeD66YEp5tjQK51ACijfiA7ml1UoZohQNKqq2BnCnLDIwgUhm6JWgM0XgJHNbq0tefAIh1l0/K9IR0y1ymDXPvqKPtyzFOsobImAwGjBnGohGgrpkFpO4L6mrkGbW6ox4omD7Q8c5AbgiHU7WMLEY0bKgF2j5VQGhCDpdB/5lIWlOmFKHaMn+2HKzxocI+B2l+3znXP9irMlJdmvzITOkA9oWDcc7TgjEiNrvCFyK+DDt0qWHsVYKPkF5LW10yn82AucXnhHiGYOhaPAVDlxy8pM3o6GnSxJ4iYyLf1uzatxWf8uadUSg42Xg8INajX88tsALw9CHIOiA47wfGMsBhq2hRGJlawimNNpDpnYiszAhw4c8YkEGKCajMVWsxyVLTvIaiJhMqknBetDT1w2ynJVDJQkhTppKP3GNEDiIjttN5EW1EESxB1pJKKJXkD2NyKUmZXy0NVvhaX4r7p1HVQC3CoorraYbIZxhMrPDBcFEYb4dyCl7VHzq4De8sEzgFk3ZQCZWw8PcRoCnZQOC8IKIPKS1aLzoBK65uNVUKDG7AthwZFamwFlxiH9Jm2V9PdbC+iXo6KXXUpiQyqUibO5FDpLSEAyki2BIrbTzcTQlMkqLSoOWI6VWjGiVyiupTlFwIYkwP7KsgJ1IHfhR5r9OB+/fmisKDNdLGHzpxWu1yR10xWuwrVtSht28hEheZOsnriodanfjdYrtU9Sv+lo0dMVnodZzHtGrgQ6a3vIQw6pCETxqQ3DwRbElmBAt15Dp27bnFtDAXYiBnrdSNpTc92PdSnTzT2TmLnx6r6KnzH+h2UpMX6bjQzUh1sGnAeVZiBUVgGqBqwpDElmvujA3U69j7/PN1U5QGBG5mkOsAFw6Kg+Ffip/OaDsTBbXnt6CfN2MGjJ07YfCihMRPVvSwV6X6v2xOHNAVdOLTpzUlY+nTki+bGk7fu6Gl97Xs9joEWYOAC8gTMedTcHEsrrYbDDu4DWwyo0BBoYRleST4zF0zd9Bp3TSqDJUeK16BDm2asKuZAe53CHYcO5gUdDVhHtLjGoKePabSbBhGAsfGQDhrg+suHE7N1uOfIEXj1BTtECxtCAYxTnEEN/p76Ne6eMKTDS+rgpHIYvHlGQ/tOZcrJ6btCSUu3tAsLtaoOtaEZ52bGT2hScWj7hC5Hp9Vli6Zr8AD1M4VAZegkBvblDbwAMksK4qeHJhINPz24AgxNFVS0oQK/l3ooJObzew4fhsNnz8KmrZuBNWt5rBpgGi8BxgMX01x9NP/wZwdYkwfu/RDcrCpmoKRnbnrqCXgNAZrHKkiNItovDCnBFsGacfNqY55RElmtcWdEBADZ01Dqgwi23+iPZw0LJI3vqeKCd5qESGqmnZt3GD47SKsBBLXs/NupXsCjcn43lDulAnrvf0EJiwDW5Ajgx2IVzKF2QvMsBzXs+C/7HiNw86KanJXqlNJulqGhD4M4lX2lqV7YIU2NDiY9q3mkrZH/095H4ejaWT0e81ga/Dqa7L0W4+YF5eEQWxoa3+Pxd/z6+73WN4PdyDH2zaD/1m/ed4MbyXtuWqx1oLoGXy64Dx8kfn4QLUhAbbE/KNCKpFYdUoSbki0n19fhpiefzPtKopiHXusODYzABSr6NHC6eRXRBXCGrDL11g98JFto/+mTcOszT1WhCCPA5huuUF7rwRhG0Eg7Qi9wBVlKo3rfOfub6yc/SGDgOJQ0uLGjewFxG8nTHVy3vGKS1EXFq06Kgii0nX6kzduMBSudhwJSNLKAVwnS3K2IhA8/sR/2nnietmmuryWIpA6s+RXQCUDBla1De0sKHYEAowYl1M+XMO9PWDYj/92HH4L3XnZlZig6LonPODgGhhEilJrT9yWJZm4AA+QUiV1tSLZ/6/d7WnzoOo/3ngF/5oSXKq0OIhz0tWJa8YagVHXoARqRumCBGwKMaktUJWozE8DKFv54KE1x/+lje8uGUoQdmfhqcMJYCsr90vrca6nN6wcdklWPTCWhmB2JyNsPHoBPH3g2rxfM9rNIaEUTzFFVnhCDaWyrQjZ/RGNojsoBYNUE1MkHwTlaOhSfscUwn5ZPfdpRhqq0rV+X1uSlz/vWbWI+zRnJjc4C2vCzYqZkyd8aNuqi95fMbFM0yJyWO2575hm47dmnodu8iSQ0vaNNhRQPFZg6t+RaK4jJYfg1gvD6fmopzXx7lmzo1OOmUwiTKfzE7Z+EE2trw3EZDPHVbDgP7jGafLwTCbwCaVZVtF5FGIC8cZAnwHzLR6bAeNpuGN+65vRj9xalbeVtxGCNs68AKPOLhJBrYBh0QNUuGGyctB3/hNq+HbTJOnDqJPzs7Z/JGOmmK1kAajpaUleEk2nnNiQkK1NhegI9UMBKSRRgM4PSlrfRcbIyhSdOn4JfufcusZs6B2JU+TAjhIeoDo4Plr/eQtGVr7OBZD8SEbxoIxoQdEbtobI/669dtEXHDY+WPe7Tdy9aWvYu1WsHXKyTKKCAzfaoB4n8jhyadYM4Hr9ilQUTdaTrP3r0Edh76gR0ar9v+QwuI0pnVvFl5R2aejJm01/jtsMBeOuLSkGii+7S343l4vKHmph73GQ2hX5lFX4v2tJvu/ASeM/lVxq1xhNXKBnTj1J180JL60s+Ipn1OtGd6kUMZLAMFB2KhgeguFPobaQdBGKw7f0ATZni00JFy2ASpzZcHXgQHUGLTRDzA5VNwO7VIDbrkNdGcKibTQsoVHKR6sCSmf1I+vjQY4/Br3/x3gjm1bKpUPZwdCJsRKhKmSisq6apIxrrgBLAezkaDVSXX2UGQ2OmiRidXXeTDOrUA0/F6J/49Cfg8RPHW9pwKLFR52aZGRo3jJRGVQctIsTe6ZR/uhPpXJct6KoYaal4oz+7kYq8GGlV2XPpoLQTdHXRYpK0ledHp+IavOSIlsWH/ly1H4N5oorg86dPPg8/dfunIyYCdKvTMiCcVI9T0BkCmEkfng6pn9LBaOhcHUYuGDRob6OKZ/EfiUxmx2Ql2kfxOBxm8Hdu/At4MlZIqx7+1W0EXB+0jJMylQQPY3Tq4XSngQE0cKV7WHdq4nhxebmGx5EDGgduIP2yaXFeeqRBlJEWYNLXDtM4Wk3ueBoabOZ26kCKGxxT+n306BH4rg9/CA716xkXk2Q7J9OUJbRkCCQwa+sHVRY06Bs0v7s2NrLEMZPSuZ9w6RQSsdiiidBJlNCT1Uh8VC9PnTkD33PTX8ADRw4bKe3bwHTAxZ1R6OXReaGHpVpn3/vN0SVeJJh0xG5wjs5nbQ1F1YFR27rdaFpYKm3XTAsL6bA0DydcbBsBS22aWGHzQgRGsKaHP/ghxpluvwmBin8fPHwI3v+RG+GJU6cyFiarqxkbWUJrDcT0UaMHwhpAo0NhbXsfOhgBSTNoCY1Qu49Bo5bSkfhNqzDdvAqPxQr93QjqG/ftNSqJe3h+NNjyvStJ3Ejuvr7WYBYA53g1KGJpTGqbvR9GbWu1bI5W3Fj6jabFJdP6vMlkEoaWZwIOTZb6+ijV3fFRL//FfGfvRnDto9stS2k6WBN//Mn98L0f/gvYf+Y0TDYXLGTNnSSz0Aa1XRAHps4A7GBp8KEbfbCRUQUMqQP5pY8tOyWBaDfRrGJSr9y0CZ6brcP/8LFb4Ne+8Hk4G8/FAwJOUsOQeSKFg13ERjO6dLBOJFzQnc1LbLpn1sDDZQ5YMl1JixtIu3y+7WPgmlMdeCipARaqPxeUAJUsuO20kEpt+y9jG//AzTfCkX4WBdommCYMrK5kTGAyNzplP3tBKQV6c8QR3cCo9XIggneBYagP1BdPyug7u8LVtkeBE2WTFYtbhhFHjF6P5sc/v+sO+I8P3g8/+7avha+77AroqGdWVUOg1nWDOZpDh86ty6HB5cAMUD69yq3gRs7NkSnfaxHCBBpCUf1dIm2rks20dN2P01FeUIK6vFlHz6e6zpQrb0HAxq/xXiggJwR8dN9j8HOf+VR+BWKyGoG8aSUem/J4aiKejfoWpOSM5aW4YsLWOQ5U9ytGHJCVN8h89R0aFZFzLDM5qKa+q1slqNnxOmLNg5KQPB6g7K0C7Mejn/oHPvpheMeey+F7rn813HDRHtgeGSBVRD26tcQNANJqhdzhnBRj0KBqZE5jnsd2nq3zVhos3JlLqUeKxDeeW3qTG2jYA1TvvHmMykd3Wq0Ng9WGuh8PqkTnZ9bX4RNPPA6/f/+X4PY4A7geTc4E4mxukmROE27JA8ZChds56GxVG/G7JxnHlD40qleJK2G6kEdoMxGzQ14thboXAYRqKrD663jbsSlotdrHnjo7uwY3P/0k3BR79cvPuwDefeXV8O6rXgYv27ELNiW1BNbkgAXnOSgpHJRak0EQn2dSOjvBYEAwYMNyGkLS15dsFvVAk3fAdiO00vYqQlqcwMvCINU12WhZCyW7OQBPJmVtZmy6eqp/TTXo5MTZs7Dv2BH4yGOPwI3xeOLkiTj7F8dOEbwrEcRddgqsFqkcvRri0UD13jNrfmTgwiivREjC/GA3DZITBPvmfbkZ2Mxwb3MHrqn+4lg5+vOCgdk/XRo6/eu7AvY+MmEWzx+Obr2H4szib3/xbrjhwovh+197A3zd5VfDhgMDtkPTgXiWMDhJXc0SVVVss83HLsIqAixuAZ1WnczLW+LJYrB9oHzRXn4Lv+sH4gG8vc0dQX+VrUNo0Hd3lML/4vbb4AsHnoX1DsskSQTylFy1xWU7zWDOQJ6wZGZzIYCxjzletw2otmkxZKSNllpOV2cU5BoHta9fW2C1a/QX0HmwqOhR7qjLz9sE33jJ5fDeK6+BV+68EFYi+oMzM4x6GqW1SmLjV9amBzOqQ/uc/CyHQhyLDHMeWFLM40bSpj9iR6ajr5n02ZAmEzTxJdS6Iw68HABK0IfBcCCH1128B371ve+D+w8diJ6MffDnUcMenK1VIOf3NJyfGSwPeE2QodStLbwRjcjB7LEy/AwBbLycC3KJokBblWC9nVxCZdM/Mt0C8FfX2CO9btrD11xyKXzbZVfCe/ZcASsR7bNQN5rx1VwUcppOgVkDubMvJaEGt3CW69nBUDb5EUZonNM1wsj91j0Yzwtxflpt6HLaPCDsgPe8yRvk9sSLvD8gVp88DYbFdlb28wDkQVEY/yST8IaLL4W3xPb7wJveDB9/5in4w8cfgTuPxrmGSXm/pJPBH4A2NcoMZeE5GlSXOkg6biO91MPgdQAbP1w5qRVK9zbnvKwWybXKb/TdOkjanjiVlOE1286Dn3j5q+DtaR/DvgBY9jNUDB0DdvAHdyQjkbvqjyXah+48MqMKp3NupYrooIgiO4LUDdTdSldJg4oDnq817xeWlmhGereG+V2NDRnz8DYPdrJo6OUII7+ozBJjosRjJZqT74neqvdefgV8/MAz8MsP3RfnHU4W5QCVd0QARTZ+0X16pXgglPjnJEm5njZvclwYkYvcTSEM5IecZYEXKpMTE/JK6D384wjkb4/ejQumq4PdZf1Os5l/oTYoV00kCJEpzB645kDZyQTgfG1n30QikEEq/VMGEIqXUtdQCcAKtIIdFzfCRsKZZtsG0iJotMueNyqS6ShNljpzqLzocCAg+BwaUhpIe7KXk/dM4SPt9Z02rH/Lrt3wh08+Dr+59xE4lRJNwCjCIZi5HIc3w3AcxjfCYLHGEQib3o6NpQ3Mjp6uQxWA9rAj2lX/5JWvgW+95LKs/WYklc0Os6HSMSotGnGmsomU5kQJVIYydjWDU2C7us6lU77BcUP9emnirwchuLS+Zv63kRYdkynfMGhN3TtJCqIaFFKy4A+wgqRXxfAneEyxFNMVUG+N5sj7r7oO9mzaAv9blNbHs9dlonSLpxABYBykLBs8R1ph2krQAngrs0DgZmmuP60qpwhld6weLp6swK+//k3w6u3nZxNDwByUuaHALYAOlo4x2iSQe66+OwwCYuOX5tyQGQq2dTqcwxVY4t5G0uPwXFwX6l4mrZEWgpIlLKor+upileX5Ym3UOrbmZ3QI6sSbHTOlHWbBPvM3on39qvPPgx+9+/PwRHTzsWjX4GTpjKrTDYVUW6gN6IM6tWAOL4sQYKBua9paQ/SFJWamrSo2bYbfueGtAzDro2+B2REcWoeW6MGWbSkFhxtqhczNAGbRlnlYNJxZNpxD2mX6COLwRnNixj9cz/0rBgOtDwp8dF/zno8kmVvteu2W7fCrr78BLkoLmye1TFPLlhrukFWGLzo8jXw05z4HvJxjsyDX0quSUNb73Rzjf/N1b4IrN2+pYO7L0fcwvmWyVn3QALWTBmJzEyDlKwZsdEiSyhKvegO6f8OY8TsvVdp5sRr/ui9WBw4qa0vlxgNk02YDPMt173ivN1RddyBed8e1W7fBb0dPyBagtaB94wEqqylsrP+DqjDwywz+0IlEPyB4VW2lYFCMKVtUhNkMfj7azFdu3poBvM5gdpI5gxvqN7cayPPUod9mOf121FA4QLEmHWGABu6aGMwnYKDOFx0vVdrR9GDrxSc8bezrzQffTrzywqS5lTUdJr6haVP7roXazuuUJv1etmkr/PT1r8wCToN6gF0vPNER3sKnGmS2306ZI5HtbIdlWrlVtkhOYP5AHBi8e/fFUjEBtTv0xucMYgE4wGAHWi+5tdS4dss2KHYYGrFleRHUOJElFplMga6VoMCRAxZc4waePae8pV+GKoFd29kxMXVaSp037HG8Np2l0YFyeyAd6lltcmTJDOVYU3HfEv3W358+x5uVcVXGClHklbwZ3Noq1Yo1wuLXrRoZFdwSBUEbBMVESlskvyqqme+Mg4Je+ZhbPV8kQG+vPWKD+pUSdT5E0jt27C43mvyocAiidSiepjnrErX+2QYrFlzDBp49p7xFyhH9pUe6p+jJUCU9R31TFDYiSPQBVUiYNoDKd/DtF6yEZxD3wQqx74mAvnrTpgzoIJMMWDMUTJ1baAPaZ4g1PkiN1G8oPSrQILCLhP5InMK+cLqpAlnZzTPFjL53IFUMazKTy1MdQXeOH7z0Srgu2ut17epGPQjwQYMXB4leYNhoo5xLIypa1Xsdhluo40udE2+u2bwZvvviy9rjGA9saJsecg8aZkivzA5lelwQvV3/8NqXw2w2K4PEXm0wDgCGD9KrYNgsI6BfOChEWCClGOBU2z5K59dt2w7v2nWRVJQrpE0LPb3N6o7pbOBZ953BoRti12QVfvaKl0cpsBlkyznJQzMrEB898AMMnbLncsBLnD6AbnypR4BBXYJOE5l01epm+PHLrxWBMwsLvEtt7EBotQmDnto15w9qvBSPr9mxC752x84ipUN1OdbC69ziMkFjdKojszkRQrNSOgbliTrNyv7mZDt/Z5w4SSKhNdhoTW97Bo2FIKWWIPtGh+oDTRL7TVvPh//76lfBfzj8LNx04hjsWz9b3u7Ls2MBZEbFuQXqYBEWE8IsWCaElzAtAAE5WAQy4Gn/m0k8rooA/przt8P7d10KO+Lkx3oYd5kOMDZGQgDxG3DQryuke6mMVKX8Bkc8X8UJfOtFe+AThw/n5eOwo0y4QxIOB+MBqPc8G6QZr/zc54Khbiwl9yRmlJIU6R2NZOj3a+tw9XQFfv+Nb4Wt3VTUTFY7oLwZWiipopbqlGgHRfqrCfP5fGfvySCqYRsvwo+wgXnOeVTz1CUcVsV3xrFyWhdhIWGNfILVYPyrJSW3j0jSoDxNUCXuouB5qj+p4+8Lk+Rc6cpMXvo906/D++74FDwXZuo7w5RJZ8c22mMl5gcOC6fQ3tZtNDiZGhTz8vbIM3jHzj2wXfX+BGRjZsBiMGsKsEWCAk2vHkg/HVeqr9O1MgseKrCNlFV5oqNBbrtxCzSJs7QMgmOvATnXqdETmnkpAseEQQvQRlsqU3AWbHuMgVnzReKUlEZVJn9bkLUoS+oE8FCmx7/9kj3wm0/ui2OuXjZ6KjPPAIOGyVEIi4Te+PvQwVLcYnQVA8U266O58b7o2WBm8K+RyP1iMAdXDEtkRY6pL4M6v/mbpA5JZ1ZzvDa2dHpfgKOhiXdsly8NqYGH86VqcHUz5PT1HsC8hGCcA2G8OBEi+lcG51B/Nfh9xwOY3y6jpgfWNpAxFYH6XdHL8hv79kKYTgkYtOmm+WKBrkE34niY/4I/jkVaSBbDvoft0R56RRwQ9r2VBMbPOXi6hnmN0orLL3sqUAeSCtnzgUpCsHRmvsASQQM2OECrziQrbbFBD3Pq1ei4SBfVC1HycvJETK1BXvPAHCyvjaTW5wADIeTzHGsDqQO0EwTVBjKvEEr7vHr7edGWn8Dx7MIjW7qR2+CrtDmFjgO6qU6D+Q2kQ9ldl97ZSB/RejDLyDfUAYNm9Fw1PacOjCEtLVhjZQYqUwOUyTFWPak6g1gBTfZHYWIoE2PChXHpls/RpjP14/yDep46CpepAb3MABpcegYT09gSMqZdXB4Lg2okLXD0hlB6MmYSmfem83bAx44fIQnd1Rfecl4NaQIwt/GW+wSLM/FiRzhTAH11nOI2zApgZv9aDGMA9rA4GFCH2nNR1T+Fju7rdanB9fJWXKtAb37kaIMspWoV6JlWkbzBdQamP9g00ik4bbD1NnnoOLD5mijX0Xr1nO+AXGed91weUcCRa22embKo8Ku3xDmDo4cgKCeDBTAuTwRoQOveYIxUzlSLEBCq2NzI/s0tWw2TmPktuwwABlJkmdACtcRRRjMGOsWZX9daZsDM0b5RqQDhSHDEBKspWCoNaO+H4OOj19KbeaeaQOc94JeOYI0UhvwN7tx3njAn26WDaiCNIoMLrFJ618pqeVUiqK2RWw1l7A4vnapEGF1ON5DI45f5pXrefqSMEqgvXl09J6ZslHEe1PnHixWwDNUiTpsdxmsBMBRPrV/uREoG1AxV52U54B7XhLEnRkwxnT6UTmBkSytoHjQawJM/qFIYz/6cQO2e58O/sZeO5BHLApEJocDv2QudWN8S1PSa5or3pjhCxXyzxc7uBPJyrKrF/7Q0mFvbcwweh9yJmdZBIwZlZzfuWZ0+LKw18NZb1Q1wpKTUoDyv6MCaXKIRejVJ0UKj7jDObhupxvBeWKqvzA1Olw9IDa5T9aqtpjxRQgdrU+ZvS4OKFmpgdLENHdwTvSabDupd2HhUKhLmM/lcwqCXslSkc98pQ+MZnJPvWJwHRl+LFm1g0rPkZomu81BSHdTzHNcaW7SUSIvoMHLOEWO832ibeDDjgnTmmhHu7o7lsSi0AY3zSQmtk/j/bD9rpB420jyh84IDc3TOWKIFiEWNEFS+Bgyq4wiY6ab3agwGfT5/cB1jhLCxDjdicQyfUXTASF6Lgi5Paz7vixYJje2815K5YXo4M9S3nrseabDFEpoNdG1jtDgXw4H03Rice+861zAA7ghKrb1VG0LuKZu49y0W6jNmyarQaDDNrgatetCk+ajBF8bqBjC0+VWn4nGBLr8fo2MD8YvShpEbWpjla1eZo2trdqKLnsqbHcHGQ3sZA+/t0Ht1NVqLXxx//OTz0AxBnhyZcXzhodnwPl4B0WNiEHDeTRATysgSVRizbzApADAwL4LuFOpmcOmXeXndegpgYOJwXPNZeHFDZrcXKmhZe/DMaStZ+I5vUNSN5+6rVza6QYlS1EhmY8THNPcdP9rOQUmkpY6wgbTqWDRRwA0pC3QjyAtLT508XgYbxPBOV1uZMNLowXaUfM+lL8sKQ/2MyjEGNV0ufw8uDVIGCh97jx2SF7DkRSx+bn6zgarOSxsUb5nuFPaePAGAOK6FdMVb9+W6ZLrxL1YG+aLs9bH35EkzA6zbFlzcgkzPOXhADDp+UGCAAoDT62vwU7feCCfXzgy3yZhTzkCdAhg/awZyB+Ir77GCmz9h8p2Ega3rwLQbIEPpdGcj7b92+62wlhaQx9oRDajn0B/ghYPZ8ELFGbrdM3x95+GDwMtL4AtoeH6y8xH+nK+1NMJB4gLq07MZ3HX4kH3DDU2yHIQBYdigoxKW1TLMl8IAI+q1IcH4uP/wAbj38LPw2LGjAzBji3bXQoYOBOvShBYT7XOeZgQHCFQNRuf8WuYjRw7C3QefhYcjMMxWH1jrr/mnJ7n80W/wCHMOUOVKBR1f7z16GI6tr6sNmywP2sbDfNB3vicbZvq8JK1ycgt6u7wA40effdqCYQTUfC70BYB5HVR7DFoEekmsJzs8OBnY6Z3pvBfIU/vyB50373vEbJFhwI2OfvrtB4UrglogpjgvffVvUHXQr7wybXonsdueeAzOhBnc/PhDeaOeCdo3DXGMPGyTvGzABfn5cvnddW0q/dmTT+S94dHZIsVERpMPjuXr7rU/wZL80c6CNbzcslsTrff8n5/cF3vd2YpzsKAGaDBzpCcNJK0CA0uZQXq0z0rHAQUKtRfPegTDBx9/OK9r/JEnH8/7gzDQtQoXm9rTzWVjI16VG3D00VJ1tI0tDYm1ofSmPGlG7EQ0kW6NnTEtKP6XTz2e66K3zht83ADDjq95tdEwT8Nwh2Sa0V2fipL5o88+WRbEz4viE44oB6HTjyLVKTZoqoPCUVGO4FBd+w6DGQuY01cHaW+NTx08INKtpeI1R7TP1khhPtVpggWtJtnYs3T4vqhpYgmdAHHo7Jm8nvEzZ07BbU/vL4DohuobdB1QsUafa3taHbpqZnbP5cv30cWL1ugK3QnQ9xx6FvadeD7TfuDMGfjoE3ulM2pQG23uCYPaDmGePeeO0MjDXxvtAlbz3fLMk/BYHBAWCd3ROtKVIShMrlxo2tjGBOBBoQY16tZxD+pfUzhmwhKg03Zuv/3og1Fa9Haf584x2BXjpzmFIegOxSgNfKQ8AG0dfZnc0FNq+D945AHaT3ElRk7gDx59ANIaHQO6u6G0KwXU8oNli6mLodPfV52iU3XWHUoDuWweG+BPEu0rtNNYPP7r44/k+1NVP94vUH8W5VsQG829TPDmpD40r/QncumYRWz80eN7C16mE6h7lcMAoCBqDsCqe0c0nXeLKWZydbzKHMBK6UjgZw8fhk8ceNbaoyo76bnpYTWAMJILQQZY5gA7AOMgj9JJLrdTQAb1fRv9fjRK589GKVf2AynA+Pyh5+DmaHrkNJ0FtedfRx0MGuuj67FBa5UjbwJ4a85rEk37Sjw+9fST8JkDz5TOmGmfwO3x+rZYp6kCvv7WUuMBHQIzL5VdE9y9sCCNViWylU2ngKzOb33mqYiRg2WV/7RVCdvRhhEOc9Bo7EYYWTlp/AEDcAXsBOZJ2rh+WnYJ/cUv3Q1HkirvhpIGPXMBmpLLd0gtfX16VCdMYl6DEWGw/Vhi7snZGvzS3Z+j7cZou960oGC8+fN33Zk/4vS2aBMcmpOuIoM06K7pOW0nC5hBgRpq2Qmsa5G2n7/r9kxrJ7SXHVp/8Qt3wrGzpwX8GtiirbpGh/L8bPEch+0DFgbVvFC8zr9Q6DgUafs/vvSFrA0TXspq/938Rm0V7KJ0M7haUHBq0qJQIqXGbAfljesjqO8/cQx+66H7TQ9t2XVjzNJBC785nXNIIsLAK8DH7z98P+w9cTyrvdQJ80HnT0Vb+l/fd4+R5gLmDoZmEMAArEYC6mvFtk5dexOpc+VqcP72/V+CJ6LPP29sSkJkQttR74t26Z/sfUjS+kN3Ri/0/CBca00+b74Oy3UAMB4Wz7e0PevvP/IQ7Dt1qmw0lPZi6SZ1E07B05BAnNfoKtTldEe7HxLDVeaoDHSyfdjLUTeuX4V/F23pv4heD89QM2iBBjhgSAo6svw9n0fnmUkdKn1C/2f7HoV/dd+9tO902egmdcQJb0UWj9+4/4vRJNkvdqsxQbBhRvE5qVyhFRtp6DrofEKVnppfbGLw70eeeBx+6767YbJphWznKe3YOy3aJpog/9e9d8EHH3ukLBvAtndXXXrieXD0MG+D8x0HjXZ0fAcwGiXzvquSeaqOD0Us/OsoSDK/eb/vSfFwaKnG66Ogxp2AvB2Ylo6XVA30LqrYwwDGrgl8nW3CCnIGNw8MJxMyPSLBSSX+7BfugPuPHxEpzcAYmCKKud0yAFdpWGoaNY1qMIWlQdPx8LEj8M8+91k4neIJEJM8mJ3IICXFpy+R/6fPfBIeOHJ4KOXAaprW3uVeeosUVucizdSzvizmVwLzQ0ePwM/dcXve4zGbSStTorsjTVNAjvH3FyLfvxTt1Ck9K/ynQ0tQGTAC2MEjtoFrTCN18GCUtcNKVzvjo8ePwk9/7jMZE4nG6YRox44GhYwnICHJjKo49HjTeGWCO/CR0kVrJtJrOK3qRbr1qvuu7vF9pO/h73/qY/DUqeeNlOPKD4DtQO1tuGYcOHBpqaSkUwLzf3/bR+F4nA6ZrGySBU462ksvg2JSpF3aATVtpfBDH/8oPBif0w017WwjzgOzsSvBSmNtVmg7mQ8GQzqePPk8/Eik/XC0n7u8sWWL9kmW0NN4HItt+IGYfv/zxwywWl4Q7QnhJs3XwQK8C/Y+P5eWJBC6QbUvnT8daX//rTfDmSTwWCtOaTBoGlrkp+BPRFhLOjfi8Jq777ZmqTeSsMTJJzLKuDIfNvI6ZbQc2PraOqyfPQuzeKydOg07I/H/z9e/G1523gV1ERq1ao9fxXKMFEt9Za6W7hpszOj90V7+7ls+BIfixEnatndKG0VOaC89pDLSAoJ9JGx97Wykfy3vTb5ndTP8+298D1y6bbssnCOL6GClmd/h0DSHEdqZnZn+INURAE2hStEnjh+Dv3fLTXAg0lRoX420k4RTtCfez/pZoZtov2LTFvj1r3sXXHXe+WZpW1lkJkBzNasgRDqWV9w1B9zaPEudKAmDf/DJKNDiZFvexD7SzzvNdnkTe16irQ5OMsidLc2Se8BMB+rJjh/+4f8F5gXUDzHruDx1DaxeiSiAahvFcDLODP3Row/BVdu2wSsuuADqrBAMTQgYSl4ttb1fU2zkzrrlsrqNx3+JNvMPfvwWeD7Fpf2naQ/qTjZT76qGEW3TSWHHYqf8k0cehiu2b4NX7txR6Waed65DUaWEXufZYfWuTZiJphlrPT6yfx/8yMf/Eg5HbZGBvKlIuMmAdiKEAA4EiuRp+qM4lnlZBPT1519glKqx7xVfEYbnk86acVrbshZc0b8x/qZo7//EZ2+DgyxEEqBXqqmU7WfXuIXvAjBiXrUUKtBUI8wF9NiDgzgEh2eTRNs6DP61KEFujJWcxd/E3G3J3tNMhSG4NXM7BQ593emBlDIzjsXG/K0Hvgi/GAdJZ7ATIBdATCoglC9LQN0RE2mvw1NR69y0b1/+oPOa886D80Zo9+aQNkUMQBqAnlJ8+j0ZJdov3fU5+OV774aTKT7SvbKpRXsnTKu0E7CJiLUofv/8sUdz21x7/vmwPdEOli5PoxEg6toM7qE9eH0+8v1f3veFyPfPw6mYMG9kT6ZQcZFW2mUDUGIceheYs6PngTlHDUyOFEbeAA+ik/oq+vvyxXf169BC1oEWcEzmx/paND3Ws/nBZsjVm7fAT7z+q+Cdey6PDOkG664xGU1KcAh+bYOeiRLhtmefjgOjO2FvtN+K5yKZGKt5AiK7ubqJME73fl7ZMn9aH9X3bD3RT+bTWqrHGlweaf+ZN78Fvv7Sy/KAzK8IZNQ22DpgY9aQ9yzqch49fPqZZ+CffvqTcSr+tKO9uOk6nioeoT0RMiPaZ5n2tczzRPsroqT+4de8Hr7h0itz6WZrEGi76wy9CmsT/qXzNAP4mQNPwy/f8zl44Pnj0RNDAmS1emTy/t9KIxpTg8EdQIHcSWeDg3mA1jf79rIvZhlT/rDR2NIAvKQBr4Bd1rxbz4ydra1npiZw9BEcIca9bfdF8J3XvBzefdmVsGU6ta84wpCxqOpiJEk8PxE7zs3RNfSf47Tqrc8+lScdpnkWjcAgdudEADEaAtAq831enDuDOY0Loh3bn020z+CrL74Y3nfttfBNV12Vpd5gSVq0tOuLTL+yoY9Ge/fWOPv3+w8+CHcefC6q47Qh/JRUdOmIxW/bKdpHVKTQXkGd6M/AjnXoYn1eu2MnfMe1L4f3XH41bIt80qtc8a8Onu9a2xyPPLk9Avl3H7ov0n6gDFizRF6VafmJTHNP8kNDMAOYUT8BGnXB8r1hI9B9vPaeeyrt/EAIlVXaCB8MDivajJSmDhFohfZAA60C7JlIugRqZvY1ccD1jXuugG+/5jp4ZWR2KrQlJTSDS90C3HP4UDZl/mTvI/DM6VNlKpt8s8zQjtR0deRzvii4EJ4BrUUSaBFKBsdaAkcBxSw2YqpLH+m/aus2eOell8L7XnYdvCl2UNmPRPjW6JBQAH3Xc8/Bjfsehz999FF4+vQpmiyZin9cBq5Tol1UNEiDq2ar3CJQ8+ZNBdhr0jHT0sepPa7del7eb/19174MXnXBTuClxlvaUWMuCbG7Dz0Ht0Zf/QejAHni9IncCQvPiwDp2MRIbsWueGOA5ityfmn/9XTSVds5l58L6gSnAuKgpAEUya35mqHKgJYIboMgzW1upLWg7ar9UJpfJHZGcr6OrAQkSd0rEySBOAFhRkdibmJ4ktipEc6PDfrmCy+Ga7afBxdG9X5+sh+JgLWYz/FoXx6MnpO9cTbyzgiIw2tnyjsBNEvJEw1ZKrB7iyRbp2xOgkRFXf6rUVjq03OnTEeiN0vsdalHn4AdwZHqd0Es780XXQTXRFt195bNcEGincpKtuzRqJ0OnY60R8/F5yPtB8+cNTOs2Q+eNEukP7vjplUqi5mhGzV3HKwLs7DJpMxD9twk/s4GtJf6JNp3Rtpft+vC7InavXlzHCes5vXnUogp8uD4udjpHovmxF1RixyJnRrFB86TJVM5Ty5QZD851lFlBm1nB4DJdg7GxKjnDDcWQlxngKGSzYCGVhizo/meA3WGtTJDyAdW05NbLzO2nxWJvb4uUruAYpalSU8bsvRkk4vIMHqvU7OTXQX0ZCqDJlZx7O+UKVbdc1HLzGDrzp0V2Kb2wE6dcVb2CyHaWRsF3gXJ85JUbWrUTDcN7jKQJ9OqSQztRL+g2dPebjutZRI9zPvAZghpzcT7zHfZnaov30XrsZIMygotQhdpDn6Hp+NOyG0y6Spw2dRA6/bRAG4OBFth5N507gMNR7CVZ6yuS/dJdMoH4lyBQFvzpsqnDYUmHc009qUh+8QIZuiMVCRtbxF6JWmG6gZI4qK8utoViUHqLcejArLoTPVrEUKVq4BG6qBZgmA5WFp2swn00zhJQ2BIC75nLUQ7pga/vpfy+Ajtk05evUUBwRzaofFrQgC2eVghs/RLwOr7JB2TCRP5nrXKtPB9VjsrjPGdaJeX8h3txa9M8ZjukX0iLjkE4xoCBWapTwPMWgCN1ruEja0+ajLkxkKoi9xpUEvXjrf7AuJU2QQOJID0XWZiVqWRKazaZTMZ9qAAGCM0k9LV/bxRqWQUkNMLUwbAlXFo6qUrF4oECUGtA106dx7ERTDk1wQS7dRJQ+pM3AFZktPoVvY/UdKg0K20hjmQ7HwE80qlp320UQvRTdonpNozj0t5YdIX2jXfaYJM+J6Obg7tJIUHmlAdAzCjm53WUrpVJTkfB3MK87ek8NcmKS/oSAAQBhCoZRVwECAH0AwuwM62VPo0ui9xxUwJ4vrLwHKjKv0yS/W9FjUIZI8NmCXPcSbYZpjaQAXVaMvQnssk2vtUZho4VrNKz6AuTTv7wVu0E78r7Ypo075YtaVI6hbtSUqHzHfueL3srxdqHTiPIu6HtJP/3ggWJzw8sOvzmnjbHrgAtPPCdID4RZlpTwjSICr34I7AX6RRYQOafJH91KoiWVqTfZx/J50CBVTGUnrJ34AUrY2pQbsIzD54aZCL6/NC7kHVveTYZ6lXBiwh84D3Aay0g6IfLO2IDiScxA1ccQHtWvAgOl5pkms65HwTnV2QjhkE1OD4DoYW4bumXUtZHSevH+pnoKaFeo4D3jfqOicsb3IMCiJQA3diRQ1J7jwY6INdEQgnWU2D8BZFMiCbLZSH2WAueJsDrOo1IKZ8jIRGWwd5RpUpZCqpyvqWO1w2RZj4yQjtQeUFA1ygq8eARlyedqx2jOOXTT+gXQ1YBdx0rbvfwFyaR7t0QAAZ+Ml9UJ1X5aE6wQsFcwpTjbVmUBWVtHwyCupQJFpKlE0KxewQSJqTVOPGR8pUhFooDGBJgR1UicP54RDQAIBO5QV9XzO2PmJPVQ+sp1ReNjPSNfnaNY8g1A1FSL1L5waiGX2h2KAdXN0U0M11bYpyqfilaWfNwlqS8hCNw3wXcwWE/wGHgsTSrujmarBEVmlqvQCqr/nFBXMKZuNNqxhrvj5/c88wiWznTHxhEtLgShqXMFyaVzFZSYKgGbsMHU6CMYil8QXElZm2fjpXMqW4oQgkgW1+BmgyL6h+tSOivDq3iOZKru2QfM31CqoDapkRTI4cF1Q+NTGbbTJ2z0IGlKSu6ZaiGSzfmc+8KLmhnUAr5ikDGXGw4ZW0G8LAyGydt/hsTI5Bp9C/oma5cCApCwLKoOINgVoqAJJkhjpBg1WKo86EH2MbW2qAhglYiTRSgJlHlqq6Jyn0IxIbGBcQNANMvVnDBKKd0RKU1gJdd8VHLY1atNdzpElBHKWdfwLUzgdEOypeMFSlGZE1iGpXqhwaLWlpr+RZMGvaUfO9EV/4AnYFWBU/aBPEAZDBXfPvtJVoNKAd+fsGQGJCYG5nSwHNLKKuYHBbSxUQ8iruOOyGo3S5E7TMMw/XnmB/VTkCwlDjURAkibI2MqzO/3WdYJB3m3aFTAI5eoDDCO0WiyBodPtTiMQOoaLJPSwQDUMyxWxxJGnazMcgDhtSjsqjVNcxhdvNlbcURmN66+XwROtrf48yKPdUkRrY8uYUWN3AmBB7SW9xQYl0e4wCQV0oqSESQz/fArDPSC/sAa7uwRPD0ockMxfm9iscFINQeRkqregb3nQAtHVo0WzOcQjaUhFgyVnpINoNwGEIalO+ohNgfudjfqqOizAHS63rFib9L92bbjhTbLSWAU8thIWCrHOlgco2HD2jwQ1BD+Ra4qIWjIY2dUuBxdI9TKvlgDEQdJ1QgxqgaigCJPuv2YaeR7uyK5envUkwKAMGzFggKBAx7SLRg8qXaCeAByZg0Mw4LLFFO0e0OiBWSBth2IBUE2emTBymyxL6XAMDV65BEVh7jICaEykholV6uV0NKA2yprRoE1V/Rhg693F/Txfd6pRMuxoUV6nlM2gV0Cj9y017TqsEi87pXPhO+bQ6oBE+nP9GwLxEOHdAc8HB1boBbNR+WZYaGvgi/eYxcsT+QEePv4HtpMsyzXhwwNPuAMIheDJeGO3nQrce0M2lXZMHG6AdWvSPgNikASvUBnmeO5hTeGGA1gRsANg5WtMtEgSy0h/uOei7MsK4SoTlgTAmIXS80zZMrpSQcNGhnVkz9L8ItGs6WjT6eJ++QTt7c2paR7sZM+j7uDHacUFHWJTWPRZgfpiWdzKU/5Ey1e9D13rj0FdJUjo4aT2UDjZvW+nyE9QFC4eQB5RolEGllU3DlqhRNOtn1L3RJW7RyyVUQABomloZpx1REXj8pX0HjmbK19RaiAaemBnQ7Mod3ENFM+eNdWyQ2cltizUH7o+opLmlGW2nMGmpDYxbF4c0W9IVzTgfdy6PeWmnzDh9Ax0T6qyXTQtgO4GvVKD0qK8BqQJg03K5YGuueA4amrVMUPR48FJa3Umw0iVxaqTcphkkt1J2nbVUpKoGwDbNFG/GMTDkfYnoVL1KJ9kQzahyD5UHmndgylQ059lcrM/pduBidVr0g/OC9ADu+RbNiJYOVQ+NBXR8ZozKfcp78HJSMxNNqAuDwrWKtuLINYh6CtXzXnqbwlpVtfc4b1XVQXLfKXW95tLMZ452uRPCKF0wXqsB7fYe/yyg2WQ3ntaoJcUaQ3urvceq0alpbj3YxAU0y8ts87NvhWYayvuF29Cjpere2mroxjPB3RiIrbFnwOqnpbiyGGBNurmMFg2A42lg7Bl4cWmXPM+R9nk81+rPP78M7Yjzr1+E8P8B0szv+tLrxRwAAAAASUVORK5CYII=";
  return (0, import_jsx_runtime.jsx)("svg", { ...props, width: "120", height: "120", viewBox: "0 0 120 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    backgroundSize: "100% 100%",
    backgroundImage: `url("${img}")`
  } });
};
var Trust = ({ theme = "light", ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("rect", { width: "44", height: "44", fill: theme === "light" ? "var(--ck-brand-trust-02)" : "var(--ck-brand-trust-02b)" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M33.0246 11.8662C33.4096 11.8662 33.774 12.0243 34.0421 12.2925C34.3102 12.5675 34.4615 12.9387 34.4546 13.3168C34.3859 17.4143 34.2277 20.5493 33.9321 23.0312C33.6433 25.5131 33.2102 27.3556 32.5571 28.8475C32.1171 29.8443 31.574 30.6693 30.9346 31.3706C30.0752 32.2987 29.0921 32.9725 28.0196 33.6119C27.561 33.8861 27.0843 34.1568 26.5842 34.4408C25.5172 35.0468 24.3441 35.713 23.0146 36.6025C22.5333 36.9256 21.9077 36.9256 21.4265 36.6025C20.0766 35.7026 18.8879 35.0281 17.8112 34.4173C17.5718 34.2815 17.3379 34.1488 17.109 34.0175C15.8509 33.2887 14.7165 32.5943 13.7265 31.5906C13.0665 30.9306 12.4959 30.1262 12.0421 29.1706C11.4234 27.8918 11.004 26.345 10.6946 24.3443C10.2821 21.67 10.0759 18.1706 10.0002 13.3168C9.99336 12.9387 10.1377 12.5675 10.4059 12.2925C10.674 12.0243 11.0452 11.8662 11.4302 11.8662H12.0215C13.8433 11.8731 17.8652 11.6943 21.344 8.98559C21.8596 8.58683 22.5815 8.58683 23.0971 8.98559C26.5759 11.6943 30.5977 11.8731 32.4265 11.8662H33.0246ZM29.8277 27.9331C30.2746 27.0118 30.6459 25.74 30.9277 23.9112C31.2646 21.725 31.4709 18.755 31.5671 14.7125C29.4221 14.6506 25.7371 14.2381 22.224 11.8731C18.7109 14.2312 15.0259 14.6437 12.8877 14.7125C12.9633 18.0537 13.1146 20.6525 13.3552 22.6943C13.6302 25.0181 14.0221 26.5925 14.5102 27.6993C14.8333 28.435 15.1909 28.9643 15.6171 29.4318C16.1877 30.0575 16.9096 30.5731 17.8927 31.1643C18.3005 31.409 18.7502 31.6635 19.2396 31.9406C20.1116 32.4341 21.1099 32.9991 22.224 33.7081C23.3175 33.0107 24.3014 32.4515 25.1633 31.9616C25.4231 31.8139 25.6717 31.6725 25.909 31.5356C27.119 30.8412 28.0127 30.2637 28.6796 29.59C29.1265 29.1293 29.4909 28.6275 29.8277 27.9331Z", fill: theme === "light" ? "var(--ck-brand-trust-01)" : "var(--ck-brand-trust-01b)" })] });
var Argent = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("rect", { width: "32", height: "32", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M18.3242 7.63647H13.6516C13.4955 7.63647 13.3704 7.76611 13.367 7.92726C13.2726 12.4568 10.9768 16.7559 7.02532 19.8009C6.89986 19.8976 6.87128 20.0792 6.963 20.21L9.69685 24.112C9.78986 24.2448 9.97107 24.2747 10.0986 24.1772C12.5694 22.2856 14.5567 20.0038 15.9879 17.4746C17.4191 20.0038 19.4065 22.2856 21.8773 24.1772C22.0047 24.2747 22.186 24.2448 22.2791 24.112L25.013 20.21C25.1045 20.0792 25.0759 19.8976 24.9506 19.8009C20.999 16.7559 18.7033 12.4568 18.609 7.92726C18.6056 7.76611 18.4803 7.63647 18.3242 7.63647Z", fill: "var(--ck-brand-argent)" })] });
var ImToken = ({ ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: `linear-gradient(
      180deg,
      var(--ck-brand-imtoken-01) 0%,
      var(--ck-brand-imtoken-02) 100%
    )`
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M26.8543 9.96509C27.5498 19.3857 21.4942 23.8384 16.0655 24.3132C11.0184 24.7546 6.26765 21.6534 5.85087 16.8885C5.50707 12.952 7.94004 11.2761 9.8516 11.109C11.8177 10.9367 13.4698 12.2925 13.6132 13.9342C13.7512 15.5125 12.7664 16.2308 12.0815 16.2906C11.5398 16.3381 10.8584 16.0093 10.7968 15.3032C10.7441 14.6965 10.9744 14.6138 10.9182 13.9693C10.8179 12.8219 9.81731 12.6882 9.26951 12.7357C8.60654 12.7937 7.40368 13.5675 7.5725 15.4949C7.7422 17.439 9.60628 18.9751 12.0498 18.7614C14.6868 18.531 16.5227 16.4779 16.6608 13.5983C16.6595 13.4458 16.6916 13.2948 16.7548 13.156L16.7557 13.1525C16.7841 13.0922 16.8174 13.0342 16.8551 12.9793C16.9113 12.8949 16.9835 12.8016 17.0767 12.6997C17.0775 12.697 17.0775 12.697 17.0793 12.697C17.147 12.6205 17.2288 12.5379 17.3211 12.4491C18.473 11.3623 22.6214 8.79916 26.5448 9.61074C26.6277 9.62851 26.7026 9.67262 26.7584 9.73649C26.8142 9.80035 26.8478 9.88054 26.8543 9.96509", fill: "white" }) });
var Frame = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("rect", { width: "32", height: "32", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M24.9055 15.8824V8.30065C24.9055 7.63399 24.3583 7.08497 23.6938 7.08497H16.1238C16.0456 7.08497 15.9805 7.05882 15.9153 7.00654L15.0033 6.0915C14.9511 6.03922 14.873 6 14.7948 6H7.21173C6.54723 6 6 6.53595 6 7.21569V14.7974C6 14.8758 6.02606 14.9412 6.07818 15.0065L6.99023 15.9216C7.04235 15.9739 7.08143 16.0523 7.08143 16.1307V23.7124C7.08143 24.3791 7.62866 24.9281 8.29316 24.9281H15.8762C15.9544 24.9281 16.0195 24.9542 16.0847 25.0065L16.9967 25.9216C17.0489 25.9739 17.127 26 17.2052 26H24.7883C25.4528 26 26 25.4641 26 24.7843V17.2026C26 17.1242 25.9739 17.0588 25.9218 16.9935L25.0098 16.0784C24.9446 16.0261 24.9055 15.9608 24.9055 15.8824ZM19.759 19.9346H12.241C12.1498 19.9346 12.0717 19.8562 12.0717 19.7647V12.2353C12.0717 12.1438 12.1498 12.0654 12.241 12.0654H19.759C19.8502 12.0654 19.9283 12.1438 19.9283 12.2353V19.7647C19.9414 19.8562 19.8632 19.9346 19.759 19.9346Z", fill: "#00D2BE" })] });
var Rainbow = ({ round = false, ...props }) => {
  const withBackground = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEyMCAxMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxyZWN0IHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfNjJfMzI5KSIvPgo8cGF0aCBkPSJNMjAgMzhIMjZDNTYuOTI3OSAzOCA4MiA2My4wNzIxIDgyIDk0VjEwMEg5NEM5Ny4zMTM3IDEwMCAxMDAgOTcuMzEzNyAxMDAgOTRDMTAwIDUzLjEzMDkgNjYuODY5MSAyMCAyNiAyMEMyMi42ODYzIDIwIDIwIDIyLjY4NjMgMjAgMjZWMzhaIiBmaWxsPSJ1cmwoI3BhaW50MV9yYWRpYWxfNjJfMzI5KSIvPgo8cGF0aCBkPSJNODQgOTRIMTAwQzEwMCA5Ny4zMTM3IDk3LjMxMzcgMTAwIDk0IDEwMEg4NFY5NFoiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik0yNiAyMEwyNiAzNkgyMEwyMCAyNkMyMCAyMi42ODYzIDIyLjY4NjMgMjAgMjYgMjBaIiBmaWxsPSJ1cmwoI3BhaW50M19saW5lYXJfNjJfMzI5KSIvPgo8cGF0aCBkPSJNMjAgMzZIMjZDNTguMDMyNSAzNiA4NCA2MS45Njc1IDg0IDk0VjEwMEg2NlY5NEM2NiA3MS45MDg2IDQ4LjA5MTQgNTQgMjYgNTRIMjBWMzZaIiBmaWxsPSJ1cmwoI3BhaW50NF9yYWRpYWxfNjJfMzI5KSIvPgo8cGF0aCBkPSJNNjggOTRIODRWMTAwSDY4Vjk0WiIgZmlsbD0idXJsKCNwYWludDVfbGluZWFyXzYyXzMyOSkiLz4KPHBhdGggZD0iTTIwIDUyTDIwIDM2TDI2IDM2TDI2IDUySDIwWiIgZmlsbD0idXJsKCNwYWludDZfbGluZWFyXzYyXzMyOSkiLz4KPHBhdGggZD0iTTIwIDYyQzIwIDY1LjMxMzcgMjIuNjg2MyA2OCAyNiA2OEM0MC4zNTk0IDY4IDUyIDc5LjY0MDYgNTIgOTRDNTIgOTcuMzEzNyA1NC42ODYzIDEwMCA1OCAxMDBINjhWOTRDNjggNzAuODA0IDQ5LjE5NiA1MiAyNiA1MkgyMFY2MloiIGZpbGw9InVybCgjcGFpbnQ3X3JhZGlhbF82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik01MiA5NEg2OFYxMDBINThDNTQuNjg2MyAxMDAgNTIgOTcuMzEzNyA1MiA5NFoiIGZpbGw9InVybCgjcGFpbnQ4X3JhZGlhbF82Ml8zMjkpIi8+CjxwYXRoIGQ9Ik0yNiA2OEMyMi42ODYzIDY4IDIwIDY1LjMxMzcgMjAgNjJMMjAgNTJMMjYgNTJMMjYgNjhaIiBmaWxsPSJ1cmwoI3BhaW50OV9yYWRpYWxfNjJfMzI5KSIvPgo8ZGVmcz4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDBfbGluZWFyXzYyXzMyOSIgeDE9IjYwIiB5MT0iMCIgeDI9IjYwIiB5Mj0iMTIwIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiMxNzQyOTkiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDAxRTU5Ii8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQxX3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYgOTQpIHJvdGF0ZSgtOTApIHNjYWxlKDc0KSI+CjxzdG9wIG9mZnNldD0iMC43NzAyNzciIHN0b3AtY29sb3I9IiNGRjQwMDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjODc1NEM5Ii8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl82Ml8zMjkiIHgxPSI4MyIgeTE9Ijk3IiB4Mj0iMTAwIiB5Mj0iOTciIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGNDAwMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4NzU0QzkiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDNfbGluZWFyXzYyXzMyOSIgeDE9IjIzIiB5MT0iMjAiIHgyPSIyMyIgeTI9IjM3IiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiM4NzU0QzkiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY0MDAwIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ0X3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjYgOTQpIHJvdGF0ZSgtOTApIHNjYWxlKDU4KSI+CjxzdG9wIG9mZnNldD0iMC43MjM5MjkiIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ1X2xpbmVhcl82Ml8zMjkiIHgxPSI2OCIgeTE9Ijk3IiB4Mj0iODQiIHkyPSI5NyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjRkZGNzAwIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGOTkwMSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50Nl9saW5lYXJfNjJfMzI5IiB4MT0iMjMiIHkxPSI1MiIgeDI9IjIzIiB5Mj0iMzYiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGRjcwMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiNGRjk5MDEiLz4KPC9saW5lYXJHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDdfcmFkaWFsXzYyXzMyOSIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgyNiA5NCkgcm90YXRlKC05MCkgc2NhbGUoNDIpIj4KPHN0b3Agb2Zmc2V0PSIwLjU5NTEzIiBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50OF9yYWRpYWxfNjJfMzI5IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDUxIDk3KSBzY2FsZSgxNyA0NS4zMzMzKSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMEFBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDFEQTQwIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ5X3JhZGlhbF82Ml8zMjkiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMjMgNjkpIHJvdGF0ZSgtOTApIHNjYWxlKDE3IDMyMi4zNykiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8L2RlZnM+Cjwvc3ZnPgo=";
  const roundWithBackground = "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMTIwIiBoZWlnaHQ9IjEyMCIgdmlld0JveD0iMCAwIDEyMCAxMjAiIGZpbGw9Im5vbmUiIHhtbG5zPSJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZyI+CjxnIGNsaXAtcGF0aD0idXJsKCNjbGlwMF84XzU1NCkiPgo8bWFzayBpZD0ibWFzazBfOF81NTQiIHN0eWxlPSJtYXNrLXR5cGU6YWxwaGEiIG1hc2tVbml0cz0idXNlclNwYWNlT25Vc2UiIHg9IjAiIHk9IjAiIHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIj4KPGNpcmNsZSBjeD0iNjAiIGN5PSI2MCIgcj0iNjAiIGZpbGw9IiNEOUQ5RDkiLz4KPC9tYXNrPgo8ZyBtYXNrPSJ1cmwoI21hc2swXzhfNTU0KSI+CjxyZWN0IHdpZHRoPSIxMjAiIGhlaWdodD0iMTIwIiBmaWxsPSJ1cmwoI3BhaW50MF9saW5lYXJfOF81NTQpIi8+CjwvZz4KPHBhdGggZD0iTTI2LjY2NjcgNDEuNjY2N0gzMS42NjY3QzU3LjQ0IDQxLjY2NjcgNzguMzMzMyA2Mi41NiA3OC4zMzMzIDg4LjMzMzNWOTMuMzMzM0g4OC4zMzMzQzkxLjA5NDggOTMuMzMzMyA5My4zMzMzIDkxLjA5NDcgOTMuMzMzMyA4OC4zMzMzQzkzLjMzMzMgNTQuMjc1OCA2NS43MjQyIDI2LjY2NjcgMzEuNjY2NyAyNi42NjY3QzI4LjkwNTIgMjYuNjY2NyAyNi42NjY3IDI4LjkwNTIgMjYuNjY2NyAzMS42NjY3VjQxLjY2NjdaIiBmaWxsPSJ1cmwoI3BhaW50MV9yYWRpYWxfOF81NTQpIi8+CjxwYXRoIGQ9Ik04MCA4OC4zMzMzSDkzLjMzMzNDOTMuMzMzMyA5MS4wOTQ4IDkxLjA5NDcgOTMuMzMzMyA4OC4zMzMzIDkzLjMzMzNIODBWODguMzMzM1oiIGZpbGw9InVybCgjcGFpbnQyX2xpbmVhcl84XzU1NCkiLz4KPHBhdGggZD0iTTMxLjY2NjcgMjYuNjY2N0wzMS42NjY3IDQwSDI2LjY2NjdMMjYuNjY2NyAzMS42NjY3QzI2LjY2NjcgMjguOTA1MiAyOC45MDUyIDI2LjY2NjcgMzEuNjY2NyAyNi42NjY3WiIgZmlsbD0idXJsKCNwYWludDNfbGluZWFyXzhfNTU0KSIvPgo8cGF0aCBkPSJNMjYuNjY2NiA0MEgzMS42NjY2QzU4LjM2MDQgNDAgODAgNjEuNjM5NiA4MCA4OC4zMzMzVjkzLjMzMzNINjVWODguMzMzM0M2NSA2OS45MjM4IDUwLjA3NjEgNTUgMzEuNjY2NiA1NUgyNi42NjY2VjQwWiIgZmlsbD0idXJsKCNwYWludDRfcmFkaWFsXzhfNTU0KSIvPgo8cGF0aCBkPSJNNjYuNjY2NiA4OC4zMzMzSDgwVjkzLjMzMzNINjYuNjY2NlY4OC4zMzMzWiIgZmlsbD0idXJsKCNwYWludDVfbGluZWFyXzhfNTU0KSIvPgo8cGF0aCBkPSJNMjYuNjY2NiA1My4zMzMzTDI2LjY2NjYgNDBMMzEuNjY2NiA0MEwzMS42NjY2IDUzLjMzMzNIMjYuNjY2NloiIGZpbGw9InVybCgjcGFpbnQ2X2xpbmVhcl84XzU1NCkiLz4KPHBhdGggZD0iTTI2LjY2NjYgNjEuNjY2N0MyNi42NjY2IDY0LjQyODEgMjguOTA1MiA2Ni42NjY3IDMxLjY2NjYgNjYuNjY2N0M0My42MzI4IDY2LjY2NjcgNTMuMzMzMyA3Ni4zNjcyIDUzLjMzMzMgODguMzMzM0M1My4zMzMzIDkxLjA5NDcgNTUuNTcxOSA5My4zMzMzIDU4LjMzMzMgOTMuMzMzM0g2Ni42NjY2Vjg4LjMzMzNDNjYuNjY2NiA2OS4wMDM0IDUwLjk5NjYgNTMuMzMzMyAzMS42NjY2IDUzLjMzMzNIMjYuNjY2NlY2MS42NjY3WiIgZmlsbD0idXJsKCNwYWludDdfcmFkaWFsXzhfNTU0KSIvPgo8cGF0aCBkPSJNNTMuMzMzMyA4OC4zMzMzSDY2LjY2NjZWOTMuMzMzM0g1OC4zMzMzQzU1LjU3MTkgOTMuMzMzMyA1My4zMzMzIDkxLjA5NDggNTMuMzMzMyA4OC4zMzMzWiIgZmlsbD0idXJsKCNwYWludDhfcmFkaWFsXzhfNTU0KSIvPgo8cGF0aCBkPSJNMzEuNjY2NiA2Ni42NjY3QzI4LjkwNTIgNjYuNjY2NyAyNi42NjY2IDY0LjQyODEgMjYuNjY2NiA2MS42NjY3TDI2LjY2NjYgNTMuMzMzM0wzMS42NjY2IDUzLjMzMzNMMzEuNjY2NiA2Ni42NjY3WiIgZmlsbD0idXJsKCNwYWludDlfcmFkaWFsXzhfNTU0KSIvPgo8L2c+CjxkZWZzPgo8bGluZWFyR3JhZGllbnQgaWQ9InBhaW50MF9saW5lYXJfOF81NTQiIHgxPSI2MCIgeTE9IjAiIHgyPSI2MCIgeTI9IjEyMCIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMTc0Mjk5Ii8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAwMUU1OSIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50MV9yYWRpYWxfOF81NTQiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzEuNjY2NyA4OC4zMzMzKSByb3RhdGUoLTkwKSBzY2FsZSg2MS42NjY3KSI+CjxzdG9wIG9mZnNldD0iMC43NzAyNzciIHN0b3AtY29sb3I9IiNGRjQwMDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjODc1NEM5Ii8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQyX2xpbmVhcl84XzU1NCIgeDE9Ijc5LjE2NjYiIHkxPSI5MC44MzMzIiB4Mj0iOTMuMzMzMyIgeTI9IjkwLjgzMzMiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIj4KPHN0b3Agc3RvcC1jb2xvcj0iI0ZGNDAwMCIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiM4NzU0QzkiLz4KPC9saW5lYXJHcmFkaWVudD4KPGxpbmVhckdyYWRpZW50IGlkPSJwYWludDNfbGluZWFyXzhfNTU0IiB4MT0iMjkuMTY2NyIgeTE9IjI2LjY2NjciIHgyPSIyOS4xNjY3IiB5Mj0iNDAuODMzMyIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiPgo8c3RvcCBzdG9wLWNvbG9yPSIjODc1NEM5Ii8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iI0ZGNDAwMCIvPgo8L2xpbmVhckdyYWRpZW50Pgo8cmFkaWFsR3JhZGllbnQgaWQ9InBhaW50NF9yYWRpYWxfOF81NTQiIGN4PSIwIiBjeT0iMCIgcj0iMSIgZ3JhZGllbnRVbml0cz0idXNlclNwYWNlT25Vc2UiIGdyYWRpZW50VHJhbnNmb3JtPSJ0cmFuc2xhdGUoMzEuNjY2NiA4OC4zMzMzKSByb3RhdGUoLTkwKSBzY2FsZSg0OC4zMzMzKSI+CjxzdG9wIG9mZnNldD0iMC43MjM5MjkiIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ1X2xpbmVhcl84XzU1NCIgeDE9IjY2LjY2NjYiIHkxPSI5MC44MzMzIiB4Mj0iODAiIHkyPSI5MC44MzMzIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxsaW5lYXJHcmFkaWVudCBpZD0icGFpbnQ2X2xpbmVhcl84XzU1NCIgeDE9IjI5LjE2NjYiIHkxPSI1My4zMzMzIiB4Mj0iMjkuMTY2NiIgeTI9IjQwIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSI+CjxzdG9wIHN0b3AtY29sb3I9IiNGRkY3MDAiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjRkY5OTAxIi8+CjwvbGluZWFyR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ3X3JhZGlhbF84XzU1NCIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgzMS42NjY2IDg4LjMzMzMpIHJvdGF0ZSgtOTApIHNjYWxlKDM1KSI+CjxzdG9wIG9mZnNldD0iMC41OTUxMyIgc3RvcC1jb2xvcj0iIzAwQUFGRiIvPgo8c3RvcCBvZmZzZXQ9IjEiIHN0b3AtY29sb3I9IiMwMURBNDAiLz4KPC9yYWRpYWxHcmFkaWVudD4KPHJhZGlhbEdyYWRpZW50IGlkPSJwYWludDhfcmFkaWFsXzhfNTU0IiBjeD0iMCIgY3k9IjAiIHI9IjEiIGdyYWRpZW50VW5pdHM9InVzZXJTcGFjZU9uVXNlIiBncmFkaWVudFRyYW5zZm9ybT0idHJhbnNsYXRlKDUyLjUgOTAuODMzMykgc2NhbGUoMTQuMTY2NyAzNy43Nzc4KSI+CjxzdG9wIHN0b3AtY29sb3I9IiMwMEFBRkYiLz4KPHN0b3Agb2Zmc2V0PSIxIiBzdG9wLWNvbG9yPSIjMDFEQTQwIi8+CjwvcmFkaWFsR3JhZGllbnQ+CjxyYWRpYWxHcmFkaWVudCBpZD0icGFpbnQ5X3JhZGlhbF84XzU1NCIgY3g9IjAiIGN5PSIwIiByPSIxIiBncmFkaWVudFVuaXRzPSJ1c2VyU3BhY2VPblVzZSIgZ3JhZGllbnRUcmFuc2Zvcm09InRyYW5zbGF0ZSgyOS4xNjY2IDY3LjUpIHJvdGF0ZSgtOTApIHNjYWxlKDE0LjE2NjcgMjY4LjY0MikiPgo8c3RvcCBzdG9wLWNvbG9yPSIjMDBBQUZGIi8+CjxzdG9wIG9mZnNldD0iMSIgc3RvcC1jb2xvcj0iIzAxREE0MCIvPgo8L3JhZGlhbEdyYWRpZW50Pgo8Y2xpcFBhdGggaWQ9ImNsaXAwXzhfNTU0Ij4KPHJlY3Qgd2lkdGg9IjEyMCIgaGVpZ2h0PSIxMjAiIGZpbGw9IndoaXRlIi8+CjwvY2xpcFBhdGg+CjwvZGVmcz4KPC9zdmc+Cg==";
  return (0, import_jsx_runtime.jsx)("svg", { ...props, width: "120", height: "120", viewBox: "0 0 120 120", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    backgroundSize: "100% 100%",
    backgroundImage: `url("${round ? roundWithBackground : withBackground}")`
  } });
};
var Brave$1 = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("rect", { rx: "27%", width: "88", height: "88", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M69.0892 28.2123L70.5781 24.5643L66.3594 20.1967C64.0763 17.9136 59.2123 19.2537 59.2123 19.2537L53.7031 13H34.2721L28.7381 19.2785C28.7381 19.2785 23.8741 17.9632 21.591 20.1967L17.3722 24.5395L18.8612 28.1875L17 33.5974L23.204 57.2472C24.4945 62.3097 25.3631 64.2702 29.011 66.8511L40.352 74.5441C41.4439 75.2142 42.784 76.3805 44 76.3805C45.216 76.3805 46.5561 75.2142 47.648 74.5441L58.989 66.8511C62.6369 64.2702 63.5055 62.3097 64.796 57.2472L71 33.5974L69.0892 28.2123Z", fill: "url(#paint0_linear_2183_5890)" }), (0, import_jsx_runtime.jsx)("path", { d: "M57.6737 23.2739C57.6737 23.2739 64.796 31.8851 64.796 33.6967C64.796 35.5579 63.9026 36.0294 63.0092 36.9972L57.6737 42.705C57.1774 43.2013 56.1103 44.045 56.7307 45.5092C57.3511 46.9982 58.2197 48.8346 57.227 50.7206C56.2344 52.6314 54.4972 53.8971 53.3805 53.6985C51.7195 53.1594 50.1348 52.4088 48.6654 51.4651C47.7224 50.8447 44.6949 48.3382 44.6949 47.3704C44.6949 46.4026 47.8217 44.6406 48.4173 44.2932C48.9881 43.8961 51.6434 42.3575 51.693 41.7619C51.7427 41.1664 51.7427 41.0175 50.9485 39.5285C50.1544 38.0395 48.7647 36.0542 48.9632 34.7638C49.2114 33.4733 51.4449 32.7785 53.1075 32.1581L58.2445 30.2224C58.6415 30.0239 58.5423 29.8502 57.3511 29.7261C56.1599 29.6268 52.8097 29.1801 51.296 29.602C49.7822 30.0239 47.2509 30.6691 47.0028 31.0165C46.8042 31.364 46.6057 31.364 46.829 32.5551L48.2684 40.3722C48.3677 41.3649 48.5662 42.0349 47.5239 42.2831C46.432 42.5313 44.6204 42.9531 44 42.9531C43.3796 42.9531 41.5432 42.5313 40.4761 42.2831C39.409 42.0349 39.6075 41.3649 39.7316 40.3722C39.8309 39.3796 40.9228 33.7215 41.1461 32.5551C41.3943 31.364 41.171 31.364 40.9724 31.0165C40.7243 30.6691 38.1682 30.0239 36.6544 29.602C35.1654 29.1801 31.7904 29.6268 30.5993 29.7509C29.4081 29.8502 29.3088 29.9991 29.7059 30.2472L34.8428 32.1581C36.4807 32.7785 38.7638 33.4733 38.9871 34.7638C39.2353 36.079 37.8208 38.0395 37.0018 39.5285C36.1829 41.0175 36.2077 41.1664 36.2574 41.7619C36.307 42.3575 38.9871 43.8961 39.5331 44.2932C40.1287 44.6654 43.2555 46.4026 43.2555 47.3704C43.2555 48.3382 40.3024 50.8447 39.3097 51.4651C37.8404 52.4088 36.2557 53.1594 34.5947 53.6985C33.4779 53.8971 31.7408 52.6314 30.7233 50.7206C29.7307 48.8346 30.6241 46.9982 31.2197 45.5092C31.8401 44.0202 30.7978 43.2261 30.2767 42.705L24.9412 36.9972C24.0726 36.079 23.1792 35.5827 23.1792 33.7463C23.1792 31.9099 30.3015 23.3235 30.3015 23.3235L37.0763 24.4154C37.8704 24.4154 39.6324 23.7454 41.2454 23.1746C42.8585 22.6783 43.9752 22.6287 43.9752 22.6287C43.9752 22.6287 45.0671 22.6287 46.705 23.1746C48.3428 23.7206 50.08 24.4154 50.8741 24.4154C51.693 24.4154 57.6985 23.2491 57.6985 23.2491L57.6737 23.2739ZM52.3382 56.2298C52.7849 56.4779 52.512 57.0239 52.0901 57.3217L45.7868 62.2353C45.2904 62.7316 44.4963 63.4761 43.9752 63.4761C43.454 63.4761 42.6847 62.7316 42.1636 62.2353C40.0743 60.5717 37.9648 58.9337 35.8355 57.3217C35.4384 57.0239 35.1654 56.5028 35.5873 56.2298L39.3097 54.2445C40.7894 53.4618 42.3551 52.8539 43.9752 52.4329C44.3474 52.4329 46.705 53.2767 48.6158 54.2445L52.3382 56.2298Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M59.262 19.2785L53.7032 13H34.2721L28.7381 19.2785C28.7381 19.2785 23.8741 17.9632 21.591 20.1967C21.591 20.1967 28.0432 19.6259 30.2767 23.2491L37.126 24.4154C37.9201 24.4154 39.682 23.7454 41.2951 23.1746C42.9081 22.6783 44.0249 22.6287 44.0249 22.6287C44.0249 22.6287 45.1168 22.6287 46.7546 23.1746C48.3925 23.7206 50.1296 24.4154 50.9238 24.4154C51.7427 24.4154 57.7482 23.2491 57.7482 23.2491C59.9817 19.6259 66.4339 20.1967 66.4339 20.1967C64.1508 17.9136 59.2868 19.2537 59.2868 19.2537", fill: "url(#paint1_linear_2183_5890)" }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_2183_5890", x1: "17", y1: "45.3241", x2: "71", y2: "45.3241", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.4", stopColor: "#FF5500" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.6", stopColor: "#FF2000" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint1_linear_2183_5890", x1: "22.4879", y1: "18.8219", x2: "66.4339", y2: "18.8219", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#FF452A" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "#FF2000" })] })] })] });
var Crypto = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "white" }, children: [(0, import_jsx_runtime.jsx)("mask", { id: "mask0_2091_4394", style: { maskType: "alpha" }, maskUnits: "userSpaceOnUse", x: "13", y: "9", width: "62", height: "71", children: (0, import_jsx_runtime.jsx)("path", { d: "M44 9L13 26.75V62.25L44 80L75 62.25V26.75L44 9ZM31.7577 24.3492H56.1513L59.0935 36.684H28.9307L31.7577 24.3492ZM41.5613 61.2993L36.2955 66.161H31.8427L20.6924 46.9369L28.8701 40.9079L36.0953 45.4627V53.6578L41.5552 58.8504V61.2993H41.5613ZM37.9759 53.1584L38.7888 45.4326L36.1256 38.5432H51.9229L49.3204 45.4326L50.0787 53.1283L44 53.1584H37.9759ZM56.2059 66.1069H51.8076L46.5419 61.2993V58.8564L52.0018 53.6638V45.4627L59.1421 40.8537L67.2955 46.9369L56.2059 66.1069Z", fill: "#002D74" }) }), (0, import_jsx_runtime.jsxs)("g", { mask: "url(#mask0_2091_4394)", children: [(0, import_jsx_runtime.jsx)("rect", { y: "8", width: "44", height: "72", fill: "url(#paint0_linear_2091_4394)" }), (0, import_jsx_runtime.jsx)("rect", { x: "88", y: "80", width: "44", height: "72", transform: "rotate(-180 88 80)", fill: "url(#paint1_linear_2091_4394)" })] }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_2091_4394", x1: "22", y1: "8", x2: "22", y2: "80", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#010935" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "#142C70" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint1_linear_2091_4394", x1: "110", y1: "80", x2: "110", y2: "152", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#010935" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "#142C70" })] })] })] });
var Ledger = ({ ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "black" }, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M37.2106 16H16V29.4577H19.2182V19.2182L37.2106 19.1011V16ZM37.3568 33.4073V54.6179H50.8146V51.3997H40.575L40.458 33.4073H37.3568ZM16 72.1714H37.2106V69.0703L19.2182 68.9533V58.7137H16V72.1714ZM50.9609 16H72.1714V29.4577H68.9533V19.2182L50.9609 19.1011V16ZM72.1714 72.1714H50.9609V69.0703L68.9533 68.9533V58.7137H72.1714V72.1714Z", fill: "white" }) });
var Steak = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "600", height: "600", viewBox: "0 0 600 600", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "black" }, children: [(0, import_jsx_runtime.jsx)("path", { d: "M470.747 209.191C462.305 192.354 448.646 178.695 431.808 170.253C413.337 161 389.233 161 341.006 161C331.236 161 307.916 161 300 161C292.084 161 268.728 161 258.994 161C210.856 161 186.662 161 168.191 170.253C151.354 178.69 137.7 192.35 129.27 209.191C119.999 227.662 120 251.767 120 299.976C120 348.185 119.999 372.308 129.27 390.778C137.7 407.619 151.354 421.279 168.191 429.716C186.662 438.97 210.784 438.97 258.994 438.97C268.764 438.97 292.084 438.97 300 438.97C307.916 438.97 331.272 438.97 341.006 438.97C389.144 438.97 413.337 438.97 431.808 429.716C448.646 421.274 462.305 407.616 470.747 390.778C480 372.308 480 348.203 480 299.976C480 251.749 480 227.662 470.747 209.191Z", fill: "#FFCEAA" }), (0, import_jsx_runtime.jsx)("path", { d: "M218.557 350.342C216.323 345.957 212.922 342.274 208.729 339.698C204.536 337.121 199.713 335.752 194.791 335.741H166.747C163.876 335.755 161.041 336.37 158.422 337.548C155.804 338.725 153.462 340.439 151.547 342.577C149.632 344.716 148.186 347.232 147.303 349.964C146.42 352.696 146.12 355.582 146.422 358.437C147.385 367.476 148.954 374.34 151.575 379.564C157.629 391.573 167.378 401.323 179.388 407.377C188.195 411.798 201.674 413.26 222.444 413.742C225.415 413.812 228.353 413.109 230.97 411.702C233.587 410.295 235.793 408.232 237.373 405.715C238.953 403.199 239.852 400.315 239.982 397.346C240.113 394.378 239.47 391.427 238.116 388.781L218.557 350.342Z", fill: "#FF3B9A" }), (0, import_jsx_runtime.jsx)("path", { d: "M180.618 312.563C189.852 312.562 198.95 310.335 207.14 306.071C215.33 301.806 222.371 295.63 227.668 288.066L254.856 249.253C259.761 242.25 262.839 234.134 263.81 225.64C264.782 217.146 263.616 208.545 260.419 200.616V200.384C258.913 196.555 256.409 193.2 253.167 190.666C249.925 188.133 246.064 186.514 241.985 185.978C209.732 186.085 190.726 186.887 179.405 192.575C167.37 198.586 157.611 208.339 151.592 220.37C146.725 230.247 145.227 258.007 144.87 280.507C144.797 284.698 145.56 288.862 147.114 292.754C148.668 296.647 150.983 300.191 153.923 303.179C156.863 306.167 160.369 308.539 164.236 310.156C168.103 311.774 172.254 312.604 176.445 312.599L180.618 312.563Z", fill: "#FF3B9A" }), (0, import_jsx_runtime.jsx)("path", { d: "M449.702 220.356C443.655 208.365 433.909 198.639 421.906 192.614C409.89 186.588 389.262 186.053 353.337 186C304.664 186 289.528 242 279.134 256.834L248.556 300.497C243.645 307.51 240.729 315.725 240.12 324.266C239.511 332.806 241.231 341.352 245.098 348.991L267.758 393.813C270.842 399.931 275.578 405.063 281.43 408.627C287.282 412.191 294.016 414.045 300.867 413.978H301.49C309.495 413.978 334.171 413.978 342.283 413.978C385.072 413.978 408.713 413.977 421.906 407.381C433.914 401.331 443.66 391.58 449.702 379.568C456.317 366.374 456.316 342.787 456.316 299.944C456.316 257.101 456.317 233.621 449.702 220.356Z", fill: "#FF3B9A" })] });
var Unstoppable = ({ ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "linear-gradient(180deg, #FED812 0%, #FFAF00 100%)" }, children: (0, import_jsx_runtime.jsx)("path", { d: "M47.4 43.7163C47.4 45.6251 45.8781 47.1714 44.0001 47.1714C42.1219 47.1714 40.6 45.6251 40.6 43.7163L40.6 -7H27L27 43.7163C27 53.2612 34.6106 61 44.0001 61C53.3882 61 61 53.2612 61 43.7163V-7H47.4V43.7163Z", fill: "#1F2129" }) });
var ONTO = ({ ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "white" }, children: (0, import_jsx_runtime.jsx)("path", { d: "M20 16L28.675 24.677C32.1885 21.8644 36.4154 20.0873 40.8816 19.545C45.348 19.0026 49.8769 19.7164 53.9604 21.6063C58.0438 23.4963 61.5207 26.4876 64.0005 30.2447C66.4804 34.0019 67.8653 38.3763 68 42.8772V43.5854V72L59.3367 63.3231C55.8263 66.1389 51.6014 67.9196 47.1361 68.4655C42.6708 69.0112 38.1419 68.3007 34.0577 66.4135C29.9734 64.5262 26.4956 61.537 24.0144 57.7813C21.5333 54.0255 20.1472 49.6521 20.0115 45.1515V44.4433L20 16ZM25.931 30.3311V44.4146C25.9323 47.7294 26.8335 50.9817 28.5384 53.8236C30.2432 56.6655 32.6875 58.9902 35.6101 60.5497C38.5328 62.1089 41.8238 62.8439 45.1313 62.6764C48.439 62.5087 51.639 61.4445 54.3894 59.5978L54.8611 59.2754L27.0873 31.4884L25.931 30.3311ZM33.6223 28.4022L33.1505 28.7304L60.9186 56.5117L62.069 57.6632V43.5854C62.0683 40.2717 61.1679 37.0204 59.464 34.179C57.7603 31.3377 55.3171 29.0132 52.3957 27.4539C49.4742 25.8946 46.1844 25.1592 42.8777 25.3262C39.5712 25.4933 36.372 26.5565 33.6223 28.4022Z", fill: "#23262F" }) });
var Slope = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "#6C67F1" }, children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M50.6667 24.3696L34.8872 40.1864L24.0001 37.7402L37.3334 24.3696L48.4438 13.3798C49.268 12.5646 50.6667 13.1484 50.6667 14.3077V24.3696ZM37.3339 51.0358L50.6672 37.74V24.3694L35.2001 39.8737L37.3339 51.0358Z", fill: "url(#paint0_linear_2593_6077)" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M37.3337 64.2947V50.9617L50.667 37.6284L55.7849 45.8435L55.9822 45.6463L64 50.9616L39.5582 75.2343C38.7347 76.0521 37.3336 75.4687 37.3336 74.3082V64.2949L37.3337 64.2947Z", fill: "url(#paint1_linear_2593_6077)" }), (0, import_jsx_runtime.jsx)("path", { d: "M24 37.7405H32.573C35.202 37.7405 37.3333 39.8718 37.3333 42.5009V51.0359H28.7602C26.1313 51.0359 24 48.9046 24 46.2757V37.7405Z", fill: "#F1F0FF" }), (0, import_jsx_runtime.jsx)("path", { d: "M50.6667 37.7405H59.2398C61.8688 37.7405 64 39.8718 64 42.5009V51.0359H55.4271C52.798 51.0359 50.6667 48.9046 50.6667 46.2757V37.7405Z", fill: "#F1F0FF" }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_2593_6077", x1: "37.3336", y1: "13", x2: "37.3336", y2: "51.0358", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#A8ADFF" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.648556", stopColor: "white" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint1_linear_2593_6077", x1: "50.6668", y1: "37.6284", x2: "50.6668", y2: "75.616", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.260784", stopColor: "#B6BAFF" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "#E4E2FF" })] })] })] });
var Safe = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "var(--ck-brand-safe)" }, children: [(0, import_jsx_runtime.jsx)("path", { d: "M68.7186 44H62.6472C60.8339 44 59.3646 45.4686 59.3646 47.281V56.0888C59.3646 57.9012 57.8952 59.3697 56.0819 59.3697H31.9278C30.1145 59.3697 28.6452 60.8383 28.6452 62.6507V68.719C28.6452 70.5314 30.1145 72 31.9278 72H57.48C59.2933 72 60.7417 70.5314 60.7417 68.719V63.8504C60.7417 62.038 62.2111 60.7524 64.0244 60.7524H68.7174C70.5307 60.7524 72 59.2838 72 57.4714V47.2429C72 45.4305 70.5307 44 68.7174 44H68.7186Z", fill: "#121312" }), (0, import_jsx_runtime.jsx)("path", { d: "M28.6406 31.9308C28.6406 30.1162 30.1104 28.6458 31.9243 28.6458H56.0712C57.8851 28.6458 59.3548 27.1754 59.3548 25.3608V19.285C59.3548 17.4704 57.8851 16 56.0712 16H30.5245C28.7107 16 27.2409 17.4704 27.2409 19.285V23.9666C27.2409 25.7813 25.7711 27.2516 23.9572 27.2516H19.2837C17.4698 27.2516 16 28.722 16 30.5366V40.7888C16 42.6034 17.4759 44 19.2898 44H25.3631C27.177 44 28.6468 42.5296 28.6468 40.715L28.6406 31.932V31.9308Z", fill: "#121312" }), (0, import_jsx_runtime.jsx)("path", { d: "M41.1004 37.6774H46.8995C48.7894 37.6774 50.3226 39.2117 50.3226 41.1004V46.8995C50.3226 48.7894 48.7882 50.3225 46.8995 50.3225H41.1004C39.2106 50.3225 37.6774 48.7882 37.6774 46.8995V41.1004C37.6774 39.2105 39.2118 37.6774 41.1004 37.6774V37.6774Z", fill: "#121312" })] });
var Frontier = ({ ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "#CC703C" }, children: (0, import_jsx_runtime.jsx)("path", { d: "M63.6429 20L63.3645 20.7254L62.4521 23.0445L61.8461 24.5395C57.2427 35.7491 53.6629 41.0688 49.8557 41.0688C48.8938 41.0936 47.9371 40.9212 47.0465 40.5625C46.156 40.2038 45.3512 39.6667 44.6834 38.9852L44.1979 38.5518C42.9885 37.4538 42.4799 37.1831 41.3154 37.1832C40.7094 37.1832 39.6238 37.9435 38.2521 39.7303C36.4147 42.2912 34.8522 45.0327 33.59 47.9106L33.4353 48.2482L49.7645 48.2483L47.7312 52.4075H32.4845L32.4843 69.44L28 69.44L28.0001 20L63.6429 20ZM57.2889 24.1518L32.4843 24.1518L32.4843 40.6262C35.4564 35.5545 38.2816 33.0086 41.32 33.0086C42.3421 32.9765 43.3595 33.1534 44.3082 33.5284C45.2569 33.9034 46.1159 34.468 46.8311 35.1865L47.3323 35.6335C48.4611 36.6585 48.8956 36.8941 49.8604 36.8941C50.9211 36.8957 53.7433 32.4855 57.2889 24.1518Z", fill: "white" }) });
var Zerion = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: "linear-gradient(120.22deg, #2962EF 0%, #255CE5 100%)"
}, children: [(0, import_jsx_runtime.jsx)("path", { d: "M19.0864 22C17.5783 22 16.9973 23.8648 18.2628 24.6438L49.9199 43.732C50.709 44.2178 51.7614 44.0258 52.3048 43.2969L66.2236 25.024C67.17 23.7545 66.2138 22 64.5757 22H19.0864Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M68.8425 66C70.3503 66 70.9466 64.1252 69.6814 63.3464L38.015 44.2605C37.2259 43.7748 36.1989 43.991 35.6558 44.7198L21.7099 62.9891C20.7639 64.2582 21.7499 66 23.3877 66H68.8425Z", fill: "white" })] });
var Phantom = ({ background = false, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: background ? { background: "#AB9FF2" } : void 0, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M37.7425 57.0705C34.1942 62.3362 28.2483 69 20.3366 69C16.5965 69 13.0001 67.5093 13 61.0322C12.9997 44.5362 36.2555 19.0003 57.8334 19C70.1084 18.9998 75 27.2474 75 36.6136C75 48.6357 66.9442 62.3824 58.9368 62.3824C56.3955 62.3824 55.1487 61.031 55.1487 58.888C55.1487 58.3288 55.2442 57.7228 55.4365 57.0705C52.7029 61.5902 47.4285 65.7849 42.4896 65.7849C38.8933 65.7849 37.0713 63.5944 37.0713 60.5187C37.0713 59.4003 37.311 58.2357 37.7425 57.0705ZM53.7586 31.6834C51.8054 31.6868 50.4738 33.2938 50.478 35.5864C50.4822 37.879 51.8198 39.5273 53.7729 39.5241C55.6789 39.5208 57.0099 37.8679 57.0058 35.5752C57.0016 33.2827 55.6646 31.6802 53.7586 31.6834ZM64.1193 31.6725C62.1661 31.6759 60.8345 33.2829 60.8387 35.5755C60.8429 37.868 62.1798 39.5164 64.1336 39.5131C66.0396 39.5099 67.3706 37.8569 67.3664 35.5643C67.3622 33.2718 66.0253 31.6693 64.1193 31.6725Z", fill: background ? "#ffffff" : "currentColor" }) });
var PlaceHolder = () => {
  return (0, import_jsx_runtime.jsx)("div", { style: { width: 80, height: 80, background: "#555" } });
};
var Dawn = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88px", height: "88px", viewBox: "0 0 192 192", version: "1.1", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", children: [(0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { x1: "50%", y1: "0%", x2: "50%", y2: "100%", id: "linearGradient-1", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#151515", offset: "0%" }), (0, import_jsx_runtime.jsx)("stop", { stopColor: "#232323", offset: "100%" })] }), (0, import_jsx_runtime.jsx)("rect", { rx: "27%", id: "path-2", x: "0", y: "0", width: "192", height: "192" }), (0, import_jsx_runtime.jsxs)("linearGradient", { x1: "50%", y1: "0%", x2: "50%", y2: "99.7051532%", id: "linearGradient-3", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#F3DC83", offset: "0%" }), (0, import_jsx_runtime.jsx)("stop", { stopColor: "#F9EEC8", offset: "100%" })] })] }), (0, import_jsx_runtime.jsx)("g", { id: "Icons---Pixel-Fitted", stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime.jsxs)("g", { id: "Group", children: [(0, import_jsx_runtime.jsxs)("g", { id: "Rectangle", children: [(0, import_jsx_runtime.jsx)("use", { fill: "#232323", xlinkHref: "#path-2" }), (0, import_jsx_runtime.jsx)("use", { fill: "url(#linearGradient-1)", xlinkHref: "#path-2" })] }), (0, import_jsx_runtime.jsx)("path", { d: "M123.748399,157.001808 C115.293464,160.853955 105.89735,163 96,163 C86.1026503,163 76.7065363,160.853955 68.2516012,157.001808 Z M146.526595,140.002206 C144.677242,142.123986 142.696426,144.128189 140.59684,146.002121 L51.4031598,146.002121 C49.3035743,144.128189 47.3227581,142.123986 45.4734054,140.002206 Z M157.337411,122.999613 C155.955969,126.133404 154.34141,129.141319 152.515704,132.001388 L39.484296,132.001388 C37.6585895,129.141319 36.0440306,126.133404 34.662589,122.999613 Z M96,29 C133.003078,29 163,58.9969218 163,96 C163,103.706309 161.69895,111.108742 159.304524,117.999626 L32.6954763,117.999626 C30.3010496,111.108742 29,103.706309 29,96 C29,58.9969218 58.9969218,29 96,29 Z", id: "Combined-Shape", fill: "url(#linearGradient-3)" })] }) })] });
var InfinityWallet = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, version: "1.1", id: "e551690a-81c0-4880-9b93-334a37ce6796", xmlns: "http://www.w3.org/2000/svg", xmlnsXlink: "http://www.w3.org/1999/xlink", x: "0px", y: "0px", viewBox: "0 0 1025 1025", children: [(0, import_jsx_runtime.jsx)("style", { type: "text/css", children: `
        .infinityWallet-st0{fill:url(#ID_InfinityWallet_1);}
        .infinityWallet-st1{fill:url(#ID_InfinityWallet_2);}
        .infinityWallet-st2{opacity:0.49;fill:url(#ID_InfinityWallet_3);enable-background:new;}
        .infinityWallet-st3{opacity:0.49;fill:url(#ID_InfinityWallet_4);enable-background:new;}
        .infinityWallet-st4{opacity:0.49;fill:url(#ID_InfinityWallet_5);enable-background:new;}
        .infinityWallet-st5{fill:url(#ID_InfinityWallet_6);}
        .infinityWallet-st6{opacity:0.49;fill:url(#ID_InfinityWallet_7);enable-background:new;}
        .infinityWallet-st7{opacity:0.49;fill:url(#ID_InfinityWallet_8);enable-background:new;}
        .infinityWallet-st8{opacity:0.49;fill:url(#ID_InfinityWallet_9);enable-background:new;}
      ` }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_1", gradientUnits: "userSpaceOnUse", x1: "512.5", y1: "1056.1801", x2: "512.5", y2: "317.03", gradientTransform: "matrix(1 0 0 -1 0 1260)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0", style: { stopColor: "#1D2643" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", style: { stopColor: "#12142C" } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st0", d: "M130,0H895c71.8,0,130,58.2,130,130V895c0,71.8-58.2,130-130,130H130C58.2,1025,0,966.8,0,895V130\n    	C0,58.2,58.2,0,130,0z" }), (0, import_jsx_runtime.jsxs)("g", { children: [(0, import_jsx_runtime.jsxs)("g", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_2", gradientUnits: "userSpaceOnUse", x1: "326.0557", y1: "-1280.3162", x2: "326.0557", y2: "-296.3967", gradientTransform: "matrix(1 0 0 1 0 1474)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "1.000000e-02", style: { stopColor: "#00BFE1" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.97", style: { stopColor: "#2738AB" } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st1", d: "M550.9,380.8c-0.7-2-2.4-3.4-4.4-3.9c-2.3-0.6-4.7,0-6.4,1.7l-13.4,13.4l-2.2,2.2L418.3,288.5\n    			c-40.2-40-105.2-40-145.4,0L121.7,439.9c-40,40.5-40,105.6,0,146.1l151.4,150.5c40.2,40,105.1,40,145.3,0l34.4-34.4\n    			c4.5-4.5,9.9-10.7,12.9-18.7c4.7-13.1,2.8-27.7-5.2-39.1c-1.5-2.2-3.2-4.2-5.1-6c-16.9-16.5-43.9-16.3-60.7,0.3l-37.2,37.1\n    			c-2.2,2.3-5,3.8-8.1,4.5c-2.9,0.7-6,0.5-8.8-0.6c-2.9-1-5.5-2.7-7.7-5L182.6,524.2c-2.3-2.3-3.9-5.2-4.6-8.4\n    			c-0.8-4-0.1-8.2,2.1-11.8l0.8-0.9L334,350.3c2.4-2.4,5.4-4,8.7-4.6c1-0.2,2.1-0.3,3.1-0.3c4.4-0.1,8.7,1.7,11.7,5l105.8,105.2\n    			l-5.3,5.3l-10.4,10.6c-1.7,1.7-2.3,4.1-1.7,6.4c0.5,2,2,3.7,3.9,4.4l95.7,11.7c8.2-0.1,14.8-6.7,15-15L550.9,380.8z" }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_3", gradientUnits: "userSpaceOnUse", x1: "137.7126", y1: "-935.1906", x2: "201.098", y2: "-882.1746", gradientTransform: "matrix(1 0 0 1 -0.94 1473.3899)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st2", d: "M181.4,522.9c-4.3-4.9-5.1-13.3-1.3-19c0,0-49.7,54.3-25.8,114.4l31.5,31.3l45.8-76.2L181.4,522.9z" }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_4", gradientUnits: "userSpaceOnUse", x1: "4132.3252", y1: "1674.2513", x2: "4102.1333", y2: "1717.0756", gradientTransform: "matrix(-1 0 0 -1 4515 2382.0898)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st3", d: "M336.4,677.7c56.1,51.6,117.9,22.9,117.9,22.9s8.1-7.5,11.4-17.4c-8.3-4-68.6-47.2-68.6-47.2l-35.6,35.6\n    			C348.6,687.1,336.4,677.7,336.4,677.7z" }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_5", gradientUnits: "userSpaceOnUse", x1: "4217.4238", y1: "2067.1885", x2: "4240.0796", y2: "2011.1337", gradientTransform: "matrix(-1 0 0 -1 4515 2382.0898)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st4", d: "M299.4,385c0,0,35.9-36.2,36-36c0,0,9.6-7.7,19.7-0.7c0,0-59.7-49.2-123.6-18.3l-18.6,18.7L299.4,385z" })] }), (0, import_jsx_runtime.jsxs)("g", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_6", gradientUnits: "userSpaceOnUse", x1: "698.9443", y1: "-1280.3162", x2: "698.9443", y2: "-296.3967", gradientTransform: "matrix(1 0 0 1 0 1474)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "1.000000e-02", style: { stopColor: "#00BFE1" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.97", style: { stopColor: "#2738AB" } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st5", d: "M474.1,644.3c0.7,2,2.4,3.4,4.4,3.9c2.3,0.6,4.7,0,6.4-1.7l13.4-13.4l2.2-2.2l106.2,105.6\n    			c40.2,40,105.2,40,145.4,0l151.2-151.4c40-40.5,40-105.6,0-146.1L751.9,288.5c-40.2-40-105.1-40-145.3,0l-34.4,34.4\n    			c-4.5,4.5-9.9,10.7-12.9,18.7c-4.7,13.1-2.8,27.7,5.2,39.1c1.5,2.2,3.2,4.2,5.1,6c16.9,16.5,43.9,16.3,60.7-0.3l37.2-37.1\n    			c2.2-2.3,5-3.8,8.1-4.5c2.9-0.7,6-0.5,8.8,0.6c2.9,1,5.5,2.7,7.7,5l150.3,150.3c2.3,2.3,3.9,5.2,4.6,8.4c0.8,4,0.1,8.2-2.1,11.8\n    			l-0.8,0.9L691,674.5c-2.4,2.4-5.4,4-8.7,4.6c-1,0.2-2.1,0.3-3.1,0.3c-4.4,0.1-8.7-1.7-11.7-5L561.6,569.7l5.3-5.3l10.4-10.6\n    			c1.7-1.7,2.3-4.1,1.7-6.4c-0.5-2-2-3.7-3.9-4.4l-95.6-11.7c-8.2,0.1-14.8,6.7-15,15L474.1,644.3z" }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_7", gradientUnits: "userSpaceOnUse", x1: "3824.9182", y1: "1469.7789", x2: "3888.3037", y2: "1522.7949", gradientTransform: "matrix(-1 0 0 -1 4713.1299 1956.6599)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st6", d: "M843.6,502.2c4.3,4.9,5.1,13.3,1.3,19c0,0,49.7-54.3,25.8-114.4l-31.5-31.3l-45.8,76.2L843.6,502.2z" }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_8", gradientUnits: "userSpaceOnUse", x1: "445.1279", y1: "-730.6945", x2: "414.9359", y2: "-687.8702", gradientTransform: "matrix(1 0 0 1 197.19 1047.96)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st7", d: "M688.6,347.4c-56.1-51.6-117.9-22.9-117.9-22.9s-8.1,7.5-11.4,17.4c8.3,4,68.6,47.2,68.6,47.2l35.6-35.6\n    			C676.4,338,688.6,347.4,688.6,347.4z" }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "ID_InfinityWallet_9", gradientUnits: "userSpaceOnUse", x1: "530.1512", y1: "-337.7953", x2: "552.8069", y2: "-393.8502", gradientTransform: "matrix(1 0 0 1 197.19 1047.96)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "3.000000e-02", style: { stopColor: "#1B1464" } }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", style: { stopColor: "#1B1464", stopOpacity: 0 } })] }), (0, import_jsx_runtime.jsx)("path", { className: "infinityWallet-st8", d: "M725.5,640.1c0,0-35.9,36.2-36,36c0,0-9.6,7.7-19.7,0.7c0,0,59.7,49.2,123.6,18.3l18.6-18.7L725.5,640.1z" })] })] })] });
var Rabby = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 88 88", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { background: "#8697FF" }, children: [(0, import_jsx_runtime.jsx)("path", { d: "M76.2062 48.0657C78.7621 42.356 66.1267 26.404 54.0555 19.7581C46.4467 14.6095 38.5183 15.3169 36.9125 17.5775C33.3886 22.5385 48.5814 26.7423 58.742 31.6478C56.5579 32.5964 54.4996 34.2987 53.2893 36.4758C49.5013 32.3404 41.1872 28.7791 31.4315 31.6478C24.8574 33.5809 19.3937 38.1382 17.2821 45.0216C16.7689 44.7936 16.2009 44.6669 15.6032 44.6669C13.3176 44.6669 11.4648 46.5197 11.4648 48.8052C11.4648 51.0908 13.3176 52.9435 15.6032 52.9435C16.0268 52.9435 17.3514 52.6594 17.3514 52.6594L38.5183 52.8128C30.0532 66.2418 23.3634 68.2049 23.3634 70.5314C23.3634 72.8579 29.7643 72.2274 32.1678 71.3602C43.6732 67.2088 56.0306 54.2706 58.1511 50.5462C67.056 51.6572 74.5397 51.7886 76.2062 48.0657Z", fill: "url(#paint0_linear_60607_36577)" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M58.65 31.6053C58.682 31.6193 58.7139 31.6332 58.7458 31.6471C59.2168 31.4616 59.1406 30.766 59.0113 30.2198C58.714 28.9643 53.5856 23.9001 48.7696 21.6318C42.1984 18.5367 37.3618 18.7007 36.6582 20.1307C37.9975 22.8695 44.1927 25.441 50.663 28.1266C53.3909 29.2589 56.1676 30.4114 58.65 31.6053Z", fill: "url(#paint1_linear_60607_36577)" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M50.4154 59.2247C49.0895 58.7182 47.592 58.2536 45.8898 57.8319C47.707 54.5801 48.0884 49.7663 46.3721 46.7226C43.9635 42.4512 40.9399 40.1777 33.9139 40.1777C30.0495 40.1777 19.6451 41.4794 19.4603 50.1648C19.441 51.0763 19.4599 51.9118 19.5259 52.68L38.5175 52.8176C35.9568 56.8798 33.5586 59.8928 31.4589 62.1841C33.9831 62.8309 36.0657 63.3738 37.9775 63.8722C39.7885 64.3443 41.4462 64.7764 43.1809 65.2191C45.8007 63.3102 48.2635 61.2288 50.4154 59.2247Z", fill: "url(#paint2_linear_60607_36577)" }), (0, import_jsx_runtime.jsx)("path", { d: "M17.0296 51.7821C17.8058 58.38 21.5555 60.9657 29.2177 61.7309C36.8799 62.4961 41.2751 61.9828 47.1265 62.5151C52.0136 62.9598 56.3772 65.4502 57.996 64.5895C59.4529 63.815 58.6378 61.0167 56.6884 59.2214C54.1614 56.8943 50.6641 55.2763 44.5104 54.7021C45.7368 51.3443 45.3931 46.6362 43.4885 44.0748C40.7345 40.3711 35.6513 38.6967 29.2177 39.4282C22.4962 40.1926 16.0556 43.5018 17.0296 51.7821Z", fill: "url(#paint3_linear_60607_36577)" }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_60607_36577", x1: "30.666", y1: "43.0094", x2: "75.6558", y2: "55.7677", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "white" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "white" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint1_linear_60607_36577", x1: "68.0842", y1: "42.1521", x2: "35.6221", y2: "9.60636", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#7258DC" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "#797DEA", stopOpacity: "0" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint2_linear_60607_36577", x1: "51.3184", y1: "60.3591", x2: "20.1383", y2: "42.4347", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#7461EA" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "#BFC2FF", stopOpacity: "0" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint3_linear_60607_36577", x1: "33.3531", y1: "42.6732", x2: "54.4308", y2: "69.4547", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "white" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.983895", stopColor: "#D5CEFF" })] })] })] });
var TokenPocket = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88px", height: "88px", viewBox: "0 0 88 88", version: "1.1", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsxs)("linearGradient", { x1: "107.511425%", y1: "50.0147427%", x2: "0.0459570557%", y2: "50.0147427%", id: "linearGradient-1", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#FFFFFF", offset: "0%" }), (0, import_jsx_runtime.jsx)("stop", { stopColor: "#FFFFFF", stopOpacity: "0.3233", offset: "96.67%" }), (0, import_jsx_runtime.jsx)("stop", { stopColor: "#FFFFFF", stopOpacity: "0.3", offset: "100%" })] }) }), (0, import_jsx_runtime.jsx)("g", { stroke: "none", strokeWidth: "1", fill: "none", fillRule: "evenodd", children: (0, import_jsx_runtime.jsxs)("g", { id: "tokenpocket", fillRule: "nonzero", children: [(0, import_jsx_runtime.jsx)("polygon", { fill: "#2980FE", points: "87.9604864 0 0 0 0 88 87.9604864 88" }), (0, import_jsx_runtime.jsxs)("g", { transform: "translate(16.052385, 23.804688)", children: [(0, import_jsx_runtime.jsx)("path", { d: "M19.6653508,13.8911953 L19.6784508,13.8911953 C19.6653508,13.8236484 19.6653508,13.7448437 19.6653508,13.6772969 L19.6653508,13.8911953 Z", fill: "#29AEFF" }), (0, import_jsx_runtime.jsx)("path", { d: "M41.1271993,16.0301797 L29.2440711,16.0301797 L29.2440711,38.4205938 C29.2440711,39.4787422 30.0635659,40.3343359 31.0771712,40.3343359 L39.2940168,40.3343359 C40.3077044,40.3343359 41.1271993,39.4787422 41.1271993,38.4205938 L41.1271993,16.0301797 Z", fill: "#FFFFFF" }), (0, import_jsx_runtime.jsx)("path", { d: "M23.5075248,0 L23.1085201,0 L1.83318241,0 C0.819494855,0 0,0.855507812 0,1.91374219 L0,9.68111719 C0,10.7393516 0.819494855,11.5948594 1.83318241,11.5948594 L6.82580355,11.5948594 L8.80996071,11.5948594 L8.80996071,13.8912813 L8.80996071,38.4768828 C8.80996071,39.5351172 9.62945557,40.390625 10.6430608,40.390625 L18.4502002,40.390625 C19.4638054,40.390625 20.2833003,39.5351172 20.2833003,38.4768828 L20.2833003,13.8912813 L20.2833003,13.6774688 L20.2833003,11.5948594 L22.2674574,11.5948594 L23.0761684,11.5948594 L23.4751731,11.5948594 C26.5376389,11.5948594 29.0285575,8.99447656 29.0285575,5.79742969 C29.0609093,2.60038281 26.5699906,0 23.5075248,0 Z", fill: "#FFFFFF" }), (0, import_jsx_runtime.jsx)("path", { d: "M41.1381478,16.0301797 L41.1381478,31.6550781 C41.5479364,31.7563984 41.9684266,31.8352031 42.399783,31.90275 C43.0036819,31.9928125 43.6290664,32.0491016 44.2545332,32.0603594 C44.2868849,32.0603594 44.3192367,32.0603594 44.3623723,32.0603594 L44.3623723,19.6324219 C42.5615416,19.5085859 41.1381478,17.9438359 41.1381478,16.0301797 Z", fill: "url(#linearGradient-1)" }), (0, import_jsx_runtime.jsx)("path", { d: "M44.5993714,0 C36.1237942,0 29.2440711,7.18205469 29.2440711,16.0301797 C29.2440711,23.6400312 34.3229635,30.0115234 41.1379832,31.6550781 L41.1379832,16.0301797 C41.1379832,14.0376328 42.6907839,12.4165937 44.5993714,12.4165937 C46.5080412,12.4165937 48.0608419,14.0376328 48.0608419,16.0301797 C48.0608419,17.7075078 46.9717493,19.1146484 45.483652,19.5198437 C45.2032703,19.5986484 44.9013209,19.6436797 44.5993714,19.6436797 L44.5993714,32.0603594 C44.9013209,32.0603594 45.1924864,32.0491016 45.483652,32.0378438 C53.5495229,31.5537578 59.9547666,24.5743438 59.9547666,16.0301797 C59.9655379,7.18205469 53.0858148,0 44.5993714,0 Z", fill: "#FFFFFF" }), (0, import_jsx_runtime.jsx)("path", { d: "M44.5992891,32.0603594 L44.5992891,19.6436797 C44.5131001,19.6436797 44.4376127,19.6436797 44.3513414,19.6324219 L44.3513414,32.0603594 C44.4376127,32.0603594 44.523884,32.0603594 44.5992891,32.0603594 Z", fill: "#FFFFFF" })] })] }) })] });
var Talisman = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "82", height: "82", viewBox: "0 0 82 82", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("rect", { width: "82", height: "82", rx: "12", fill: "#D5FF5C" }), (0, import_jsx_runtime.jsx)("path", { d: "M35.04 55C35.04 58.2905 37.6887 60.9623 40.9703 60.9996C44.2519 60.9623 46.9006 58.2905 46.9006 55C46.9006 51.7096 44.2519 49.0377 40.9703 49.0004C37.6887 49.0377 35.04 51.7096 35.04 55Z", fill: "#FD4848" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M22.8544 44.6623C22.2462 45.9868 20.4553 46.4546 19.4248 45.4241L17.5356 43.5349C15.583 41.5823 12.4171 41.5823 10.4645 43.5349C8.51184 45.4875 8.51184 48.6534 10.4645 50.606L25.7391 65.8807C29.3942 70.2176 34.8595 72.9788 40.9703 72.9994C47.0811 72.9788 52.5464 70.2176 56.2014 65.8807L71.4761 50.606C73.4287 48.6534 73.4287 45.4875 71.4761 43.5349C69.5234 41.5823 66.3576 41.5823 64.4049 43.5349L62.5158 45.4241C61.4852 46.4546 59.6943 45.9868 59.0861 44.6623C58.9663 44.4013 58.901 44.1213 58.901 43.8341L58.901 20.9995C58.901 18.2381 56.6624 15.9995 53.901 15.9995C51.1396 15.9995 48.901 18.2381 48.901 20.9995L48.901 32.5568C48.901 33.5506 47.8829 34.2252 46.9353 33.9257C46.3356 33.7361 45.9023 33.1901 45.9023 32.5611L45.9023 13.9996C45.9023 11.2608 43.7004 9.03637 40.9703 9C38.2402 9.03637 36.0382 11.2608 36.0382 13.9996L36.0382 32.5611C36.0382 33.1901 35.605 33.7361 35.0052 33.9257C34.0576 34.2252 33.0395 33.5506 33.0395 32.5568L33.0396 20.9995C33.0396 18.2381 30.801 15.9995 28.0395 15.9995C25.2781 15.9995 23.0395 18.2381 23.0395 20.9995L23.0395 43.8341C23.0395 44.1213 22.9743 44.4013 22.8544 44.6623ZM40.9703 44.9999C32.1659 45.0525 25.0403 54.9997 25.0403 54.9997C25.0403 54.9997 32.1659 64.9469 40.9703 64.9995C49.7746 64.9469 56.9002 54.9997 56.9002 54.9997C56.9002 54.9997 49.7746 45.0525 40.9703 44.9999Z", fill: "#FD4848" })] });
var OtherWallets = ({ ...props }) => {
  const column = {
    position: "relative",
    display: "flex",
    flexDirection: "column",
    gap: 3
  };
  const row = {
    position: "relative",
    display: "flex",
    gap: 3
  };
  const cell = {
    width: "50%",
    overflow: "hidden",
    borderRadius: "27.5%"
  };
  return (0, import_jsx_runtime.jsxs)("div", { style: column, ...props, children: [(0, import_jsx_runtime.jsxs)("div", { style: row, children: [(0, import_jsx_runtime.jsx)("div", { style: cell, children: (0, import_jsx_runtime.jsx)(WalletConnect, { background: true }) }), (0, import_jsx_runtime.jsx)("div", { style: cell, children: !isArgent() ? (0, import_jsx_runtime.jsx)(Argent, {}) : (0, import_jsx_runtime.jsx)(Rabby, {}) })] }), (0, import_jsx_runtime.jsxs)("div", { style: row, children: [(0, import_jsx_runtime.jsx)("div", { style: cell, children: !isPhantom() ? (0, import_jsx_runtime.jsx)(Phantom, { background: true }) : (0, import_jsx_runtime.jsx)(ImToken, {}) }), (0, import_jsx_runtime.jsx)("div", { style: cell, children: !isSafe() ? (0, import_jsx_runtime.jsx)(Safe, {}) : (0, import_jsx_runtime.jsx)(Trust, {}) })] })] });
};
var Fordefi = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "88", height: "88", viewBox: "0 0 96 96", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#clip0_14298_75627)", children: [(0, import_jsx_runtime.jsx)("path", { d: "M43.5075 62.5508H6V73.5954C6 79.2046 10.5379 83.7515 16.1357 83.7515H32.9997L43.5075 62.5508Z", fill: "#7994FF" }), (0, import_jsx_runtime.jsx)("path", { d: "M6.00098 39.1016H76.2075L68.0567 55.4841H6.00098V39.1016Z", fill: "#486DFF" }), (0, import_jsx_runtime.jsx)("path", { d: "M30.6398 12H6.09766V32.0282H89.8447V12H65.3025V26.9577H60.2423V12H35.7001V26.9577H30.6398V12Z", fill: "#5CD1FA" })] }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsx)("clipPath", { id: "clip0_14298_75627", children: (0, import_jsx_runtime.jsx)("rect", { width: "84", height: "72", fill: "white", transform: "translate(6 12)" }) }) })] });
var Logos = {
  Mock,
  Injected,
  OtherWallets,
  WalletConnect,
  MetaMask,
  Coinbase,
  Family,
  FamilyAccount,
  Trust,
  Argent,
  ImToken,
  Rainbow,
  Crypto,
  Ledger,
  Brave: Brave$1,
  Steak,
  Unstoppable,
  ONTO,
  Slope,
  Safe,
  Frontier,
  Zerion,
  Phantom,
  PlaceHolder,
  Frame,
  Dawn,
  InfinityWallet,
  Rabby,
  Fordefi,
  TokenPocket,
  Talisman
};
var truncateRegex = /^(0x[a-zA-Z0-9]{4})[a-zA-Z0-9]+([a-zA-Z0-9]{4})$/;
var truncateEthAddress = (address, separator = "") => {
  if (!address)
    return "";
  const match = address.match(truncateRegex);
  if (!match)
    return address;
  return `${match[1]}${separator}${match[2]}`;
};
var truncateENSAddress = (ensName, maxLength) => {
  if (ensName.length > maxLength) {
    return ensName.replace(".eth", "").slice(0, maxLength) + "...";
  } else {
    return ensName;
  }
};
var nFormatter = (num, digits = 2) => {
  if (num < 1e4)
    return num.toFixed(2);
  const lookup = [
    { value: 1, symbol: "" },
    { value: 1e3, symbol: "k" },
    { value: 1e6, symbol: "m" },
    { value: 1e9, symbol: "g" },
    { value: 1e12, symbol: "t" },
    { value: 1e15, symbol: "p" },
    { value: 1e18, symbol: "e" }
  ];
  const rx = /\.0+$|(\.[0-9]*[1-9])0+$/;
  var item = lookup.slice().reverse().find(function(item2) {
    return num >= item2.value;
  });
  return item ? (num / item.value).toFixed(digits).replace(rx, "$1") + item.symbol : "0";
};
var detectBrowser = () => {
  var _a2;
  const browser = detect();
  return (_a2 = browser === null || browser === void 0 ? void 0 : browser.name) !== null && _a2 !== void 0 ? _a2 : "";
};
var detectOS = () => {
  var _a2;
  const browser = detect();
  return (_a2 = browser === null || browser === void 0 ? void 0 : browser.os) !== null && _a2 !== void 0 ? _a2 : "";
};
var isIOS = () => {
  const os2 = detectOS();
  return os2.toLowerCase().includes("ios");
};
var isAndroid = () => {
  const os2 = detectOS();
  return os2.toLowerCase().includes("android");
};
var isMobile = () => {
  return isAndroid() || isIOS();
};
function flattenChildren(children) {
  const childrenArray = import_react70.default.Children.toArray(children);
  return childrenArray.reduce((flatChildren, child) => {
    if (child.type === import_react70.default.Fragment) {
      return flatChildren.concat(flattenChildren(child.props.children));
    }
    flatChildren.push(child);
    return flatChildren;
  }, []);
}
var isWalletConnectConnector = (connectorId) => connectorId === "walletConnect";
var isFamilyAccountsConnector = (connectorId) => connectorId === "familyAccountsProvider";
var isCoinbaseWalletConnector = (connectorId) => connectorId === "coinbaseWalletSDK";
var isSafeConnector = (connectorId) => connectorId === "safe";
var isInjectedConnector = (connectorId) => connectorId === "injected";
var walletConfigs = {
  mock: {
    icon: (0, import_jsx_runtime.jsx)(Logos.Mock, {})
  },
  argent: {
    name: "Argent",
    icon: (0, import_jsx_runtime.jsx)(Logos.Argent, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/argent",
      android: "https://play.google.com/store/apps/details?id=im.argent.contractwalletclient",
      ios: "https://apps.apple.com/app/argent/id1358741926"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://argent.link/app/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  "coinbaseWallet, coinbaseWalletSDK": {
    name: "Coinbase Wallet",
    shortName: "Coinbase",
    icon: (0, import_jsx_runtime.jsx)(Logos.Coinbase, { background: true }),
    iconShape: "squircle",
    downloadUrls: {
      download: "https://connect.family.co/v0/download/coinbasewallet",
      website: "https://www.coinbase.com/wallet/getting-started-extension",
      android: "https://play.google.com/store/apps/details?id=org.toshi",
      ios: "https://apps.apple.com/app/coinbase-wallet-store-crypto/id1278383455",
      chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    getWalletConnectDeeplink: (uri) => {
      return `https://go.cb-w.com/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  "com.coinbase.wallet": {
    name: "Coinbase Wallet",
    shortName: "Coinbase",
    icon: (0, import_jsx_runtime.jsx)(Logos.Coinbase, { background: true }),
    iconShape: "circle",
    downloadUrls: {
      download: "https://connect.family.co/v0/download/coinbasewallet",
      website: "https://www.coinbase.com/wallet/getting-started-extension",
      android: "https://play.google.com/store/apps/details?id=org.toshi",
      ios: "https://apps.apple.com/app/coinbase-wallet-store-crypto/id1278383455",
      chrome: "https://chrome.google.com/webstore/detail/coinbase-wallet-extension/hnfanknocfeofbddgcijnmhnfnkdnaad"
    },
    getWalletConnectDeeplink: (uri) => {
      return `https://go.cb-w.com/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  "com.crypto.wallet": {
    name: "Crypto.com",
    shortName: "Crypto"
  },
  dawn: {
    name: "Dawn Wallet",
    shortName: "Dawn",
    downloadUrls: {
      download: "https://apps.apple.com/us/app/dawn-ethereum-wallet/id1673143782",
      website: "https://www.dawnwallet.xyz/",
      ios: "https://apps.apple.com/us/app/dawn-ethereum-wallet/id1673143782"
    }
  },
  "co.family.wallet": {
    name: "Family",
    shortName: "Family",
    icon: (0, import_jsx_runtime.jsx)(Logos.Family, {}),
    iconShape: "squircle",
    downloadUrls: {
      download: "https://connect.family.co/v0/download/family",
      website: "https://family.co",
      ios: "https://family.co/download"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `familywallet://wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  familyAccountsProvider: {
    name: "Family",
    shortName: "Family",
    icon: (0, import_jsx_runtime.jsx)(Logos.FamilyAccount, {}),
    iconConnector: (0, import_jsx_runtime.jsx)(Logos.FamilyAccount, {}),
    iconShape: "squircle"
  },
  frame: {
    name: "Frame",
    icon: (0, import_jsx_runtime.jsx)(Logos.Frame, {}),
    iconShouldShrink: true,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/frame",
      website: "https://frame.sh",
      chrome: "https://chrome.google.com/webstore/detail/frame-companion/ldcoohedfbjoobcadoglnnmmfbdlmmhf",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/frame-extension",
      brave: "https://chrome.google.com/webstore/detail/frame-companion/ldcoohedfbjoobcadoglnnmmfbdlmmhf"
    },
    getWalletConnectDeeplink: (uri) => uri
  },
  frontier: {
    name: "Frontier Wallet",
    shortName: "Frontier",
    icon: (0, import_jsx_runtime.jsx)(Logos.Frontier, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/frontier",
      ios: "https://apps.apple.com/app/frontier-crypto-defi-wallet/id1482380988",
      android: "https://play.google.com/store/apps/details?id=com.frontierwallet",
      website: "https://frontier.xyz/",
      chrome: "https://chrome.google.com/webstore/detail/frontier-wallet/kppfdiipphfccemcignhifpjkapfbihd"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `frontier://wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  injected: {
    name: "Browser Wallet",
    shortName: "Browser",
    icon: (0, import_jsx_runtime.jsx)(Logos.Injected, {})
  },
  "metaMask, metaMask-io, io.metamask, io.metamask.mobile, metaMaskSDK": {
    name: "MetaMask",
    icon: (0, import_jsx_runtime.jsx)(Logos.MetaMask, {}),
    iconConnector: (0, import_jsx_runtime.jsx)(Logos.MetaMask, {}),
    iconShouldShrink: true,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/metamask",
      website: "https://metamask.io/download/",
      android: "https://play.google.com/store/apps/details?id=io.metamask",
      ios: "https://apps.apple.com/app/metamask/id1438144202",
      chrome: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      firefox: "https://addons.mozilla.org/firefox/addon/ether-metamask/",
      brave: "https://chrome.google.com/webstore/detail/metamask/nkbihfbeogaeaoehlefnkodbefgpgknn",
      edge: "https://microsoftedge.microsoft.com/addons/detail/metamask/ejbalbakoplchlghecdalmeeeajnimhm"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://metamask.app.link/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  "app.phantom": {
    name: "Phantom",
    iconShape: "squircle"
  },
  "me.rainbow": {
    name: "Rainbow Wallet",
    shortName: "Rainbow",
    icon: (0, import_jsx_runtime.jsx)(Logos.Rainbow, {}),
    iconShape: "squircle",
    downloadUrls: {
      download: "https://connect.family.co/v0/download/rainbow",
      website: "https://rainbow.me/?utm_source=connectkit",
      android: "https://play.google.com/store/apps/details?id=me.rainbow&referrer=utm_source%3Dconnectkit&utm_source=connectkit",
      ios: "https://apps.apple.com/app/rainbow-ethereum-wallet/id1457119021?pt=119997837&ct=connectkit&mt=8",
      chrome: "https://rainbow.me/extension?utm_source=connectkit",
      edge: "https://rainbow.me/extension?utm_source=connectkit",
      brave: "https://rainbow.me/extension?utm_source=connectkit"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://rnbwapp.com/wc?uri=${encodeURIComponent(uri)}&connector=connectkit`;
    }
  },
  "io.rabby": {
    name: "Rabby Wallet",
    shortName: "Rabby",
    downloadUrls: {
      website: "https://rabby.io",
      chrome: "https://chrome.google.com/webstore/detail/rabby-wallet/acmacodkjbdgmoleebolmdjonilkdbch"
    }
  },
  safe: {
    name: "Safe",
    icon: (0, import_jsx_runtime.jsx)(Logos.Safe, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/safe",
      website: "https://safe.global/",
      ios: "https://apps.apple.com/app/id1515759131",
      android: "https://play.google.com/store/apps/details?id=io.gnosis.safe"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://gnosis-safe.io/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  "xyz.talisman": {
    name: "Talisman",
    shortName: "Talisman",
    iconShape: "squircle",
    downloadUrls: {
      download: "https://talisman.xyz/download",
      website: "https://talisman.xyz",
      chrome: "https://chrome.google.com/webstore/detail/talisman-polkadot-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/talisman-wallet-extension/"
    }
  },
  "com.trustwallet.app": {
    name: "Trust Wallet",
    shortName: "Trust",
    icon: (0, import_jsx_runtime.jsx)(Logos.Trust, {}),
    iconShouldShrink: true,
    downloadUrls: {
      download: "https://connect.family.co/v0/download/trust",
      android: "https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp",
      ios: "https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409"
    },
    getWalletConnectDeeplink(uri) {
      return isAndroid() ? uri : `https://link.trustwallet.com/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  infinityWallet: {
    name: "Infinity Wallet",
    icon: (0, import_jsx_runtime.jsx)(Logos.InfinityWallet, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/infinityWallet",
      website: "https://infinitywallet.io/download",
      chrome: "https://infinitywallet.io/download",
      firefox: "https://infinitywallet.io/download",
      brave: "https://infinitywallet.io/download",
      edge: "https://infinitywallet.io/download"
    }
  },
  imToken: {
    name: "imToken",
    icon: (0, import_jsx_runtime.jsx)(Logos.ImToken, {}),
    downloadUrls: {
      //website: 'https://support.token.im/hc/en-us/categories/360000925393',
      download: "https://connect.family.co/v0/download/imToken",
      android: "https://play.google.com/store/apps/details?id=im.token.app",
      ios: "https://itunes.apple.com/us/app/imtoken2/id1384798940"
    },
    getWalletConnectDeeplink: (uri) => {
      return `imtokenv2://wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  unstoppable: {
    name: "Unstoppable",
    icon: (0, import_jsx_runtime.jsx)(Logos.Unstoppable, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/unstoppable",
      ios: "https://apps.apple.com/app/bank-bitcoin-wallet/id1447619907",
      android: "https://play.google.com/store/apps/details?id=io.horizontalsystems.bankwallet"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://unstoppable.money/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  onto: {
    name: "ONTO",
    icon: (0, import_jsx_runtime.jsx)(Logos.ONTO, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/onto",
      ios: "https://apps.apple.com/app/onto-an-ontology-dapp/id1436009823",
      android: "https://play.google.com/store/apps/details?id=com.github.ontio.onto",
      website: "https://onto.app/en/download/"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://onto.app/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  steak: {
    name: "Steak",
    icon: (0, import_jsx_runtime.jsx)(Logos.Steak, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/steak",
      android: "https://play.google.com/store/apps/details?id=fi.steakwallet.app",
      ios: "https://apps.apple.com/app/steakwallet/id1569375204",
      website: "https://steakwallet.fi/download"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://links.steakwallet.fi/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  ledger: {
    name: "Ledger Live",
    shortName: "Ledger",
    icon: (0, import_jsx_runtime.jsx)(Logos.Ledger, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/ledger",
      website: "https://www.ledger.com/ledger-live/download#download-device-2",
      android: "https://play.google.com/store/apps/details?id=com.ledger.live",
      ios: "https://apps.apple.com/app/ledger-live-web3-wallet/id1361671700"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `ledgerlive://wc?uri=${encodeURIComponent(uri)}`;
    },
    shouldDeeplinkDesktop: true
  },
  zerion: {
    name: "Zerion",
    icon: (0, import_jsx_runtime.jsx)(Logos.Zerion, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/zerion",
      ios: "https://apps.apple.com/app/apple-store/id1456732565",
      android: "https://play.google.com/store/apps/details?id=io.zerion.android",
      website: "https://zerion.io/"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://app.zerion.io/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  slope: {
    name: "Slope",
    icon: (0, import_jsx_runtime.jsx)(Logos.Slope, {}),
    downloadUrls: {
      download: "https://connect.family.co/v0/download/slope",
      ios: "https://apps.apple.com/app/slope-wallet/id1574624530",
      android: "https://play.google.com/store/apps/details?id=com.wd.wallet",
      chrome: "https://chrome.google.com/webstore/detail/slope-wallet/pocmplpaccanhmnllbbkpgfliimjljgo",
      website: "https://slope.finance/"
    },
    getWalletConnectDeeplink: (uri) => {
      return isAndroid() ? uri : `https://slope.finance/app/wc?uri=${encodeURIComponent(uri)}`;
    }
  },
  tokenPocket: {
    name: "TokenPocket Wallet",
    icon: (0, import_jsx_runtime.jsx)(Logos.TokenPocket, {}),
    downloadUrls: {
      website: "https://www.tokenpocket.pro/en/download/app",
      download: "https://www.tokenpocket.pro/en/download/app",
      android: "https://play.google.com/store/apps/details?id=vip.mytokenpocket",
      ios: "https://apps.apple.com/us/app/tp-global-wallet/id6444625622",
      chrome: "https://chrome.google.com/webstore/detail/tokenpocket/mfgccjchihfkkindfppnaooecgfneiii"
    }
  },
  talisman: {
    name: "Talisman",
    icon: (0, import_jsx_runtime.jsx)(Logos.Talisman, {}),
    downloadUrls: {
      download: "https://talisman.xyz/download",
      website: "https://talisman.xyz",
      chrome: "https://chrome.google.com/webstore/detail/talisman-polkadot-wallet/fijngjgcjhjmmpcmkeiomlglpeiijkld",
      firefox: "https://addons.mozilla.org/en-US/firefox/addon/talisman-wallet-extension/"
    }
  },
  walletConnect: {
    name: "Other Wallets",
    shortName: "Other",
    icon: (0, import_jsx_runtime.jsx)(Logos.WalletConnect, { background: true }),
    iconConnector: (0, import_jsx_runtime.jsx)(Logos.OtherWallets, {}),
    iconShape: "square",
    getWalletConnectDeeplink: (uri) => uri
  }
};
var wallets = Object.keys(walletConfigs).reduce((acc, key) => {
  var _a2, _b, _c2, _d, _e2, _f;
  const config = walletConfigs[key];
  if (!(config === null || config === void 0 ? void 0 : config.getWalletConnectDeeplink))
    return acc;
  const target = key.split(",")[0].trim();
  const flag = (_b = (_a2 = config.name) === null || _a2 === void 0 ? void 0 : _a2.replace("Wallet", "").replace(" ", "")) !== null && _b !== void 0 ? _b : target[0].toUpperCase() + target.slice(1);
  const connector = injected({
    target: {
      id: target,
      name: (_d = (_c2 = config.name) !== null && _c2 !== void 0 ? _c2 : config.shortName) !== null && _d !== void 0 ? _d : key,
      provider: (w2) => {
        var _a3;
        return (_a3 = w2 === null || w2 === void 0 ? void 0 : w2.ethereum) === null || _a3 === void 0 ? void 0 : _a3[`is${flag}`];
      }
    }
  });
  const name = ((_f = (_e2 = config.name) !== null && _e2 !== void 0 ? _e2 : config.shortName) !== null && _f !== void 0 ? _f : key).toLowerCase().replace(/(?:^|\s)\S/g, (a3) => a3.toUpperCase()).replace(/\s/g, "").replace(/(?:^|\s)\S/g, (a3) => a3.toLowerCase());
  acc[name] = connector;
  return acc;
}, {});
var defaultLightTheme = {
  font: {
    family: `-apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, 'Apple Color Emoji', Arial, sans-serif, 'Segoe UI Emoji'`
  },
  text: {
    primary: {
      color: "#373737"
    },
    secondary: {
      color: "#999999",
      hover: {
        color: "#111111"
      }
    },
    error: "#FC6464",
    valid: "#32D74B"
  },
  buttons: {
    primary: {
      borderRadius: 16,
      color: "#000373737000",
      background: "#FFFFFF",
      border: "#F0F0F0",
      hover: {
        color: "#000000",
        border: "#1A88F8"
      }
    },
    secondary: {
      borderRadius: 16,
      background: "#F6F7F9",
      color: "#000000"
    }
  },
  navigation: {
    color: "#999999"
  },
  modal: {
    background: "#ffffff",
    // need to generate an rgba transparent version of this for Safari
    divider: "#f7f6f8"
  },
  tooltips: {
    color: "#999999",
    background: "#ffffff",
    hover: {
      background: "#f6f7f9"
    }
  },
  overlay: {
    background: "rgba(0, 0, 0, 0.06)"
  },
  qrCode: {
    accentColor: "#F7F6F8"
  }
};
var parseTheme = (theme) => {
  return theme;
};
var userPrefersDarkMode = () => {
  if (typeof window === "undefined")
    return false;
  return window.matchMedia && window.matchMedia("(prefers-color-scheme: dark)").matches;
};
userPrefersDarkMode();
var defaultTheme$1 = {
  connectKit: {
    options: {
      iconStyle: "light"
    },
    //theme: parseTheme(defaultLightTheme),
    theme: {
      preferred: "dark",
      light: parseTheme(defaultLightTheme),
      dark: parseTheme(defaultLightTheme)
    }
  }
};
var styled = typeof styled_components_browser_esm_default.div === "function" ? styled_components_browser_esm_default : styled_components_browser_esm_default["default"];
var hexToP3 = (hex3) => {
  const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex3);
  if (result == null)
    return hex3;
  const values = {
    r: parseInt(result[1], 16),
    g: parseInt(result[2], 16),
    b: parseInt(result[3], 16)
  };
  return `color(display-p3 ${values.r / 255} ${values.g / 255} ${values.b / 255})`;
};
var base2 = {
  light: {
    /** Connect Wallet Button */
    "--ck-connectbutton-font-size": "15px",
    "--ck-connectbutton-color": "#373737",
    "--ck-connectbutton-background": "#F6F7F9",
    "--ck-connectbutton-background-secondary": "#FFFFFF",
    "--ck-connectbutton-hover-color": "#373737",
    "--ck-connectbutton-hover-background": "#F0F2F5",
    "--ck-connectbutton-active-color": "#373737",
    "--ck-connectbutton-active-background": "#EAECF1",
    "--ck-connectbutton-balance-color": "#373737",
    "--ck-connectbutton-balance-background": "#fff",
    "--ck-connectbutton-balance-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-background)",
    "--ck-connectbutton-balance-hover-background": "#F6F7F9",
    "--ck-connectbutton-balance-hover-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-hover-background)",
    "--ck-connectbutton-balance-active-background": "#F0F2F5",
    "--ck-connectbutton-balance-active-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-active-background)",
    /** Primary Button */
    "--ck-primary-button-border-radius": "16px",
    "--ck-primary-button-color": "#373737",
    "--ck-primary-button-background": "#F6F7F9",
    //'--ck-primary-button-box-shadow': 'inset 0 0 0 1px #F0F0F0',
    "--ck-primary-button-font-weight": "600",
    "--ck-primary-button-hover-color": "#373737",
    "--ck-primary-button-hover-background": "#F0F2F5",
    //'--ck-primary-button-hover-box-shadow': 'inset 0 0 0 2px var(--ck-focus-color)',
    //'--ck-primary-button-active-background': '#EAECF1',
    /** Secondary Button */
    "--ck-secondary-button-border-radius": "16px",
    "--ck-secondary-button-color": "#373737",
    "--ck-secondary-button-background": "#F6F7F9",
    //'--ck-secondary-button-box-shadow': '',
    //'--ck-secondary-button-font-weight': '',
    /** Tertiary Button */
    "--ck-tertiary-button-background": "#FFFFFF",
    "--ck-secondary-button-hover-background": "#e0e4eb",
    /** Modal */
    "--ck-modal-box-shadow": "0px 2px 4px rgba(0, 0, 0, 0.02)",
    "--ck-overlay-background": "rgba(71, 88, 107, 0.24)",
    "--ck-body-color": "#373737",
    "--ck-body-color-muted": "#999999",
    "--ck-body-color-muted-hover": "#111111",
    "--ck-body-background": "#ffffff",
    "--ck-body-background-transparent": "rgba(255,255,255,0)",
    "--ck-body-background-secondary": "#f6f7f9",
    "--ck-body-background-secondary-hover-background": "#e0e4eb",
    "--ck-body-background-secondary-hover-outline": "#4282FF",
    "--ck-body-background-tertiary": "#F3F4F7",
    "--ck-body-action-color": "#999999",
    "--ck-body-divider": "#f7f6f8",
    "--ck-body-divider-secondary": "rgba(0, 0, 0, 0.06)",
    "--ck-body-color-danger": "#FF4E4E",
    "--ck-body-color-valid": "#32D74B",
    "--ck-siwe-border": "#F0F0F0",
    /** Disclaimer */
    //'--ck-body-disclaimer-background': '#E3D6C9',
    //'--ck-body-disclaimer-box-shadow': 'none',
    "--ck-body-disclaimer-color": "#AAAAAB",
    "--ck-body-disclaimer-link-color": "#838485",
    "--ck-body-disclaimer-link-hover-color": "#000000",
    /** Tooltips */
    "--ck-tooltip-background": "#ffffff",
    "--ck-tooltip-background-secondary": "#ffffff",
    "--ck-tooltip-color": "#999999",
    "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
    /** Network dropdown */
    "--ck-dropdown-button-color": "#999999",
    "--ck-dropdown-button-box-shadow": "0 0 0 1px rgba(0,0,0,0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
    "--ck-dropdown-button-background": "#fff",
    "--ck-dropdown-button-hover-color": "#8B8B8B",
    "--ck-dropdown-button-hover-background": "#F5F7F9",
    /** QR Code */
    "--ck-qr-dot-color": "#000000",
    "--ck-qr-border-color": "#f7f6f8",
    /** Misc. */
    "--ck-focus-color": "#1A88F8",
    "--ck-spinner-color": "var(--ck-focus-color)",
    "--ck-copytoclipboard-stroke": "#CCCCCC"
  },
  dark: {
    "--ck-connectbutton-font-size": "15px",
    "--ck-connectbutton-color": "#ffffff",
    "--ck-connectbutton-background": "#383838",
    "--ck-connectbutton-background-secondary": "#282828",
    "--ck-connectbutton-hover-background": "#404040",
    "--ck-connectbutton-active-background": "#4D4D4D",
    "--ck-connectbutton-balance-color": "#fff",
    "--ck-connectbutton-balance-background": "#282828",
    "--ck-connectbutton-balance-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-background)",
    "--ck-connectbutton-balance-hover-background": "#383838",
    "--ck-connectbutton-balance-hover-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-hover-background)",
    "--ck-connectbutton-balance-active-background": "#404040",
    "--ck-connectbutton-balance-active-box-shadow": "inset 0 0 0 1px var(--ck-connectbutton-active-background)",
    "--ck-primary-button-color": "#ffffff",
    "--ck-primary-button-background": "#383838",
    //'--ck-primary-button-box-shadow': 'inset 0 0 0 1px #3D3D3D',
    "--ck-primary-button-border-radius": "16px",
    "--ck-primary-button-font-weight": "600",
    "--ck-primary-button-hover-background": "#404040",
    //'--ck-primary-button-hover-box-shadow': 'inset 0 0 0 2px rgba(255, 255, 255, 0.4)',
    //'--ck-primary-button-active-background': '#4D4D4D',
    "--ck-primary-button-active-border-radius": "16px",
    "--ck-secondary-button-color": "#ffffff",
    "--ck-secondary-button-background": "#333333",
    "--ck-secondary-button-hover-background": "#4D4D4D",
    /** Tertiary Button */
    "--ck-tertiary-button-background": "#424242",
    "--ck-focus-color": "#1A88F8",
    "--ck-overlay-background": "rgba(0,0,0,0.4)",
    "--ck-body-color": "#ffffff",
    "--ck-body-color-muted": "rgba(255, 255, 255, 0.4)",
    "--ck-body-color-muted-hover": "rgba(255, 255, 255, 0.8)",
    "--ck-body-background": "#2B2B2B",
    "--ck-body-background-transparent": "rgba(0,0,0,0)",
    "--ck-body-background-secondary": "#333333",
    "--ck-body-background-secondary-hover-background": "#4D4D4D",
    "--ck-body-background-secondary-hover-outline": "#ffffff",
    "--ck-body-background-tertiary": "#333333",
    "--ck-body-action-color": "#808080",
    "--ck-body-divider": "#383838",
    "--ck-body-color-danger": "#FF4E4E",
    "--ck-body-disclaimer-color": "#858585",
    "--ck-body-disclaimer-link-color": "#ADADAD",
    "--ck-body-disclaimer-link-hover-color": "#FFFFFF",
    "--ck-modal-box-shadow": "0px 2px 4px rgba(0, 0, 0, 0.02)",
    "--ck-copytoclipboard-stroke": "#555555",
    "--ck-tooltip-background": "#2B2B2B",
    "--ck-tooltip-background-secondary": "#333333",
    "--ck-tooltip-color": "#999999",
    "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
    /** Network dropdown */
    "--ck-dropdown-button-color": "#6C7381",
    "--ck-spinner-color": "var(--ck-focus-color)",
    "--ck-qr-dot-color": "#ffffff",
    "--ck-qr-border-color": "#3d3d3d"
  }
};
var web95 = {
  "--ck-font-family": "Lato",
  "--ck-border-radius": "0px",
  "--ck-connectbutton-color": "#373737",
  "--ck-connectbutton-background": "linear-gradient(180deg, #F0F0EA 0%, #FFFFFF 50%, #F0F0EA 100%) 100% 100% / 200% 200%, #F5F5F1",
  "--ck-connectbutton-box-shadow": " 0 0 0 1px #003C74, 2px 2px 0px rgba(255, 255, 255, 0.75), -2px -2px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-connectbutton-border-radius": "4.5px",
  "--ck-connectbutton-hover-color": "#373737",
  "--ck-connectbutton-hover-background": "linear-gradient(180deg, #F0F0EA 0%, #FFFFFF 50%, #F0F0EA 100%) 100% 0% / 200% 200%, #F5F5F1",
  "--ck-connectbutton-active-background": "linear-gradient(180deg, #F0F0EA 0%, #FFFFFF 50%, #F0F0EA 100%) 100% 100% / 200% 200%, #F5F5F1",
  "--ck-connectbutton-balance-color": "#373737",
  "--ck-connectbutton-balance-background": "#fff",
  "--ck-connectbutton-balance-box-shadow": "0 0 0 1px #E4E7E7",
  "--ck-connectbutton-balance-hover-box-shadow": "0 0 0 1px #d7dbdb",
  "--ck-connectbutton-balance-active-box-shadow": "0 0 0 1px #bbc0c0",
  "--ck-focus-color": "#1A88F8",
  "--ck-overlay-background": "rgba(0, 127,  128, 0.8)",
  "--ck-body-color": "#373737",
  "--ck-body-color-muted": "#808080",
  "--ck-body-color-muted-hover": "#111111",
  "--ck-body-background": "#F0EDE2",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary-hover-background": "#FAFAFA",
  "--ck-body-background-secondary-hover-outline": "#4282FF",
  "--ck-body-action-color": "#373737",
  "--ck-body-color-danger": "#FC6464",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-divider": "#919B9C",
  "--ck-body-divider-box-shadow": "0px 1px 0px #FBFBF8",
  // Primary button
  "--ck-primary-button-background": "linear-gradient(180deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1",
  "--ck-primary-button-box-shadow": "inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-primary-button-border-radius": "6px",
  // Primary button hover
  "--ck-primary-button-hover-box-shadow": "inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 5px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-primary-button-hover-border-radius": "6px",
  // Modal
  "--ck-modal-heading-font-weight": 400,
  "--ck-modal-box-shadow": `
    inset 0px -3px 0px #0F37A9,
    inset -2px 0px 0px #0F37A9,
    inset 0px -4px 0px #0D5DDF,
    inset -4px 0px 0px #0D5DDF,
    inset 2px 0px 0px #0453DD,
    inset 0px 2px 0px #044FD1,
    inset 4px 0px 0px #4283EB,
    inset 0px 4px 0px #4283EB
  `,
  "--ck-modal-h1-font-weight": 400,
  // Secondary button
  "--ck-secondary-button-color": "#373737",
  "--ck-secondary-button-border-radius": "6px",
  "--ck-secondary-button-box-shadow": "inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-secondary-button-background": "linear-gradient(180deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1",
  // Secondary button hover
  "--ck-secondary-button-hover-box-shadow": "inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 4px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-body-background-secondary": "rgba(0, 0, 0, 0.1)",
  "--ck-body-background-tertiary": "linear-gradient(180deg, #FBFBFB 0%, #EFEFEE 100%)",
  "--ck-tertiary-border-radius": "0px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 1px #919B9C, 1px 1px 2px rgba(0, 0, 0, 0.15), inset -2px -2px 0px #FFFFFF",
  "--ck-body-button-text-align": "left",
  "--ck-body-button-box-shadow": "0 2px 4px rgba(0, 0, 0, 0.05 )",
  "--ck-body-disclaimer-background": "linear-gradient(180deg, #FBFBFB 0%, #EFEFEE 100%)",
  "--ck-body-disclaimer-box-shadow": `
    inset 0px -3px 0px #0F37A9,
    inset -2px 0px 0px #0F37A9,
    inset 0px -4px 0px #0D5DDF,
    inset -4px 0px 0px #0D5DDF,
    inset 2px 0px 0px #0453DD,
    inset 4px 0px 0px #4283EB,
    inset 0 1px 0 0 #919B9C`,
  "--ck-body-disclaimer-font-size": "14px",
  "--ck-body-disclaimer-color": "#959594",
  "--ck-body-disclaimer-link-color": "#626262",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-qr-dot-color": "#000000",
  "--ck-qr-border-color": "#919B9C",
  "--ck-qr-border-radius": "0",
  "--ck-qr-background": "#FFFFFF",
  "--ck-copytoclipboard-stroke": "rgba(55, 55, 55, 0.4)",
  "--ck-tooltip-background": "linear-gradient(270deg, #F7F3E6 7.69%, #F5F7DA 100%)",
  "--ck-tooltip-background-secondary": "#f6f7f9",
  "--ck-tooltip-color": "#000000",
  "--ck-tooltip-shadow": " 0 0 0 1.5px #2b2622, 0px 2px 10px rgba(0, 0, 0, 0.08)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 1px #A0A0A0, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset -1px -2px 2px rgba(0, 0, 0, 0.2)",
  "--ck-dropdown-button-background": "linear-gradient(180deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1",
  "--ck-dropdown-button-hover-background": "linear-gradient(0deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1",
  "--ck-dropdown-pending-color": "#ACA899",
  "--ck-dropdown-active-color": "#FFFFFF",
  "--ck-dropdown-active-static-color": "#ACA899",
  "--ck-dropdown-active-background": "#3F69BF",
  "--ck-dropdown-active-border-radius": "0",
  "--ck-dropdown-active-inset": "-12px",
  "--ck-dropdown-color": "#ACA899",
  "--ck-dropdown-background": "#FFFFFF",
  "--ck-dropdown-box-shadow": "inset 0 0 0 1px #ACA899, 2px 2px 7px rgba(0, 0, 0, 0.15)",
  "--ck-dropdown-border-radius": "0",
  "--ck-alert-color": "#ACA899",
  "--ck-alert-background": "linear-gradient(180deg, #FBFBFB 0%, #EFEFEE 100%)",
  "--ck-alert-box-shadow": "inset 0 0 0 1px #919B9C, 1px 1px 2px rgba(0, 0, 0, 0.15), inset -2px -2px 0px #FFFFFF",
  "--ck-alert-border-radius": "0",
  "--ck-recent-badge-border-radius": "32px",
  "--ck-recent-badge-top-offset": "0px",
  /** Graphics options for our themes, not to be exposed to devs */
  "--ck-graphic-primary-color": "#333333",
  "--ck-graphic-primary-background": "#FFFFFF",
  /*
    '--ck-graphic-secondary-color': '#7D7D7D',
    '--ck-graphic-secondary-background':
      'linear-gradient(180deg, #FFFFFF 0%, #F0F0EA 100%), #F5F5F1',
    '--ck-graphic-secondary-box-shadow':
      'inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)',
  
    '--ck-graphic-compass-color': '#7D7D7D',
    */
  "--ck-graphic-compass-background": "#FFFFFF",
  /*
    '--ck-graphic-compass-box-shadow':
      'inset 0 0 0 1px #003C74, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC, inset -1px -2px 2px rgba(0, 0, 0, 0.2)',
  
    '--ck-graphic-globe-background': '#ffffff',
    '--ck-graphic-globe-lines': '#808080',
    '--ck-graphic-globe-box-shadow':
      ' 0 0 0 1px #999A9E, 1px 1px 0px rgba(255, 255, 255, 0.75), -1px -1px 0px rgba(0, 0, 0, 0.05), inset 0px 0px 0px 0px #97B9EC',
      */
  "--ck-siwe-border": "#919B9C"
};
var retro = {
  "--ck-font-family": '"SF Pro Rounded",ui-rounded,"Nunito",-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "8px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-color": "#000000",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "-4px 4px 0px #000000, inset 0 0 0 2px #000000",
  "--ck-connectbutton-border-radius": "8px",
  "--ck-connectbutton-hover-background": "#F3EDE8",
  "--ck-connectbutton-active-box-shadow": "0 0 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-connectbutton-balance-color": "#000000",
  "--ck-connectbutton-balance-background": "#F3EDE8",
  "--ck-connectbutton-balance-box-shadow": "-4px 4px 0px #000000, inset 0 0 0 2px #000000",
  "--ck-connectbutton-balance-hover-background": "#eee5dd",
  "--ck-connectbutton-balance-connectbutton-box-shadow": "-4px 8px 0px -4px #000000, inset 0 0 0 2px #000000",
  "--ck-connectbutton-balance-connectbutton-border-radius": "0px 8px 8px 0",
  "--ck-primary-button-color": "#373737",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-box-shadow": "inset 0 0 0 2px #000000, -4px 4px 0 0 #000000",
  "--ck-primary-button-border-radius": "8px",
  "--ck-primary-button-hover-background": "#F3EDE8",
  "--ck-primary-button-hover-box-shadow": "inset 0 0 0 2px #000000, -0px 0px 0 0 #000000",
  "--ck-secondary-button-border-radius": "8px",
  "--ck-secondary-button-color": "#373737",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-box-shadow": "-4px 4px 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-secondary-button-hover-background": "#F3EDE8",
  "--ck-secondary-button-hover-box-shadow": "0 0 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-focus-color": "#3B99FC",
  "--ck-overlay-background": "rgba(133, 120, 122, 0.8)",
  "--ck-body-color": "#373737",
  "--ck-body-color-muted": "rgba(0, 0, 0, 0.5)",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#EBE1D8",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "rgba(0,0,0,0.1)",
  "--ck-body-background-secondary-hover-background": "#4D4D4D",
  "--ck-body-background-secondary-hover-outline": "#373737",
  "--ck-body-background-tertiary": "#ffffff",
  "--ck-tertiary-border-radius": "8px",
  "--ck-tertiary-box-shadow": "-4px 4px 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-body-action-color": "#373737",
  "--ck-body-divider": "#373737",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-disclaimer-background": "#E3D6C9",
  "--ck-body-disclaimer-box-shadow": "-4px 4px 0 0 #000000, inset 2px 0 0 0 #000000, inset -2px 0 0 0 #000000, inset 0 -2px 0 0 #000000",
  "--ck-body-disclaimer-font-weight": "500",
  "--ck-body-disclaimer-color": "#888079",
  "--ck-body-disclaimer-link-color": "#5B5650",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-modal-box-shadow": "-10px 10px 0px #000000, inset 0 0 0 2px #000000",
  "--ck-copytoclipboard-stroke": "#555555",
  "--ck-tooltip-border-radius": "8px",
  "--ck-tooltip-color": "#373737",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#EBE1D8",
  "--ck-tooltip-shadow": "-6px 6px 0 0 #000000, 0 0 0 2px #000000",
  "--ck-spinner-color": "#1A88F8",
  "--ck-dropdown-button-color": "#000",
  "--ck-dropdown-button-box-shadow": "-2px 2px 0 2px #000000,  0 0 0 2px #000000",
  "--ck-dropdown-button-background": "#ffffff",
  "--ck-dropdown-button-hover-background": "#F3EDE8",
  "--ck-dropdown-button-hover-box-shadow": "-2px 2px 0 0 #000000,  0 0 0 2px #000000",
  "--ck-dropdown-pending-color": "rgba(0, 0, 0, 0.5)",
  "--ck-dropdown-active-color": "#FFFFFF",
  "--ck-dropdown-active-static-color": "rgba(0, 0, 0, 0.5)",
  "--ck-dropdown-active-background": "#3B99FC",
  "--ck-dropdown-active-box-shadow": "inset 0 0 0 2px #000000",
  "--ck-dropdown-active-border-radius": "8px",
  "--ck-dropdown-color": "rgba(0, 0, 0, 0.5)",
  "--ck-dropdown-background": "#FFFFFF",
  "--ck-dropdown-box-shadow": "-4px 4px 0 0 #000000, inset 0 0 0 2px #000000",
  "--ck-dropdown-border-radius": "8px",
  "--ck-alert-color": "rgba(0, 0, 0, 0.5)",
  "--ck-alert-background": " #F5F5F5",
  "--ck-alert-border-radius": "8px",
  "--ck-qr-border-radius": "8px",
  "--ck-qr-dot-color": "#000000",
  "--ck-qr-border-color": "#000000",
  "--ck-qr-background": "#ffffff",
  "--ck-recent-badge-border-radius": "32px",
  "--ck-recent-badge-box-shadow": "inset 0 0 0 2px currentColor",
  /** Graphics options for our themes, not to be exposed to devs */
  "--ck-graphic-primary-color": "#000000",
  "--ck-graphic-primary-background": "#ffffff",
  /*
    '--ck-graphic-secondary-color': '#ffffff',
    '--ck-graphic-secondary-background': '#808080',
    '--ck-graphic-secondary-box-shadow':
      '-4px 4px 0 2px #000000, 0 0 0 2px #000000',
  
    '--ck-graphic-compass-color': '#ffffff',*/
  "--ck-graphic-compass-background": "#FFFFFF",
  /*
    '--ck-graphic-compass-box-shadow':
      '-4px 4px 0 0 #000000, inset 0 0 0 2px #000000',
  
    '--ck-graphic-globe-background': '#ffffff',
    '--ck-graphic-globe-lines': '#808080',
    '--ck-graphic-globe-box-shadow': '6px -6px 0 2px #000000, 0 0 0 2px #000000',
    */
  "--ck-siwe-border": "#8E8985"
};
var soft = {
  "--ck-border-radius": "12px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-border-radius": "12px",
  "--ck-connectbutton-color": "#414451",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 1px #E9EAEC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-hover-background": "#F6F7F9",
  "--ck-connectbutton-hover-box-shadow": "inset 0 0 0 1px #E9EAEC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-balance-color": "#373737",
  "--ck-connectbutton-balance-background": "#F6F7F9",
  "--ck-connectbutton-balance-box-shadow": "none",
  "--ck-connectbutton-balance-hover-background": "#f1f1f3",
  "--ck-primary-button-border-radius": "12px",
  "--ck-primary-button-color": "#414451",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-box-shadow": "0 0 0 1px #E9EAEC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-primary-button-hover-background": "#F6F7F9",
  "--ck-primary-button-hover-box-shadow": "0 0 0 1px #D9DBDD, 0px 0 0 rgba(0, 0, 0, 0.02)",
  "--ck-secondary-button-border-radius": "12px",
  "--ck-secondary-button-color": "#414451",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-box-shadow": "0 0 0 1px #E9EAEC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-secondary-button-hover-background": "#F6F7F9",
  "--ck-secondary-button-hover-box-shadow": "0 0 0 1px #D9DBDD, 0px 0 0 rgba(0, 0, 0, 0.02)",
  "--ck-focus-color": "#1A88F8",
  "--ck-modal-box-shadow": `0px 3px 16px rgba(0, 0, 0, 0.08)`,
  "--ck-body-color": "#414451",
  "--ck-body-color-muted": "#9196A1",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#ffffff",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "#f6f7f9",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-secondary-hover-outline": "#4282FF",
  "--ck-body-background-tertiary": "#F6F8FA",
  "--ck-tertiary-border-radius": "13px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.04)",
  "--ck-body-action-color": "#999999",
  "--ck-body-divider": "#f7f6f8",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#F9FAFA",
  "--ck-body-disclaimer-color": "#AFB1B6",
  "--ck-body-disclaimer-link-color": "#787B84",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-copytoclipboard-stroke": "#CCCCCC",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#ffffff",
  "--ck-tooltip-color": "#999999",
  "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 1px rgba(0, 0, 0, 0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-dropdown-button-background": "#fff",
  "--ck-dropdown-button-hover-color": "#8B8B8B",
  "--ck-dropdown-button-hover-background": "#E7E7E7",
  "--ck-dropdown-color": "rgba(55, 55, 55, 0.4)",
  "--ck-dropdown-box-shadow": "0px 2px 15px rgba(0, 0, 0, 0.15)",
  "--ck-alert-color": "#9196A1",
  "--ck-alert-background": "#F6F8FA",
  "--ck-alert-box-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.04)",
  "--ck-alert-border-radius": "8px",
  "--ck-qr-border-radius": "12px",
  "--ck-qr-dot-color": "#2E3138",
  "--ck-qr-border-color": "#E9EAEC",
  "--ck-siwe-border": "#EAEBED"
};
var midnight = {
  "--ck-font-family": '"Inter",-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "10px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-border-radius": "8px",
  "--ck-connectbutton-color": "#ffffff",
  "--ck-connectbutton-background": "#313235",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.05)",
  "--ck-connectbutton-hover-background": "#414144",
  "--ck-connectbutton-active-background": "#4C4D4F",
  "--ck-connectbutton-balance-color": "#ffffff",
  "--ck-connectbutton-balance-background": "#1F2023",
  "--ck-connectbutton-balance-box-shadow": "inset 0 0 0 1px #313235",
  "--ck-connectbutton-balance-hover-background": "#313235",
  "--ck-connectbutton-balance-active-background": "#414144",
  "--ck-primary-button-border-radius": "8px",
  "--ck-primary-button-color": "#ffffff",
  "--ck-primary-button-background": "rgba(255, 255, 255, 0.08)",
  "--ck-primary-button-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.05)",
  "--ck-primary-button-hover-background": "rgba(255, 255, 255, 0.2)",
  "--ck-secondary-button-border-radius": "8px",
  "--ck-secondary-button-color": "#ffffff",
  "--ck-secondary-button-background": "#363638",
  "--ck-secondary-button-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.05)",
  "--ck-secondary-button-hover-background": "#3c3c3e",
  "--ck-overlay-background": "rgba(0,0,0,0.4)",
  "--ck-modal-box-shadow": `inset 0 0 0 1px #38393C, 0px 2px 4px rgba(0, 0, 0, 0.02)`,
  "--ck-focus-color": "#1A88F8",
  "--ck-body-color": "#ffffff",
  "--ck-body-color-muted": "#8B8F97",
  "--ck-body-color-muted-hover": "#ffffff",
  "--ck-body-background": "#1F2023",
  "--ck-body-background-transparent": "rgba(31, 32, 35, 0)",
  "--ck-body-background-secondary": "#313235",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-secondary-hover-outline": "rgba(255, 255, 255, 0.02)",
  "--ck-body-background-tertiary": "#313235",
  "--ck-tertiary-border-radius": "12px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.02)",
  "--ck-body-action-color": "#8B8F97",
  "--ck-body-divider": "rgba(255,255,255,0.1)",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#2B2D31",
  "--ck-body-disclaimer-box-shadow": "none",
  "--ck-body-disclaimer-color": "#808183",
  "--ck-body-disclaimer-link-color": "#AAABAD",
  "--ck-body-disclaimer-link-hover-color": "#ffffff",
  "--ck-copytoclipboard-stroke": "#CCCCCC",
  "--ck-tooltip-background": "#1F2023",
  "--ck-tooltip-background-secondary": "#1F2023",
  "--ck-tooltip-color": "#ffffff",
  "--ck-tooltip-shadow": " 0 0 0 1px rgba(255, 255, 255, 0.1), 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#6C7381",
  "--ck-dropdown-button-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.05)",
  "--ck-dropdown-button-background": "#313235",
  "--ck-dropdown-pending-color": "#8B8F97",
  "--ck-dropdown-active-color": "#FFF",
  "--ck-dropdown-active-static-color": "#FFF",
  "--ck-dropdown-active-background": "rgba(255, 255, 255, 0.07)",
  "--ck-dropdown-color": "#8B8F97",
  "--ck-dropdown-background": "#313235",
  "--ck-dropdown-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.03)",
  "--ck-dropdown-border-radius": "8px",
  "--ck-alert-color": "#8B8F97",
  "--ck-alert-background": "#404145",
  "--ck-alert-box-shadow": "inset 0 0 0 1px rgba(255, 255, 255, 0.02)",
  "--ck-qr-border-radius": "12px",
  "--ck-qr-dot-color": "#ffffff",
  "--ck-qr-border-color": "rgba(255,255,255,0.1)",
  "--ck-recent-badge-border-radius": "32px"
};
var minimal = {
  "--ck-font-family": '"Inter",-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "0px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-border-radius": "0px",
  "--ck-connectbutton-color": "#414451",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 1px #EBEBEB",
  "--ck-connectbutton-hover-color": "#111",
  "--ck-connectbutton-hover-box-shadow": "inset 0 0 0 1px #111",
  "--ck-connectbutton-balance-color": "#111111",
  "--ck-connectbutton-balance-background": "#F7F7F7",
  "--ck-connectbutton-balance-box-shadow": "inset 0 0 0 1px #F7F7F7",
  "--ck-connectbutton-balance-hover-background": "#f1f1f3",
  "--ck-connectbutton-balance-hover-box-shadow": "inset 0 0 0 1px #111",
  "--ck-primary-button-border-radius": "0px",
  "--ck-primary-button-color": "#111111",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-box-shadow": "inset 0 0 0 1px #EBEBEB",
  "--ck-primary-button-hover-box-shadow": "inset 0 0 0 1px #111111",
  "--ck-secondary-button-border-radius": "0px",
  "--ck-secondary-button-color": "#111111",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-box-shadow": "inset 0 0 0 1px #EBEBEB",
  "--ck-secondary-button-hover-box-shadow": "inset 0 0 0 1px #111111",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 1px rgba(0, 0, 0, 0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-dropdown-button-background": "#fff",
  "--ck-dropdown-button-hover-color": "#8B8B8B",
  "--ck-dropdown-button-hover-background": "#E7E7E7",
  "--ck-focus-color": "#1A88F8",
  "--ck-modal-box-shadow": `0px 3px 16px rgba(0, 0, 0, 0.08)`,
  "--ck-body-color": "#111111",
  "--ck-body-color-muted": "#A0A0A0",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#ffffff",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "#f6f7f9",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-secondary-hover-outline": "#4282FF",
  "--ck-body-background-tertiary": "#ffffff",
  "--ck-tertiary-border-radius": "0px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.04)",
  "--ck-body-action-color": "#A0A0A0",
  "--ck-body-divider": "#EBEBEB",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#FAFAFA",
  "--ck-body-disclaimer-box-shadow": "inset 0 1px 0 0 #ECECEC",
  "--ck-body-disclaimer-color": "#9D9D9D",
  "--ck-body-disclaimer-link-color": "#6E6E6E",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-copytoclipboard-stroke": "#CCCCCC",
  "--ck-tooltip-border-radius": "0px",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#ffffff",
  "--ck-tooltip-color": "#999999",
  "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-active-border-radius": "0",
  "--ck-dropdown-box-shadow": "0px 2px 15px rgba(0, 0, 0, 0.15)",
  "--ck-dropdown-border-radius": "0",
  "--ck-alert-color": "rgba(17, 17, 17, 0.4)",
  "--ck-alert-background": "#fff",
  "--ck-alert-box-shadow": "inset 0 0 0 1px #EBEBEB",
  "--ck-alert-border-radius": "0",
  "--ck-qr-border-radius": "0px",
  "--ck-qr-dot-color": "#111111",
  "--ck-qr-border-color": "#EBEBEB",
  "--ck-modal-h1-font-weight": "400",
  "--ck-modal-heading-font-weight": "400",
  "--ck-primary-button-font-weight": "400",
  "--ck-recent-badge-top-offset": "0px",
  /** Graphics options for our themes, not to be exposed to devs */
  /**
    '--ck-graphic-primary-color': '#111111',
    '--ck-graphic-primary-background': '#ffffff',
    '--ck-graphic-primary-box-shadow': 'inset 0 0 0 1px #EBEBEB',
  
    '--ck-graphic-secondary-color': '#DCDDDE',
    '--ck-graphic-secondary-background': '#ffffff',
    '--ck-graphic-secondary-box-shadow': 'inset 0 0 0 1px #EBEBEB',
  
    '--ck-graphic-compass-color': '#111111',
    '--ck-graphic-compass-background': '#ffffff',
    '--ck-graphic-compass-box-shadow': 'inset 0 0 0 1px #EBEBEB',
  
    '--ck-graphic-globe-background': '#D9D9D9',
    '--ck-graphic-globe-lines': '#ffffff',
    '--ck-graphic-globe-box-shadow': 'inset 0 0 0 1px #EBEBEB',
    */
  "--ck-siwe-border": "#EBEBEB"
};
var rounded = {
  "--ck-font-family": '"Nunito",ui-rounded,-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "24px",
  "--ck-connectbutton-font-size": "17px",
  "--ck-connectbutton-font-weight": "700",
  "--ck-connectbutton-border-radius": "14px",
  "--ck-connectbutton-color": "#000000",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 2px #DFE4EC, 0 2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-hover-background": "#F9FAFB",
  "--ck-connectbutton-balance-color": "#414451",
  "--ck-connectbutton-balance-background": "#F9FAFB",
  "--ck-connectbutton-balance-box-shadow": "0 2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-balance-hover-background": "#F5F7F9",
  "--ck-connectbutton-balance-hover-box-shadow": "0 2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-balance-active-box-shadow": "0 0 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-connectbutton-active-background": "#F5F7F9",
  "--ck-connectbutton-active-box-shadow": "inset 0 0 0 2px #CFD7E2, 0 0px 0 0 #CFD7E2, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-primary-button-border-radius": "18px",
  "--ck-primary-button-color": "#000000",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-box-shadow": "inset 0 0 0 2px #DFE4EC, inset  0 -4px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-primary-button-hover-background": "#F5F7F9",
  "--ck-primary-button-hover-box-shadow": "inset 0 0 0 2px #DFE4EC, inset  0 -2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-secondary-button-border-radius": "16px",
  "--ck-secondary-button-color": "#000000",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-box-shadow": "inset 0 0 0 2px #DFE4EC, inset  0 -4px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-secondary-button-hover-background": "#F5F7F9",
  "--ck-secondary-button-hover-box-shadow": "inset 0 0 0 2px #DFE4EC, inset  0 -2px 0 0 #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-focus-color": "#1A88F8",
  "--ck-modal-box-shadow": `0px 3px 16px rgba(0, 0, 0, 0.08)`,
  "--ck-body-color": "#000000",
  "--ck-body-color-muted": "#93989F",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#ffffff",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "#f6f7f9",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-secondary-hover-outline": "#4282FF",
  "--ck-body-background-tertiary": "#ffffff",
  "--ck-tertiary-border-radius": "22px",
  "--ck-tertiary-box-shadow": "inset 0 0 0 2px #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-body-action-color": "#93989F",
  "--ck-body-divider": "#DFE4EC",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#F9FAFB",
  "--ck-body-disclaimer-font-size": "14px",
  "--ck-body-disclaimer-font-weight": "700",
  "--ck-body-disclaimer-color": "#959697",
  "--ck-body-disclaimer-link-color": "#646464",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-copytoclipboard-stroke": "#CCCCCC",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#ffffff",
  "--ck-tooltip-color": "#999999",
  "--ck-tooltip-shadow": " 0 0 0 2px #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 2px #DFE4EC,  0 2px 0 2px #DFE4EC, 0px 2px 4px rgba(0, 0, 0, 0.02)",
  "--ck-dropdown-button-background": "#fff",
  "--ck-dropdown-button-hover-color": "#8B8B8B",
  "--ck-dropdown-button-hover-background": "#F5F7F9",
  "--ck-dropdown-pending-color": "#848D9A",
  "--ck-dropdown-active-color": "#000000",
  "--ck-dropdown-active-static-color": "#848D9A",
  "--ck-dropdown-active-background": "#F5F7F9",
  "--ck-dropdown-color": "#848D9A",
  "--ck-dropdown-background": "#FFFFFF",
  "--ck-dropdown-box-shadow": "0px 2px 15px rgba(0, 0, 0, 0.15)",
  "--ck-dropdown-border-radius": "16px",
  "--ck-alert-color": "#848D9A",
  "--ck-alert-background": "#F5F7F9",
  "--ck-qr-border-radius": "24px",
  "--ck-qr-dot-color": "#111111",
  "--ck-qr-border-color": "#DFE4EC",
  "--ck-modal-h1-font-weight": "700",
  "--ck-modal-heading-font-weight": "700",
  "--ck-primary-button-font-weight": "700",
  "--ck-recent-badge-box-shadow": "inset 0 0 0 2px currentColor",
  "--ck-recent-badge-top-offset": "0px",
  /** Graphics options for our themes, not to be exposed to devs */
  /*
    '--ck-graphic-primary-color': '#6C7381',
    '--ck-graphic-primary-background': '#ffffff',
    '--ck-graphic-primary-box-shadow': 'inset 0 0 0 2px #DFE4EC',
  
    '--ck-graphic-secondary-color': '#DFE4EC',
    '--ck-graphic-secondary-background': '#ffffff',
    '--ck-graphic-secondary-box-shadow': 'inset 0 0 0 2px #DFE4EC',
  
    '--ck-graphic-compass-color': '#ffffff',
    '--ck-graphic-compass-background': '#6C7381',
    '--ck-graphic-compass-box-shadow': 'inset 0 0 0 2px rgba(0,0,0,0.1)',
  
    '--ck-graphic-globe-background':
      'radial-gradient(84.37% 84.37% at 50% 15.63%, rgba(255, 255, 255, 0.2) 0%, rgba(0, 0, 0, 0) 100%), linear-gradient(180deg, #DFE4EC 0%, #DFE4EC 114.06%), #DFE4EC',
    '--ck-graphic-globe-lines': '#ffffff',
    '--ck-graphic-globe-box-shadow': 'inset 0 0 0 2px #DFE4EC',
    */
  "--ck-siwe-border": "#DFE4EC"
};
var nouns = {
  "--ck-font-family": '"PT Root UI",ui-rounded,"Nunito",-apple-system,BlinkMacSystemFont,"Segoe UI",Helvetica,"Apple Color Emoji",Arial,sans-serif,"Segoe UI Emoji","Segoe UI Symbol"',
  "--ck-border-radius": "24px",
  "--ck-connectbutton-font-size": "16px",
  "--ck-connectbutton-font-weight": "700",
  "--ck-connectbutton-border-radius": "10px",
  "--ck-connectbutton-color": "#151C3B",
  "--ck-connectbutton-background": "#ffffff",
  "--ck-connectbutton-box-shadow": "inset 0 0 0 1px #D6D8E1",
  "--ck-connectbutton-hover-background": "#E9EBF3",
  "--ck-connectbutton-hover-box-shadow": "inset 0 0 0 1px #D4D8E8",
  "--ck-connectbutton-active-background": "#D4D8E8",
  "--ck-connectbutton-active-box-shadow": "inset 0 0 0 1px #D4D8E8",
  "--ck-connectbutton-balance-color": "#373737",
  "--ck-connectbutton-balance-background": "#F6F7F9",
  "--ck-connectbutton-balance-box-shadow": "none",
  "--ck-connectbutton-balance-hover-background": "#f1f1f3",
  "--ck-primary-button-border-radius": "16px",
  "--ck-primary-button-color": "#151C3B",
  "--ck-primary-button-background": "#ffffff",
  "--ck-primary-button-font-weight": "700",
  "--ck-primary-button-hover-background": "#DEE1ED",
  "--ck-secondary-button-border-radius": "16px",
  "--ck-secondary-button-color": "#151C3B",
  "--ck-secondary-button-background": "#ffffff",
  "--ck-secondary-button-font-weight": "700",
  "--ck-secondary-button-hover-background": "#DEE1ED",
  "--ck-focus-color": "#1A88F8",
  "--ck-modal-box-shadow": `0px 2px 4px rgba(0, 0, 0, 0.02)`,
  "--ck-overlay-background": "rgba(213, 215, 225, 0.8)",
  "--ck-overlay-backdrop-filter": "blur(6px)",
  "--ck-body-color": "#151C3B",
  "--ck-body-color-muted": "#757A8E",
  "--ck-body-color-muted-hover": "#000000",
  "--ck-body-background": "#F4F4F8",
  "--ck-body-background-transparent": "rgba(255,255,255,0)",
  "--ck-body-background-secondary": "#E9E9F1",
  "--ck-body-background-secondary-hover-background": "#e0e4eb",
  "--ck-body-background-tertiary": "#E9E9F1",
  "--ck-tertiary-border-radius": "24px",
  "--ck-body-action-color": "#79809C",
  "--ck-body-divider": "#D9DBE3",
  "--ck-body-color-danger": "#FF4E4E",
  "--ck-body-color-valid": "#32D74B",
  "--ck-body-disclaimer-background": "#F9FAFA",
  "--ck-body-disclaimer-color": "#AFB1B6",
  "--ck-body-disclaimer-link-color": "#787B84",
  "--ck-body-disclaimer-link-hover-color": "#000000",
  "--ck-copytoclipboard-stroke": "#79809C",
  "--ck-tooltip-background": "#ffffff",
  "--ck-tooltip-background-secondary": "#ffffff",
  "--ck-tooltip-color": "#999999",
  "--ck-tooltip-shadow": "0px 2px 10px rgba(0, 0, 0, 0.08)",
  "--ck-spinner-color": "var(--ck-focus-color)",
  "--ck-dropdown-button-color": "#999999",
  "--ck-dropdown-button-box-shadow": "0 0 0 1px rgba(0, 0, 0, 0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-dropdown-button-background": "#fff",
  "--ck-dropdown-button-hover-color": "#8B8B8B",
  "--ck-dropdown-button-hover-background": "#DEE1ED",
  "--ck-dropdown-button-hover-box-shadow": "0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-dropdown-color": "#757A8E",
  "--ck-dropdown-box-shadow": "0 0 0 1px rgba(0, 0, 0, 0.01), 0px 0px 7px rgba(0, 0, 0, 0.05)",
  "--ck-alert-color": "#9196A1",
  "--ck-alert-background": "#F6F8FA",
  "--ck-alert-box-shadow": "inset 0 0 0 1px rgba(0, 0, 0, 0.04)",
  "--ck-alert-border-radius": "8px",
  "--ck-qr-border-radius": "24px",
  "--ck-qr-dot-color": "#000000",
  "--ck-qr-background": "#ffffff",
  "--ck-recent-badge-color": "#79809C",
  "--ck-recent-badge-background": "#F4F4F8",
  "--ck-recent-badge-box-shadow": "none",
  "--ck-siwe-border": "#DFE4EC",
  "--ck-graphic-primary-background": "#fff",
  "--ck-graphic-compass-background": "#fff",
  "--ck-graphic-primary-box-shadow": "0px 2.94737px 14.7368px rgba(0, 0, 0, 0.1)",
  "--ck-graphic-compass-box-shadow": "0px 2px 9px rgba(0, 0, 0, 0.15)"
};
var predefinedThemes = { base: base2, web95, retro, soft, midnight, minimal, rounded, nouns };
var themeGlobals = {
  default: {
    "--ck-font-family": `-apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica,
    'Apple Color Emoji', Arial, sans-serif, 'Segoe UI Emoji',
    'Segoe UI Symbol'`,
    "--ck-border-radius": "20px",
    "--ck-secondary-button-border-radius": "16px"
  },
  graphics: {
    light: {
      "--ck-graphic-wave-stop-01": "#E8F17D",
      "--ck-graphic-wave-stop-02": "#A8ECDE",
      "--ck-graphic-wave-stop-03": "#7AA1F2",
      "--ck-graphic-wave-stop-04": "#DEA1E8",
      "--ck-graphic-wave-stop-05": "#F46D98",
      "--ck-graphic-scaniconwithlogos-01": "#4E4E4E",
      "--ck-graphic-scaniconwithlogos-02": "#272727",
      "--ck-graphic-scaniconwithlogos-03": "#F8D74A",
      "--ck-graphic-scaniconwithlogos-04": "#F6F7F9",
      "--ck-chain-ethereum-01": "#25292E",
      "--ck-chain-ethereum-02": "#ffffff",
      "--ck-chain-ethereum-03": "#DFE0E0"
    },
    dark: {
      "--ck-graphic-wave-stop-01": "#E8F17D",
      "--ck-graphic-wave-stop-02": "#A8ECDE",
      "--ck-graphic-wave-stop-03": "#7AA1F2",
      "--ck-graphic-wave-stop-04": "#DEA1E8",
      "--ck-graphic-wave-stop-05": "#F46D98",
      "--ck-graphic-scaniconwithlogos-01": "#AFAFAF",
      "--ck-graphic-scaniconwithlogos-02": "#696969",
      "--ck-graphic-scaniconwithlogos-03": "#F8D74A",
      "--ck-graphic-scaniconwithlogos-04": "#3D3D3D"
      //'--ck-chain-ethereum-01': '#fff',
      //'--ck-chain-ethereum-02': '#000',
      //'--ck-chain-ethereum-03': '#000',
    }
  },
  ens: {
    light: {
      "--ck-ens-01-start": "#FF3B30",
      "--ck-ens-01-stop": "#FF9500",
      "--ck-ens-02-start": "#FF9500",
      "--ck-ens-02-stop": "#FFCC00",
      "--ck-ens-03-start": "#FFCC00",
      "--ck-ens-03-stop": "#34C759",
      "--ck-ens-04-start": "#5856D6",
      "--ck-ens-04-stop": "#AF52DE",
      "--ck-ens-05-start": "#5AC8FA",
      "--ck-ens-05-stop": "#007AFF",
      "--ck-ens-06-start": "#007AFF",
      "--ck-ens-06-stop": "#5856D6",
      "--ck-ens-07-start": "#5856D6",
      "--ck-ens-07-stop": "#AF52DE",
      "--ck-ens-08-start": "#AF52DE",
      "--ck-ens-08-stop": "#FF2D55"
    },
    dark: {
      "--ck-ens-01-start": "#FF453A",
      "--ck-ens-01-stop": "#FF9F0A",
      "--ck-ens-02-start": "#FF9F0A",
      "--ck-ens-02-stop": "#FFD60A",
      "--ck-ens-03-start": "#FFD60A",
      "--ck-ens-03-stop": "#32D74B",
      "--ck-ens-04-start": "#32D74B",
      "--ck-ens-04-stop": "#64D2FF",
      "--ck-ens-05-start": "#64D2FF",
      "--ck-ens-05-stop": "#0A84FF",
      "--ck-ens-06-start": "#0A84FF",
      "--ck-ens-06-stop": "#5E5CE6",
      "--ck-ens-07-start": "#5E5CE6",
      "--ck-ens-07-stop": "#BF5AF2",
      "--ck-ens-08-start": "#BF5AF2",
      "--ck-ens-08-stop": "#FF2D55"
    }
  },
  brand: {
    "--ck-family-accounts-brand": "#0FCCCC",
    "--ck-family-brand": "#1A88F8",
    "--ck-brand-walletConnect": "#3B99FC",
    "--ck-brand-coinbaseWallet": "#0052FF",
    "--ck-brand-metamask": "#f6851b",
    "--ck-brand-metamask-01": "#F6851B",
    "--ck-brand-metamask-02": "#E2761B",
    "--ck-brand-metamask-03": "#CD6116",
    "--ck-brand-metamask-04": "#161616",
    "--ck-brand-metamask-05": "#763D16",
    "--ck-brand-metamask-06": "#D7C1B3",
    "--ck-brand-metamask-07": "#C0AD9E",
    "--ck-brand-metamask-08": "#E4761B",
    "--ck-brand-metamask-09": "#233447",
    "--ck-brand-metamask-10": "#E4751F",
    "--ck-brand-metamask-11": "#FEF5E7",
    "--ck-brand-metamask-12": "#E3C8AB",
    "--ck-brand-trust-01": "#3375BB",
    "--ck-brand-trust-02": "#ffffff",
    "--ck-brand-trust-01b": "#ffffff",
    // dark Theme
    "--ck-brand-trust-02b": "#3375BB",
    // dark Theme
    "--ck-brand-argent": "#f36a3d",
    "--ck-brand-imtoken-01": "#11C4D1",
    "--ck-brand-imtoken-02": "#0062AD",
    "--ck-brand-safe": "#12FF80",
    "--ck-brand-dawn": "#000000"
  }
};
var themeColors = {
  light: predefinedThemes.base.light,
  dark: predefinedThemes.base.dark,
  web95: predefinedThemes.web95,
  retro: predefinedThemes.retro,
  soft: predefinedThemes.soft,
  midnight: predefinedThemes.midnight,
  minimal: predefinedThemes.minimal,
  rounded: predefinedThemes.rounded,
  nouns: predefinedThemes.nouns
};
var createCssVars = (scheme, important) => {
  return Ae`
    ${Object.keys(scheme).map((key) => {
    const value = scheme[key];
    return value && `${key}:${value};`;
  })}
  `;
};
var createCssColors = (scheme, override) => {
  const important = override ? " !important" : "";
  return Ae`
    ${Object.keys(scheme).map((key) => {
    const value = scheme[key];
    return value && `${key}:${value}${important};`;
  })}
    @supports (color: color(display-p3 1 1 1)) {
      ${Object.keys(scheme).map((key) => {
    const value = scheme[key];
    return `${key}:${hexToP3(value)}${important};`;
  })}
    }
  `;
};
var themes = {
  default: createCssVars(themeGlobals.default),
  light: createCssColors(themeColors.light),
  dark: createCssColors(themeColors.dark),
  web95: createCssColors(themeColors.web95),
  retro: createCssColors(themeColors.retro),
  soft: createCssColors(themeColors.soft),
  midnight: createCssColors(themeColors.midnight),
  minimal: createCssColors(themeColors.minimal),
  rounded: createCssColors(themeColors.rounded),
  nouns: createCssColors(themeColors.nouns)
};
var globals = {
  brand: createCssColors(themeGlobals.brand),
  ensLight: createCssColors(themeGlobals.ens.light),
  ensDark: createCssColors(themeGlobals.ens.dark),
  graphicsLight: createCssColors(themeGlobals.graphics.light),
  graphicsDark: createCssColors(themeGlobals.graphics.dark)
};
var globalsLight = Ae`
  ${globals.brand}
  ${globals.ensLight}
  ${globals.graphicsLight}
`;
var globalsDark = Ae`
  ${globals.brand}
  ${globals.ensDark}
  ${globals.graphicsDark}
`;
var mode2 = "auto";
var ResetContainer = styled(motion.div)`
  ${themes.default}

  ${(props) => {
  switch (props.$useTheme) {
    case "web95":
      mode2 = "light";
      return themes.web95;
    case "retro":
      mode2 = "light";
      return themes.retro;
    case "soft":
      mode2 = "light";
      return themes.soft;
    case "midnight":
      mode2 = "dark";
      return themes.midnight;
    case "minimal":
      mode2 = "light";
      return themes.minimal;
    case "rounded":
      mode2 = "light";
      return themes.rounded;
    case "nouns":
      mode2 = "light";
      return themes.nouns;
    default:
      if (props.$useMode === "light") {
        mode2 = "light";
        return themes.light;
      } else if (props.$useMode === "dark") {
        mode2 = "dark";
        return themes.dark;
      } else {
        return Ae`
            @media (prefers-color-scheme: light) {
              ${themes.light}
            }
            @media (prefers-color-scheme: dark) {
              ${themes.dark}
            }
          `;
      }
  }
}}

  ${(props) => {
  switch (mode2) {
    case "light":
      return globalsLight;
    case "dark":
      return globalsDark;
    default:
      return Ae`
          ${globalsLight}
          @media (prefers-color-scheme: dark) {
            ${globalsDark}
          }
        `;
  }
}}

  ${(props) => {
  var _a2;
  if (props.$customTheme && props.$customTheme["--ck-accent-color"] && ["light", "dark", "auto", "", void 0].includes(props.$useTheme)) {
    const accentColor = props.$customTheme["--ck-accent-color"];
    const accentTextColor = (_a2 = props.$customTheme["--ck-accent-text-color"]) !== null && _a2 !== void 0 ? _a2 : "#ffffff";
    return {
      "--ck-accent-color": accentColor,
      "--ck-accent-text-color": accentTextColor,
      // '--ck-connectbutton-color': accentTextColor,
      // '--ck-connectbutton-background': accentColor,
      // '--ck-connectbutton-background-hover': accentColor,
      // '--ck-connectbutton-background-active': LightenDarkenColor(
      // accentColor,
      // 20
      // ),
      "--ck-secondary-button-background": accentColor,
      "--ck-secondary-button-hover-background": accentColor,
      "--ck-secondary-button-color": accentTextColor,
      "--ck-button-primary-color": accentTextColor,
      "--ck-focus-color": accentColor
    };
  }
  if (props.$customTheme) {
    return createCssColors(props.$customTheme, true);
  }
}}

  all: initial;
  text-align: left;
  text-direction: ltr;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
  -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
  -webkit-text-stroke: 0.001px transparent;
  text-size-adjust: none;
  font-size: 16px;

  button {
    text-rendering: optimizeLegibility;
    -webkit-font-smoothing: antialiased;
    -moz-osx-font-smoothing: grayscale;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-text-stroke: 0.001px transparent;
  }

  &,
  * {
    font-family: var(--ck-font-family);
    box-sizing: border-box;
    outline: none;
    border: none;
  }
  /*
  @media (prefers-reduced-motion) {
    * {
      animation-duration: 60ms !important;
      transition-duration: 60ms !important;
    }
  }
  */
  img,
  svg {
    max-width: 100%;
  }
  strong {
    font-weight: 600;
  }
  a:focus-visible,
  button:focus-visible {
    outline: 2px solid var(--ck-focus-color);
  }
`;
var Portal = (props) => {
  props = {
    selector: "__CONNECTKIT__",
    ...props
  };
  const { selector, children } = props;
  const ref = (0, import_react70.useRef)(null);
  const [mounted, setMounted] = (0, import_react70.useState)(false);
  (0, import_react70.useEffect)(() => {
    const selectorPrefixed = "#" + selector.replace(/^#/, "");
    ref.current = document.querySelector(selectorPrefixed);
    if (!ref.current) {
      const div = document.createElement("div");
      div.setAttribute("id", selector);
      div.setAttribute("data-connectkit", `${CONNECTKIT_VERSION}`);
      document.body.appendChild(div);
      ref.current = div;
    }
    setMounted(true);
  }, [selector]);
  if (!ref.current)
    return null;
  return mounted ? (0, import_react_dom.createPortal)(children, ref.current) : null;
};
var defaultTheme = {
  mobileWidth: 560
};
var ErrorMessage = styled(motion.div)`
  z-index: -1;
  pointer-events: auto;
  position: absolute;
  left: 50%;
  transform: translateX(-50%);
  width: var(--width);
  top: 64px;
  color: #fff;
  font-size: 14px;
  line-height: 20px;
  font-weight: 500;
  background: var(--ck-body-color-danger);
  border-radius: 20px;
  padding: 24px 46px 82px 24px;
  transition: width var(--duration) var(--ease);
  a {
    font-weight: 700;
    text-decoration: underline;
  }
  code {
    font-size: 0.9em;
    display: inline-block;
    font-family: monospace;
    margin: 1px;
    padding: 0 4px;
    border-radius: 8px;
    font-weight: bold;
    background: rgba(255, 255, 255, 0.1);
  }
`;
var FadeIn = We`
from { opacity: 0; }
  to { opacity: 1; }
`;
var FadeInScaleUp = We`
from { opacity: 0; transform: scale(0.85); }
  to { opacity: 1; transform: scale(1); }
`;
var FadeInScaleDown = We`
from { opacity: 0; transform: scale(1.1); }
  to { opacity: 1; transform: scale(1); }
`;
var FadeOut = We`
from { opacity: 1; }
  to { opacity: 0; }
`;
var FadeOutScaleUp = We`
from { opacity: 1; transform: scale(1); }
  to { opacity: 0; transform: scale(1.1); }
`;
var FadeOutScaleDown = We`
from { opacity: 1; transform: scale(1); }
  to { opacity: 0; transform: scale(0.85); }
`;
var PageContent = styled(motion.div)`
  max-width: 100%;
  width: 295px;
  padding-top: 48px;
`;
var TextWithHr = styled(motion.div)`
  user-select: none;
  position: relative;
  display: block;
  text-align: center;
  color: var(--ck-body-color-muted);
  font-size: 15px;
  font-weight: 400;
  line-height: 21px;
  span {
    z-index: 2;
    position: relative;
    display: inline-block;
    user-select: none;
    pointer-events: none;
    padding: 0 14px;
    background: var(--ck-body-background);
    transition: background-color 200ms ease;
  }
  ${(props) => !props.$disableHr && `
  &:before {
    z-index: 2;
    content: '';
    position: absolute;
    top: 50%;
    left: 0;
    right: 0;
    height: 1px;
    transform: translateY(-1px);
    background: var(--ck-body-divider);
    box-shadow: var(--ck-body-divider-box-shadow);
  }
    `}
`;
var ModalHeading = styled(motion.div)`
  z-index: 3;
  pointer-events: none;
  user-select: none;
  position: absolute;
  top: 25px;
  left: 50%;
  display: flex;
  align-items: center;
  justify-content: center;
  height: 26px;
  transform: translateX(-50%);
  width: var(--width);
  text-align: center;
  font-size: 17px;
  line-height: 20px;
  font-weight: var(--ck-modal-heading-font-weight, 600);
  color: var(--ck-body-color);
  span {
    display: inline-block;
  }
`;
var ModalContentContainer = styled(motion.div)`
  position: relative;
  padding: 0;
`;
var ModalContent = styled(motion.div)`
  left: 0;
  right: 0;
  text-align: center;
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 0 0 16px;

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    display: block;
  }
`;
var ModalH1 = styled(motion.h1)`
  margin: 0;
  padding: 0;
  line-height: ${(props) => props.$small ? 20 : 22}px;
  font-size: ${(props) => props.$small ? 17 : 19}px;
  font-weight: var(--ck-modal-h1-font-weight, 600);
  color: ${(props) => {
  if (props.$error)
    return "var(--ck-body-color-danger)";
  if (props.$valid)
    return "var(--ck-body-color-valid)";
  return "var(--ck-body-color)";
}};
  > svg {
    position: relative;
    top: -2px;
    display: inline-block;
    vertical-align: middle;
    margin-right: 6px;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    margin-bottom: 6px;
    font-size: 17px;
  }
`;
var ModalBody = styled.div`
  font-size: 16px;
  font-weight: 400;
  line-height: 21px;
  color: var(--ck-body-color-muted);
  strong {
    font-weight: 500;
    color: var(--ck-body-color);
  }
`;
styled.div`
  padding: 0 12px;
  font-size: 13px;
  font-weight: 400;
  line-height: 16px;
  color: var(--ck-body-color-muted);
  strong {
    font-weight: 500;
    color: var(--ck-body-color);
  }
`;
var BackgroundOverlay = styled(motion.div)`
  z-index: 1;
  position: absolute;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: var(--ck-overlay-background, rgba(71, 88, 107, 0.24));
  backdrop-filter: ${(props) => props.$blur ? `blur(${props.$blur}px)` : "var(--ck-overlay-backdrop-filter, none)"};
  opacity: 0;
  animation: ${(props) => props.$active ? FadeIn : FadeOut} 150ms ease-out
    both;
`;
var BoxIn = We`
  from{ opacity: 0; transform: scale(0.97); }
  to{ opacity: 1; transform: scale(1); }
`;
var BoxOut = We`
  from{ opacity: 1; transform: scale(1); }
  to{ opacity: 0; transform: scale(0.97); }
`;
var MobileBoxIn = We`
  from { transform: translate3d(0, 100%, 0); }
  to { transform: translate3d(0, 0%, 0); }
`;
var MobileBoxOut = We`
  from { opacity: 1; }
  to { opacity: 0; }
`;
var BoxContainer = styled(motion.div)`
  z-index: 2;
  position: relative;
  color: var(--ck-body-color);

  animation: 150ms ease both;
  animation-name: ${BoxOut};
  &.active {
    animation-name: ${BoxIn};
  }

  &:before {
    content: '';
    position: absolute;
    top: 0;
    bottom: 0;
    left: 50%;
    width: var(--width);
    height: var(--height);
    transform: translateX(-50%);
    backface-visibility: hidden;
    transition: all 200ms ease;
    border-radius: var(--ck-border-radius, 20px);
    background: var(--ck-body-background);
    box-shadow: var(--ck-modal-box-shadow);
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    animation-name: ${MobileBoxOut};
    animation-duration: 130ms;
    animation-timing-function: ease;

    &.active {
      animation-name: ${MobileBoxIn};
      animation-duration: 300ms;
      animation-delay: 32ms;
      animation-timing-function: cubic-bezier(0.15, 1.15, 0.6, 1);
    }

    &:before {
      width: 100%;
      transition: 0ms height cubic-bezier(0.15, 1.15, 0.6, 1);
      will-change: height;
    }
  }
`;
var ControllerContainer = styled(motion.div)`
  z-index: 3;
  position: absolute;
  top: 0;
  left: 50%;
  height: 64px;
  transform: translateX(-50%);
  backface-visibility: hidden;
  width: var(--width);
  transition: 0.2s ease width;
  pointer-events: auto;
  //border-bottom: 1px solid var(--ck-body-divider);
`;
var InnerContainer$2 = styled(motion.div)`
  position: relative;
  overflow: hidden;
  height: var(--height);
  transition: 0.2s ease height;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    transition: 0ms height cubic-bezier(0.15, 1.15, 0.6, 1);
    /* animation-delay: 34ms; */
  }
`;
var PageContainer = styled(motion.div)`
  z-index: 2;
  position: relative;
  top: 0;
  left: 50%;
  margin-left: calc(var(--width) / -2);
  width: var(--width);
  /* left: 0; */
  /* width: 100%; */
  display: flex;
  justify-content: center;
  align-items: center;
  transform-origin: center center;
  animation: 200ms ease both;

  &.active {
    animation-name: ${FadeInScaleDown};
  }
  &.active-scale-up {
    animation-name: ${FadeInScaleUp};
  }
  &.exit-scale-down {
    z-index: 1;
    pointer-events: none;
    position: absolute;
    /* top: 0; */
    /* left: 0; */
    animation-name: ${FadeOutScaleDown};
  }
  &.exit {
    z-index: 1;
    pointer-events: none;
    position: absolute;
    /* top: 0; */
    /* left: 0; */
    /* left: 50%; */
    /* transform: translateX(-50%); */
    animation-name: ${FadeOutScaleUp};
    animation-delay: 16.6667ms;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    /* animation: 0ms ease both; */
    /* animation-delay: 35ms; */
    animation: 0ms cubic-bezier(0.15, 1.15, 0.6, 1) both;

    &.active {
      animation-name: ${FadeIn};
    }
    &.active-scale-up {
      animation-name: ${FadeIn};
    }
    &.exit-scale-down {
      z-index: 3;
      animation-name: ${FadeOut};
    }
    &.exit {
      z-index: 3;
      animation-name: ${FadeOut};
      animation-delay: 0ms;
    }
  }
`;
var PageContents = styled(motion.div)`
  margin: 0 auto;
  width: fit-content;
  padding: 29px 24px 24px;
  backface-visibility: hidden;
`;
var ModalContainer = styled.div`
  z-index: 2147483646; // z-index set one below max (2147483647) for if we wish to layer things ontop of the modal in a seperate Portal
  position: fixed;
  inset: 0;
`;
var CloseButton = styled(motion.button)`
  z-index: 3;
  cursor: pointer;
  position: absolute;
  top: 22px;
  right: 17px;
  width: 32px;
  height: 32px;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 0;
  margin: 0;
  color: var(--ck-body-action-color);
  background: var(--ck-body-background);
  transition: background-color 200ms ease, transform 100ms ease;
  /* will-change: transform; */
  svg {
    display: block;
  }

  &:hover {
    background: var(--ck-body-background-secondary);
  }
  &:active {
    transform: scale(0.9);
  }
`;
var SiweButton = styled(motion.button)`
  z-index: 3;
  position: absolute;
  inset: 0;
  width: 100%; // FireFox fix
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 0;
  margin: 0;
  color: var(--ck-body-action-color);
  background: var(--ck-body-background);
  transition: background-color 200ms ease, transform 100ms ease;
  /* will-change: transform; */
  svg {
    display: block;
    position: relative;
  }

  &:enabled {
    cursor: pointer;
    &:hover {
      background: var(--ck-body-background-secondary);
    }
    &:active {
      transform: scale(0.9);
    }
  }
`;
var BackButton = styled(motion.button)`
  z-index: 3;
  position: absolute;
  inset: 0;
  width: 100%; // FireFox fix
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 0;
  margin: 0;
  color: var(--ck-body-action-color);
  background: var(--ck-body-background);
  transition: background-color 200ms ease, transform 100ms ease;
  /* will-change: transform; */
  svg {
    display: block;
    position: relative;
    left: -1px;
  }

  &:enabled {
    cursor: pointer;
    &:hover {
      background: var(--ck-body-background-secondary);
    }
    &:active {
      transform: scale(0.9);
    }
  }
`;
var InfoButton = styled(motion.button)`
  z-index: 3;
  position: absolute;
  inset: 0;
  width: 100%; // FireFox fix
  transform: translateX(-1px);
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 16px;
  padding: 0;
  margin: 0;
  color: var(--ck-body-action-color);
  background: var(--ck-body-background);
  transition: background-color 200ms ease, transform 100ms ease;
  /* will-change: transform; */
  svg {
    display: block;
    position: relative;
  }
  &:enabled {
    cursor: pointer;
    &:hover {
      background: var(--ck-body-background-secondary);
    }
    &:active {
      transform: scale(0.9);
    }
  }
`;
var Container$8 = styled(motion.div)`
  --ease: cubic-bezier(0.25, 0.1, 0.25, 1);
  --duration: 200ms;
  --transition: height var(--duration) var(--ease),
    width var(--duration) var(--ease);
  z-index: 3;
  display: block;
  pointer-events: none;
  position: absolute;
  left: 50%;
  top: 50%;
  width: 100%;
  transform: translate3d(-50%, -50%, 0);
  backface-visibility: hidden;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    pointer-events: auto;
    left: 0;
    top: auto;
    bottom: -5px;
    transform: none;
    ${BoxContainer} {
      max-width: 448px;
      margin: 0 auto;
      &:before {
        width: 100%;
        border-radius: var(--ck-border-radius, 30px)
          var(--ck-border-radius, 30px) 0 0;
      }
    }
    ${PageContainer} {
      left: 0;
      right: 0;
      margin: 0 auto;
      width: auto;
    }
    ${PageContent} {
      margin: 0 auto;
      width: 100% !important;
    }
    ${ModalHeading} {
      top: 29px;
    }
    ${ModalContent} {
      gap: 12px;
    }
    ${ModalBody} {
      margin: 0 auto;
      max-width: 295px;
    }
    ${PageContents} {
      width: 100%;
      padding: 31px 24px;
    }
    ${ControllerContainer} {
      width: 100%;
      top: 4px;
      border-bottom: 0;
    }
    ${CloseButton} {
      right: 22px;
    }
    ${BackButton} {
      top: -1px;
      left: -3px;
    }
    ${InfoButton} {
      top: -1px;
      left: -3px;
      svg {
        width: 65%;
        height: auto;
      }
    }
    ${CloseButton},
    ${BackButton},
    ${InfoButton} {
      // Quick hack for bigger tappable area on mobile
      transform: scale(1.4) !important;
      background: transparent !important;
      svg {
        transform: scale(0.8) !important;
      }
    }
  }
`;
var Disclaimer = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 16px -24px -24px -24px;
  padding: 15px 40px 18px;
  font-size: var(--ck-body-disclaimer-font-size, 13px);
  font-weight: var(--ck-body-disclaimer-font-weight, 400);
  text-align: center;
  line-height: 19px;
  color: var(--ck-body-disclaimer-color, var(--ck-body-color-muted, inherit));

  & a {
    color: var(--ck-body-disclaimer-link-color, inherit);
    font-weight: var(--ck-body-disclaimer-font-weight, 400);
    text-decoration: none;
    transition: color 200ms ease;
    &:hover {
      color: var(--ck-body-disclaimer-link-hover-color, inherit);
    }
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    margin: 24px -24px -26px -24px;
    padding: 20px 42px 22px 42px;
  }
`;
var DisclaimerBackground = styled(motion.div)`
  pointer-events: all;
  z-index: 9;
  position: absolute;
  bottom: 0;
  left: 50%;
  width: var(--width);
  backface-visibility: hidden;
  transform: translateX(-50%);
  transform-origin: bottom center;

  border-radius: var(--ck-border-radius, 30px);
  border-top-left-radius: 0;
  border-top-right-radius: 0;
  transition: width 200ms ease;

  background: var(
    --ck-body-disclaimer-background,
    var(--ck-body-background-secondary)
  );
  box-shadow: var(--ck-body-disclaimer-box-shadow);

  ${Disclaimer} {
    margin: 0 !important;
    /* visibility: hidden; */
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    border-radius: 0;
  }
`;
var SignInTooltip = styled(motion.div)`
  z-index: 2;
  position: absolute;
  top: 100%;
  white-space: nowrap;
  padding: 8px 16px;
  color: #fff;
  font-size: 13px;
  line-height: 1.5;
  background: #1a88f8;
  border-radius: calc(var(--ck-border-radius) * 0.75);
  transform: translateY(8px) translateX(-48px);
  box-shadow: var(--ck-modal-box-shadow);
  &:before {
    content: '';
    position: absolute;
    box-shadow: var(--shadow);
    width: 18px;
    height: 18px;
    transform: translate(215%, -75%) rotate(45deg);
    background: inherit;
    border-radius: 3px 0 0 0;
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    transform: translateY(8px) translateX(-16px);
    &:before {
      transform: translate(40%, -75%) rotate(45deg);
    }
  }
`;
var useIsomorphicLayoutEffect2 = typeof window !== "undefined" ? import_react70.useLayoutEffect : import_react70.useEffect;
function useLockBodyScroll(initialLocked) {
  const [locked, setLocked] = (0, import_react70.useState)(initialLocked);
  const context = useContext21();
  useIsomorphicLayoutEffect2(() => {
    var _a2;
    if (!locked)
      return;
    const original = {
      overflow: document.body.style.overflow,
      position: document.body.style.position,
      touchAction: document.body.style.touchAction,
      paddingRight: document.body.style.paddingRight
      //htmlOverflow: document.documentElement.style.overflow,
    };
    const style2 = getComputedStyle(document.body);
    const offsetX = parseInt(style2.marginRight) + parseInt(style2.paddingRight) + parseInt(style2.borderRight) + parseInt(style2.marginLeft) + parseInt(style2.paddingLeft) + parseInt(style2.borderLeft);
    const scrollBarWidth = window.innerWidth - document.body.offsetWidth - offsetX;
    document.documentElement.style.setProperty("--ck-scrollbar-width", `${scrollBarWidth}px`);
    document.body.style.overflow = "hidden";
    document.body.style.position = "relative";
    document.body.style.touchAction = "none";
    if ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.avoidLayoutShift) {
      document.body.style.paddingRight = `${scrollBarWidth}px`;
    }
    return () => {
      var _a3;
      document.documentElement.style.removeProperty("--ck-scrollbar-width");
      document.body.style.overflow = original.overflow;
      document.body.style.position = original.position;
      document.body.style.touchAction = original.touchAction;
      if ((_a3 = context.options) === null || _a3 === void 0 ? void 0 : _a3.avoidLayoutShift) {
        document.body.style.paddingRight = original.paddingRight;
      }
    };
  }, [locked]);
  (0, import_react70.useEffect)(() => {
    if (locked !== initialLocked)
      setLocked(initialLocked);
  }, [initialLocked]);
  return [locked, setLocked];
}
var KEYCODE_TAB = 9;
function useFocusTrap() {
  const elRef = (0, import_react70.useRef)(null);
  function handleFocus(e2) {
    if (!elRef.current)
      return;
    var focusableEls = elRef.current.querySelectorAll(`
        a[href]:not(:disabled),
        button:not(:disabled),
        textarea:not(:disabled),
        input[type="text"]:not(:disabled),
        input[type="radio"]:not(:disabled),
        input[type="checkbox"]:not(:disabled),
        select:not(:disabled)
      `), firstFocusableEl = focusableEls[0], lastFocusableEl = focusableEls[focusableEls.length - 1];
    var isTabPressed = e2.key === "Tab" || e2.keyCode === KEYCODE_TAB;
    if (!isTabPressed) {
      return;
    }
    if (e2.shiftKey) {
      if (document.activeElement === firstFocusableEl) {
        lastFocusableEl.focus();
        e2.preventDefault();
      }
    } else {
      if (document.activeElement === lastFocusableEl) {
        firstFocusableEl.focus();
        e2.preventDefault();
      }
    }
  }
  (0, import_react70.useEffect)(() => {
    if (elRef.current) {
      elRef.current.addEventListener("keydown", handleFocus);
      elRef.current.focus({ preventScroll: true });
    }
    return () => {
      if (elRef.current) {
        elRef.current.removeEventListener("keydown", handleFocus);
      }
    };
  }, []);
  return elRef;
}
function FocusTrap(props) {
  const elRef = useFocusTrap();
  (0, import_react70.useEffect)(() => {
    if (!elRef.current)
      return;
    elRef.current.focus({ preventScroll: true });
  }, []);
  return (0, import_jsx_runtime.jsx)("div", { ref: elRef, tabIndex: 0, children: props.children });
}
function usePrevious(value, initial) {
  const ref = (0, import_react70.useRef)({ target: value, previous: initial });
  if (ref.current.target !== value) {
    ref.current.previous = ref.current.target;
    ref.current.target = value;
  }
  return ref.current.previous;
}
var Context$1 = (0, import_react70.createContext)(null);
var ConnectKitThemeProvider = ({ children, theme = "auto", mode: mode3 = "auto", customTheme }) => {
  const value = {
    theme,
    mode: mode3,
    customTheme
  };
  return (0, import_react70.createElement)(Context$1.Provider, { value }, (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children }));
};
var useThemeContext = () => {
  const context = import_react70.default.useContext(Context$1);
  if (!context)
    throw Error("ConnectKitThemeProvider must be inside a Provider.");
  return context;
};
var ExternalLinkIcon = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "16", height: "16", viewBox: "0 0 16 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  left: 0,
  top: 0
}, ...props, children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 4C2.89543 4 2 4.89543 2 6V12C2 13.1046 2.89543 14 4 14H10C11.1046 14 12 13.1046 12 12V9.66667C12 9.11438 12.4477 8.66667 13 8.66667C13.5523 8.66667 14 9.11438 14 9.66667V12C14 14.2091 12.2091 16 10 16H4C1.79086 16 0 14.2091 0 12V6C0 3.79086 1.79086 2 4 2H6.33333C6.88562 2 7.33333 2.44772 7.33333 3C7.33333 3.55228 6.88562 4 6.33333 4H4Z", fill: "currentColor", fillOpacity: 0.3 }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9.5 1C9.5 0.447715 9.94772 0 10.5 0H15C15.5523 0 16 0.447715 16 1V5.5C16 6.05228 15.5523 6.5 15 6.5C14.4477 6.5 14 6.05228 14 5.5V3.41421L8.70711 8.70711C8.31658 9.09763 7.68342 9.09763 7.29289 8.70711C6.90237 8.31658 6.90237 7.68342 7.29289 7.29289L12.5858 2H10.5C9.94772 2 9.5 1.55228 9.5 1Z", fill: "currentColor", fillOpacity: 0.3 })] });
var AlertIcon = ({ ...props }) => {
  return (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "19", height: "18", viewBox: "0 0 19 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M6.81753 1.60122C7.39283 0.530035 8.46953 0 9.50409 0C10.5507 0 11.6022 0.539558 12.1805 1.59767L18.6047 13.3334C18.882 13.8283 19 14.3568 19 14.8622C19 16.5296 17.7949 18 15.9149 18H3.08514C1.20508 18 0 16.5296 0 14.8622C0 14.3454 0.131445 13.8172 0.405555 13.3379L6.81753 1.60122ZM9.50409 2C9.13355 2 8.77256 2.18675 8.57866 2.54907L8.57458 2.5567L2.14992 14.3166L2.144 14.3268C2.04638 14.4959 2 14.6817 2 14.8622C2 15.5497 2.43032 16 3.08514 16H15.9149C16.5697 16 17 15.5497 17 14.8622C17 14.6681 16.9554 14.4805 16.8588 14.309L16.8529 14.2986L10.4259 2.55741C10.2191 2.1792 9.86395 2 9.50409 2Z", fill: "currentColor" }), (0, import_jsx_runtime.jsx)("path", { d: "M9.5 11.2297C9.01639 11.2297 8.7459 10.9419 8.72951 10.4186L8.60656 6.4157C8.59016 5.88372 8.95902 5.5 9.4918 5.5C10.0164 5.5 10.4016 5.89244 10.3852 6.42442L10.2623 10.4099C10.2377 10.9419 9.96721 11.2297 9.5 11.2297ZM9.5 14.5C8.95082 14.5 8.5 14.0901 8.5 13.5058C8.5 12.9215 8.95082 12.5116 9.5 12.5116C10.0492 12.5116 10.5 12.9128 10.5 13.5058C10.5 14.0988 10.041 14.5 9.5 14.5Z", fill: "currentColor" })] });
};
var DisconnectIcon = ({ ...props }) => {
  return (0, import_jsx_runtime.jsx)("svg", { "aria-hidden": "true", width: "15", height: "14", viewBox: "0 0 15 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    left: 0,
    top: 0
  }, ...props, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M4 0C1.79086 0 0 1.79086 0 4V10C0 12.2091 1.79086 14 4 14H6C6.55228 14 7 13.5523 7 13C7 12.4477 6.55228 12 6 12H4C2.89543 12 2 11.1046 2 10V4C2 2.89543 2.89543 2 4 2H6C6.55228 2 7 1.55228 7 1C7 0.447715 6.55228 0 6 0H4ZM11.7071 3.29289C11.3166 2.90237 10.6834 2.90237 10.2929 3.29289C9.90237 3.68342 9.90237 4.31658 10.2929 4.70711L11.5858 6H9.5H6C5.44772 6 5 6.44772 5 7C5 7.55228 5.44772 8 6 8H9.5H11.5858L10.2929 9.29289C9.90237 9.68342 9.90237 10.3166 10.2929 10.7071C10.6834 11.0976 11.3166 11.0976 11.7071 10.7071L14.7071 7.70711C15.0976 7.31658 15.0976 6.68342 14.7071 6.29289L11.7071 3.29289Z", fill: "currentColor", fillOpacity: "0.4" }) });
};
var TickIcon = ({ ...props }) => {
  return (0, import_jsx_runtime.jsx)("svg", { "aria-hidden": "true", width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M9 18C13.9706 18 18 13.9706 18 9C18 4.02944 13.9706 0 9 0C4.02944 0 0 4.02944 0 9C0 13.9706 4.02944 18 9 18ZM13.274 7.13324C13.6237 6.70579 13.5607 6.07577 13.1332 5.72604C12.7058 5.37632 12.0758 5.43932 11.726 5.86676L7.92576 10.5115L6.20711 8.79289C5.81658 8.40237 5.18342 8.40237 4.79289 8.79289C4.40237 9.18342 4.40237 9.81658 4.79289 10.2071L7.29289 12.7071C7.49267 12.9069 7.76764 13.0128 8.04981 12.9988C8.33199 12.9847 8.59505 12.8519 8.77396 12.6332L13.274 7.13324Z", fill: "currentColor" }) });
};
var RetryIconCircle = ({ ...props }) => {
  return (0, import_jsx_runtime.jsx)("svg", { "aria-hidden": "true", width: "32", height: "32", viewBox: "0 0 32 32", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M32 16C32 24.8366 24.8366 32 16 32C7.16344 32 0 24.8366 0 16C0 7.16344 7.16344 0 16 0C24.8366 0 32 7.16344 32 16ZM24.5001 8.74263C25.0834 8.74263 25.5563 9.21551 25.5563 9.79883V14.5997C25.5563 15.183 25.0834 15.6559 24.5001 15.6559H19.6992C19.1159 15.6559 18.643 15.183 18.643 14.5997C18.643 14.0164 19.1159 13.5435 19.6992 13.5435H21.8378L20.071 11.8798C20.0632 11.8724 20.0555 11.865 20.048 11.8574C19.1061 10.915 17.8835 10.3042 16.5643 10.1171C15.2452 9.92999 13.9009 10.1767 12.7341 10.82C11.5674 11.4634 10.6413 12.4685 10.0955 13.684C9.54968 14.8994 9.41368 16.2593 9.70801 17.5588C10.0023 18.8583 10.711 20.0269 11.7273 20.8885C12.7436 21.7502 14.0124 22.2582 15.3425 22.336C16.6726 22.4138 17.9919 22.0572 19.1017 21.3199C19.5088 21.0495 19.8795 20.7333 20.2078 20.3793C20.6043 19.9515 21.2726 19.9262 21.7004 20.3228C22.1282 20.7194 22.1534 21.3876 21.7569 21.8154C21.3158 22.2912 20.8176 22.7161 20.2706 23.0795C18.7793 24.0702 17.0064 24.5493 15.2191 24.4448C13.4318 24.3402 11.7268 23.6576 10.3612 22.4998C8.9956 21.3419 8.0433 19.7716 7.6478 18.0254C7.2523 16.2793 7.43504 14.4519 8.16848 12.8186C8.90192 11.1854 10.1463 9.83471 11.7142 8.97021C13.282 8.10572 15.0884 7.77421 16.861 8.02565C18.6282 8.27631 20.2664 9.09278 21.5304 10.3525L23.4439 12.1544V9.79883C23.4439 9.21551 23.9168 8.74263 24.5001 8.74263Z", fill: "currentColor" }) });
};
var RetryIcon = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "16", height: "14", viewBox: "0 0 16 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime.jsx)("path", { d: "M14.5 2V6H10.5", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M14 5.66537L10.9899 2.75871C10.0931 1.83853 8.92897 1.24216 7.6729 1.05947C6.41683 0.876774 5.13688 1.11765 4.02592 1.7458C2.91497 2.37395 2.0332 3.35534 1.5135 4.54208C0.993792 5.72883 0.864305 7.05663 1.14455 8.3254C1.42479 9.59418 2.09958 10.7352 3.06724 11.5765C4.03489 12.4178 5.24298 12.9138 6.50946 12.9898C7.77594 13.0657 9.03219 12.7176 10.0889 11.9977C10.4765 11.7337 10.8295 11.4249 11.142 11.0792", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" })] });
var CopyToClipboardIcon$1 = ({ ...props }) => (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "24", height: "24", viewBox: "0 0 24 24", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime.jsx)("path", { d: "M14 9.5V7C14 5.89543 13.1046 5 12 5H7C5.89543 5 5 5.89543 5 7V12C5 13.1046 5.89543 14 7 14H9.5", stroke: "var(--ck-body-color-muted)", strokeWidth: "2" }), (0, import_jsx_runtime.jsx)("rect", { x: "10", y: "10", width: "9", height: "9", rx: "2", stroke: "var(--ck-body-color-muted)", strokeWidth: "2" }), (0, import_jsx_runtime.jsx)("path", { d: "M1 3L3 5L7 1", stroke: "var(--ck-body-color)", strokeWidth: "1.75", strokeLinecap: "round", strokeLinejoin: "round" })] });
var AuthIcon = ({ ...props }) => (0, import_jsx_runtime.jsx)("div", { ...props, style: {
  zIndex: 2,
  display: "flex",
  alignItems: "center",
  justifyContent: "center",
  position: "absolute",
  bottom: 0,
  right: 0,
  background: "#34C759",
  borderRadius: 10,
  boxShadow: "0 0 0 1.5px var(--background)",
  width: 10,
  height: 10,
  ...props === null || props === void 0 ? void 0 : props.style
}, children: (0, import_jsx_runtime.jsx)("svg", { "aria-hidden": "true", width: "6", height: "6", viewBox: "0 0 6 6", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)("path", { d: "M0.75 3L2.25 4.5L5.25 1.5", stroke: "white", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }) }) });
var StatusState;
(function(StatusState2) {
  StatusState2["READY"] = "ready";
  StatusState2["LOADING"] = "loading";
  StatusState2["SUCCESS"] = "success";
  StatusState2["REJECTED"] = "rejected";
  StatusState2["ERROR"] = "error";
})(StatusState || (StatusState = {}));
var SIWEContext = (0, import_react70.createContext)(null);
var useSIWE = ({ onSignIn, onSignOut } = {}) => {
  const siweContextValue = (0, import_react70.useContext)(SIWEContext);
  if (!siweContextValue) {
    return {
      isSignedIn: false,
      data: void 0,
      status: StatusState.ERROR,
      error: new Error("useSIWE hook must be inside a SIWEProvider."),
      isRejected: false,
      isError: true,
      isLoading: false,
      isSuccess: false,
      isReady: false,
      reset: () => {
      },
      signIn: () => Promise.reject(),
      signOut: () => Promise.reject()
    };
  }
  const { session, nonce, status, signOut, signIn, resetStatus } = siweContextValue;
  const { address, chainId } = session.data || {};
  const currentStatus = address ? StatusState.SUCCESS : session.isLoading || nonce.isLoading ? StatusState.LOADING : status;
  const isLoading = currentStatus === StatusState.LOADING;
  const isSuccess = currentStatus === StatusState.SUCCESS;
  const isRejected = currentStatus === StatusState.REJECTED;
  const isError = currentStatus === StatusState.ERROR;
  const isReady = !address || nonce.isFetching || isLoading || isSuccess;
  const reset2 = () => resetStatus();
  const isSignedIn = !!address;
  return {
    isSignedIn,
    data: isSignedIn ? {
      address,
      chainId
    } : void 0,
    status: currentStatus,
    error: session.error || nonce.error,
    isRejected,
    isError,
    isLoading,
    isSuccess,
    isReady,
    signIn: async () => {
      if (!isSignedIn) {
        const data = await signIn();
        if (data)
          onSignIn === null || onSignIn === void 0 ? void 0 : onSignIn(data);
      }
    },
    signOut: async () => {
      if (isSignedIn) {
        await signOut();
        onSignOut === null || onSignOut === void 0 ? void 0 : onSignOut();
      }
    },
    reset: reset2
  };
};
var enUS = {
  // Family Account
  continueWithFamily: "Continue with Family",
  orSelectWallet: "or select a wallet from the list below",
  loginWithEmailOrPhone: "Login with Email or Phone",
  connectWithFamilyIOS: "Connect with Family iOS",
  // ConnectKit
  connectWallet: "Connect Wallet",
  disconnect: "Disconnect",
  connected: "Connected",
  wrongNetwork: "Wrong Network",
  switchNetworks: "Switch Networks",
  chainNetwork: "{{ CHAIN }} Network",
  copyToClipboard: "Copy to Clipboard",
  copyCode: "Copy Code",
  moreInformation: "More Information",
  back: "Back",
  close: "Close",
  or: "or",
  more: "More",
  tryAgain: "Try Again",
  tryAgainQuestion: "Try Again?",
  dontHaveTheApp: "Don't have the app?",
  scanTheQRCode: "Scan the QR code",
  useWalletConnectModal: "Use WalletConnect Modal",
  useModal: "Use Modal",
  installTheExtension: "Install the Extension",
  getWalletName: "Get {{ CONNECTORNAME }}",
  otherWallets: "Other Wallets",
  learnMore: "Learn More",
  getWallet: "Get a Wallet",
  approveInWallet: "Approve in Wallet",
  confirmInWallet: "Confirm in Wallet",
  awaitingConfirmation: "Awaiting Confirmation",
  signIn: "Sign In",
  signOut: "Sign Out",
  signedIn: "Signed In",
  signedOut: "Signed Out",
  walletNotConnected: "Wallet Not Connected",
  warnings_walletSwitchingUnsupported: `Your wallet does not support switching networks from this app.`,
  warnings_walletSwitchingUnsupportedResolve: `Try switching networks from within your wallet instead.`,
  warnings_chainUnsupported: `This app does not support the current connected network.`,
  warnings_chainUnsupportedResolve: `Switch or disconnect to continue.`,
  onboardingScreen_heading: `Get a Wallet`,
  onboardingScreen_h1: `Start Exploring Web3`,
  onboardingScreen_p: `Your wallet is the gateway to all things Ethereum, the magical technology that makes it possible to explore web3.`,
  onboardingScreen_ctaText: `Choose Your First Wallet`,
  onboardingScreen_ctaUrl: `https://ethereum.org/en/wallets/find-wallet/`,
  aboutScreen_heading: `About Wallets`,
  aboutScreen_a_h1: `For your digital assets`,
  aboutScreen_a_p: `Wallets let you send, receive, store, and interact with digital assets like NFTs and other Ethereum tokens.`,
  aboutScreen_b_h1: `A better way to login`,
  aboutScreen_b_p: `With modern apps, your wallet can be used as an easy way to login, instead of having to remember a password.`,
  aboutScreen_c_h1: `Explore the world of web3`,
  aboutScreen_c_p: `Your wallet is an essential utility that lets you explore and participate in the fast evolving world of web3.`,
  aboutScreen_ctaText: `Learn More`,
  aboutScreen_ctaUrl: `https://ethereum.org/en/wallets/`,
  connectorsScreen_heading: `Connect Wallet`,
  connectorsScreen_newcomer: `I dont have a wallet`,
  connectorsScreen_h1: `What is a wallet?`,
  connectorsScreen_p: `Wallets are used to send, receive, and store digital assets. Connecting a wallet lets you interact with apps.`,
  mobileConnectorsScreen_heading: `Choose Wallet`,
  scanScreen_heading: `Scan with Phone`,
  scanScreen_heading_withConnector: `Scan with {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Open a [WALLETCONNECTLOGO] WalletConnect 
supported wallet to scan`,
  scanScreen_tooltip_default: `Open {{ CONNECTORNAME }} on 
your mobile phone to scan`,
  downloadAppScreen_heading: `Get {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Scan with your phone camera to download on iOS or Android.`,
  downloadAppScreen_ios: `Scan with your phone camera to download on iOS.`,
  downloadAppScreen_android: `Scan with your phone camera to download on Android.`,
  injectionScreen_unavailable_h1: `Unsupported Browser`,
  injectionScreen_unavailable_p: `To connect your {{ CONNECTORSHORTNAME }} wallet,
install the extension on {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Install {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `To connect your {{ CONNECTORSHORTNAME }} wallet,
install the browser extension.`,
  injectionScreen_connecting_h1: `Requesting Connection`,
  injectionScreen_connecting_p: `Open the {{ CONNECTORSHORTNAME }} browser 
extension to connect your wallet.`,
  injectionScreen_connecting_injected_h1: `Requesting Connection`,
  injectionScreen_connecting_injected_p: `Accept the request through your wallet to connect to this app.`,
  injectionScreen_connected_h1: `Already Connected`,
  injectionScreen_connected_p: `It is now okay to close this popup`,
  injectionScreen_rejected_h1: `Request Cancelled`,
  injectionScreen_rejected_p: `You cancelled the request.
Click above to try again.`,
  injectionScreen_failed_h1: `Connection Failed`,
  injectionScreen_failed_p: `Sorry, something went wrong.
Please try connecting again.`,
  injectionScreen_notconnected_h1: `Login to {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `To continue, please login to your {{ CONNECTORNAME }} extension.`,
  profileScreen_heading: "Connected",
  switchNetworkScreen_heading: "Switch Networks",
  signInWithEthereumScreen_tooltip: "Youre not signed in to this app.\n**Sign In With Ethereum** to continue.",
  signInWithEthereumScreen_signedOut_heading: "Sign In With Ethereum",
  signInWithEthereumScreen_signedOut_h1: "This app would like to verify you \n as the owner of this wallet.",
  signInWithEthereumScreen_signedOut_p: `Please sign the message request 
 in your wallet to continue.`,
  signInWithEthereumScreen_signedOut_button: "Sign In",
  signInWithEthereumScreen_signedIn_heading: "Signed In With Ethereum",
  signInWithEthereumScreen_signedIn_h1: "You successfully verified yourself \n as the owner of this wallet.",
  signInWithEthereumScreen_signedIn_p: `Signing out will require you to 
 authenticate again in the future.`,
  signInWithEthereumScreen_signedIn_button: "Sign Out"
};
var arAE = {
  ...enUS,
  // fallback
  connectWallet: " ",
  disconnect: " ",
  connected: "",
  wrongNetwork: " ",
  switchNetworks: " ",
  chainNetwork: " {{ CHAIN }}",
  copyToClipboard: "  ",
  copyCode: " ",
  moreInformation: "  ",
  back: "",
  close: "",
  or: "",
  more: "",
  tryAgain: " ",
  tryAgainQuestion: "   ",
  dontHaveTheApp: "  ",
  scanTheQRCode: "   ",
  useWalletConnectModal: "  ",
  useModal: " ",
  installTheExtension: " ",
  getWalletName: "  {{ CONNECTORNAME }}",
  otherWallets: " ",
  learnMore: "  ",
  getWallet: "  ",
  approveInWallet: "  ",
  confirmInWallet: "  ",
  awaitingConfirmation: " ",
  signIn: " ",
  signOut: " ",
  signedIn: "  ",
  signedOut: "  ",
  walletNotConnected: "  ",
  warnings_walletSwitchingUnsupported: `        .`,
  warnings_walletSwitchingUnsupportedResolve: `        .`,
  warnings_chainUnsupported: `       .`,
  warnings_chainUnsupportedResolve: `      .`,
  onboardingScreen_heading: `  `,
  onboardingScreen_h1: `  3`,
  onboardingScreen_p: `           3.`,
  onboardingScreen_ctaText: `  `,
  onboardingScreen_ctaUrl: `https://ethereum.org/ar/wallets/find-wallet/`,
  aboutScreen_heading: ` `,
  aboutScreen_a_h1: `   `,
  aboutScreen_a_p: `           NFTs   .`,
  aboutScreen_b_h1: `   `,
  aboutScreen_b_p: `                 .`,
  aboutScreen_c_h1: `  3`,
  aboutScreen_c_p: `          3   .`,
  aboutScreen_ctaText: `  `,
  aboutScreen_ctaUrl: `https://ethereum.org/ar/wallets/`,
  connectorsScreen_heading: ` `,
  connectorsScreen_newcomer: `  `,
  connectorsScreen_h1: `  `,
  connectorsScreen_p: `      .      .`,
  mobileConnectorsScreen_heading: ` `,
  scanScreen_heading: `  `,
  scanScreen_heading_withConnector: `  {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `    
  .`,
  scanScreen_tooltip_default: ` {{ CONNECTORNAME }}   `,
  downloadAppScreen_heading: `  {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `       iOS  Android

.`,
  downloadAppScreen_ios: `       iOS.`,
  downloadAppScreen_android: `       Android.`,
  injectionScreen_unavailable_h1: `  `,
  injectionScreen_unavailable_p: `  {{ CONNECTORSHORTNAME }}      {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: ` {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `  {{ CONNECTORSHORTNAME }}     .`,
  injectionScreen_connecting_h1: ` `,
  injectionScreen_connecting_p: `   {{ CONNECTORSHORTNAME }}  .`,
  injectionScreen_connecting_injected_h1: ` `,
  injectionScreen_connecting_injected_p: `      .`,
  injectionScreen_connected_h1: ` `,
  injectionScreen_connected_p: `      .`,
  injectionScreen_rejected_h1: `  `,
  injectionScreen_rejected_p: `   .     .`,
  injectionScreen_failed_h1: ` `,
  injectionScreen_failed_p: `   .     .`,
  injectionScreen_notconnected_h1: `   {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `      {{ CONNECTORNAME }}.`,
  profileScreen_heading: "",
  switchNetworkScreen_heading: " ",
  signInWithEthereumScreen_tooltip: "       .\n**   ** .",
  signInWithEthereumScreen_signedOut_heading: "   ",
  signInWithEthereumScreen_signedOut_h1: "     \n   .",
  signInWithEthereumScreen_signedOut_p: `      .`,
  signInWithEthereumScreen_signedOut_button: " ",
  signInWithEthereumScreen_signedIn_heading: "    ",
  signInWithEthereumScreen_signedIn_h1: "       .",
  signInWithEthereumScreen_signedIn_p: `         .`,
  signInWithEthereumScreen_signedIn_button: " "
};
var eeEE = {
  ...enUS,
  // fallback
  connectWallet: "henda rahakott",
  disconnect: "Katkesta hendus",
  connected: "hendatud",
  wrongNetwork: "Vale vrk",
  switchNetworks: "Vaheta vrke",
  chainNetwork: "{{ CHAIN }} Vrk",
  copyToClipboard: "Kopeeri likelauale",
  copyCode: "Kopeeri koodi",
  moreInformation: "Rohkem infot",
  back: "Tagasi",
  close: "Pane kinni",
  or: "vi",
  more: "Rohkem",
  tryAgain: "Proovi uuesti",
  tryAgainQuestion: "Proovi uuesti?",
  dontHaveTheApp: "Kas teil pole rakendust?",
  scanTheQRCode: "Skaneeri QR-kood",
  useWalletConnectModal: "Kasuta WalletConnecti modalit",
  useModal: "Kasuta Modalit",
  installTheExtension: "Installi laiendust",
  getWalletName: "Hanki {{ CONNECTORNAME }}",
  otherWallets: "Teised rahakotid",
  learnMore: "Avasta rohkem",
  getWallet: "Lae alla rahakott",
  approveInWallet: "Kiita heaks rahakotis",
  confirmInWallet: "Kinnita rahakotis",
  awaitingConfirmation: "Kinnituse ootel",
  signIn: "Logi sisse",
  signOut: "Logi vlja",
  signedIn: "Sisse logitud",
  signedOut: "Vlja logitud",
  walletNotConnected: "Raakott pole hendatud",
  warnings_walletSwitchingUnsupported: `Teie rahakott ei toeta vrgu vahetamist sellest rakendusest.`,
  warnings_walletSwitchingUnsupportedResolve: `Proovige vrgu vahetamist teha oma rahakoti seest.`,
  warnings_chainUnsupported: `See rakendus ei toeta praegu hendatud vrku.`,
  warnings_chainUnsupportedResolve: `Jtkamiseks vahetage vi hendage lahti.`,
  onboardingScreen_heading: `Hankige rahakott`,
  onboardingScreen_h1: `Alustage Web3 uurimist`,
  onboardingScreen_p: `Teie rahakott on vrav kigele, mis puudutab Ethereumit, maagilist tehnoloogiat, mis vimaldab uurida Web3.`,
  onboardingScreen_ctaText: `Valige oma esimene rahakott`,
  onboardingScreen_ctaUrl: `https://ethereum.org/en/wallets/find-wallet/`,
  aboutScreen_heading: `Rahakottidest`,
  aboutScreen_a_h1: `Teie digitaalsetele varadele`,
  aboutScreen_a_p: `Rahakotid vimaldavad teil saata, vastu vtta, salvestada ja suhelda digitaalsete varadega nagu NFT-d ja teised Ethereumi tokenid.`,
  aboutScreen_b_h1: `Parem viis sisse logimiseks`,
  aboutScreen_b_p: `Kaasaegsete rakendustega saab teie rahakotti kasutada lihtsa sisselogimisviisina, ilma et peaksite meeles pidama parooli.`,
  aboutScreen_c_h1: `Uurige Web3 maailma`,
  aboutScreen_c_p: `Teie rahakott on oluline triist, mis vimaldab teil uurida ja osaleda kiiresti arenevas Web3 maailmas.`,
  aboutScreen_ctaText: `Lisateavet saamiseks`,
  aboutScreen_ctaUrl: `https://ethereum.org/en/wallets/`,
  connectorsScreen_heading: `hendage rahakott`,
  connectorsScreen_newcomer: `Mul pole rahakotti`,
  connectorsScreen_h1: `Mis on rahakott?`,
  connectorsScreen_p: `Rahakotte kasutatakse digitaalsete varade saatmiseks, vastuvtmiseks ja salvestamiseks. Rahakoti hendamine vimaldab teil rakendustega suhelda.`,
  mobileConnectorsScreen_heading: `Valige rahakott`,
  scanScreen_heading: `Skaneerige telefoni abil`,
  scanScreen_heading_withConnector: `Skaneerige koos {{ CONNECTORNAME }}-ga`,
  scanScreen_tooltip_walletConnect: `Ava [WALLETCONNECTLOGO] WalletConnect 
toetatud rahakott skaneerimiseks`,
  scanScreen_tooltip_default: `Ava {{ CONNECTORNAME }} oma 
mobiiltelefonil skaneerimiseks`,
  downloadAppScreen_heading: `Hankige {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Skaneerige oma telefoni kaameraga allalaadimiseks iOS-i vi Androidi jaoks.`,
  downloadAppScreen_ios: `Skaneerige oma telefoni kaameraga allalaadimiseks iOS-i jaoks.`,
  downloadAppScreen_android: `Skaneerige oma telefoni kaameraga Androidi allalaadimiseks.`,
  injectionScreen_unavailable_h1: `Toetuseta brauser`,
  injectionScreen_unavailable_p: `Teie {{ CONNECTORSHORTNAME }} rahakoti hendamiseks
installige laiendus {{ SUGGESTEDEXTENSIONBROWSER }}-le.`,
  injectionScreen_install_h1: `Installige {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `Teie {{ CONNECTORSHORTNAME }} rahakoti hendamiseks
installige brauseri laiendus.`,
  injectionScreen_connecting_h1: `henduse taotlemine`,
  injectionScreen_connecting_p: `Ava {{ CONNECTORSHORTNAME }} brauseri 
laiendus rahakoti hendamiseks.`,
  injectionScreen_connecting_injected_h1: `henduse taotlemine`,
  injectionScreen_connecting_injected_p: `Nustuge rakendusega hendamiseks oma rahakotis.`,
  injectionScreen_connected_h1: `Juba hendatud`,
  injectionScreen_connected_p: `Selle popup-i saab nd sulgeda`,
  injectionScreen_rejected_h1: `Taotlus thistatud`,
  injectionScreen_rejected_p: `Thistasite taotluse.
Klpsake lal, et uuesti proovida.`,
  injectionScreen_failed_h1: `henduse loomine ebannestus`,
  injectionScreen_failed_p: `Vabandame, midagi lks valesti.
Proovige hendust uuesti luua.`,
  injectionScreen_notconnected_h1: `Logige sisse {{ CONNECTORNAME }}-ga`,
  injectionScreen_notconnected_p: `Jtkamiseks logige sisse oma {{ CONNECTORNAME }} laiendisse.`,
  profileScreen_heading: "hendatud",
  switchNetworkScreen_heading: "Vrkude vahetamine",
  signInWithEthereumScreen_tooltip: "Te pole selle rakendusse sisse logitud.\n**Logi sisse Ethereumiga** jtkamiseks.",
  signInWithEthereumScreen_signedOut_heading: "Logi sisse Ethereumiga",
  signInWithEthereumScreen_signedOut_h1: "See rakendus soovib teid autentida \n selle rahakoti omanikuna.",
  signInWithEthereumScreen_signedOut_p: `Jtkamiseks allkirjastage snumipring 
 oma rahakotis.`,
  signInWithEthereumScreen_signedOut_button: "Logi sisse",
  signInWithEthereumScreen_signedIn_heading: "Logi vlja",
  signInWithEthereumScreen_signedIn_h1: "Olete edukalt autentinud end \n selle rahakoti omanikuna.",
  signInWithEthereumScreen_signedIn_p: `Vlja logimine nuab tulevikus 
 uuesti autentimist.`,
  signInWithEthereumScreen_signedIn_button: "Logi vlja"
};
var esES = {
  ...enUS,
  // fallback
  connectWallet: "Conecta una cartera",
  disconnect: "Desconectar",
  connected: "Conectado",
  wrongNetwork: "Red incorrecta",
  switchNetworks: "Cambio de red",
  chainNetwork: "Red {{ CHAIN }}",
  copyToClipboard: "Copiar al portapapeles",
  copyCode: "Copiar cdigo",
  moreInformation: "Ms informacin",
  back: "Atrs",
  close: "Cerrar",
  or: "o",
  more: "Ms",
  tryAgain: "Intentar de nuevo",
  tryAgainQuestion: "Intentar de nuevo?",
  dontHaveTheApp: "No tienes la aplicacin?",
  scanTheQRCode: "Escanea el cdigo QR",
  useWalletConnectModal: "Utilizar WalletConnect Modal",
  useModal: "Utilizar Modal",
  installTheExtension: "Instalar la extensin",
  getWalletName: "Obtn {{ CONNECTORNAME }}",
  otherWallets: "Otras carteras",
  learnMore: "Ms informacin",
  getWallet: "Obtn una cartera",
  approveInWallet: "Aprobar en la cartera",
  confirmInWallet: "Confirmar en la cartera",
  awaitingConfirmation: "A la espera de confirmacin",
  signIn: "Iniciar sesin",
  signOut: "Cerrar sesin",
  signedIn: "Sesin iniciada",
  signedOut: "Sesin cerrada",
  walletNotConnected: "Cartera no conectada",
  warnings_walletSwitchingUnsupported: `Tu cartera no permite cambiar de red desde esta aplicacin.`,
  warnings_walletSwitchingUnsupportedResolve: `Prueba a cambiar de red desde tu cartera.`,
  warnings_chainUnsupported: `Esta aplicacin no es compatible con la red conectada actualmente.`,
  warnings_chainUnsupportedResolve: `Cambia o desconecta para continuar.`,
  onboardingScreen_heading: `Obtn una cartera`,
  onboardingScreen_h1: `Comienza a explorar la Web3`,
  onboardingScreen_p: `Tu cartera es el portal de acceso a todo lo relacionado con Ethereum, la tecnologa mgica que permite explorar la Web3.`,
  onboardingScreen_ctaText: `Elige tu primera cartera`,
  onboardingScreen_ctaUrl: `https://ethereum.org/es/wallets/find-wallet/`,
  aboutScreen_heading: `Acerca de las carteras`,
  aboutScreen_a_h1: `Para tus activos digitales`,
  aboutScreen_a_p: `Las carteras te permiten enviar, recibir, almacenar e interactuar con activos digitales como los NFT y otros tokens de Ethereum.`,
  aboutScreen_b_h1: `Una manera mejor de iniciar sesin`,
  aboutScreen_b_p: `Con las aplicaciones modernas, puedes utilizar tu cartera para iniciar sesin fcilmente, en vez de tener que recordar una contrasea.`,
  aboutScreen_c_h1: `Explora el mundo de la Web3`,
  aboutScreen_c_p: `Tu cartera es una herramienta esencial que te permite explorar y participar en el mundo en rpida evolucin de la Web3.`,
  aboutScreen_ctaText: `Ms informacin`,
  aboutScreen_ctaUrl: `https://ethereum.org/es/wallets/`,
  connectorsScreen_heading: `Conecta una cartera`,
  connectorsScreen_newcomer: `No tengo una cartera`,
  connectorsScreen_h1: `Qu es una cartera?`,
  connectorsScreen_p: `Las carteras se utilizan para enviar, recibir y almacenar activos digitales. Si conectas una cartera, podrs interactuar con las aplicaciones.`,
  mobileConnectorsScreen_heading: `Elige una cartera`,
  scanScreen_heading: `Escanea con el telfono`,
  scanScreen_heading_withConnector: `Escanea con {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Abre una cartera compatible con WalletConnect [WALLETCONNECTLOGO] para escanear`,
  scanScreen_tooltip_default: `Abre {{ CONNECTORNAME }} en tu telfono mvil para escanear`,
  downloadAppScreen_heading: `Obtn {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Escanea con la cmara de tu telfono para descargarla en iOS o Android.`,
  downloadAppScreen_ios: `Escanea con la cmara de tu telfono para descargarla en iOS.`,
  downloadAppScreen_android: `Escanea con la cmara de tu telfono para descargarla en Android.`,
  injectionScreen_unavailable_h1: `Navegador no compatible`,
  injectionScreen_unavailable_p: `Para conectar tu cartera de {{ CONNECTORSHORTNAME }}, instala la extensin en {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Instala {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `Para conectar tu cartera de {{ CONNECTORSHORTNAME }}, instala la extensin del navegador.`,
  injectionScreen_connecting_h1: `Solicitud de conexin`,
  injectionScreen_connecting_p: `Abre la extensin del navegador de {{ CONNECTORSHORTNAME }}  para conectar tu cartera.`,
  injectionScreen_connecting_injected_h1: `Solicitud de conexin`,
  injectionScreen_connecting_injected_p: `Acepta la solicitud a travs de tu cartera para conectarte a esta aplicacin.`,
  injectionScreen_connected_h1: `Ya conectada`,
  injectionScreen_connected_p: `Ya puedes cerrar esta ventana emergente`,
  injectionScreen_rejected_h1: `Solicitud cancelada`,
  injectionScreen_rejected_p: `Has cancelado la solicitud. Haz clic arriba para intentarlo de nuevo.`,
  injectionScreen_failed_h1: `Error de conexin`,
  injectionScreen_failed_p: `Lo sentimos, ha habido un problema. Intenta conectarte de nuevo.`,
  injectionScreen_notconnected_h1: `Inicia sesin en {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `Para continuar, inicia sesin en tu extensin de {{ CONNECTORNAME }}.`,
  profileScreen_heading: "Conectado",
  switchNetworkScreen_heading: "Cambio de red",
  signInWithEthereumScreen_tooltip: "No has iniciado sesin en esta aplicacin.\n**Inicia sesin con Ethereum** para continuar.",
  signInWithEthereumScreen_signedOut_heading: "Inicia sesin con Ethereum",
  signInWithEthereumScreen_signedOut_h1: "Esta aplicacin desea verificar que eres el propietario de esta cartera.",
  signInWithEthereumScreen_signedOut_p: `Firma la solicitud de mensaje en tu cartera para continuar.`,
  signInWithEthereumScreen_signedOut_button: "Iniciar sesin",
  signInWithEthereumScreen_signedIn_heading: "Sesin iniciada con Ethereum",
  signInWithEthereumScreen_signedIn_h1: "Te has verificado correctamente como propietario de esta cartera.",
  signInWithEthereumScreen_signedIn_p: `Si cierras la sesin, tendrs que volver a autenticarte ms adelante.`,
  signInWithEthereumScreen_signedIn_button: "Cerrar sesin"
};
var faIR = {
  ...enUS,
  // fallback
  connectWallet: "   ",
  disconnect: " ",
  connected: " ",
  wrongNetwork: " ",
  switchNetworks: " ",
  chainNetwork: "{{ CHAIN }} ",
  copyToClipboard: "  ",
  copyCode: " ",
  moreInformation: " ",
  back: "",
  close: "",
  or: "",
  more: "",
  tryAgain: " ",
  tryAgainQuestion: "   ",
  dontHaveTheApp: "  ",
  scanTheQRCode: "  ",
  useWalletConnectModal: "   ",
  useModal: "  ",
  installTheExtension: " ",
  getWalletName: " {{ CONNECTORNAME }}",
  otherWallets: "  ",
  learnMore: " ",
  getWallet: "    ",
  approveInWallet: "    ",
  confirmInWallet: "    ",
  awaitingConfirmation: "  ",
  signIn: "",
  signOut: "",
  signedIn: " ",
  signedOut: " ",
  walletNotConnected: "   ",
  warnings_walletSwitchingUnsupported: `           .`,
  warnings_walletSwitchingUnsupportedResolve: `         .`,
  warnings_chainUnsupported: `           .`,
  warnings_chainUnsupportedResolve: `          .`,
  onboardingScreen_heading: `  `,
  onboardingScreen_h1: `   3`,
  onboardingScreen_p: `              3   .`,
  onboardingScreen_ctaText: `      `,
  onboardingScreen_ctaUrl: `https://ethereum.org/fa/wallets/find-wallet/`,
  aboutScreen_heading: `  `,
  aboutScreen_a_h1: `   `,
  aboutScreen_a_p: `                    .`,
  aboutScreen_b_h1: `    `,
  aboutScreen_b_p: `                       .`,
  aboutScreen_c_h1: ` 3   `,
  aboutScreen_c_p: `                 3       .`,
  aboutScreen_ctaText: `  `,
  aboutScreen_ctaUrl: `https://ethereum.org/fa/wallets/`,
  connectorsScreen_heading: `    `,
  connectorsScreen_newcomer: `  `,
  connectorsScreen_h1: `   `,
  connectorsScreen_p: `          .              .`,
  mobileConnectorsScreen_heading: `  `,
  scanScreen_heading: `  `,
  scanScreen_heading_withConnector: `  {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `              `,
  scanScreen_tooltip_default: `{{ CONNECTORNAME }}         `,
  downloadAppScreen_heading: ` {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `         iOS  Android  .`,
  downloadAppScreen_ios: `       iOS  .`,
  downloadAppScreen_android: `       Android  .`,
  injectionScreen_unavailable_h1: `  `,
  injectionScreen_unavailable_p: `      {{ CONNECTORSHORTNAME }}     {{ SUGGESTEDEXTENSIONBROWSER }}  .`,
  injectionScreen_install_h1: ` {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `      {{ CONNECTORSHORTNAME }}     .`,
  injectionScreen_connecting_h1: ` `,
  injectionScreen_connecting_p: `  {{ CONNECTORSHORTNAME }}          .`,
  injectionScreen_connecting_injected_h1: ` `,
  injectionScreen_connecting_injected_p: `             .`,
  injectionScreen_connected_h1: `    `,
  injectionScreen_connected_p: `      .`,
  injectionScreen_rejected_h1: `  `,
  injectionScreen_rejected_p: `    .      .`,
  injectionScreen_failed_h1: ` `,
  injectionScreen_failed_p: `   .     .`,
  injectionScreen_notconnected_h1: `   {{ CONNECTORNAME }}  `,
  injectionScreen_notconnected_p: `     {{ CONNECTORNAME }}  .`,
  profileScreen_heading: "",
  switchNetworkScreen_heading: " ",
  signInWithEthereumScreen_tooltip: "        .\n**   **   .",
  signInWithEthereumScreen_signedOut_heading: "   ",
  signInWithEthereumScreen_signedOut_h1: "     \n         .",
  signInWithEthereumScreen_signedOut_p: `            .`,
  signInWithEthereumScreen_signedOut_button: "   ",
  signInWithEthereumScreen_signedIn_heading: "   ",
  signInWithEthereumScreen_signedIn_h1: "             .",
  signInWithEthereumScreen_signedIn_p: `           .`,
  signInWithEthereumScreen_signedIn_button: ""
};
var frFR = {
  ...enUS,
  // fallback
  connectWallet: "Connecter le portefeuille",
  disconnect: "Dconnecter",
  connected: "Connect",
  wrongNetwork: "Rseau incorrect",
  switchNetworks: "Changer de rseau",
  chainNetwork: "Rseau {{ CHAIN }}",
  copyToClipboard: "Copier dans le presse-papiers",
  copyCode: "Copier le code",
  moreInformation: "Plus dinformations",
  back: "Retour",
  close: "Fermer",
  or: "ou",
  more: "Plus",
  tryAgain: "Ressayer",
  tryAgainQuestion: "Ressayer?",
  dontHaveTheApp: "Vous navez pas lapplication ?",
  scanTheQRCode: "Scannez le code QR",
  useWalletConnectModal: "Utiliser la modale WalletConnect",
  useModal: "Utiliser la modale",
  installTheExtension: "Installer lextension",
  getWalletName: "Obtenez {{ CONNECTORNAME }}",
  otherWallets: "Autres portefeuilles",
  learnMore: "En savoir plus",
  getWallet: "Obtenir un portefeuille",
  approveInWallet: "Approuver dans le portefeuille",
  confirmInWallet: "Confirmer dans le portefeuille",
  awaitingConfirmation: "En attente de confirmation",
  signIn: "Se connecter",
  signOut: "Se dconnecter",
  signedIn: "Connect",
  signedOut: "Dconnect",
  walletNotConnected: "Portefeuille non connect",
  warnings_walletSwitchingUnsupported: `Votre portefeuille ne prend pas en charge le changement de rseau  partir de cette application.`,
  warnings_walletSwitchingUnsupportedResolve: `Essayez plutt de changer de rseau  partir de votre portefeuille.`,
  warnings_chainUnsupported: `Cette application ne prend pas en charge le rseau connect actuel.`,
  warnings_chainUnsupportedResolve: `Changez ou dconnectez-vous pour continuer.`,
  onboardingScreen_heading: `Obtenez un portefeuille`,
  onboardingScreen_h1: `Commencez  explorer le Web3`,
  onboardingScreen_p: `Votre portefeuille est la porte d'entre vers tout ce qui concerne l'Ethereum, la technologie magique qui permet d'explorer le Web3.`,
  onboardingScreen_ctaText: `Choisissez votre premier portefeuille`,
  onboardingScreen_ctaUrl: `https://ethereum.org/fr/wallets/find-wallet/`,
  aboutScreen_heading: ` propos des portefeuilles`,
  aboutScreen_a_h1: `Pour vos actifs numriques`,
  aboutScreen_a_p: `Les portefeuilles vous permettent d'envoyer, de recevoir, de stocker et d'interagir avec des actifs numriques tels que des NFT et d'autres jetons Ethereum.`,
  aboutScreen_b_h1: `Une meilleure faon de se connecter`,
  aboutScreen_b_p: `Avec les applications modernes, votre portefeuille peut s'utiliser pour vous connecter facilement, au lieu d'avoir  mmoriser un mot de passe.`,
  aboutScreen_c_h1: `Explorez le monde du Web3`,
  aboutScreen_c_p: `Votre portefeuille est un utilitaire essentiel qui vous permet d'explorer et de participer au monde en volution rapide du Web3.`,
  aboutScreen_ctaText: `En savoir plus`,
  aboutScreen_ctaUrl: `https://ethereum.org/fr/wallets/`,
  connectorsScreen_heading: `Connectez le portefeuille`,
  connectorsScreen_newcomer: `Je nai pas de portefeuille`,
  connectorsScreen_h1: `Quest-ce quun portefeuille ?`,
  connectorsScreen_p: `Les portefeuilles s'utilisent pour envoyer, recevoir et stocker des actifs numriques. La connexion d'un portefeuille vous permet d'interagir avec les applications.`,
  mobileConnectorsScreen_heading: `Choisissez le portefeuille`,
  scanScreen_heading: `Scannez avec le tlphone`,
  scanScreen_heading_withConnector: `Scannez avec {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Ouvrez un portefeuille pris en charge par WalletConnect [WALLETCONNECTLOGO] pour scanner`,
  scanScreen_tooltip_default: `Ouvrez {{ CONNECTORNAME }} sur votre tlphone mobile pour scanner`,
  downloadAppScreen_heading: `Obtenez {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Scannez avec l'appareil photo de votre tlphone pour le tlcharger sur iOS ou Android.`,
  downloadAppScreen_ios: `Scannez avec l'appareil photo de votre tlphone pour le tlcharger sur iOS.`,
  downloadAppScreen_android: `Scannez avec l'appareil photo de votre tlphone pour le tlcharger sur Android.`,
  injectionScreen_unavailable_h1: `Navigateur non pris en charge`,
  injectionScreen_unavailable_p: `Pour connecter votre portefeuille {{ CONNECTORSHORTNAME }}, installez lextension sur {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Installez {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `Pour connecter votre portefeuille {{ CONNECTORSHORTNAME }}, installez lextension de navigateur.`,
  injectionScreen_connecting_h1: `Demande de connexion`,
  injectionScreen_connecting_p: `Ouvrez lextension de navigateur {{ CONNECTORSHORTNAME }} pour connecter votre portefeuille.`,
  injectionScreen_connecting_injected_h1: `Demande de connexion`,
  injectionScreen_connecting_injected_p: `Acceptez la demande via votre portefeuille pour vous connecter  cette application.`,
  injectionScreen_connected_h1: `Dj connect`,
  injectionScreen_connected_p: `Vous pouvez maintenant fermer ce pop-up`,
  injectionScreen_rejected_h1: `Demande annule`,
  injectionScreen_rejected_p: `Vous avez annul la demande. Cliquez ci-dessus pour ressayer.`,
  injectionScreen_failed_h1: `chec de la connexion`,
  injectionScreen_failed_p: `Malheureusement, un problme est survenu. Veuillez ressayer de vous connecter.`,
  injectionScreen_notconnected_h1: `Connectez-vous  {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `Pour continuer, veuillez vous connecter  votre extension {{ CONNECTORNAME }} .`,
  profileScreen_heading: "Connect",
  switchNetworkScreen_heading: "Changer de rseau",
  signInWithEthereumScreen_tooltip: "Vous ntes pas connect  cette application.\n**Connectez-vous avec Ethereum** pour continuer.",
  signInWithEthereumScreen_signedOut_heading: "Connectez-vous avec Ethereum",
  signInWithEthereumScreen_signedOut_h1: "Cette application souhaite vrifier que vous tes bien le propritaire de ce portefeuille.",
  signInWithEthereumScreen_signedOut_p: `Veuillez signer la demande de message dans votre portefeuille pour continuer.`,
  signInWithEthereumScreen_signedOut_button: "Se connecter",
  signInWithEthereumScreen_signedIn_heading: "Connect avec Ethereum",
  signInWithEthereumScreen_signedIn_h1: "Vous avez russi  vous identifier en tant que propritaire de ce portefeuille.",
  signInWithEthereumScreen_signedIn_p: `La dconnexion vous obligera  vous authentifier  nouveau  l'avenir.`,
  signInWithEthereumScreen_signedIn_button: "Se dconnecter"
};
var jaJP = {
  ...enUS,
  // fallback
  connectWallet: "",
  disconnect: "",
  connected: "",
  wrongNetwork: "",
  switchNetworks: "",
  chainNetwork: "{{ CHAIN }} ",
  copyToClipboard: "",
  copyCode: "",
  moreInformation: "",
  back: "",
  close: "",
  or: "",
  more: "",
  tryAgain: "",
  tryAgainQuestion: "",
  dontHaveTheApp: "",
  scanTheQRCode: "QR ",
  useWalletConnectModal: "WalletConnect ",
  useModal: "",
  installTheExtension: "",
  getWalletName: "{{ CONNECTORNAME }} ",
  otherWallets: "",
  learnMore: "",
  getWallet: "",
  approveInWallet: "",
  confirmInWallet: "",
  awaitingConfirmation: "",
  signIn: "",
  signOut: "",
  signedIn: "",
  signedOut: "",
  walletNotConnected: "",
  warnings_walletSwitchingUnsupported: ``,
  warnings_walletSwitchingUnsupportedResolve: ``,
  warnings_chainUnsupported: ``,
  warnings_chainUnsupportedResolve: ``,
  onboardingScreen_heading: ``,
  onboardingScreen_h1: `Web3 `,
  onboardingScreen_p: `web3 `,
  onboardingScreen_ctaText: ``,
  onboardingScreen_ctaUrl: `https://ethereum.org/ja/wallets/find-wallet/`,
  aboutScreen_heading: ``,
  aboutScreen_a_h1: ``,
  aboutScreen_a_p: `NFT  `,
  aboutScreen_b_h1: ``,
  aboutScreen_b_p: ``,
  aboutScreen_c_h1: `web3 `,
  aboutScreen_c_p: ` web3 `,
  aboutScreen_ctaText: ``,
  aboutScreen_ctaUrl: `https://ethereum.org/ja/wallets/`,
  connectorsScreen_heading: ``,
  connectorsScreen_newcomer: ``,
  connectorsScreen_h1: ``,
  connectorsScreen_p: ` `,
  mobileConnectorsScreen_heading: ``,
  scanScreen_heading: ``,
  scanScreen_heading_withConnector: `{{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `[WALLETCONNECTLOGO] WalletConnect  `,
  scanScreen_tooltip_default: ` {{ CONNECTORNAME }}  `,
  downloadAppScreen_heading: `{{ CONNECTORNAME }} `,
  downloadAppScreen_iosAndroid: `iOS  Android `,
  downloadAppScreen_ios: `iOS `,
  downloadAppScreen_android: `Android `,
  injectionScreen_unavailable_h1: ``,
  injectionScreen_unavailable_p: `{{ CONNECTORSHORTNAME }} {{ SUGGESTEDEXTENSIONBROWSER }} `,
  injectionScreen_install_h1: `{{ CONNECTORNAME }} `,
  injectionScreen_install_p: `{{ CONNECTORSHORTNAME }} `,
  injectionScreen_connecting_h1: ``,
  injectionScreen_connecting_p: `{{ CONNECTORSHORTNAME }}  `,
  injectionScreen_connecting_injected_h1: ``,
  injectionScreen_connecting_injected_p: ``,
  injectionScreen_connected_h1: ``,
  injectionScreen_connected_p: ``,
  injectionScreen_rejected_h1: ``,
  injectionScreen_rejected_p: ``,
  injectionScreen_failed_h1: ``,
  injectionScreen_failed_p: ``,
  injectionScreen_notconnected_h1: `{{ CONNECTORNAME }} `,
  injectionScreen_notconnected_p: ` {{ CONNECTORNAME }} `,
  profileScreen_heading: "",
  switchNetworkScreen_heading: "",
  signInWithEthereumScreen_tooltip: "\n****",
  signInWithEthereumScreen_signedOut_heading: "",
  signInWithEthereumScreen_signedOut_h1: " ",
  signInWithEthereumScreen_signedOut_p: `  `,
  signInWithEthereumScreen_signedOut_button: "",
  signInWithEthereumScreen_signedIn_heading: "",
  signInWithEthereumScreen_signedIn_h1: " ",
  signInWithEthereumScreen_signedIn_p: ` `,
  signInWithEthereumScreen_signedIn_button: ""
};
var ptBR = {
  ...enUS,
  // fallback
  connectWallet: "Conectar carteira",
  disconnect: "Desconectar",
  connected: "Conectado",
  wrongNetwork: "Rede incorreta",
  switchNetworks: "Alternar rede",
  chainNetwork: "Rede {{ CHAIN }}",
  copyToClipboard: "Copiar para a rea de transferncia",
  copyCode: "Copiar cdigo",
  moreInformation: "Mais informaes",
  back: "Voltar",
  close: "Fechar",
  or: "ou",
  more: "Mais",
  tryAgain: "Tentar novamente",
  tryAgainQuestion: "Tentar novamente?",
  dontHaveTheApp: "No tem o aplicativo?",
  scanTheQRCode: "Escaneie o cdigo QR",
  useWalletConnectModal: "Use o modal do WalletConnect",
  useModal: "Usar modal",
  installTheExtension: "Instale a extenso",
  getWalletName: "Obter {{ CONNECTORNAME }}",
  otherWallets: "Outras carteiras",
  learnMore: "Saiba mais",
  getWallet: "Obtenha uma carteira",
  approveInWallet: "Aprovar na carteira",
  confirmInWallet: "Confirmar na carteira",
  awaitingConfirmation: "Aguardando confirmao",
  signIn: "Entrar",
  signOut: "Sair",
  signedIn: "Conectado",
  signedOut: "Desconectado",
  walletNotConnected: "Carteira no conectada",
  warnings_walletSwitchingUnsupported: `A sua carteira no permite a troca de rede a partir deste aplicativo.`,
  warnings_walletSwitchingUnsupportedResolve: `Tente trocar de rede de dentro da sua carteira.`,
  warnings_chainUnsupported: `Este aplicativo no  compatvel com a rede conectada.`,
  warnings_chainUnsupportedResolve: `Altere a rede ou desconecte para continuar.`,
  onboardingScreen_heading: `Obtenha uma carteira`,
  onboardingScreen_h1: `Comece a explorar a Web3`,
  onboardingScreen_p: `Sua carteira  a porta de entrada para todas as coisas Ethereum, a tecnologia mgica que torna possvel explorar a web3.`,
  onboardingScreen_ctaText: `Escolha sua primeira carteira`,
  onboardingScreen_ctaUrl: `https://ethereum.org/pt-br/wallets/find-wallet/`,
  aboutScreen_heading: `Sobre as carteiras`,
  aboutScreen_a_h1: `Para seus ativos digitais`,
  aboutScreen_a_p: `As carteiras permitem que voc envie, receba, armazene e interaja com ativos digitais como NFTs e outros tokens Ethereum.`,
  aboutScreen_b_h1: `Uma maneira melhor de fazer login`,
  aboutScreen_b_p: `Com aplicativos modernos, sua carteira pode ser usada como uma maneira fcil de fazer login, em vez de ter que lembrar uma senha.`,
  aboutScreen_c_h1: `Explore o mundo da Web3`,
  aboutScreen_c_p: `Sua carteira  uma utilidade essencial que permite explorar e participar do mundo em rpida evoluo da Web3.`,
  aboutScreen_ctaText: `Saiba mais`,
  aboutScreen_ctaUrl: `https://ethereum.org/pt-br/wallets/`,
  connectorsScreen_heading: `Conectar carteira`,
  connectorsScreen_newcomer: `Eu no tenho uma carteira`,
  connectorsScreen_h1: `O que  uma carteira?`,
  connectorsScreen_p: `As carteiras so usadas para enviar, receber e armazenar ativos digitais. A conexo de uma carteira permite que voc interaja com aplicativos.`,
  mobileConnectorsScreen_heading: `Escolha uma carteira`,
  scanScreen_heading: `Escanear com o celular`,
  scanScreen_heading_withConnector: `Escanear com o {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Abra uma carteira compatvel 
com o WalletConnect [WALLETCONNECTLOGO] para escanear`,
  scanScreen_tooltip_default: `Abra o {{ CONNECTORNAME }} no 
seu celular para escanear`,
  downloadAppScreen_heading: `Obter {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Escaneie com a cmera do seu celular para baixar no iOS ou Android.`,
  downloadAppScreen_ios: `Escaneie com a cmera do seu celular para baixar no iOS.`,
  downloadAppScreen_android: `Escaneie com a cmera do seu celular para baixar no Android.`,
  injectionScreen_unavailable_h1: `Navegador no compatvel`,
  injectionScreen_unavailable_p: `Para conectar sua carteira {{ CONNECTORSHORTNAME }},
instale a extenso no {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Instalar {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `Para conectar sua carteira {{ CONNECTORSHORTNAME }},
instale a extenso do navegador`,
  injectionScreen_connecting_h1: `Solicitando conexo`,
  injectionScreen_connecting_p: `Abra a extenso do navegador do {{ CONNECTORSHORTNAME }} 
para conectar a sua carteira.`,
  injectionScreen_connecting_injected_h1: `Solicitando conexo`,
  injectionScreen_connecting_injected_p: `Aceite a solicitao por meio de sua carteira para se conectar a este aplicativo.`,
  injectionScreen_connected_h1: `J conectado`,
  injectionScreen_connected_p: `Agora voc j pode fechar esta janela`,
  injectionScreen_rejected_h1: `Solicitao cancelada`,
  injectionScreen_rejected_p: `Voc cancelou a solicitao.
Clique acima para tentar novamente.`,
  injectionScreen_failed_h1: `A conexo falhou`,
  injectionScreen_failed_p: `Desculpe, ocorreu um erro.
Por favor, tente conectar novamente.`,
  injectionScreen_notconnected_h1: `Faa login no {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `Para continuar, faa login na sua extenso do {{ CONNECTORNAME }}.`,
  profileScreen_heading: "Conectado",
  switchNetworkScreen_heading: "Alternar rede",
  signInWithEthereumScreen_tooltip: "Voc no est conectado a este aplicativo.\n**Entre com Ethereum** para continuar.",
  signInWithEthereumScreen_signedOut_heading: "Entrar com Ethereum",
  signInWithEthereumScreen_signedOut_h1: "Este aplicativo gostaria de verificar voc \n como o proprietrio desta carteira.",
  signInWithEthereumScreen_signedOut_p: `Por favor, assine o pedido de mensagem 
 em sua carteira para continuar.`,
  signInWithEthereumScreen_signedOut_button: "Entrar",
  signInWithEthereumScreen_signedIn_heading: "Conectado com Ethereum",
  signInWithEthereumScreen_signedIn_h1: "Voc se verificou com sucesso \n como o proprietrio desta carteira",
  signInWithEthereumScreen_signedIn_p: `Se sair, ser necessrio que voc 
 autentique novamente no futuro.`,
  signInWithEthereumScreen_signedIn_button: "Sair"
};
var ruRU = {
  ...enUS,
  // fallback
  connectWallet: " ",
  disconnect: "",
  connected: "",
  wrongNetwork: " ",
  switchNetworks: " ",
  chainNetwork: " {{ CHAIN }}",
  copyToClipboard: "   ",
  copyCode: " ",
  moreInformation: " ",
  back: "",
  close: "",
  or: "",
  more: "",
  tryAgain: " ",
  tryAgainQuestion: " ?",
  dontHaveTheApp: "   ?",
  scanTheQRCode: " QR-",
  useWalletConnectModal: "  WalletConnect",
  useModal: "  ",
  installTheExtension: " ",
  getWalletName: " {{ CONNECTORNAME }}",
  otherWallets: " ",
  learnMore: " ",
  getWallet: " ",
  approveInWallet: "",
  confirmInWallet: "",
  awaitingConfirmation: " ",
  signIn: "",
  signOut: "",
  signedIn: "",
  signedOut: "",
  walletNotConnected: "  ",
  warnings_walletSwitchingUnsupported: `        .`,
  warnings_walletSwitchingUnsupportedResolve: `        .`,
  warnings_chainUnsupported: `      .`,
  warnings_chainUnsupportedResolve: `      .`,
  onboardingScreen_heading: ` `,
  onboardingScreen_h1: `  3`,
  onboardingScreen_p: `       Ethereum,  ,    3.`,
  onboardingScreen_ctaText: `   `,
  onboardingScreen_ctaUrl: `https://ethereum.org/en/wallets/find-wallet/`,
  aboutScreen_heading: ` `,
  aboutScreen_a_h1: `   `,
  aboutScreen_a_p: `   , ,      ,   NFT    Ethereum.`,
  aboutScreen_b_h1: `  `,
  aboutScreen_b_p: `              .`,
  aboutScreen_c_h1: `  3`,
  aboutScreen_c_p: `  -   ,           3.`,
  aboutScreen_ctaText: ` `,
  aboutScreen_ctaUrl: `https://ethereum.org/en/wallets/`,
  connectorsScreen_heading: ` `,
  connectorsScreen_newcomer: `   `,
  connectorsScreen_h1: `  ?`,
  connectorsScreen_p: `   ,     .       .`,
  mobileConnectorsScreen_heading: ` `,
  scanScreen_heading: `  `,
  scanScreen_heading_withConnector: `   {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: ` [WALLETCONNECTLOGO]  WalletConnect   `,
  scanScreen_tooltip_default: ` {{ CONNECTORNAME }}      `,
  downloadAppScreen_heading: ` {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `       iOS  Android.`,
  downloadAppScreen_ios: `       iOS.`,
  downloadAppScreen_android: `       Android.`,
  injectionScreen_unavailable_h1: ` `,
  injectionScreen_unavailable_p: `    {{ CONNECTORSHORTNAME }},     {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: ` {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `    {{ CONNECTORSHORTNAME }},    .`,
  injectionScreen_connecting_h1: `  `,
  injectionScreen_connecting_p: `    {{ CONNECTORSHORTNAME }}    .`,
  injectionScreen_connecting_injected_h1: `  `,
  injectionScreen_connecting_injected_p: `    ,    .`,
  injectionScreen_connected_h1: ` `,
  injectionScreen_connected_p: `   `,
  injectionScreen_rejected_h1: ` `,
  injectionScreen_rejected_p: `  .
 ,   .`,
  injectionScreen_failed_h1: ` `,
  injectionScreen_failed_p: `, -   .
,   .`,
  injectionScreen_notconnected_h1: `  {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `     {{ CONNECTORNAME }}.`,
  profileScreen_heading: " ",
  switchNetworkScreen_heading: " ",
  signInWithEthereumScreen_tooltip: "     .\n**   Ethereum**,  .",
  signInWithEthereumScreen_signedOut_heading: "   Ethereum",
  signInWithEthereumScreen_signedOut_h1: "     \n     .",
  signInWithEthereumScreen_signedOut_p: `,     
   ,  .`,
  signInWithEthereumScreen_signedOut_button: "",
  signInWithEthereumScreen_signedIn_heading: "   Ethereum",
  signInWithEthereumScreen_signedIn_h1: "    \n     .",
  signInWithEthereumScreen_signedIn_p: `  
    .`,
  signInWithEthereumScreen_signedIn_button: ""
};
var zhCN = {
  ...enUS,
  // fallback
  connectWallet: "",
  disconnect: "",
  connected: "",
  wrongNetwork: "",
  switchNetworks: "",
  chainNetwork: "{{ CHAIN }}",
  copyToClipboard: "",
  copyCode: "",
  moreInformation: "",
  back: "",
  close: "",
  or: "",
  more: "",
  tryAgain: "",
  tryAgainQuestion: "",
  dontHaveTheApp: "",
  scanTheQRCode: "",
  useWalletConnectModal: " WalletConnect ",
  useModal: "",
  installTheExtension: "",
  getWalletName: "{{ CONNECTORNAME }}",
  otherWallets: "",
  learnMore: "",
  getWallet: "",
  approveInWallet: "",
  confirmInWallet: "",
  awaitingConfirmation: "",
  signIn: "",
  signOut: "",
  signedIn: "",
  signedOut: "",
  walletNotConnected: "",
  warnings_walletSwitchingUnsupported: ``,
  warnings_walletSwitchingUnsupportedResolve: ``,
  warnings_chainUnsupported: ``,
  warnings_chainUnsupportedResolve: ``,
  onboardingScreen_heading: ``,
  onboardingScreen_h1: ` Web3`,
  onboardingScreen_p: ` Web3 `,
  onboardingScreen_ctaText: ``,
  onboardingScreen_ctaUrl: `https://ethereum.org/zh/wallets/find-wallet/`,
  aboutScreen_heading: ``,
  aboutScreen_a_h1: ``,
  aboutScreen_a_p: ` NFT `,
  aboutScreen_b_h1: ``,
  aboutScreen_b_p: ``,
  aboutScreen_c_h1: ` Web3 `,
  aboutScreen_c_p: ` Web3 `,
  aboutScreen_ctaText: ``,
  aboutScreen_ctaUrl: `https://ethereum.org/zh/wallets/`,
  connectorsScreen_heading: ``,
  connectorsScreen_newcomer: ``,
  connectorsScreen_h1: ``,
  connectorsScreen_p: ``,
  mobileConnectorsScreen_heading: ``,
  scanScreen_heading: ``,
  scanScreen_heading_withConnector: `{{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: ` [WALLETCONNECTLOGO] WalletConnect `,
  scanScreen_tooltip_default: `{{ CONNECTORNAME }} `,
  downloadAppScreen_heading: `{{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: ` iOS  Android `,
  downloadAppScreen_ios: ` iOS `,
  downloadAppScreen_android: ` Android `,
  injectionScreen_unavailable_h1: ``,
  injectionScreen_unavailable_p: `{{ CONNECTORSHORTNAME }}{{ SUGGESTEDEXTENSIONBROWSER }}`,
  injectionScreen_install_h1: `{{ CONNECTORNAME }}`,
  injectionScreen_install_p: `{{ CONNECTORSHORTNAME }}`,
  injectionScreen_connecting_h1: ``,
  injectionScreen_connecting_p: `{{ CONNECTORSHORTNAME }} `,
  injectionScreen_connecting_injected_h1: ``,
  injectionScreen_connecting_injected_p: ``,
  injectionScreen_connected_h1: ``,
  injectionScreen_connected_p: ``,
  injectionScreen_rejected_h1: ``,
  injectionScreen_rejected_p: ``,
  injectionScreen_failed_h1: ``,
  injectionScreen_failed_p: ``,
  injectionScreen_notconnected_h1: `{{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `{{ CONNECTORNAME }}`,
  profileScreen_heading: "",
  switchNetworkScreen_heading: "",
  signInWithEthereumScreen_tooltip: "\n****",
  signInWithEthereumScreen_signedOut_heading: "",
  signInWithEthereumScreen_signedOut_h1: " ",
  signInWithEthereumScreen_signedOut_p: ` `,
  signInWithEthereumScreen_signedOut_button: "",
  signInWithEthereumScreen_signedIn_heading: "",
  signInWithEthereumScreen_signedIn_h1: " ",
  signInWithEthereumScreen_signedIn_p: ` `,
  signInWithEthereumScreen_signedIn_button: ""
};
var caAD = {
  ...enUS,
  // fallback
  connectWallet: "Connecta la cartera",
  disconnect: "Desconnectar",
  connected: "Connectat",
  wrongNetwork: "Xarxa incorrecta",
  switchNetworks: "Canvi de xarxa",
  chainNetwork: "Xarxa {{ CHAIN }}",
  copyToClipboard: "Copia al portapapers",
  copyCode: "Copia codi",
  moreInformation: "Ms informaci",
  back: "Enrere",
  close: "Tanca",
  or: "o",
  more: "Ms",
  tryAgain: "Torna-ho a intentar",
  tryAgainQuestion: "Tornar a intentar-ho?",
  dontHaveTheApp: "No tens l'aplicaci?",
  scanTheQRCode: "Escaneja el codi QR",
  useWalletConnectModal: "Utilitza WalletConnect Modal",
  useModal: "Utilitza Modal",
  installTheExtension: "Installa l'extensi",
  getWalletName: "Obt {{ CONNECTORNAME }}",
  otherWallets: "Altres carteres",
  learnMore: "Ms informaci",
  getWallet: "Obt una cartera",
  approveInWallet: "Aprova a la cartera",
  confirmInWallet: "Confirma a la cartera",
  awaitingConfirmation: "Esperant confirmaci",
  signIn: "Inicia sessi",
  signOut: "Tanca sessi",
  signedIn: "Sessi iniciada",
  signedOut: "Sessi tancada",
  walletNotConnected: "Cartera no connectada",
  warnings_walletSwitchingUnsupported: `La teva cartera no permet canviar de xarxa des d'aquesta aplicaci.`,
  warnings_walletSwitchingUnsupportedResolve: `Prova a canviar de xarxa des de la teva cartera.`,
  warnings_chainUnsupported: `Aquesta aplicaci no s compatible amb la xarxa connectada actualment.`,
  warnings_chainUnsupportedResolve: `Canvia o desconnecta per continuar.`,
  onboardingScreen_heading: `Obt una cartera`,
  onboardingScreen_h1: `Comena a explorar la Web3`,
  onboardingScreen_p: `La teva cartera s el portal d'accs a tot el relacionat amb Ethereum, la tecnologia mgica que permet explorar la Web3.`,
  onboardingScreen_ctaText: `Tria la teva primera cartera`,
  onboardingScreen_ctaUrl: `https://ethereum.org/es/wallets/find-wallet/`,
  aboutScreen_heading: `Sobre les carteres`,
  aboutScreen_a_h1: `Per als teus actius digitals`,
  aboutScreen_a_p: `Les carteres et permeten enviar, rebre, emmagatzemar i interactuar amb actius digitals com els NFT i altres tokens d'Ethereum.`,
  aboutScreen_b_h1: `Una manera millor d'iniciar sessi`,
  aboutScreen_b_p: `Amb les aplicacions modernes, pots utilitzar la teva cartera per iniciar sessi fcilment, en lloc de haver de recordar una contrasenya.`,
  aboutScreen_c_h1: `Explora el mn de la Web3`,
  aboutScreen_c_p: `La teva cartera s una eina essencial que et permet explorar i participar en el mn en rpida evoluci de la Web3.`,
  aboutScreen_ctaText: `Ms informaci`,
  aboutScreen_ctaUrl: `https://ethereum.org/es/wallets/`,
  connectorsScreen_heading: `Connecta una cartera`,
  connectorsScreen_newcomer: `No tinc una cartera`,
  connectorsScreen_h1: `Qu s una cartera?`,
  connectorsScreen_p: `Les carteres s'utilitzen per enviar, rebre i emmagatzemar actius digitals. Si connectes una cartera, podrs interactuar amb les aplicacions.`,
  mobileConnectorsScreen_heading: `Tria una cartera`,
  scanScreen_heading: `Escaneja amb el telfon`,
  scanScreen_heading_withConnector: `Escaneja amb {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `Obre una cartera compatible amb WalletConnect [WALLETCONNECTLOGO] per escanejar`,
  scanScreen_tooltip_default: `Obre {{ CONNECTORNAME }} en el teu telfon mbil per escanejar`,
  downloadAppScreen_heading: `Obt {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Escaneja amb la cmera del teu telfon per descarregar-la en iOS o Android.`,
  downloadAppScreen_ios: `Escaneja amb la cmera del teu telfon per descarregar-la en iOS.`,
  downloadAppScreen_android: `Escaneja amb la cmera del teu telfon per descarregar-la en Android.`,
  injectionScreen_unavailable_h1: `Navegador no compatible`,
  injectionScreen_unavailable_p: `Per connectar la teva cartera de {{ CONNECTORSHORTNAME }}, installa l'extensi en {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Installa {{ CONNECTORNAME }}`,
  injectionScreen_install_p: `Per connectar la teva cartera de {{ CONNECTORSHORTNAME }}, installa l'extensi del navegador.`,
  injectionScreen_connecting_h1: `Sollicitud de connexi`,
  injectionScreen_connecting_p: `Obre l'extensi del navegador de {{ CONNECTORSHORTNAME }}  per connectar la teva cartera.`,
  injectionScreen_connecting_injected_h1: `Sollicitud de connexi`,
  injectionScreen_connecting_injected_p: `Accepta la sollicitud a travs de la teva cartera per connectar-te a aquesta aplicaci.`,
  injectionScreen_connected_h1: `Ja connectada`,
  injectionScreen_connected_p: `Ja pots tancar aquesta finestra emergent`,
  injectionScreen_rejected_h1: `Sollicitud cancellada`,
  injectionScreen_rejected_p: `Has cancellat la sollicitud. Fes clic a dalt per tornar-ho a intentar.`,
  injectionScreen_failed_h1: `Error de connexi`,
  injectionScreen_failed_p: `Ho sentim, hi ha hagut un problema. Intenta connectar-te de nou.`,
  injectionScreen_notconnected_h1: `Inicia sessi en {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: `Per continuar, inicia sessi en la teva extensi de {{ CONNECTORNAME }}.`,
  profileScreen_heading: "Connectat",
  switchNetworkScreen_heading: "Canvi de xarxa",
  signInWithEthereumScreen_tooltip: "No has iniciat sessi en aquesta aplicaci.\n**Inicia sessi amb Ethereum** per continuar.",
  signInWithEthereumScreen_signedOut_heading: "Inicia sessi amb Ethereum",
  signInWithEthereumScreen_signedOut_h1: "Aquesta aplicaci vol verificar que ets el propietari d'aquesta cartera.",
  signInWithEthereumScreen_signedOut_p: `Signa la sollicitud de missatge en la teva cartera per continuar.`,
  signInWithEthereumScreen_signedOut_button: "Inicia sessi",
  signInWithEthereumScreen_signedIn_heading: "Sessi iniciada amb Ethereum",
  signInWithEthereumScreen_signedIn_h1: "T'has verificat correctament com a propietari d'aquesta cartera.",
  signInWithEthereumScreen_signedIn_p: `Si tanques la sessi, haurs de tornar a autenticar-te ms endavant.`,
  signInWithEthereumScreen_signedIn_button: "Tanca sessi"
};
var trTR = {
  ...enUS,
  // fallback
  connectWallet: "Czdan Bala",
  disconnect: "Balanty Kes",
  connected: "Baland",
  wrongNetwork: "Yanl A",
  switchNetworks: "A Deitir",
  chainNetwork: "{{ CHAIN }} A",
  copyToClipboard: "Panoya Kopyala",
  copyCode: "Kodu Kopyala",
  moreInformation: "Daha Fazla Bilgi",
  back: "Geri",
  close: "Kapat",
  or: "veya",
  more: "Daha Fazla",
  tryAgain: "Tekrar Dene",
  tryAgainQuestion: "Tekrar Dene?",
  dontHaveTheApp: "Uygulaman yok mu?",
  scanTheQRCode: "Karekodu tarat",
  useWalletConnectModal: "WalletConnect Modalini Kullan ",
  useModal: "Modal Kullan",
  installTheExtension: "Eklentiyi ndir",
  getWalletName: "{{ CONNECTORNAME }} Aln",
  otherWallets: "Dier Czdanlar",
  learnMore: "Daha Fazlasn ren",
  getWallet: "Czdan Al",
  approveInWallet: "Czdanda Yetki Ver",
  confirmInWallet: "Czdanda Onayla",
  awaitingConfirmation: "Dorulama Bekleniyor",
  signIn: "Giri Yap",
  signOut: "k Yap",
  signedIn: "Giri Yapld",
  signedOut: "k Yapld",
  walletNotConnected: "Czdan Bal Deil",
  warnings_walletSwitchingUnsupported: `Bu uygulamada a deitirmeyi czdann desteklemiyor.`,
  warnings_walletSwitchingUnsupportedResolve: `Bunun yerine czdannzdan alar deitirmeyi deneyin.`,
  warnings_chainUnsupported: `Bu uygulama kullanm olduunuz a desteklemiyor.`,
  warnings_chainUnsupportedResolve: `Devam etmek iin a deitir veya balanty kes.`,
  onboardingScreen_heading: `Czdan Al`,
  onboardingScreen_h1: `Web3' kefetmeye bala`,
  onboardingScreen_p: `Czdannz, Web3' kefetmeyi mmkn klan sihirli teknoloji olan Ethereum'a alan kapdr.`,
  onboardingScreen_ctaText: `lk Czdann Se`,
  onboardingScreen_ctaUrl: `https://ethereum.org/tr/wallets/find-wallet/`,
  aboutScreen_heading: `Czdanlar Hakknda`,
  aboutScreen_a_h1: `Dijital varlklarn iin`,
  aboutScreen_a_p: `Czdanlar, NFT'ler ve dier Ethereum varlklar gibi dijital varlklar gndermenize, almanza, saklamanza ve bunlarla etkileim kurmanza olanak tanr.`,
  aboutScreen_b_h1: `Giri yapmann daha iyi bir yolu`,
  aboutScreen_b_p: `Modern uygulamalar ile parola hatrlamak yerine czdannz ile kolayca giri yapabilirsiniz.`,
  aboutScreen_c_h1: `Web3 dnyasn kefet`,
  aboutScreen_c_p: `Czdannz, hzla gelien Web3 dnyasn kefetmenizi ve bu dnyaya katlmanz salayan temel bir yardmc programdr.`,
  aboutScreen_ctaText: `Daha Fazlasn ren`,
  aboutScreen_ctaUrl: `https://ethereum.org/tr/wallets/`,
  connectorsScreen_heading: `Czdan Bala`,
  connectorsScreen_newcomer: `Czdanm Yok`,
  connectorsScreen_h1: `Czdan nedir?`,
  connectorsScreen_p: `Czdanlar, dijital varlklar gndermek, almak ve depolamak iin kullanlr. Bir czdan balamak, uygulamalarla etkileime gemenizi salar.`,
  mobileConnectorsScreen_heading: `Czdan Se`,
  scanScreen_heading: `Telefon ile Tarat`,
  scanScreen_heading_withConnector: `{{ CONNECTORNAME }} ile tarat`,
  scanScreen_tooltip_walletConnect: `Desteklenen bir czdan taramak iin
 [WALLETCONNECTLOGO] WalletConnect uygulamasn a`,
  scanScreen_tooltip_default: `Taramak iin telefonunda
 {{ CONNECTORNAME }} uygulamasn a`,
  downloadAppScreen_heading: `{{ CONNECTORNAME }} ndir`,
  downloadAppScreen_iosAndroid: `iOS ve Android'e indirmek iin telefon kameran ile tarat.`,
  downloadAppScreen_ios: `iOS'a indirmek iin telefon kameran ile tarat.`,
  downloadAppScreen_android: `Android'e indirmek iin telefon kameran ile tarat.`,
  injectionScreen_unavailable_h1: `Desteklenmeyen Tarayc`,
  injectionScreen_unavailable_p: `{{ CONNECTORSHORTNAME }} czdanna balanmak iin
{{ SUGGESTEDEXTENSIONBROWSER }} zerinde indirmen gerekiyor.`,
  injectionScreen_install_h1: `{{ CONNECTORNAME }} ndir`,
  injectionScreen_install_p: `{{ CONNECTORSHORTNAME }} czdanna balanmak iin,
tarayc eklentisini indir.`,
  injectionScreen_connecting_h1: `Balant steniyor.`,
  injectionScreen_connecting_p: `Czdann balamak iin
 taraycdan {{ CONNECTORSHORTNAME }} uzantsn an.`,
  injectionScreen_connecting_injected_h1: `Balant steniyor.`,
  injectionScreen_connecting_injected_p: `Bu uygulamaya balanmak iin czdanna gelen istei kabul et.`,
  injectionScreen_connected_h1: `Zaten Balanm`,
  injectionScreen_connected_p: `Bu alr pencereyi artk kapatabilirsin`,
  injectionScreen_rejected_h1: `stek iptal edildi.`,
  injectionScreen_rejected_p: `stei iptal ettin.
Tekrar denemek iin yukary tklayn.`,
  injectionScreen_failed_h1: `Balant Baarsz`,
  injectionScreen_failed_p: `zgnz, bir eyler ters gitti.
Ltfen daha sonra tekrar deneyin.`,
  injectionScreen_notconnected_h1: `{{ CONNECTORNAME }} ile giri yap`,
  injectionScreen_notconnected_p: `Devam etmek iin, {{ CONNECTORNAME }} eklentisine giri yapn.`,
  profileScreen_heading: "Baland",
  switchNetworkScreen_heading: "A Deitir",
  signInWithEthereumScreen_tooltip: "Bu uygulamada oturum amadnz.\n Devam etmek iin **Ethereum le Giri Yap**.",
  signInWithEthereumScreen_signedOut_heading: "Ethereum le Giri Yap",
  signInWithEthereumScreen_signedOut_h1: "Bu uygulama seni \n bu czdann sahibi olarak dorulamak istiyor.",
  signInWithEthereumScreen_signedOut_p: `Devam etmek iin 
 czdannzdaki istei onaylayn.`,
  signInWithEthereumScreen_signedOut_button: "Giri Yap",
  signInWithEthereumScreen_signedIn_heading: "Ethereum le Giri Yapld",
  signInWithEthereumScreen_signedIn_h1: "Bu czdann sahibi olduunu \n baaryla onayladn.",
  signInWithEthereumScreen_signedIn_p: `k yaparsan ileride 
 tekrar giri yapman gerekecek. `,
  signInWithEthereumScreen_signedIn_button: "k Yap"
};
var viVN = {
  ...enUS,
  // fallback
  connectWallet: "Kt ni v",
  disconnect: "Ngt kt ni",
  connected: " kt ni",
  wrongNetwork: "Mng khng h tr",
  switchNetworks: "i mng",
  chainNetwork: "Mng {{ CHAIN }}",
  copyToClipboard: "Sao chp",
  copyCode: "Sao chp m",
  moreInformation: "Thm thng tin",
  back: "Quay li",
  close: "ng",
  or: "hoc",
  more: "Thm",
  tryAgain: "Th li",
  tryAgainQuestion: "Th li?",
  dontHaveTheApp: "Khng c app?",
  scanTheQRCode: "Qut m QR",
  useWalletConnectModal: "Dng WalletConnect Modal",
  useModal: "Dng Modal",
  installTheExtension: "Ci tin ch",
  getWalletName: "Ly {{ CONNECTORNAME }}",
  otherWallets: "Cc v khc",
  learnMore: "Xem thm",
  getWallet: "To mt v",
  approveInWallet: "Cp quyn trong v",
  confirmInWallet: "Xc nhn trong v",
  awaitingConfirmation: "ang ch xc nhn",
  signIn: "ng nhp",
  signOut: "ng xut",
  signedIn: " ng nhp",
  signedOut: " ng xut",
  walletNotConnected: "Cha kt ni v",
  warnings_walletSwitchingUnsupported: `V ca bn khng h tr i mng t ng dng.`,
  warnings_walletSwitchingUnsupportedResolve: `Hy th i mng t pha v ca bn.`,
  warnings_chainUnsupported: `ng dng ny khng h tr mng hin ti.`,
  warnings_chainUnsupportedResolve: `i hoc ngt kt ni  tip tc.`,
  onboardingScreen_heading: `To mt v`,
  onboardingScreen_h1: `Bt u khm kh Web3`,
  onboardingScreen_p: `V ca bn l cng giao tip mi th trn Ethereum, cng ngh tuyt vi gip khm ph Web3.`,
  onboardingScreen_ctaText: `Chn v u tin ca bn`,
  onboardingScreen_ctaUrl: `https://ethereum.org/en/wallets/find-wallet/`,
  aboutScreen_heading: `Gii thiu cc v`,
  aboutScreen_a_h1: `Cho ti sn s ca bn`,
  aboutScreen_a_p: `Cc v  bn gi, nhn, lu tr, v tng tc vi cc ti sn in t nh NFTs v cc loi tin Ethereum khc.`,
  aboutScreen_b_h1: `Mt cch tt hn  ng nhp`,
  aboutScreen_b_p: `Vi cc ng dng hin i, v ca bn c th dng  ng nhp d dng thay v phi nh ti khon v mt khu.`,
  aboutScreen_c_h1: `Khm ph th gii Web3`,
  aboutScreen_c_p: `V ca bn l mt tin ch thit yu cho php bn khm ph v tham gia vo th gii web3 ang pht trin nhanh chng.`,
  aboutScreen_ctaText: `Tm hiu thm`,
  aboutScreen_ctaUrl: `https://ethereum.org/en/wallets/`,
  connectorsScreen_heading: `Kt ni V`,
  connectorsScreen_newcomer: `Ti cha c v`,
  connectorsScreen_h1: `V l g?`,
  connectorsScreen_p: `V dng  gi, nhn, v lu tr cc ti sn in t. Kt ni vi mt v gip bn tng tc vi cc ng dng.`,
  mobileConnectorsScreen_heading: `Chn v`,
  scanScreen_heading: `Scan bng in thoi`,
  scanScreen_heading_withConnector: `Qut vi {{ CONNECTORNAME }}`,
  scanScreen_tooltip_walletConnect: `M mt [WALLETCONNECTLOGO] m WalletConnect 
 h tr  qut`,
  scanScreen_tooltip_default: `M {{ CONNECTORNAME }} trong 
in thoi ca bn  qut`,
  downloadAppScreen_heading: `Ly {{ CONNECTORNAME }}`,
  downloadAppScreen_iosAndroid: `Qut bng camera trn in thoi ca bn  ti v cho iOS hoc Android.`,
  downloadAppScreen_ios: `Qut bng camera trn in thoi a bn  ti v cho iOS.`,
  downloadAppScreen_android: `Qut bng camera trn in thoi a bn  ti v cho Android.`,
  injectionScreen_unavailable_h1: `Trnh duyt khng c h tr`,
  injectionScreen_unavailable_p: ` kt ni v {{ CONNECTORSHORTNAME }} ca bn,
ci t tin ch trn {{ SUGGESTEDEXTENSIONBROWSER }}.`,
  injectionScreen_install_h1: `Ci {{ CONNECTORNAME }}`,
  injectionScreen_install_p: ` kt ni v {{ CONNECTORSHORTNAME }},
ci t tin ch trn trnh duyt.`,
  injectionScreen_connecting_h1: `ang yu cu kt ni`,
  injectionScreen_connecting_p: `M tin ch {{ CONNECTORSHORTNAME }} 
 trn trnh duyt  kt ni.`,
  injectionScreen_connecting_injected_h1: `ang yu cu kt ni`,
  injectionScreen_connecting_injected_p: `ng  yu cu t pha v ca bn  kt ni ng dng ny.`,
  injectionScreen_connected_h1: ` kt ni`,
  injectionScreen_connected_p: ` c th ng popup`,
  injectionScreen_rejected_h1: ` hy yu cu`,
  injectionScreen_rejected_p: `Bn va hy yu cu.
Nhn pha trn  th li.`,
  injectionScreen_failed_h1: `Kt ni khng thnh cng`,
  injectionScreen_failed_p: `Xin li, c g  khng ng.
Vui lng th li.`,
  injectionScreen_notconnected_h1: `ng nhp vo {{ CONNECTORNAME }}`,
  injectionScreen_notconnected_p: ` tip tc, vui lng ng nhp bng tin ch {{ CONNECTORNAME }}.`,
  profileScreen_heading: " kt ni",
  switchNetworkScreen_heading: "i mng",
  signInWithEthereumScreen_tooltip: "Bn cha ng nhp vo ng dng.\n**ng nhp qua Ethereum**  tip tc.",
  signInWithEthereumScreen_signedOut_heading: "ng nhp qua Ethereum",
  signInWithEthereumScreen_signedOut_h1: "ng dng ny mun xc nhn bn \n l ch s hu ca v.",
  signInWithEthereumScreen_signedOut_p: `Vui lng k tin nhn yu cu 
 trn v ca bn  tip tc.`,
  signInWithEthereumScreen_signedOut_button: "ng nhp",
  signInWithEthereumScreen_signedIn_heading: "ng nhp qua Ethereum",
  signInWithEthereumScreen_signedIn_h1: "Bn  xc nhn thnh cng.",
  signInWithEthereumScreen_signedIn_p: `Sau khi ng xut bn s cn 
 xc nhn li trong ln tip theo.`,
  signInWithEthereumScreen_signedIn_button: "ng xut"
};
var getLocale = (lang) => {
  switch (lang) {
    case "ee-EE":
      return eeEE;
    case "ar-AE":
      return arAE;
    case "es-ES":
      return esES;
    case "fa-IR":
      return faIR;
    case "fr-FR":
      return frFR;
    case "ja-JP":
      return jaJP;
    case "pt-BR":
      return ptBR;
    case "ru-RU":
      return ruRU;
    case "zh-CN":
      return zhCN;
    case "ca-AD":
      return caAD;
    case "tr-TR":
      return trTR;
    case "vi-VN":
      return viVN;
    default:
      return enUS;
  }
};
function useLocales(replacements) {
  var _a2, _b;
  const context = useContext21();
  const language = (_b = (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.language) !== null && _b !== void 0 ? _b : "en-US";
  const translations = (0, import_react70.useMemo)(() => {
    return getLocale(language);
  }, [language]);
  if (!translations) {
    console.error(`Missing translations for: ${language}`);
    return `Missing translations for: ${language}`;
  }
  const translated = {};
  Object.keys(translations).map((key) => {
    const string = translations[key];
    return translated[key] = localize(string, replacements);
  });
  return translated;
}
var localize = (text, replacements) => {
  let parsedText = text;
  if (replacements) {
    Object.keys(replacements).forEach((key) => {
      parsedText = parsedText.replace(new RegExp(`({{ ${key} }})`, "g"), replacements[key]);
    });
  }
  return replaceMarkdown(parsedText);
};
var replaceMarkdown = (markdownText) => {
  let text = markdownText;
  text = text.split("\n");
  text = text.map((t2, i2) => {
    return (0, import_jsx_runtime.jsxs)(import_react70.default.Fragment, { children: [wrapTags(t2), i2 < text.length - 1 && (0, import_jsx_runtime.jsx)("br", {})] }, i2);
  });
  return text;
};
var wrapTags = (text) => {
  const textArray = text.split(/(\*\*[^\*]*\*\*)/g);
  let result = textArray.map((str, i2) => {
    if (/(\*\*.*\*\*)/g.test(str)) {
      return (0, import_jsx_runtime.jsx)("strong", { children: str.replace(/\*\*/g, "") }, i2);
    }
    return `${str}`;
  });
  return result.map((r2) => {
    if (typeof r2 === "string") {
      return r2.split(/(\[WALLETCONNECTLOGO\])/g).map((s2) => {
        if (s2 === "[WALLETCONNECTLOGO]") {
          return (0, import_jsx_runtime.jsx)("span", { className: "ck-tt-logo", children: (0, import_jsx_runtime.jsx)(Logos.WalletConnect, {}) }, s2);
        }
        return s2;
      });
    }
    return r2;
  });
};
var LOG_LEVEL = {
  debug: 10,
  info: 20,
  warn: 30,
  error: 40,
  none: 100
};
var useIsoLayoutEffect = typeof window !== "undefined" && window.document && window.document.createElement !== void 0 ? import_react70.useLayoutEffect : import_react70.useEffect;
var useFitText = ({ logLevel: logLevelOption = "info", maxFontSize = 100, minFontSize = 20, onFinish, onStart, resolution = 5 } = {}) => {
  const logLevel = LOG_LEVEL[logLevelOption];
  const initState = (0, import_react70.useCallback)(() => {
    return {
      calcKey: 0,
      fontSize: maxFontSize,
      fontSizePrev: minFontSize,
      fontSizeMax: maxFontSize,
      fontSizeMin: minFontSize
    };
  }, [maxFontSize, minFontSize]);
  const ref = (0, import_react70.useRef)(null);
  const innerHtmlPrevRef = (0, import_react70.useRef)();
  const isCalculatingRef = (0, import_react70.useRef)(false);
  const [state, setState] = (0, import_react70.useState)(initState);
  const { calcKey, fontSize, fontSizeMax, fontSizeMin, fontSizePrev } = state;
  let animationFrameId = null;
  const [ro2] = (0, import_react70.useState)(() => new ResizeObserver_es_default(() => {
    animationFrameId = window.requestAnimationFrame(() => {
      if (isCalculatingRef.current) {
        return;
      }
      onStart && onStart();
      isCalculatingRef.current = true;
      setState({
        ...initState(),
        calcKey: calcKey + 1
      });
    });
  }));
  (0, import_react70.useEffect)(() => {
    if (ref.current) {
      ro2.observe(ref.current);
    }
    return () => {
      animationFrameId && window.cancelAnimationFrame(animationFrameId);
      ro2.disconnect();
    };
  }, [animationFrameId, ro2]);
  const innerHtml = ref.current && ref.current.innerHTML;
  (0, import_react70.useEffect)(() => {
    if (calcKey === 0 || isCalculatingRef.current)
      return;
    if (innerHtml !== innerHtmlPrevRef.current) {
      onStart && onStart();
      setState({
        ...initState(),
        calcKey: calcKey + 1
      });
    }
    innerHtmlPrevRef.current = innerHtml;
  }, [calcKey, initState, innerHtml, onStart]);
  useIsoLayoutEffect(() => {
    if (calcKey === 0) {
      return;
    }
    const isWithinResolution = Math.abs(fontSize - fontSizePrev) <= resolution;
    const isOverflow = !!ref.current && (ref.current.scrollHeight > ref.current.offsetHeight || ref.current.scrollWidth > ref.current.offsetWidth);
    const isFailed = isOverflow && fontSize === fontSizePrev;
    const isAsc = fontSize > fontSizePrev;
    if (isWithinResolution) {
      if (isFailed) {
        isCalculatingRef.current = false;
        if (logLevel <= LOG_LEVEL.info) {
          console.info(`[use-fit-text] reached \`minFontSize = ${minFontSize}\` without fitting text`);
        }
      } else if (isOverflow) {
        setState({
          fontSize: isAsc ? fontSizePrev : fontSizeMin,
          fontSizeMax,
          fontSizeMin,
          fontSizePrev,
          calcKey
        });
      } else {
        isCalculatingRef.current = false;
        onFinish && onFinish(fontSize);
      }
      return;
    }
    let delta;
    let newMax = fontSizeMax;
    let newMin = fontSizeMin;
    if (isOverflow) {
      delta = isAsc ? fontSizePrev - fontSize : fontSizeMin - fontSize;
      newMax = Math.min(fontSizeMax, fontSize);
    } else {
      delta = isAsc ? fontSizeMax - fontSize : fontSizePrev - fontSize;
      newMin = Math.max(fontSizeMin, fontSize);
    }
    setState({
      calcKey,
      fontSize: fontSize + delta / 2,
      fontSizeMax: newMax,
      fontSizeMin: newMin,
      fontSizePrev: fontSize
    });
  }, [
    calcKey,
    fontSize,
    fontSizeMax,
    fontSizeMin,
    fontSizePrev,
    onFinish,
    ref,
    resolution
  ]);
  return { fontSize, ref };
};
var FitText = ({ children }) => {
  const [ready, setReady] = import_react70.default.useState(false);
  const { fontSize, ref: textRef } = useFitText({
    logLevel: "none",
    maxFontSize: 100,
    minFontSize: 70,
    onStart: () => setReady(true),
    onFinish: () => setReady(true)
  });
  return (0, import_jsx_runtime.jsx)("div", { ref: textRef, style: {
    visibility: ready ? "visible" : "hidden",
    fontSize: `${fontSize}%`,
    maxHeight: "100%",
    maxWidth: "100%",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  }, children });
};
FitText.displayName = "FitText";
function useConnectors2() {
  const connectors = useConnectors();
  return connectors !== null && connectors !== void 0 ? connectors : [];
}
function useConnector(id3, uuid) {
  const connectors = useConnectors2();
  if (id3 === "injected" && uuid) {
    return connectors.find((c3) => c3.id === id3 && c3.name === uuid);
  } else if (id3 === "injected") {
    return connectors.find((c3) => c3.id === id3 && c3.name.includes("Injected"));
  }
  return connectors.find((c3) => c3.id === id3);
}
function useFamilyAccountsConnector() {
  return useConnector("familyAccountsProvider");
}
function useFamilyConnector() {
  return useConnector("co.family.wallet");
}
function useWalletConnectConnector() {
  return useConnector("walletConnect");
}
var useWallet = (id3) => {
  const wallets2 = useWallets();
  const wallet = wallets2.find((c3) => c3.id === id3);
  if (!wallet)
    return null;
  return wallet;
};
var useWallets = () => {
  const connectors = useConnectors2();
  const context = useContext21();
  const wallets2 = connectors.map((connector) => {
    var _a2, _b;
    const walletId = Object.keys(walletConfigs).find(
      // where id is comma seperated list
      (id3) => id3.split(",").map((i2) => i2.trim()).indexOf(connector.id) !== -1
    );
    const c3 = {
      id: connector.id,
      name: (_b = (_a2 = connector.name) !== null && _a2 !== void 0 ? _a2 : connector.id) !== null && _b !== void 0 ? _b : connector.type,
      icon: (0, import_jsx_runtime.jsx)("img", { src: connector.icon, alt: connector.name, width: "100%", height: "100%" }),
      connector,
      iconShape: "squircle",
      isInstalled: connector.type === "mock" || connector.type === "injected" && connector.id !== "metaMask" || isCoinbaseWalletConnector(connector.id)
      // always run coinbase wallet SDK
    };
    if (walletId) {
      const wallet = walletConfigs[walletId];
      return {
        ...c3,
        iconConnector: connector.icon ? (0, import_jsx_runtime.jsx)("img", { src: connector.icon, alt: connector.name, width: "100%", height: "100%" }) : void 0,
        ...wallet
      };
    }
    return c3;
  });
  return wallets2.filter((wallet, index5, self2) => self2.findIndex((w2) => w2.id === wallet.id) === index5).map((wallet) => {
    var _a2, _b;
    if (wallet.id === "walletConnect") {
      return {
        ...wallet,
        name: ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.walletConnectName) || wallet.name,
        shortName: ((_b = context.options) === null || _b === void 0 ? void 0 : _b.walletConnectName) || wallet.shortName
      };
    }
    return wallet;
  }).filter((wallet, index5, self2) => !(wallet.id === "coinbaseWalletSDK" && self2.find((w2) => w2.id === "com.coinbase.wallet"))).filter((wallet, index5, self2) => !((wallet.id === "metaMaskSDK" || wallet.id === "metaMask") && self2.find((w2) => w2.id === "io.metamask" || w2.id === "io.metamask.mobile"))).sort((a3, b4) => {
    const AisInstalled = a3.isInstalled && isInjectedConnector(a3.connector.type);
    const BisInstalled = b4.isInstalled && isInjectedConnector(b4.connector.type);
    if (AisInstalled && !BisInstalled)
      return -1;
    if (!AisInstalled && BisInstalled)
      return 1;
    return 0;
  }).sort((a3, b4) => {
    if (a3.id === "walletConnect")
      return 1;
    if (b4.id === "walletConnect")
      return -1;
    return 0;
  });
};
var ProfileIcon = ({ isSignedIn }) => (0, import_jsx_runtime.jsxs)("div", { style: { position: "relative" }, children: [isSignedIn ? (0, import_jsx_runtime.jsx)(AuthIcon, { style: {
  bottom: -1,
  right: -1
} }) : (0, import_jsx_runtime.jsx)("div", { style: {
  zIndex: 2,
  position: "absolute",
  top: -2,
  right: -2,
  background: "#1A88F8",
  borderRadius: 8,
  boxShadow: "0 0 0 2px var(--ck-body-background)",
  width: 8,
  height: 8
} }), (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: { overflow: "visible" }, children: [(0, import_jsx_runtime.jsx)("circle", { cx: "10", cy: "10", r: "9", stroke: "currentColor", strokeWidth: "2" }), (0, import_jsx_runtime.jsx)("path", { d: "M16.5 16.775C14.8618 15.0649 12.5552 14 10 14C7.44477 14 5.13825 15.0649 3.5 16.775", stroke: "currentColor", strokeWidth: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "10", cy: "8", r: "3", stroke: "currentColor", strokeWidth: "2" })] })] });
var InfoIcon = ({ ...props }) => (0, import_jsx_runtime.jsx)("svg", { "aria-hidden": "true", width: "22", height: "22", viewBox: "0 0 22 22", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20 11C20 15.9706 15.9706 20 11 20C6.02944 20 2 15.9706 2 11C2 6.02944 6.02944 2 11 2C15.9706 2 20 6.02944 20 11ZM22 11C22 17.0751 17.0751 22 11 22C4.92487 22 0 17.0751 0 11C0 4.92487 4.92487 0 11 0C17.0751 0 22 4.92487 22 11ZM11.6445 12.7051C11.6445 13.1348 11.3223 13.4678 10.7744 13.4678C10.2266 13.4678 9.92578 13.1885 9.92578 12.6191V12.4795C9.92578 11.4268 10.4951 10.8574 11.2686 10.3203C12.2031 9.67578 12.665 9.32129 12.665 8.59082C12.665 7.76367 12.0205 7.21582 11.043 7.21582C10.3232 7.21582 9.80762 7.57031 9.45312 8.16113C9.38282 8.24242 9.32286 8.32101 9.2667 8.39461C9.04826 8.68087 8.88747 8.8916 8.40039 8.8916C8.0459 8.8916 7.66992 8.62305 7.66992 8.15039C7.66992 7.96777 7.70215 7.7959 7.75586 7.61328C8.05664 6.625 9.27051 5.75488 11.1182 5.75488C12.9336 5.75488 14.5234 6.71094 14.5234 8.50488C14.5234 9.7832 13.7822 10.417 12.7402 11.1045C11.999 11.5986 11.6445 11.9746 11.6445 12.5762V12.7051ZM11.9131 15.5625C11.9131 16.1855 11.376 16.6797 10.7529 16.6797C10.1299 16.6797 9.59277 16.1748 9.59277 15.5625C9.59277 14.9395 10.1191 14.4453 10.7529 14.4453C11.3867 14.4453 11.9131 14.9287 11.9131 15.5625Z", fill: "currentColor" }) });
var CloseIcon = ({ ...props }) => (0, import_jsx_runtime.jsx)(motion.svg, { width: 14, height: 14, viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime.jsx)("path", { d: "M1 13L13 1M1 1L13 13", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round" }) });
var BackIcon = ({ ...props }) => (0, import_jsx_runtime.jsx)(motion.svg, { width: 9, height: 16, viewBox: "0 0 9 16", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime.jsx)("path", { d: "M8 1L1 8L8 15", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) });
var contentTransitionDuration = 0.22;
var contentVariants$2 = {
  initial: {
    //willChange: 'transform,opacity',
    zIndex: 2,
    opacity: 0
  },
  animate: {
    opacity: 1,
    scale: 1,
    transition: {
      duration: contentTransitionDuration * 0.75,
      delay: contentTransitionDuration * 0.25,
      ease: [0.26, 0.08, 0.25, 1]
    }
  },
  exit: {
    zIndex: 1,
    opacity: 0,
    pointerEvents: "none",
    position: "absolute",
    left: ["50%", "50%"],
    x: ["-50%", "-50%"],
    transition: {
      duration: contentTransitionDuration,
      ease: [0.26, 0.08, 0.25, 1]
    }
  }
};
var Modal = ({ open, pages, pageId, positionInside, inline, demo, onClose, onBack, onInfo }) => {
  var _a2, _b, _c2, _d, _e2, _f, _g, _h, _j, _k, _l2, _m;
  const context = useContext21();
  const themeContext = useThemeContext();
  const mobile = isMobile();
  const { isSignedIn, reset: reset2 } = useSIWE();
  const wallet = useWallet((_a2 = context.connector) === null || _a2 === void 0 ? void 0 : _a2.id);
  const walletInfo = {
    name: wallet === null || wallet === void 0 ? void 0 : wallet.name,
    shortName: (_b = wallet === null || wallet === void 0 ? void 0 : wallet.shortName) !== null && _b !== void 0 ? _b : wallet === null || wallet === void 0 ? void 0 : wallet.name,
    icon: (_c2 = wallet === null || wallet === void 0 ? void 0 : wallet.iconConnector) !== null && _c2 !== void 0 ? _c2 : wallet === null || wallet === void 0 ? void 0 : wallet.icon,
    iconShape: (_d = wallet === null || wallet === void 0 ? void 0 : wallet.iconShape) !== null && _d !== void 0 ? _d : "circle",
    iconShouldShrink: wallet === null || wallet === void 0 ? void 0 : wallet.iconShouldShrink
  };
  const locales = useLocales({
    CONNECTORNAME: walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name
  });
  const [state, setOpen] = useTransition({
    timeout: mobile ? 160 : 160,
    // different animations, 10ms extra to avoid final-frame drops
    preEnter: true,
    mountOnEnter: true,
    unmountOnExit: true
  });
  const mounted = !(state === "exited" || state === "unmounted");
  const rendered = state === "preEnter" || state !== "exiting";
  const currentDepth = context.route === routes.CONNECTORS ? 0 : context.route === routes.DOWNLOAD ? 2 : 1;
  const prevDepth = usePrevious(currentDepth, currentDepth);
  if (!positionInside)
    useLockBodyScroll(mounted);
  usePrevious(pageId, pageId);
  (0, import_react70.useEffect)(() => {
    setOpen(open);
    if (open)
      setInTransition(void 0);
  }, [open]);
  const [dimensions, setDimensions] = (0, import_react70.useState)({
    width: void 0,
    height: void 0
  });
  const [inTransition, setInTransition] = (0, import_react70.useState)(void 0);
  const updateBounds = (node) => {
    const bounds = {
      width: node === null || node === void 0 ? void 0 : node.offsetWidth,
      height: node === null || node === void 0 ? void 0 : node.offsetHeight
    };
    setDimensions({
      width: `${bounds === null || bounds === void 0 ? void 0 : bounds.width}px`,
      height: `${bounds === null || bounds === void 0 ? void 0 : bounds.height}px`
    });
  };
  let blockTimeout;
  const contentRef = (0, import_react70.useCallback)((node) => {
    if (!node)
      return;
    ref.current = node;
    setInTransition(inTransition === void 0 ? false : true);
    clearTimeout(blockTimeout);
    blockTimeout = setTimeout(() => setInTransition(false), 360);
    updateBounds(node);
  }, [open, inTransition]);
  const { chain: chain2 } = useAccount();
  const { switchChain: switchChain3 } = useSwitchChain();
  const ref = (0, import_react70.useRef)(null);
  (0, import_react70.useEffect)(() => {
    if (ref.current)
      updateBounds(ref.current);
  }, [chain2, switchChain3, mobile, isSignedIn, context.options, context.resize]);
  (0, import_react70.useEffect)(() => {
    if (!mounted) {
      setDimensions({
        width: void 0,
        height: void 0
      });
      return;
    }
    const listener = (e2) => {
      if (e2.key === "Escape" && onClose)
        onClose();
    };
    document.addEventListener("keydown", listener);
    return () => {
      document.removeEventListener("keydown", listener);
    };
  }, [mounted, onClose]);
  const dimensionsCSS = {
    "--height": dimensions.height,
    "--width": dimensions.width
  };
  function shouldUseQrcode() {
    if (!wallet)
      return false;
    const useInjector = !wallet.getWalletConnectDeeplink || wallet.isInstalled;
    return !useInjector;
  }
  function getHeading() {
    var _a3;
    switch (context.route) {
      case routes.ABOUT:
        return locales.aboutScreen_heading;
      case routes.CONNECT:
        if (shouldUseQrcode()) {
          return isWalletConnectConnector((_a3 = wallet === null || wallet === void 0 ? void 0 : wallet.connector) === null || _a3 === void 0 ? void 0 : _a3.id) ? locales.scanScreen_heading : locales.scanScreen_heading_withConnector;
        } else {
          return walletInfo === null || walletInfo === void 0 ? void 0 : walletInfo.name;
        }
      case routes.CONNECTORS:
        return locales.connectorsScreen_heading;
      case routes.MOBILECONNECTORS:
        return locales.mobileConnectorsScreen_heading;
      case routes.DOWNLOAD:
        return locales.downloadAppScreen_heading;
      case routes.ONBOARDING:
        return locales.onboardingScreen_heading;
      case routes.PROFILE:
        return locales.profileScreen_heading;
      case routes.SWITCHNETWORKS:
        return locales.switchNetworkScreen_heading;
      case routes.SIGNINWITHETHEREUM:
        return isSignedIn ? locales.signInWithEthereumScreen_signedIn_heading : locales.signInWithEthereumScreen_signedOut_heading;
      default:
        return "";
    }
  }
  const Content2 = (0, import_jsx_runtime.jsx)(ResetContainer, { "$useTheme": (_e2 = demo === null || demo === void 0 ? void 0 : demo.theme) !== null && _e2 !== void 0 ? _e2 : themeContext.theme, "$useMode": (_f = demo === null || demo === void 0 ? void 0 : demo.mode) !== null && _f !== void 0 ? _f : themeContext.mode, "$customTheme": (_g = demo === null || demo === void 0 ? void 0 : demo.customTheme) !== null && _g !== void 0 ? _g : themeContext.customTheme, children: (0, import_jsx_runtime.jsxs)(ModalContainer, { role: "dialog", style: {
    pointerEvents: rendered ? "auto" : "none",
    position: positionInside ? "absolute" : void 0
  }, children: [!inline && (0, import_jsx_runtime.jsx)(BackgroundOverlay, { "$active": rendered, onClick: onClose, "$blur": (_h = context.options) === null || _h === void 0 ? void 0 : _h.overlayBlur }), (0, import_jsx_runtime.jsxs)(Container$8, { style: dimensionsCSS, initial: false, children: [(0, import_jsx_runtime.jsx)("div", { style: {
    pointerEvents: inTransition ? "all" : "none",
    // Block interaction while transitioning
    position: "absolute",
    top: 0,
    bottom: 0,
    left: "50%",
    transform: "translateX(-50%)",
    width: "var(--width)",
    zIndex: 9,
    transition: "width 200ms ease"
  } }), (0, import_jsx_runtime.jsxs)(BoxContainer, { className: `${rendered && "active"}`, children: [(0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: ((_j = context.options) === null || _j === void 0 ? void 0 : _j.disclaimer) && context.route === routes.CONNECTORS && (0, import_jsx_runtime.jsx)(DisclaimerBackground, { initial: {
    opacity: 0
  }, animate: {
    opacity: 1
  }, exit: { opacity: 0 }, transition: {
    delay: 0,
    duration: 0.2,
    ease: [0.25, 0.1, 0.25, 1]
  }, children: (0, import_jsx_runtime.jsx)(Disclaimer, { children: (0, import_jsx_runtime.jsx)("div", { children: (_k = context.options) === null || _k === void 0 ? void 0 : _k.disclaimer }) }) }) }), (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: context.errorMessage && (0, import_jsx_runtime.jsxs)(ErrorMessage, { initial: { y: "10%", x: "-50%" }, animate: { y: "-100%" }, exit: { y: "100%" }, transition: { duration: 0.2, ease: "easeInOut" }, children: [(0, import_jsx_runtime.jsx)("span", { children: context.errorMessage }), (0, import_jsx_runtime.jsx)("div", { onClick: () => context.displayError(null), style: {
    position: "absolute",
    right: 24,
    top: 24,
    cursor: "pointer"
  }, children: (0, import_jsx_runtime.jsx)(CloseIcon, {}) })] }) }), (0, import_jsx_runtime.jsxs)(ControllerContainer, { children: [onClose && (0, import_jsx_runtime.jsx)(CloseButton, { "aria-label": flattenChildren(locales.close).toString(), onClick: onClose, children: (0, import_jsx_runtime.jsx)(CloseIcon, {}) }), (0, import_jsx_runtime.jsx)("div", { style: {
    position: "absolute",
    top: 23,
    left: 20,
    width: 32,
    height: 32
  }, children: (0, import_jsx_runtime.jsx)(AnimatePresence, { children: onBack ? (0, import_jsx_runtime.jsx)(BackButton, { disabled: inTransition, "aria-label": flattenChildren(locales.back).toString(), onClick: onBack, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    duration: mobile ? 0 : 0.1,
    delay: mobile ? 0.01 : 0
  }, children: (0, import_jsx_runtime.jsx)(BackIcon, {}) }, "backButton") : context.route === routes.PROFILE && context.signInWithEthereum ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [!isSignedIn && !((_l2 = context.options) === null || _l2 === void 0 ? void 0 : _l2.hideTooltips) && (0, import_jsx_runtime.jsx)(motion.div, { style: {
    position: "absolute",
    inset: 0,
    pointerEvents: "none"
  }, initial: { opacity: 0, scale: 0.8 }, animate: {
    opacity: 1,
    scale: 1,
    transition: { delay: 0.5, duration: 0.2 }
  }, exit: {
    opacity: 0,
    scale: 0.6,
    transition: {
      delay: 0,
      duration: mobile ? 0 : 0.1
    }
  }, children: (0, import_jsx_runtime.jsx)(SignInTooltip, { children: locales.signInWithEthereumScreen_tooltip }) }), (0, import_jsx_runtime.jsx)(SiweButton, { disabled: inTransition, "aria-label": locales.signInWithEthereumScreen_signedOut_heading, onClick: () => {
    reset2();
    context.setRoute(routes.SIGNINWITHETHEREUM);
  }, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    duration: mobile ? 0 : 0.1,
    delay: mobile ? 0.01 : 0
  }, children: (0, import_jsx_runtime.jsx)(ProfileIcon, { isSignedIn }) }, "siweButton")] }) : onInfo && !((_m = context.options) === null || _m === void 0 ? void 0 : _m.hideQuestionMarkCTA) && (0, import_jsx_runtime.jsx)(InfoButton, { disabled: inTransition, "aria-label": flattenChildren(locales.moreInformation).toString(), onClick: onInfo, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    duration: mobile ? 0 : 0.1,
    delay: mobile ? 0.01 : 0
  }, children: (0, import_jsx_runtime.jsx)(InfoIcon, {}) }, "infoButton") }) })] }), (0, import_jsx_runtime.jsx)(ModalHeading, { children: (0, import_jsx_runtime.jsx)(AnimatePresence, { children: (0, import_jsx_runtime.jsx)(motion.div, { style: {
    position: "absolute",
    top: 0,
    bottom: 0,
    left: 52,
    right: 52,
    display: "flex",
    //alignItems: 'center',
    justifyContent: "center"
  }, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    duration: mobile ? 0 : 0.17,
    delay: mobile ? 0.01 : 0
  }, children: (0, import_jsx_runtime.jsx)(FitText, { children: getHeading() }) }, `${context.route}-${isSignedIn ? "signedIn" : ""}`) }) }), (0, import_jsx_runtime.jsx)(InnerContainer$2, { children: Object.keys(pages).map((key) => {
    const page = pages[key];
    return (
      // TODO: We may need to use the follow check avoid unnecessary computations, but this causes a bug where the content flashes
      // (key === pageId || key === prevPage) && (
      (0, import_jsx_runtime.jsx)(Page, { open: key === pageId, initial: !positionInside && state !== "entered", enterAnim: key === pageId ? currentDepth > prevDepth ? "active-scale-up" : "active" : "", exitAnim: key !== pageId ? currentDepth < prevDepth ? "exit-scale-down" : "exit" : "", children: (0, import_jsx_runtime.jsx)(PageContents, { ref: contentRef, style: {
        pointerEvents: key === pageId && rendered ? "auto" : "none"
      }, children: page }, `inner-${key}`) }, key)
    );
  }) })] })] })] }) });
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: mounted && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: positionInside ? Content2 : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(Portal, { children: (0, import_jsx_runtime.jsx)(FocusTrap, { children: Content2 }) }) }) }) });
};
var Page = ({ children, open, initial, prevDepth, currentDepth, enterAnim, exitAnim }) => {
  const [state, setOpen] = useTransition({
    timeout: 400,
    preEnter: true,
    initialEntered: open,
    mountOnEnter: true,
    unmountOnExit: true
  });
  const mounted = !(state === "exited" || state === "unmounted");
  const rendered = state === "preEnter" || state !== "exiting";
  (0, import_react70.useEffect)(() => {
    setOpen(open);
  }, [open]);
  if (!mounted)
    return null;
  return (0, import_jsx_runtime.jsx)(PageContainer, { className: `${rendered ? enterAnim : exitAnim}`, style: {
    animationDuration: initial ? "0ms" : void 0,
    animationDelay: initial ? "0ms" : void 0
  }, children });
};
var OrDivider = ({ children, hideHr }) => {
  const locales = useLocales();
  return (0, import_jsx_runtime.jsx)(TextWithHr, { "$disableHr": hideHr, children: (0, import_jsx_runtime.jsx)("span", { children: children !== null && children !== void 0 ? children : locales.or }) });
};
var Graphic = styled(motion.div)`
  position: relative;
  margin: 16px auto 20px;
  height: 190px;
  max-width: 295px;
  pointer-events: none;
  user-select: none;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    height: 200px;
    max-width: 100%;
    margin-bottom: 32px;
  }
`;
var LogoGroup = styled(motion.div)`
  position: absolute;
  inset: 0;
  z-index: 2;
`;
var graphicIn = We`
  0%{
    opacity:0;
    transform:scale(0.9);
  }
  100%{
    opacity:1;
    transform:none;
  }
`;
var GraphicBackground = styled(motion.div)`
  z-index: 1;
  position: absolute;
  inset: 0;
  top: -2px;
  overflow: hidden;
  &:before {
    content: '';
    position: absolute;
    inset: 0;
    background: var(--ck-body-background);
    background: radial-gradient(
      closest-side,
      var(--ck-body-background-transparent, transparent) 18.75%,
      var(--ck-body-background) 100%
    );
    background-size: 100%;
  }
  svg {
    display: block;
    width: 100%;
    height: auto;
  }
  animation: ${graphicIn} 1000ms 100ms ease both;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    animation: none;
  }
`;
var logoIn = We`
  0%{
    opacity:0;
    transform:scale(0) translateY(40%);
  }
  100%{
    opacity:1;
    transform:none;
  }
`;
var LogoPosition = styled(motion.div)`
  position: absolute;
  inset: 0;
  animation: cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite both;
  animation-delay: inherit;
`;
var LogoInner = styled(motion.div)`
  position: absolute;
`;
var LogoGraphic = styled(motion.div)`
  position: relative;
  overflow: hidden;
  height: 58px;
  width: 58px;
  border-radius: 13.84px;
  box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.05), 0 2px 20px 0 rgba(0, 0, 0, 0.03);

  svg {
    display: block;
    width: 100%;
    height: 100%;
  }
`;
var float = We`
  0%,100%{ transform:none; }
  50%{ transform: translateY(-10%) }
`;
var FloatWrapper = styled(motion.div)`
  position: relative;
  animation: cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite both;
  animation-name: ${float};
  animation-duration: 3600ms;
`;
var rotate = We`
  0%,100%{ transform:rotate(-3deg); }
  50%{ transform:rotate(3deg); }
`;
var RotateWrapper = styled(motion.div)`
  position: relative;
  animation: cubic-bezier(0.455, 0.03, 0.515, 0.955) infinite both;
  animation-name: ${rotate};
  animation-duration: 3200ms;
`;
var Logo$2 = styled(motion.div)`
  position: absolute;
  inset: 0;

  animation: ${logoIn} 750ms cubic-bezier(0.19, 1, 0.22, 1) both;
  &:nth-child(1){ z-index:2; animation-delay:0ms;  }
  &:nth-child(2){ z-index:1; animation-delay:60ms; }
  &:nth-child(3){ z-index:1; animation-delay:30ms; }
  &:nth-child(4){ z-index:1; animation-delay:90ms; }
  &:nth-child(5){ z-index:1; animation-delay:120ms;}

  &:nth-child(1){ ${RotateWrapper}{ animation-delay:0ms; } }
  &:nth-child(2){ ${RotateWrapper}{ animation-delay:-600ms; } }
  &:nth-child(3){ ${RotateWrapper}{ animation-delay:-1200ms; } }
  &:nth-child(4){ ${RotateWrapper}{ animation-delay:-1800ms; } }
  &:nth-child(5){ ${RotateWrapper}{ animation-delay:-2400ms; } }

  &:nth-child(1){ ${FloatWrapper}{ animation-delay:-200ms; } }
  &:nth-child(2){ ${FloatWrapper}{ animation-delay:-600ms; } }
  &:nth-child(3){ ${FloatWrapper}{ animation-delay:-800ms; } }
  &:nth-child(4){ ${FloatWrapper}{ animation-delay:-300ms; } }
  &:nth-child(5){ ${FloatWrapper}{ animation-delay:-3200ms; } }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    animation: none !important;
    ${RotateWrapper},${FloatWrapper} {
      animation: none !important;
    }
  }

  ${LogoInner} {
    transform: translate(-50%, -50%);
  }

  &:nth-child(1) ${LogoPosition} {
    transform: translate(50%, 50%);
    ${LogoGraphic} {
      border-radius: 17.2px;
      width: 72px;
      height: 72px;
    }
  }
  &:nth-child(2) ${LogoPosition} {
    transform: translate(21%, 21.5%);
  }
  &:nth-child(3) ${LogoPosition} {
    transform: translate(78%, 14%);
  }
  &:nth-child(4) ${LogoPosition} {
    transform: translate(22.5%, 76%);
  }
  &:nth-child(5) ${LogoPosition} {
    transform: translate(76%, 80%);
  }
`;
var wave = (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "298", height: "188", viewBox: "0 0 298 188", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { d: "M1 55.2757L21.6438 46.0285C55.5896 30.8228 94.4104 30.8228 128.356 46.0286L169.644 64.5229C203.59 79.7287 242.41 79.7286 276.356 64.5229L297 55.2757M1 44.2118L21.6438 34.9646C55.5896 19.7589 94.4104 19.7589 128.356 34.9646L169.644 53.459C203.59 68.6647 242.41 68.6647 276.356 53.459L297 44.2118M1 33.1477L21.6438 23.9005C55.5896 8.69479 94.4104 8.69479 128.356 23.9005L169.644 42.3949C203.59 57.6006 242.41 57.6006 276.356 42.3949L297 33.1477M1 22.1477L21.6438 12.9005C55.5896 -2.30521 94.4104 -2.30521 128.356 12.9005L169.644 31.3949C203.59 46.6006 242.41 46.6006 276.356 31.3949L297 22.1477M1 66.3398L21.6438 57.0926C55.5896 41.8869 94.4104 41.8869 128.356 57.0926L169.644 75.587C203.59 90.7927 242.41 90.7927 276.356 75.587L297 66.3398M1 77.404L21.6438 68.1568C55.5896 52.9511 94.4104 52.9511 128.356 68.1569L169.644 86.6512C203.59 101.857 242.41 101.857 276.356 86.6512L297 77.404M1 88.4681L21.6438 79.2209C55.5896 64.0152 94.4104 64.0152 128.356 79.2209L169.644 97.7153C203.59 112.921 242.41 112.921 276.356 97.7153L297 88.4681M1 121.66L21.6438 112.413C55.5896 97.2075 94.4104 97.2075 128.356 112.413L169.644 130.908C203.59 146.113 242.41 146.113 276.356 130.908L297 121.66M1 110.596L21.6438 101.349C55.5896 86.1433 94.4104 86.1433 128.356 101.349L169.644 119.843C203.59 135.049 242.41 135.049 276.356 119.843L297 110.596M1 99.5321L21.6438 90.2849C55.5896 75.0792 94.4104 75.0792 128.356 90.2849L169.644 108.779C203.59 123.985 242.41 123.985 276.356 108.779L297 99.5321M1 132.724L21.6438 123.477C55.5896 108.271 94.4104 108.271 128.356 123.477L169.644 141.971C203.59 157.177 242.41 157.177 276.356 141.971L297 132.724M1 143.788L21.6438 134.541C55.5896 119.336 94.4104 119.336 128.356 134.541L169.644 153.036C203.59 168.241 242.41 168.241 276.356 153.036L297 143.788M1 154.853L21.6438 145.605C55.5896 130.4 94.4104 130.4 128.356 145.605L169.644 164.1C203.59 179.305 242.41 179.305 276.356 164.1L297 154.853M1 165.853L21.6438 156.605C55.5896 141.4 94.4104 141.4 128.356 156.605L169.644 175.1C203.59 190.305 242.41 190.305 276.356 175.1L297 165.853", stroke: "url(#paint0_linear_1094_2077)", strokeOpacity: "0.9", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_1094_2077", x1: "1", y1: "112.587", x2: "297.034", y2: "79.6111", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-wave-stop-01)" }), (0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-wave-stop-02)", offset: "0.239583" }), (0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-wave-stop-03)", offset: "0.515625" }), (0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-wave-stop-04)", offset: "0.739583" }), (0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-wave-stop-05)", offset: "1" })] }) })] });
var SpinnerContainer$3 = styled(motion.div)`
  position: absolute;
  right: 16px;
  top: 0;
  bottom: 0;
  display: flex;
  align-items: center;
  justify-content: center;
`;
var Arrow = styled.svg`
  --x: -3px;
  --stroke-width: 2;
  position: relative;
  top: 1px;
  left: -0.5px;
  display: inline-block;
  vertical-align: middle;
  margin-left: 9px;
  margin-right: 1px;
  transition: all 100ms ease;
  transform: translateX(var(--x, -3px));
  color: currentColor;
  opacity: 0.4;
`;
var ArrowChevron = styled.path``;
var ArrowLine = styled.line`
  transition: inherit;
  transition-property: transform;
  transform-origin: 90% 50%;
  transform: scaleX(0.1);
`;
var DownloadArrow = styled.div`
  display: inline-block;
  vertical-align: middle;
  position: relative;
  margin-right: 6px;
  color: currentColor;
`;
var DownloadArrowInner = styled.div`
  transform: rotate(90deg);
  ${Arrow} {
    margin: 0 auto;
  }
`;
var ButtonContainerInner$1 = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  inset: 0;
  height: 100%;
`;
var ButtonContainer$2 = styled.button`

  ${({ disabled }) => disabled && Ae`
      cursor: not-allowed;
      pointer-events: none;
      ${InnerContainer$1} {
        opacity: 0.4;
      }
    `}

  ${({ $variant }) => {
  if ($variant === "primary") {
    return Ae`
        --color: var(--ck-primary-button-color, var(--ck-body-color));
        --background: var(
          --ck-primary-button-background,
          var(--ck-body-background-primary)
        );
        --box-shadow: var(--ck-primary-button-box-shadow);
        --border-radius: var(--ck-primary-button-border-radius);
        --font-weight: var(--ck-primary-button-font-weight, 500);

        --hover-color: var(--ck-button-primary-hover-color, var(--color));
        --hover-background: var(
          --ck-primary-button-hover-background,
          var(--background)
        );
        --hover-box-shadow: var(
          --ck-primary-button-hover-box-shadow,
          var(--box-shadow)
        );
        --hover-border-radius: var(
          --ck-primary-button-hover-border-radius,
          var(--border-radius)
        );
        --hover-font-weight: var(
          --ck-primary-button-font-weight,
          var(--font-weight)
        );
      `;
  } else if ($variant === "secondary") {
    return Ae`
        --color: var(--ck-secondary-button-color, var(--ck-body-color));
        --background: var(
          --ck-secondary-button-background,
          var(--ck-body-background-secondary)
        );
        --box-shadow: var(--ck-secondary-button-box-shadow);
        --border-radius: var(--ck-secondary-button-border-radius);
        --font-weight: var(--ck-secondary-button-font-weight, 500);

        --hover-color: var(--ck-secondary-button-hover-color, var(--color));
        --hover-background: var(
          --ck-secondary-button-hover-background,
          var(--background)
        );
        --hover-box-shadow: var(
          --ck-secondary-button-hover-box-shadow,
          var(--box-shadow)
        );
        --hover-border-radius: var(
          --ck-secondary-button-hover-border-radius,
          var(--border-radius)
        );
        --hover-font-weight: var(
          --ck-secondary-button-font-weight,
          var(--font-weight)
        );
      `;
  } else if ($variant === "tertiary") {
    return Ae`
        --color: var(
          --ck-tertiary-button-color,
          var(--ck-secondary-button-color)
        );
        --background: var(
          --ck-tertiary-button-background,
          var(--ck-secondary-button-background)
        );
        --box-shadow: var(
          --ck-tertiary-button-box-shadow,
          var(--ck-secondary-button-box-shadow)
        );
        --border-radius: var(
          --ck-tertiary-button-border-radius,
          var(--ck-secondary-button-border-radius)
        );
        --font-weight: var(
          --ck-tertiary-button-font-weight,
          var(--ck-secondary-button-font-weight)
        );

        --hover-color: var(
          --button-tertiary-hover-color,
          var(--ck-tertiary-button-color)
        );
        --hover-background: var(
          --ck-tertiary-button-hover-background,
          var(--ck-tertiary-button-background)
        );
        --hover-box-shadow: var(
          --ck-tertiary-button-hover-box-shadow,
          var(--ck-tertiary-button-box-shadow)
        );
        --hover-border-radius: var(
          --ck-tertiary-button-hover-border-radius,
          var(--ck-tertiary-button-border-radius, var(--border-radius))
        );
        --hover-font-weight: var(
          --ck-tertiary-button-font-weight,
          var(--ck-secondary-button-font-weight)
        );
      `;
  }
}}

  appearance: none;
  cursor: pointer;
  user-select: none;
  min-width: fit-content;
  width: 100%;
  display:block;
  text-align: center;
  height: 48px;
  margin: 12px 0 0;
  line-height: 48px;
  padding: 0 4px;
  font-size: 16px;
  font-weight: var(--font-weight,500);
  text-decoration: none;
  white-space: nowrap;
  transition: 100ms ease;
  transition-property: box-shadow, background-color;
  color: var(--color);
  background: var(--background);
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  will-change: transform, box-shadow, background-color, color;

  ${DownloadArrow} {
    ${Arrow} {
      transform: translateX(0);
      ${ArrowLine} {
        transform: none;
      }
      ${ArrowChevron} {
      }
    }
  }
}

  @media only screen and (min-width: ${defaultTheme.mobileWidth + 1}px) {
    &:hover,
    &:focus-visible {
      color: var(--ck-accent-text-color, var(--hover-color));
      background: var(--ck-accent-color, var(--hover-background));
      border-radius: var(--hover-border-radius);
      box-shadow: var(--hover-box-shadow);

      ${Arrow} {
        transform: translateX(0);
        ${ArrowLine} {
          transform: none;
        }
        ${ArrowChevron} {
        }
      }
      ${DownloadArrow} {
        ${Arrow} {
          transform: translateX(var(--x));
          ${ArrowLine} {
            transform: scaleX(0.1);
          }
          ${ArrowChevron} {
          }
        }
      }
    }
    &:active {
      box-shadow: var(--ck-secondary-button-active-box-shadow, var(--hover-box-shadow));
    }
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    transition: transform 100ms ease;
    transform: scale(1);
    font-size: 17px;
    &:active {
    }
  }
`;
var InnerContainer$1 = styled.div`
  transform: translateZ(0); // Shifting fix
  position: relative;
  display: inline-block;
  vertical-align: middle;
  max-width: calc(100% - 42px);
  transition: opacity 300ms ease;
  /*
  overflow: hidden;
  text-overflow: ellipsis;
  */
`;
var IconContainer$5 = styled(motion.div)`
  position: relative;
  display: inline-block;
  vertical-align: middle;
  max-width: 20px;
  max-height: 20px;
  margin: 0 10px;
  &:first-child {
    margin-left: 0;
  }
  &:last-child {
    margin-right: 0;
  }
  ${(props) => {
  return props.$rounded && Ae`
        overflow: hidden;
        border-radius: 5px;
      `;
}}
  svg {
    display: block;
    position: relative;
    max-width: 100%;
    height: auto;
  }
`;
var Spin$1 = We`
  0%{ transform: rotate(0deg); }
  100%{ transform: rotate(360deg); }
`;
var SpinnerContainer$2 = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  animation: ${Spin$1} 1s linear infinite;
  svg {
    display: block;
    position: relative;
    animation: ${Spin$1} 1s ease-in-out infinite;
  }
`;
var transition$2 = {
  duration: 0.4,
  ease: [0.175, 0.885, 0.32, 0.98]
};
var Spinner$4 = () => (0, import_jsx_runtime.jsx)(SpinnerContainer$2, { initial: { opacity: 0, rotate: 180 }, animate: {
  opacity: 1,
  rotate: 0
}, exit: {
  position: "absolute",
  opacity: 0,
  rotate: -180,
  transition: {
    ...transition$2
  }
}, transition: {
  ...transition$2,
  delay: 0.2
}, children: (0, import_jsx_runtime.jsxs)("svg", { width: "18", height: "18", viewBox: "0 0 18 18", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("circle", { cx: "9", cy: "9", r: "7", stroke: "currentColor", strokeOpacity: "0.1", strokeWidth: "2.5" }), (0, import_jsx_runtime.jsx)("path", { d: "M16 9C16 5.13401 12.866 2 9 2", stroke: "currentColor", strokeWidth: "2.5", strokeLinecap: "round" })] }) });
var transition$1 = {
  duration: 0.4,
  ease: [0.175, 0.885, 0.32, 0.98]
};
var Button = ({
  children,
  variant = "secondary",
  // unique aspect to how we're handling buttons
  disabled,
  icon,
  iconPosition = "left",
  roundedIcon,
  waiting,
  arrow,
  download,
  href,
  style: style2,
  onClick
}) => {
  const key = typeof children === "string" ? children : flattenChildren(children).join("");
  const hrefUrl = href && (typeof href === "string" ? href : flattenChildren(href).join(""));
  return (0, import_jsx_runtime.jsx)(ButtonContainer$2, { as: href ? "a" : void 0, onClick: (event) => {
    if (!disabled && onClick)
      onClick(event);
  }, href: hrefUrl, target: href && "_blank", rel: href && "noopener noreferrer", disabled, "$variant": variant, style: style2, children: (0, import_jsx_runtime.jsxs)(AnimatePresence, { initial: false, children: [(0, import_jsx_runtime.jsxs)(ButtonContainerInner$1, { initial: { opacity: 0, y: -10 }, animate: {
    opacity: 1,
    y: -1
  }, exit: {
    position: "absolute",
    opacity: 0,
    y: 10,
    transition: {
      ...transition$1
    }
  }, transition: {
    ...transition$1,
    delay: 0.2
  }, children: [icon && iconPosition === "left" && (0, import_jsx_runtime.jsx)(IconContainer$5, { "$rounded": roundedIcon, children: icon }), download && (0, import_jsx_runtime.jsx)(DownloadArrow, { children: (0, import_jsx_runtime.jsx)(DownloadArrowInner, { children: (0, import_jsx_runtime.jsxs)(Arrow, { width: "13", height: "12", viewBox: "0 0 13 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)(ArrowLine, { stroke: "currentColor", x1: "1", y1: "6", x2: "12", y2: "6", strokeWidth: "var(--stroke-width)", strokeLinecap: "round" }), (0, import_jsx_runtime.jsx)(ArrowChevron, { stroke: "currentColor", d: "M7.51431 1.5L11.757 5.74264M7.5 10.4858L11.7426 6.24314", strokeWidth: "var(--stroke-width)", strokeLinecap: "round" })] }) }) }), (0, import_jsx_runtime.jsx)(InnerContainer$1, { style: { paddingLeft: arrow ? 6 : 0 }, children: (0, import_jsx_runtime.jsx)(FitText, { children }) }), icon && iconPosition === "right" && (0, import_jsx_runtime.jsx)(IconContainer$5, { "$rounded": roundedIcon, children: icon }), arrow && (0, import_jsx_runtime.jsxs)(Arrow, { width: "13", height: "12", viewBox: "0 0 13 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)(ArrowLine, { stroke: "currentColor", x1: "1", y1: "6", x2: "12", y2: "6", strokeWidth: "2", strokeLinecap: "round" }), (0, import_jsx_runtime.jsx)(ArrowChevron, { stroke: "currentColor", d: "M7.51431 1.5L11.757 5.74264M7.5 10.4858L11.7426 6.24314", strokeWidth: "2", strokeLinecap: "round" })] })] }, key), waiting && (0, import_jsx_runtime.jsx)(SpinnerContainer$3, { children: (0, import_jsx_runtime.jsx)(Spinner$4, {}) })] }) });
};
var Introduction = () => {
  var _a2, _b;
  const context = useContext21();
  const locales = useLocales({});
  const ctaUrl = (_b = (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.walletOnboardingUrl) !== null && _b !== void 0 ? _b : locales.onboardingScreen_ctaUrl;
  return (0, import_jsx_runtime.jsxs)(PageContent, { children: [(0, import_jsx_runtime.jsxs)(Graphic, { children: [(0, import_jsx_runtime.jsxs)(LogoGroup, { children: [(0, import_jsx_runtime.jsx)(Logo$2, { children: (0, import_jsx_runtime.jsx)(LogoPosition, { children: (0, import_jsx_runtime.jsx)(LogoInner, { children: (0, import_jsx_runtime.jsx)(FloatWrapper, { children: (0, import_jsx_runtime.jsx)(RotateWrapper, { children: (0, import_jsx_runtime.jsx)(LogoGraphic, { children: (0, import_jsx_runtime.jsx)(Logos.Coinbase, { background: true }) }) }) }) }) }) }), (0, import_jsx_runtime.jsx)(Logo$2, { children: (0, import_jsx_runtime.jsx)(LogoPosition, { children: (0, import_jsx_runtime.jsx)(LogoInner, { children: (0, import_jsx_runtime.jsx)(FloatWrapper, { children: (0, import_jsx_runtime.jsx)(RotateWrapper, { children: (0, import_jsx_runtime.jsx)(LogoGraphic, { children: (0, import_jsx_runtime.jsx)(Logos.MetaMask, { background: true }) }) }) }) }) }) }), (0, import_jsx_runtime.jsx)(Logo$2, { children: (0, import_jsx_runtime.jsx)(LogoPosition, { children: (0, import_jsx_runtime.jsx)(LogoInner, { children: (0, import_jsx_runtime.jsx)(FloatWrapper, { children: (0, import_jsx_runtime.jsx)(RotateWrapper, { children: (0, import_jsx_runtime.jsx)(LogoGraphic, { children: (0, import_jsx_runtime.jsx)(Logos.Trust, {}) }) }) }) }) }) }), (0, import_jsx_runtime.jsx)(Logo$2, { children: (0, import_jsx_runtime.jsx)(LogoPosition, { children: (0, import_jsx_runtime.jsx)(LogoInner, { children: (0, import_jsx_runtime.jsx)(FloatWrapper, { children: (0, import_jsx_runtime.jsx)(RotateWrapper, { children: (0, import_jsx_runtime.jsx)(LogoGraphic, { children: (0, import_jsx_runtime.jsx)(Logos.Argent, {}) }) }) }) }) }) }), (0, import_jsx_runtime.jsx)(Logo$2, { children: (0, import_jsx_runtime.jsx)(LogoPosition, { children: (0, import_jsx_runtime.jsx)(LogoInner, { children: (0, import_jsx_runtime.jsx)(FloatWrapper, { children: (0, import_jsx_runtime.jsx)(RotateWrapper, { children: (0, import_jsx_runtime.jsx)(LogoGraphic, { children: (0, import_jsx_runtime.jsx)(Logos.ImToken, {}) }) }) }) }) }) })] }), (0, import_jsx_runtime.jsx)(GraphicBackground, { children: wave })] }), (0, import_jsx_runtime.jsxs)(ModalContent, { style: { paddingBottom: 18 }, children: [(0, import_jsx_runtime.jsx)(ModalH1, { "$small": true, children: locales.onboardingScreen_h1 }), (0, import_jsx_runtime.jsx)(ModalBody, { children: locales.onboardingScreen_p })] }), (0, import_jsx_runtime.jsx)(Button, { href: ctaUrl, arrow: true, children: locales.onboardingScreen_ctaText })] });
};
var imageHeight = 208;
var ImageContainer$1 = styled.div`
  pointer-events: none;
  user-select: none;
  height: ${imageHeight}px;
  padding: 0 0 12px;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    display: block;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    display: none;
  }
`;
var ImageContainerInner = styled(motion.div)``;
var MobileImageContainer = styled.div`
  pointer-events: none;
  user-select: none;
  height: ${imageHeight}px;
  padding: 0 0 12px;
  display: none;
  align-items: center;
  justify-content: center;
  svg {
    display: block;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    display: flex;
  }
`;
var Slides = styled.div`
  position: relative;
`;
var Slide = styled(motion.div)`
  scroll-snap-type: x mandatory;
  position: relative;
  bottom: 0;
  left: 0;
  right: 0;
  width: 100%;
  padding: 0 4px 8px;
  /* will-change: transform, opacity; */
  transition: 400ms 50ms cubic-bezier(0.16, 1, 0.3, 1);
  transition-property: transform, opacity;
  ${(props) => !props.$active && Ae`
      pointer-events: none;
      position: absolute;
      opacity: 0;
      transform: scale(0.95);
      transition-duration: 300ms;
      transition-delay: 0ms;
    `}
`;
var Slider = styled.div`
  --background: var(--ck-body-background-secondary);
  --background-transparent: var(--ck-body-background-transparent, transparent);
  position: relative;
  padding: 0 0 4px;
  border-radius: 16px;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    margin: 0 -24px;
    ${Slides} {
      position: relative;
      z-index: 3;
      display: flex;
      overflow: auto;
      scroll-behavior: smooth;
      scroll-snap-type: x mandatory;
      margin-top: -${imageHeight}px;
      padding-top: ${imageHeight}px;
      -ms-overflow-style: none; /* Internet Explorer 10+ */
      scrollbar-width: none; /* Firefox */
      &::-webkit-scrollbar {
        display: none; /* Safari and Chrome */
      }
    }
    ${Slide} {
      position: relative;
      opacity: 1;
      transform: none;
      flex-shrink: 0;
      scroll-snap-align: start;
    }
  }
`;
var Dots = styled.div`
  position: relative;
  top: -1px;
  display: flex;
  justify-content: center;
  pointer-events: auto;
`;
var Dot = styled.button`
  display: flex;
  align-items: center;
  height: 28px;
  padding: 2px;
  background: none;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    padding: 4px;
    &:before {
      transform: none !important;
    }
  }
  &:before {
    content: '';
    display: block;
    width: 16px;
    height: 3px;
    opacity: 0.12;
    border-radius: 4px;
    background: var(--ck-accent-color, var(--ck-body-color));
    transition: transform 200ms ease, opacity 180ms ease;
  }
  ${(props) => props.$active ? Ae`
          cursor: default;
          &:before {
            opacity: 1;
          }
        ` : !props.disabled && Ae`
          cursor: pointer;
          &:hover:before {
            transform: scaleY(3.5);
          }
          &:active:before {
          }
        `}
`;
var pulseAnim = { scale: [0.9, 1.25, 1.6], opacity: [0, 0.11, 0] };
var pulseTransition = { ease: "linear", duration: 2, repeat: Infinity };
var Center = styled.div`
  position: absolute;
  left: 50%;
  top: 50%;
  transform: translateY(-50%) translateX(-50%);
`;
var spin = We`
  from{ transform: rotate(0deg); }
  to{ transform: rotate(360deg); }
`;
var SpinContainer = styled(motion.div)`
  z-index: -1;
  position: absolute;
  inset: 0;
  overflow: hidden;
  border-radius: 100%;
  animation: ${spin} 16s linear infinite;
`;
var BgLighten = styled(motion.div)`
  overflow: hidden;
  border-radius: inherit;
  z-index: 0;
  position: absolute;
  inset: 0;
  background: rgba(255, 255, 255, 0.1);
`;
var MainCircle = styled(motion.div)`
  z-index: 2;
  position: relative;
  border-radius: 50%;
  background: var(--ck-body-background);
`;
var MainCircleInner = styled(motion.div)`
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 50%;
`;
var Compass = (0, import_jsx_runtime.jsxs)("svg", { width: "34", height: "34", viewBox: "0 0 34 34", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { d: "M17 34C26.3 34 34 26.2833 34 17C34 7.7 26.2833 0 16.9833 0C7.7 0 0 7.7 0 17C0 26.2833 7.71667 34 17 34ZM9.83333 25.6833C8.68333 26.2333 7.8 25.3333 8.33333 24.2L13.1667 14.3333C13.45 13.75 13.8167 13.3833 14.35 13.1333L24.1833 8.33333C25.4 7.75 26.25 8.65 25.6833 9.81667L20.8833 19.6667C20.6167 20.2 20.2333 20.6 19.6833 20.85L9.83333 25.6833ZM17.0167 19.1333C18.1833 19.1333 19.1333 18.1833 19.1333 17.0167C19.1333 15.85 18.1833 14.9167 17.0167 14.9167C15.8667 14.9167 14.9167 15.85 14.9167 17.0167C14.9167 18.1833 15.8667 19.1333 17.0167 19.1333Z", fill: "var(--ck-graphic-compass-color, var(--ck-body-color))" }), (0, import_jsx_runtime.jsx)("path", { d: "M17 34C26.3 34 34 26.2833 34 17C34 7.7 26.2833 0 16.9833 0C7.7 0 0 7.7 0 17C0 26.2833 7.71667 34 17 34ZM9.83333 25.6833C8.68333 26.2333 7.8 25.3333 8.33333 24.2L13.1667 14.3333C13.45 13.75 13.8167 13.3833 14.35 13.1333L24.1833 8.33333C25.4 7.75 26.25 8.65 25.6833 9.81667L20.8833 19.6667C20.6167 20.2 20.2333 20.6 19.6833 20.85L9.83333 25.6833ZM17.0167 19.1333C18.1833 19.1333 19.1333 18.1833 19.1333 17.0167C19.1333 15.85 18.1833 14.9167 17.0167 14.9167C15.8667 14.9167 14.9167 15.85 14.9167 17.0167C14.9167 18.1833 15.8667 19.1333 17.0167 19.1333Z", fill: "url(#ck-compass-gradient)" }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsxs)("linearGradient", { id: "ck-compass-gradient", x1: "17", y1: "0", x2: "17", y2: "34", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "rgba(0,0,0,0)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "rgba(0,0,0,0.05)" })] }) })] });
var Wallet = ({ inverted = false }) => (0, import_jsx_runtime.jsxs)("svg", { width: "58", height: "50", viewBox: "0 0 58 50", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M57.9332 20.3335V42.1113C57.9332 46.4069 54.451 49.8891 50.1555 49.8891H8.15546C3.85991 49.8891 0.377686 46.4069 0.377686 42.1113V25.0002V7.8891C0.377686 3.59355 3.85991 0.111328 8.15546 0.111328H47.0444C48.7626 0.111328 50.1555 1.50422 50.1555 3.22244C50.1555 4.94066 48.7626 6.33355 47.0443 6.33355H9.71102C7.9928 6.33355 6.59991 7.72644 6.59991 9.44466C6.59991 11.1629 7.9928 12.5558 9.71102 12.5558H50.1555C54.451 12.5558 57.9332 16.038 57.9332 20.3335ZM46.2667 34.3337C48.4145 34.3337 50.1556 32.5926 50.1556 30.4448C50.1556 28.297 48.4145 26.5559 46.2667 26.5559C44.1189 26.5559 42.3778 28.297 42.3778 30.4448C42.3778 32.5926 44.1189 34.3337 46.2667 34.3337Z", fill: inverted ? "var(--ck-graphic-primary-color, var(--ck-body-background))" : "var(--ck-graphic-primary-color, var(--ck-body-color))" }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_2501_7732", x1: "29.1555", y1: "0.111328", x2: "29.1555", y2: "49.8891", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: inverted ? "var(--ck-body-color-muted)" : "var(--ck-body-background-transparent, transparent)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: inverted ? "var(--ck-body-color)" : "var(--ck-body-background)" })] }) })] });
var Send = (0, import_jsx_runtime.jsx)("svg", { width: "41", height: "41", viewBox: "0 0 41 41", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)("path", { d: "M35.4446 0.839914L2.14484 10.7065C0.0395033 11.3303 -0.632966 13.9786 0.919705 15.5313L7.9624 22.574C9.47585 24.0874 11.8661 24.273 13.5951 23.0114L25.2866 14.4797C25.5558 14.2832 25.9281 14.3121 26.1638 14.5478C26.3998 14.7838 26.4285 15.1567 26.2313 15.426L17.6874 27.0937C16.4213 28.8228 16.6052 31.2168 18.1206 32.7322L25.1811 39.7926C26.7337 41.3453 29.382 40.6728 30.0058 38.5675L39.8724 5.2677C40.6753 2.55794 38.1544 0.037024 35.4446 0.839914Z", fill: "var(--ck-graphic-secondary-color, white)" }) });
var Receive = (0, import_jsx_runtime.jsx)("svg", { width: "38", height: "44", viewBox: "0 0 38 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19 0.875C21.4853 0.875 23.5 2.88972 23.5 5.375V27.761L30.068 21.193C31.8254 19.4357 34.6746 19.4357 36.432 21.193C38.1893 22.9504 38.1893 25.7996 36.432 27.557L22.182 41.807C20.4246 43.5643 17.5754 43.5643 15.818 41.807L1.56802 27.557C-0.18934 25.7996 -0.18934 22.9504 1.56802 21.193C3.32538 19.4357 6.17462 19.4357 7.93198 21.193L14.5 27.761V5.375C14.5 2.88972 16.5147 0.875 19 0.875Z", fill: "var(--ck-graphic-secondary-color, white)" }) });
var Key = ({ ...props }) => {
  var _a2;
  const id3 = (_a2 = props === null || props === void 0 ? void 0 : props.id) !== null && _a2 !== void 0 ? _a2 : "";
  return (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "81", height: "81", viewBox: "0 0 81 81", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M81 27C81 41.9117 68.9117 54 54 54C51.2722 54 48.6389 53.5955 46.1568 52.8432L36 63H27V72H18V81H4.5C2.01472 81 0 78.9853 0 76.5V64.864C0 63.6705 0.474103 62.5259 1.31802 61.682L28.1568 34.8432C27.4045 32.3611 27 29.7278 27 27C27 12.0883 39.0883 0 54 0C68.9117 0 81 12.0883 81 27ZM60.75 25.875C63.8566 25.875 66.375 23.3566 66.375 20.25C66.375 17.1434 63.8566 14.625 60.75 14.625C57.6434 14.625 55.125 17.1434 55.125 20.25C55.125 23.3566 57.6434 25.875 60.75 25.875Z", fill: `url(#${id3}paint0_linear_2509_6177)` }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M81 27C81 41.9117 68.9117 54 54 54C51.2722 54 48.6389 53.5955 46.1568 52.8432L36 63H27V72H18V81H4.5C2.01472 81 0 78.9853 0 76.5V64.864C0 63.6705 0.474103 62.5259 1.31802 61.682L28.1568 34.8432C27.4045 32.3611 27 29.7278 27 27C27 12.0883 39.0883 0 54 0C68.9117 0 81 12.0883 81 27ZM60.75 25.875C63.8566 25.875 66.375 23.3566 66.375 20.25C66.375 17.1434 63.8566 14.625 60.75 14.625C57.6434 14.625 55.125 17.1434 55.125 20.25C55.125 23.3566 57.6434 25.875 60.75 25.875Z", fill: `url(#${id3}paint1_radial_2509_6177)`, fillOpacity: "0.2" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M44.5658 51.2522C45.1527 50.6653 46.0151 50.4492 46.8095 50.6899C49.0823 51.3788 51.4958 51.75 54 51.75C67.6691 51.75 78.75 40.669 78.75 27C78.75 13.331 67.6691 2.25 54 2.25C40.331 2.25 29.25 13.331 29.25 27C29.25 29.5042 29.6212 31.9177 30.3101 34.1905C30.5508 34.9849 30.3347 35.8473 29.7478 36.4342L2.90901 63.273C2.48705 63.6949 2.25 64.2672 2.25 64.864V76.5C2.25 77.7426 3.25736 78.75 4.5 78.75H15.75V72C15.75 70.7574 16.7574 69.75 18 69.75H24.75V63C24.75 61.7574 25.7574 60.75 27 60.75H35.068L44.5658 51.2522ZM36 63H27V72H18V81H4.5C2.01472 81 0 78.9853 0 76.5V64.864C0 63.6705 0.474103 62.5259 1.31802 61.682L28.1568 34.8432C27.4045 32.3611 27 29.7278 27 27C27 12.0883 39.0883 0 54 0C68.9117 0 81 12.0883 81 27C81 41.9117 68.9117 54 54 54C51.2722 54 48.6389 53.5955 46.1568 52.8432L36 63ZM68.625 20.25C68.625 24.5992 65.0992 28.125 60.75 28.125C56.4008 28.125 52.875 24.5992 52.875 20.25C52.875 15.9008 56.4008 12.375 60.75 12.375C65.0992 12.375 68.625 15.9008 68.625 20.25ZM66.375 20.25C66.375 23.3566 63.8566 25.875 60.75 25.875C57.6434 25.875 55.125 23.3566 55.125 20.25C55.125 17.1434 57.6434 14.625 60.75 14.625C63.8566 14.625 66.375 17.1434 66.375 20.25Z", fill: "black", fillOpacity: "0.1" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M33.4205 47.5795C33.8598 48.0188 33.8598 48.7312 33.4205 49.1705L3.0455 79.5455C2.60616 79.9848 1.89384 79.9848 1.4545 79.5455C1.01517 79.1062 1.01517 78.3938 1.4545 77.9545L31.8295 47.5795C32.2688 47.1402 32.9812 47.1402 33.4205 47.5795Z", fill: "#A5A9AD" }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: `${id3}paint0_linear_2509_6177`, x1: "72", y1: "5.625", x2: "2.25", y2: "78.75", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#D4DFE6" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.0967282", stopColor: "#C6CACD" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.526645", stopColor: "#BDBAC4" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "#939CA1" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: `${id3}paint1_radial_2509_6177`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(52.875 12.375) rotate(93.2705) scale(39.4392)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "white" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "white" })] })] })] });
};
var VitalikAddress = (0, import_jsx_runtime.jsxs)("svg", { width: "131", height: "14", viewBox: "0 0 131 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { d: "M5.74805 13.2549C8.86816 13.2549 10.7227 10.6973 10.7227 6.63672C10.7227 2.57617 8.85059 0.0625 5.74805 0.0625C2.63672 0.0625 0.755859 2.59375 0.755859 6.64551C0.755859 10.7148 2.61914 13.2549 5.74805 13.2549ZM5.74805 11.4004C4.02539 11.4004 3.04102 9.64258 3.04102 6.63672C3.04102 3.68359 4.04297 1.91699 5.74805 1.91699C7.44434 1.91699 8.4375 3.6748 8.4375 6.64551C8.4375 9.65137 7.46191 11.4004 5.74805 11.4004Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M13.0869 13.1758C13.4561 13.1758 13.6934 13.0439 13.9658 12.6221L15.9697 9.66016H16.0137L18.0264 12.6572C18.2549 13.0088 18.4922 13.1758 18.8965 13.1758C19.4854 13.1758 19.9424 12.7891 19.9424 12.209C19.9424 11.9805 19.8633 11.7695 19.7051 11.541L17.376 8.28906L19.6963 5.16016C19.8896 4.90527 19.9688 4.68555 19.9688 4.43066C19.9688 3.88574 19.5381 3.49902 18.9229 3.49902C18.5361 3.49902 18.2988 3.6748 18.0176 4.10547L16.1191 6.95312H16.0752L14.1328 4.08789C13.8516 3.64844 13.6318 3.49902 13.2012 3.49902C12.6035 3.49902 12.1465 3.91211 12.1465 4.44824C12.1465 4.70312 12.2256 4.92285 12.3838 5.13379L14.7129 8.35059L12.3486 11.5498C12.1641 11.8135 12.0762 12.0156 12.0762 12.2705C12.0762 12.7979 12.498 13.1758 13.0869 13.1758Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M26.2441 13.2549C29.1445 13.2549 31.1924 11.7432 31.1924 9.57227C31.1924 7.9375 30.0146 6.68066 28.3184 6.3291V6.27637C29.7773 5.87207 30.7178 4.7998 30.7178 3.45508C30.7178 1.48633 28.8633 0.0625 26.2441 0.0625C23.625 0.0625 21.7617 1.49512 21.7617 3.44629C21.7617 4.80859 22.7109 5.88965 24.1699 6.27637V6.3291C22.4736 6.67188 21.3047 7.92871 21.3047 9.57227C21.3047 11.7344 23.335 13.2549 26.2441 13.2549ZM26.2441 5.55566C24.9258 5.55566 24.0029 4.78223 24.0029 3.6748C24.0029 2.55859 24.9258 1.77637 26.2441 1.77637C27.5537 1.77637 28.4854 2.5498 28.4854 3.6748C28.4854 4.78223 27.5537 5.55566 26.2441 5.55566ZM26.2441 11.5234C24.7236 11.5234 23.6514 10.6357 23.6514 9.40527C23.6514 8.1748 24.7236 7.28711 26.2441 7.28711C27.7646 7.28711 28.8369 8.16602 28.8369 9.40527C28.8369 10.6357 27.7646 11.5234 26.2441 11.5234Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M36.3164 13.1494C37.7578 13.1494 38.7598 12.4199 39.208 11.3477H39.252V12.0771C39.252 12.7891 39.7266 13.1758 40.3594 13.1758C40.9922 13.1758 41.4404 12.7803 41.4404 12.0771V1.29297C41.4404 0.554688 40.9834 0.141602 40.3418 0.141602C39.7002 0.141602 39.252 0.554688 39.252 1.29297V5.24805H39.1992C38.707 4.21973 37.6523 3.52539 36.3164 3.52539C33.9697 3.52539 32.4492 5.38867 32.4492 8.33301C32.4492 11.2949 33.9697 13.1494 36.3164 13.1494ZM36.9756 11.3564C35.5605 11.3564 34.6904 10.1963 34.6904 8.3418C34.6904 6.49609 35.5693 5.32715 36.9756 5.32715C38.3555 5.32715 39.2607 6.51367 39.2607 8.3418C39.2607 10.1875 38.3555 11.3564 36.9756 11.3564Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M44.0508 13.1494C44.6396 13.1494 44.9736 12.8594 45.1846 12.1738L46.0195 9.76562H50.7568L51.5918 12.1914C51.7939 12.8682 52.1367 13.1494 52.752 13.1494C53.4111 13.1494 53.8857 12.7188 53.8857 12.1035C53.8857 11.9014 53.8418 11.6992 53.7363 11.4092L50.0449 1.38965C49.7285 0.537109 49.2188 0.167969 48.3838 0.167969C47.5576 0.167969 47.0479 0.554688 46.7402 1.39844L43.0576 11.4092C42.9521 11.6816 42.9082 11.9277 42.9082 12.1035C42.9082 12.7451 43.3564 13.1494 44.0508 13.1494ZM46.5557 7.97266L48.3398 2.55859H48.4014L50.2031 7.97266H46.5557Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M60.1172 13.2549C62.8594 13.2549 64.8545 11.4004 64.8545 8.8252C64.8545 6.42578 63.1406 4.66797 60.6973 4.66797C58.9746 4.66797 57.709 5.54688 57.208 6.71582H57.1641V6.58398C57.208 3.66602 58.2275 1.89941 60.1436 1.89941C61.084 1.89941 61.7607 2.26855 62.3496 3.07715C62.7012 3.52539 62.9824 3.73633 63.4307 3.73633C64.0283 3.73633 64.3975 3.34082 64.3975 2.82227C64.3975 2.57617 64.3359 2.35645 64.1953 2.10156C63.5625 0.897461 62.0859 0.0537109 60.1523 0.0537109C56.9268 0.0537109 54.9932 2.57617 54.9932 6.80371C54.9932 8.24512 55.2305 9.45801 55.6963 10.4336C56.5752 12.2881 58.1396 13.2549 60.1172 13.2549ZM60.082 11.4092C58.667 11.4092 57.5508 10.293 57.5508 8.86914C57.5508 7.4541 58.6494 6.41699 60.1084 6.41699C61.5674 6.41699 62.6309 7.4541 62.6221 8.91309C62.6221 10.3018 61.4971 11.4092 60.082 11.4092Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M68.1328 8.83398C68.8447 8.83398 69.416 8.27148 69.416 7.55078C69.416 6.83008 68.8447 6.25879 68.1328 6.25879C67.4121 6.25879 66.8408 6.83008 66.8408 7.55078C66.8408 8.27148 67.4121 8.83398 68.1328 8.83398Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M73.3359 8.83398C74.0479 8.83398 74.6191 8.27148 74.6191 7.55078C74.6191 6.83008 74.0479 6.25879 73.3359 6.25879C72.6152 6.25879 72.0439 6.83008 72.0439 7.55078C72.0439 8.27148 72.6152 8.83398 73.3359 8.83398Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M78.5391 8.83398C79.251 8.83398 79.8223 8.27148 79.8223 7.55078C79.8223 6.83008 79.251 6.25879 78.5391 6.25879C77.8184 6.25879 77.2471 6.83008 77.2471 7.55078C77.2471 8.27148 77.8184 8.83398 78.5391 8.83398Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M83.7422 8.83398C84.4541 8.83398 85.0254 8.27148 85.0254 7.55078C85.0254 6.83008 84.4541 6.25879 83.7422 6.25879C83.0215 6.25879 82.4502 6.83008 82.4502 7.55078C82.4502 8.27148 83.0215 8.83398 83.7422 8.83398Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M92.2148 13.2549C94.957 13.2549 96.9521 11.4004 96.9521 8.8252C96.9521 6.42578 95.2383 4.66797 92.7949 4.66797C91.0723 4.66797 89.8066 5.54688 89.3057 6.71582H89.2617V6.58398C89.3057 3.66602 90.3252 1.89941 92.2412 1.89941C93.1816 1.89941 93.8584 2.26855 94.4473 3.07715C94.7988 3.52539 95.0801 3.73633 95.5283 3.73633C96.126 3.73633 96.4951 3.34082 96.4951 2.82227C96.4951 2.57617 96.4336 2.35645 96.293 2.10156C95.6602 0.897461 94.1836 0.0537109 92.25 0.0537109C89.0244 0.0537109 87.0908 2.57617 87.0908 6.80371C87.0908 8.24512 87.3281 9.45801 87.7939 10.4336C88.6729 12.2881 90.2373 13.2549 92.2148 13.2549ZM92.1797 11.4092C90.7646 11.4092 89.6484 10.293 89.6484 8.86914C89.6484 7.4541 90.7471 6.41699 92.2061 6.41699C93.665 6.41699 94.7285 7.4541 94.7197 8.91309C94.7197 10.3018 93.5947 11.4092 92.1797 11.4092Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M103.377 13.2549C106.497 13.2549 108.352 10.6973 108.352 6.63672C108.352 2.57617 106.479 0.0625 103.377 0.0625C100.266 0.0625 98.3848 2.59375 98.3848 6.64551C98.3848 10.7148 100.248 13.2549 103.377 13.2549ZM103.377 11.4004C101.654 11.4004 100.67 9.64258 100.67 6.63672C100.67 3.68359 101.672 1.91699 103.377 1.91699C105.073 1.91699 106.066 3.6748 106.066 6.64551C106.066 9.65137 105.091 11.4004 103.377 11.4004Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M117.167 13.1758C117.8 13.1758 118.248 12.7715 118.248 12.0596V10.5654H119.127C119.733 10.5654 120.094 10.1875 120.094 9.63379C120.094 9.08887 119.733 8.70215 119.136 8.70215H118.248V1.81152C118.248 0.756836 117.554 0.141602 116.385 0.141602C115.453 0.141602 114.899 0.52832 114.073 1.75879C112.553 3.99121 111.111 6.16211 110.224 7.75293C109.872 8.38574 109.731 8.79883 109.731 9.29102C109.731 10.0469 110.268 10.5654 111.085 10.5654H116.086V12.0596C116.086 12.7715 116.543 13.1758 117.167 13.1758ZM116.121 8.75488H111.788V8.69336C112.816 6.82129 114.073 4.92285 116.086 2.04004H116.121V8.75488Z", fill: "var(--ck-body-color)" }), (0, import_jsx_runtime.jsx)("path", { d: "M126.105 13.2549C128.918 13.2549 130.869 11.4355 130.869 8.78125C130.869 6.35547 129.138 4.6416 126.712 4.6416C125.438 4.6416 124.392 5.13379 123.855 5.9248H123.812L124.146 2.17188H129.27C129.85 2.17188 130.228 1.80273 130.228 1.24023C130.228 0.686523 129.85 0.317383 129.27 0.317383H123.803C122.81 0.317383 122.3 0.72168 122.221 1.72363L121.816 6.51367C121.808 6.56641 121.808 6.60156 121.808 6.6543C121.79 7.26953 122.15 7.78809 122.88 7.78809C123.398 7.78809 123.618 7.67383 124.146 7.14648C124.629 6.67188 125.323 6.34668 126.123 6.34668C127.617 6.34668 128.681 7.38379 128.681 8.84277C128.681 10.3457 127.617 11.4092 126.114 11.4092C124.893 11.4092 124.049 10.8027 123.618 9.77441C123.381 9.30859 123.091 9.12402 122.616 9.12402C122.019 9.12402 121.641 9.49316 121.641 10.082C121.641 10.4072 121.72 10.6709 121.843 10.9434C122.467 12.3232 124.154 13.2549 126.105 13.2549Z", fill: "var(--ck-body-color)" })] });
var SlideOne = ({ layoutId }) => {
  return (0, import_jsx_runtime.jsxs)("div", { style: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }, children: [(0, import_jsx_runtime.jsx)(motion.div, { initial: { rotate: 90, scale: 0.2, x: "100%" }, animate: { rotate: 0, scale: 1, x: 0 }, exit: { rotate: 40, scale: 0.1, x: "70%" }, style: {
    zIndex: 4,
    position: "relative",
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    width: 76,
    height: 76,
    background: "var(--ck-graphic-secondary-background, #6366F1)",
    borderRadius: "50%",
    boxShadow: "var(--ck-graphic-secondary-box-shadow, 0px 2px 10px rgba(99, 102, 241, 0.3))"
  }, children: Receive }), (0, import_jsx_runtime.jsx)(MainCircle, { layoutId, style: {
    position: "relative",
    zIndex: 10,
    margin: "0 -8px",
    width: 112,
    height: 112
  }, children: (0, import_jsx_runtime.jsxs)(MainCircleInner, { style: {
    background: "var(--ck-graphic-primary-background, var(--ck-body-background))",
    boxShadow: "var(--ck-graphic-primary-box-shadow, 0px 3px 15px rgba(0, 0, 0, 0.1))"
  }, initial: {
    opacity: 0
  }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: [(0, import_jsx_runtime.jsx)(BgLighten, {}), (0, import_jsx_runtime.jsx)(motion.div, { style: { zIndex: 2, position: "relative" }, children: (0, import_jsx_runtime.jsx)(Wallet, {}) })] }, "SlideOneInner") }, layoutId), (0, import_jsx_runtime.jsx)(motion.div, { initial: { rotate: -90, scale: 0.2, x: "-100%" }, animate: { rotate: 0, scale: 1, x: 0 }, exit: { rotate: -40, scale: 0.1, x: "-70%" }, style: {
    zIndex: 4,
    position: "relative",
    width: 76,
    height: 76,
    background: "var(--ck-graphic-secondary-background, #3897FB)",
    borderRadius: "50%",
    boxShadow: "var(--ck-graphic-secondary-box-shadow, 0px 2px 10px rgba(56, 151, 251, 0.3))"
  }, children: (0, import_jsx_runtime.jsx)(Center, { children: (0, import_jsx_runtime.jsx)("div", { style: { position: "relative", left: -2, top: 3 }, children: Send }) }) })] });
};
var SlideTwo = ({ layoutId }) => {
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsxs)("div", { style: {
    position: "relative",
    left: -14
  }, children: [(0, import_jsx_runtime.jsx)(MainCircle, { layoutId, style: {
    zIndex: 10,
    position: "absolute",
    left: 15,
    top: 12,
    width: 32,
    height: 32
  }, children: (0, import_jsx_runtime.jsx)(MainCircleInner, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, style: {
    background: "var(--ck-graphic-primary-background, var(--ck-body-background))",
    boxShadow: "var(--ck-graphic-primary-box-shadow, 0px 2px 5px rgba(37, 41, 46, 0.16))"
  }, children: (0, import_jsx_runtime.jsx)(Center, { children: (0, import_jsx_runtime.jsx)(Wallet, {}) }) }, "SlideTwoInner") }, layoutId), (0, import_jsx_runtime.jsxs)(motion.div, { initial: { scale: 0.2 }, animate: { scale: 1 }, exit: { scale: 0.2 }, style: {
    zIndex: 7,
    position: "relative",
    display: "flex",
    alignItems: "center",
    padding: "21px 56px",
    paddingRight: 52,
    background: "var(--ck-graphic-primary-background, var(--ck-body-background))",
    boxShadow: "var(--ck-graphic-primary-box-shadow, 0px 2px 9px rgba(0, 0, 0, 0.07))",
    borderRadius: "var(--ck-border-radius, 16px)"
  }, children: [(0, import_jsx_runtime.jsx)(BgLighten, {}), (0, import_jsx_runtime.jsx)("div", { style: { position: "relative", zIndex: 2, top: 1, left: 1 }, children: VitalikAddress })] }), (0, import_jsx_runtime.jsx)(motion.div, { style: {
    zIndex: 8,
    position: "absolute",
    top: -16,
    right: -28
  }, initial: { rotate: 90, x: -70, scale: 0.4 }, animate: { rotate: 0, x: 0, scale: 1 }, exit: { rotate: 0, x: -70, scale: 0.4 }, children: (0, import_jsx_runtime.jsx)(Key, { id: layoutId }) })] }) });
};
var SlideThree = ({ layoutId }) => {
  const id3 = Math.random();
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsxs)(motion.div, { style: {
    position: "relative"
  }, children: [(0, import_jsx_runtime.jsxs)(MainCircle, { layoutId, initial: { rotate: 80 }, style: {
    zIndex: 10,
    position: "relative",
    width: 128,
    height: 128
  }, children: [(0, import_jsx_runtime.jsx)(MainCircleInner, { initial: { opacity: 0, rotate: 100 }, animate: { opacity: 1 }, exit: { opacity: 0 }, style: {
    overflow: "hidden",
    background: `var(--ck-graphic-globe-background, radial-gradient(
              82.42% 82.42% at 50% 86.72%,
              rgba(255, 255, 255, 0.2) 0%,
              rgba(0, 0, 0, 0) 100%
            ),
            linear-gradient(180deg, #3897FB 0%, #5004F1 100%))`,
    boxShadow: "var(--ck-graphic-globe-box-shadow, 0px -6px 20px rgba(56, 151, 251, 0.23))"
  }, children: (0, import_jsx_runtime.jsx)(SpinContainer, { style: !Boolean(layoutId) ? {
    animationPlayState: "paused"
  } : void 0, children: (0, import_jsx_runtime.jsxs)("svg", { width: "128", height: "128", viewBox: "0 0 128 128", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsxs)("g", { children: [(0, import_jsx_runtime.jsx)("circle", { cx: "30", cy: "141", r: "64", stroke: `url(#networkRadialA-${id3})`, strokeWidth: "3" }), (0, import_jsx_runtime.jsx)("circle", { cx: "78.8515", cy: "131.123", r: "54.1005", transform: "rotate(-37.4016 78.8515 131.123)", stroke: `url(#networkRadialB-${id3})`, strokeWidth: "3" }), (0, import_jsx_runtime.jsx)("circle", { cx: "63.6053", cy: "2.12794", r: "50.8338", transform: "rotate(134.702 63.6053 2.12794)", stroke: `url(#networkRadialC-${id3})`, strokeWidth: "3" }), (0, import_jsx_runtime.jsx)("circle", { cx: "126.658", cy: "56.6577", r: "50.3433", transform: "rotate(-105 126.658 56.6577)", stroke: `url(#networkRadialD-${id3})`, strokeWidth: "3" }), (0, import_jsx_runtime.jsx)("circle", { cx: "13.6619", cy: "18.9603", r: "46.0247", transform: "rotate(107.362 13.6619 18.9603)", stroke: `url(#networkRadialE-${id3})`, strokeWidth: "3" })] }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("radialGradient", { id: `networkRadialA-${id3}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(60.5 84) rotate(104.668) scale(77.0097)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: `networkRadialB-${id3}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(96.1805 81.6717) rotate(97.125) scale(64.7443)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: `networkRadialC-${id3}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(96.3816 -36.4455) rotate(114.614) scale(57.7177)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: `networkRadialD-${id3}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(137.86 7.73234) rotate(92.3288) scale(62.743)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: `networkRadialE-${id3}`, cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(35.3203 -21.566) rotate(104.513) scale(54.8617)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-globe-lines, white)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-graphic-globe-lines, white)", stopOpacity: "0" })] })] })] }) }) }, "SlideThreeInner"), (0, import_jsx_runtime.jsxs)(motion.div, { exit: { opacity: 0 }, children: [(0, import_jsx_runtime.jsx)(motion.div, { initial: !Boolean(layoutId) ? { scale: 1.1 } : void 0, animate: Boolean(layoutId) ? pulseAnim : void 0, transition: { ...pulseTransition }, style: {
    position: "absolute",
    inset: 0,
    borderRadius: "50%",
    boxShadow: "0 0 0 2px var(--ck-graphic-globe-lines, rgba(126, 112, 243, 1))"
  } }, "pulseA"), (0, import_jsx_runtime.jsx)(motion.div, { initial: !Boolean(layoutId) ? { scale: 1.2, opacity: 0.25 } : void 0, animate: Boolean(layoutId) ? pulseAnim : void 0, transition: { ...pulseTransition, delay: 0.5 }, style: {
    position: "absolute",
    inset: 0,
    borderRadius: "50%",
    boxShadow: "0 0 0 2px var(--ck-graphic-globe-lines, rgba(126, 112, 243, 1))"
  } }, "pulseB")] })] }, layoutId), (0, import_jsx_runtime.jsxs)(motion.div, { initial: { rotate: -20, scale: 0.1, y: -10, x: -10 }, animate: { rotate: 0, scale: 1, y: 0, x: 0 }, exit: { zIndex: 3, scale: 0.2, y: -25, x: 15 }, style: {
    zIndex: 12,
    borderRadius: "50%",
    position: "absolute",
    bottom: -4,
    right: -4,
    width: 54,
    height: 54,
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    padding: 13,
    background: "var(--ck-graphic-compass-background, var(--ck-body-background))",
    boxShadow: "var(--ck-graphic-compass-box-shadow, 0px 2px 9px rgba(0, 0, 0, 0.15))"
  }, children: [(0, import_jsx_runtime.jsx)(BgLighten, {}), (0, import_jsx_runtime.jsx)(motion.div, { style: { zIndex: 2, position: "absolute" }, initial: { rotate: -170 }, animate: { rotate: 0 }, exit: {
    rotate: -180,
    transition: { duration: 0 }
    // needed to avoid AnimatePresence taking too long to unmount the animation which causes issues on page close
  }, transition: {
    type: "spring",
    stiffness: 6,
    damping: 0.9,
    mass: 0.2
  }, children: Compass })] })] }, "SlideThree") });
};
var About = () => {
  var _a2, _b;
  const locales = useLocales({
    //CONNECTORNAME: connector.name,
  });
  const context = useContext21();
  const ctaUrl = (_b = (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.ethereumOnboardingUrl) !== null && _b !== void 0 ? _b : locales.aboutScreen_ctaUrl;
  const [ready, setReady] = (0, import_react70.useState)(true);
  const [slider, setSlider] = (0, import_react70.useState)(0);
  const interacted = (0, import_react70.useRef)(false);
  const scrollPos = (0, import_react70.useRef)(0);
  const animationEase = [0.16, 1, 0.3, 1];
  const animationDuration = 600;
  let interval;
  (0, import_react70.useEffect)(() => {
    return () => clearInterval(interval);
  }, []);
  const isSwipe = () => {
    if (sliderRef.current) {
      const { overflow } = getComputedStyle(sliderRef.current);
      return overflow !== "visible";
    }
    return false;
  };
  const gotoSlide = (index5) => {
    setReady(false);
    if (isSwipe()) {
      scrollToSlide(index5);
    } else {
      setSlider(index5);
    }
  };
  const scrollToSlide = (index5) => {
    if (sliderRef.current) {
      const { offsetWidth: width } = sliderRef.current;
      sliderRef.current.scrollLeft = width * index5;
      setTimeout(() => setSlider(index5), 100);
    }
  };
  const onScroll = () => {
    if (!sliderRef.current)
      return;
    const { offsetWidth: width, scrollLeft: x2 } = sliderRef.current;
    const prevScroll = scrollPos.current;
    scrollPos.current = x2;
    const threshold = 4;
    if (prevScroll - x2 > -threshold && prevScroll - x2 < threshold) {
      const currentSlide = Math.round(x2 / width);
      setSlider(currentSlide);
    }
  };
  const onTouchMove = () => {
    didInteract();
  };
  const onTouchEnd = () => {
    const { offsetWidth: width, scrollLeft: x2 } = sliderRef.current;
    const currentSlide = Math.round(x2 / width);
    setSlider(currentSlide);
  };
  const didInteract = () => {
    interacted.current = true;
    clearTimeout(interval);
  };
  const sliderRef = (0, import_react70.useRef)(null);
  (0, import_react70.useEffect)(() => {
    if (!sliderRef.current)
      return;
    sliderRef.current.addEventListener("scroll", onScroll);
    sliderRef.current.addEventListener("touchmove", onTouchMove);
    sliderRef.current.addEventListener("touchend", onTouchEnd);
    return () => {
      if (!sliderRef.current)
        return;
      sliderRef.current.removeEventListener("scroll", onScroll);
      sliderRef.current.removeEventListener("touchmove", onTouchMove);
      sliderRef.current.removeEventListener("touchend", onTouchEnd);
    };
  }, [sliderRef]);
  const graphics = [
    (0, import_jsx_runtime.jsx)(SlideOne, { layoutId: "graphicCircle", duration: animationDuration, ease: animationEase }),
    (0, import_jsx_runtime.jsx)(SlideTwo, { layoutId: "graphicCircle", duration: animationDuration, ease: animationEase }),
    (0, import_jsx_runtime.jsx)(SlideThree, { layoutId: "graphicCircle", duration: animationDuration, ease: animationEase })
  ];
  const mobileGraphics = [
    (0, import_jsx_runtime.jsx)(SlideOne, { duration: animationDuration, ease: animationEase }),
    (0, import_jsx_runtime.jsx)(SlideTwo, { duration: animationDuration, ease: animationEase }),
    (0, import_jsx_runtime.jsx)(SlideThree, { duration: animationDuration, ease: animationEase })
  ];
  const slideHeight = (() => {
    var _a3;
    switch ((_a3 = context.options) === null || _a3 === void 0 ? void 0 : _a3.language) {
      case "en-US":
      case "zh-CN":
        return 64;
      default:
        return 84;
    }
  })();
  const slides = [
    (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(ModalH1, { style: { height: 24 }, "$small": true, children: (0, import_jsx_runtime.jsx)(FitText, { children: locales.aboutScreen_a_h1 }) }), (0, import_jsx_runtime.jsx)(ModalBody, { style: { height: slideHeight }, children: (0, import_jsx_runtime.jsx)(FitText, { children: locales.aboutScreen_a_p }) })] }),
    (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(ModalH1, { style: { height: 24 }, "$small": true, children: (0, import_jsx_runtime.jsx)(FitText, { children: locales.aboutScreen_b_h1 }) }), (0, import_jsx_runtime.jsx)(ModalBody, { style: { height: slideHeight }, children: (0, import_jsx_runtime.jsx)(FitText, { children: locales.aboutScreen_b_p }) })] }),
    (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(ModalH1, { style: { height: 24 }, "$small": true, children: (0, import_jsx_runtime.jsx)(FitText, { children: locales.aboutScreen_c_h1 }) }), (0, import_jsx_runtime.jsx)(ModalBody, { style: { height: slideHeight }, children: (0, import_jsx_runtime.jsx)(FitText, { children: locales.aboutScreen_c_p }) })] })
  ];
  return (0, import_jsx_runtime.jsxs)(PageContent, { children: [(0, import_jsx_runtime.jsxs)(Slider, { children: [(0, import_jsx_runtime.jsx)(ImageContainer$1, { children: (0, import_jsx_runtime.jsx)(MotionConfig, { transition: {
    duration: animationDuration / 1e3,
    ease: animationEase
  }, children: (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, onExitComplete: () => setReady(true), children: graphics.map((g3, i2) => slider === i2 && (0, import_jsx_runtime.jsx)(ImageContainerInner, { style: { position: "absolute" }, children: g3 }, i2)) }) }) }), (0, import_jsx_runtime.jsx)(Slides, { ref: sliderRef, children: (0, import_jsx_runtime.jsx)(AnimatePresence, { children: slides.map((s2, i2) => (0, import_jsx_runtime.jsxs)(Slide, { "$active": slider === i2, children: [(0, import_jsx_runtime.jsx)(MobileImageContainer, { children: (0, import_jsx_runtime.jsx)(MotionConfig, { transition: {
    duration: 0
  }, children: (0, import_jsx_runtime.jsx)(ImageContainerInner, { children: mobileGraphics[i2] }) }) }), (0, import_jsx_runtime.jsx)(ModalContent, { style: { gap: 8, paddingBottom: 0 }, children: s2 })] }, i2)) }) })] }), (0, import_jsx_runtime.jsx)(OrDivider, { children: (0, import_jsx_runtime.jsx)(Dots, { children: slides.map((s2, i2) => (0, import_jsx_runtime.jsx)(Dot, { "$active": slider === i2, onClick: () => {
    didInteract();
    gotoSlide(i2);
  } }, i2)) }) }), (0, import_jsx_runtime.jsx)(Button, { href: ctaUrl, arrow: true, children: locales.aboutScreen_ctaText })] });
};
var Shimmer$1 = We`
  0%{ transform: translate(-100%) rotate(-45deg); }
  100%{ transform: translate(100%) rotate(-80deg); }
`;
var Container$7 = styled(motion.div)`
  display: flex;
  flex-direction: column;
  gap: 12px;
`;
var InfoBox = styled.div`
  padding: 24px 24px 28px;
  border-radius: var(--ck-tertiary-border-radius, 24px);
  box-shadow: var(--ck-tertiary-box-shadow, none);
  background: var(--ck-body-background-tertiary);
  ${ModalBody} {
    max-width: none;
  }
`;
var InfoBoxButtons = styled.div`
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
  margin: 5px -8px -12px;
  button {
  }
`;
var LearnMoreContainer = styled(motion.div)`
  text-align: center;
  margin-top: 16px;
  margin-bottom: -6px;
`;
var LearnMoreButton = styled(motion.button)`
  appearance: none;
  user-select: none;
  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  height: 42px;
  padding: 0 16px;
  border-radius: 6px;
  background: none;
  color: var(--ck-body-color-muted);
  font-size: 15px;
  line-height: 18px;
  font-weight: 500;
  /* will-change: transform; */
  transition: color 200ms ease, transform 100ms ease;
  svg {
    transition: all 100ms ease-out;
    display: block;
    position: relative;
    top: 2px;
    left: 2px;
    transform: translateZ(0px);
    path,
    circle {
      transition: all 100ms ease-out;
    }
    path:last-of-type {
      transform-origin: 0 0;
      transform: scaleX(1.3) skewY(-12deg);
      opacity: 0;
    }
    circle {
      transform: translate(20%, -15%);
    }
  }
  &:hover {
    color: var(--ck-body-color-muted-hover);
    svg {
      path,
      circle {
        opacity: 1;
        transform: none;
      }
    }
  }
  &:active {
    transform: scale(0.96);
  }
`;
styled(motion.div)`
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 0 0 16px;
  overflow-y: scroll;
  max-height: 20rem;

  &::-webkit-scrollbar {
    display: none;
  }
`;
styled(motion.button)`
  cursor: pointer;
  user-select: none;
  position: relative;
  display: flex;
  align-items: center;
  padding: 0 20px;
  width: 100%;
  height: 64px;
  font-size: 17px;
  font-weight: var(--ck-primary-button-font-weight, 500);
  line-height: 20px;
  text-align: var(--ck-body-button-text-align, left);
  transition: 180ms ease;
  transition-property: background, color, box-shadow, transform, opacity;
  will-change: transform, box-shadow, background-color, color, opacity;

  --fallback-color: var(--ck-primary-button-color);
  --fallback-background: var(--ck-primary-button-background);
  --fallback-box-shadow: var(--ck-primary-button-box-shadow);
  --fallback-border-radius: var(--ck-primary-button-border-radius);

  --color: var(--ck-primary-button-color, var(--fallback-color));
  --background: var(--ck-primary-button-background, var(--fallback-background));
  --box-shadow: var(--ck-primary-button-box-shadow, var(--fallback-box-shadow));
  --border-radius: var(
    --ck-primary-button-border-radius,
    var(--fallback-border-radius)
  );

  --hover-color: var(--ck-primary-button-hover-color, var(--color));
  --hover-background: var(
    --ck-primary-button-hover-background,
    var(--background)
  );
  --hover-box-shadow: var(
    --ck-primary-button-hover-box-shadow,
    var(--box-shadow)
  );
  --hover-border-radius: var(
    --ck-primary-button-hover-border-radius,
    var(--border-radius)
  );

  --active-color: var(--ck-primary-button-active-color, var(--hover-color));
  --active-background: var(
    --ck-primary-button-active-background,
    var(--hover-background)
  );
  --active-box-shadow: var(
    --ck-primary-button-active-box-shadow,
    var(--hover-box-shadow)
  );
  --active-border-radius: var(
    --ck-primary-button-active-border-radius,
    var(--hover-border-radius)
  );

  color: var(--color);
  background: var(--background);
  box-shadow: var(--box-shadow);
  border-radius: var(--border-radius);

  &:disabled {
    transition: 180ms ease;
    opacity: 0.4;
  }

  --bg: var(--background);
  &:not(:disabled) {
    &:hover {
      color: var(--hover-color);
      background: var(--hover-background);
      box-shadow: var(--hover-box-shadow);
      border-radius: var(--hover-border-radius);
      --bg: var(--hover-background, var(--background));
    }
    &:focus-visible {
      transition-duration: 100ms;
      color: var(--hover-color);
      background: var(--hover-background);
      box-shadow: var(--hover-box-shadow);
      border-radius: var(--hover-border-radius);
      --bg: var(--hover-background, var(--background));
    }
    &:active {
      color: var(--active-color);
      background: var(--active-background);
      box-shadow: var(--active-box-shadow);
      border-radius: var(--active-border-radius);
      --bg: var(--active-background, var(--background));
    }
  }
`;
styled(motion.span)`
  position: relative;
  top: var(--ck-recent-badge-top-offset, 0.5px);
  display: inline-block;
  padding: 10px 7px;
  line-height: 0;
  font-size: 13px;
  font-weight: 400;
  border-radius: var(--ck-recent-badge-border-radius, var(--border-radius));
  color: var(
    --ck-recent-badge-color,
    var(--ck-accent-color, var(--ck-body-color-muted, currentColor))
  );
  background: var(--ck-recent-badge-background, transparent);
  overflow: hidden;
  span {
    display: inline-block;
    position: relative;
  }
  &:before {
    z-index: 1;
    content: '';
    position: absolute;
    inset: 0;
    opacity: 0.4;
    box-shadow: var(--ck-recent-badge-box-shadow, inset 0 0 0 1px currentColor);
    border-radius: inherit;
  }
  &:after {
    z-index: 2;
    content: '';
    position: absolute;
    inset: -10%;
    top: -110%;
    aspect-ratio: 1/1;
    opacity: 0.7;
    background: linear-gradient(
      170deg,
      transparent 10%,
      var(--ck-recent-badge-background, var(--bg)) 50%,
      transparent 90%
    );
    animation: ${Shimmer$1} 2s linear infinite;
  }
`;
styled(motion.span)`
  display: flex;
  align-items: center;
  gap: 9px;
  width: 100%;
  overflow: hidden;
  white-space: nowrap;
  text-overflow: ellipsis;
  padding: 2px 0;
  padding-right: 38px;
`;
styled(motion.div)`
  position: absolute;
  right: 20px;
  width: 32px;
  height: 32px;
  overflow: hidden;
  svg,
  img {
    display: block;
    position: relative;
    pointer-events: none;
    overflow: hidden;
    border-radius: 27.5%;
    width: 100%;
    height: 100%;
  }
`;
var WalletIcon$1 = ({ ...props }) => {
  return (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "20", height: "19", viewBox: "0 0 20 19", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: [(0, import_jsx_runtime.jsx)("path", { d: "M1.57568 4.60616C1.57568 2.69827 3.12234 1.15161 5.03023 1.15161H15.3939C17.3018 1.15161 18.8484 2.69826 18.8484 4.60616V10.3637C18.8484 12.2716 17.3018 13.8183 15.3939 13.8183H5.03023C3.12234 13.8183 1.57568 12.2716 1.57568 10.3637V4.60616Z", stroke: "currentColor", strokeWidth: "2" }), (0, import_jsx_runtime.jsx)("path", { d: "M1 4.79293C1 2.435 3.31004 0.770014 5.54697 1.51566L12.4561 3.81869C13.8667 4.2889 14.8182 5.60901 14.8182 7.09596V13.6313C14.8182 15.9892 12.5081 17.6542 10.2712 16.9086L3.36212 14.6056C1.95149 14.1353 1 12.8152 1 11.3283V4.79293Z", fill: "var(--ck-body-background)", stroke: "currentColor", strokeWidth: "2" }), (0, import_jsx_runtime.jsx)("circle", { cx: "10.3863", cy: "10.1894", r: "1.32574", fill: "currentColor" })] });
};
var Shimmer = We`
  0%{ transform: translate(-100%) rotate(-45deg); }
  100%{ transform: translate(100%) rotate(-80deg); }
`;
var ConnectorButton = styled(motion.button)`
  display: block;
  text-decoration: none;
`;
var ConnectorLabel = styled(motion.span)``;
var ConnectorIcon = styled(motion.div)``;
var styles = {
  desktop: {
    ConnectorButton: Ae`
      cursor: pointer;
      user-select: none;
      position: relative;
      display: flex;
      align-items: center;
      padding: 0 20px;
      width: 100%;
      height: 64px;
      font-size: 17px;
      font-weight: var(--ck-primary-button-font-weight, 500);
      line-height: 20px;
      text-align: var(--ck-body-button-text-align, left);
      transition: 180ms ease;
      transition-property: background, color, box-shadow, transform, opacity;
      will-change: transform, box-shadow, background-color, color, opacity;

      --fallback-color: var(--ck-primary-button-color);
      --fallback-background: var(--ck-primary-button-background);
      --fallback-box-shadow: var(--ck-primary-button-box-shadow);
      --fallback-border-radius: var(--ck-primary-button-border-radius);

      --color: var(--ck-primary-button-color, var(--fallback-color));
      --background: var(
        --ck-primary-button-background,
        var(--fallback-background)
      );
      --box-shadow: var(
        --ck-primary-button-box-shadow,
        var(--fallback-box-shadow)
      );
      --border-radius: var(
        --ck-primary-button-border-radius,
        var(--fallback-border-radius)
      );

      --hover-color: var(--ck-primary-button-hover-color, var(--color));
      --hover-background: var(
        --ck-primary-button-hover-background,
        var(--background)
      );
      --hover-box-shadow: var(
        --ck-primary-button-hover-box-shadow,
        var(--box-shadow)
      );
      --hover-border-radius: var(
        --ck-primary-button-hover-border-radius,
        var(--border-radius)
      );

      --active-color: var(--ck-primary-button-active-color, var(--hover-color));
      --active-background: var(
        --ck-primary-button-active-background,
        var(--hover-background)
      );
      --active-box-shadow: var(
        --ck-primary-button-active-box-shadow,
        var(--hover-box-shadow)
      );
      --active-border-radius: var(
        --ck-primary-button-active-border-radius,
        var(--hover-border-radius)
      );

      color: var(--color);
      background: var(--background);
      box-shadow: var(--box-shadow);
      border-radius: var(--border-radius);

      &:disabled {
        transition: 180ms ease;
        opacity: 0.4;
      }

      --bg: var(--background);
      &:not(:disabled) {
        &:hover {
          color: var(--hover-color);
          background: var(--hover-background);
          box-shadow: var(--hover-box-shadow);
          border-radius: var(--hover-border-radius);
          --bg: var(--hover-background, var(--background));
        }
        &:focus-visible {
          transition-duration: 100ms;
          color: var(--hover-color);
          background: var(--hover-background);
          box-shadow: var(--hover-box-shadow);
          border-radius: var(--hover-border-radius);
          --bg: var(--hover-background, var(--background));
        }
        &:active {
          color: var(--active-color);
          background: var(--active-background);
          box-shadow: var(--active-box-shadow);
          border-radius: var(--active-border-radius);
          --bg: var(--active-background, var(--background));
        }
      }
    `,
    ConnectorLabel: Ae`
      display: flex;
      align-items: center;
      gap: 9px;
      width: 100%;
      overflow: hidden;
      white-space: nowrap;
      text-overflow: ellipsis;
      padding: 2px 0;
      padding-right: 38px;
    `,
    ConnectorIcon: Ae`
      position: absolute;
      right: 20px;
      width: 32px;
      height: 32px;
      overflow: hidden;
      svg,
      img {
        display: block;
        position: relative;
        pointer-events: none;
        overflow: hidden;
        width: 100%;
        height: 100%;
      }

      &[data-shape='squircle'] {
        border-radius: 22.5%;
      }
      &[data-shape='circle'] {
        border-radius: 100%;
      }
      &[data-shape='square'] {
        border-radius: 0;
      }
    `
  },
  mobile: {
    ConnectorButton: Ae`
      text-align: center;
      background: none;
      max-width: 100%;
      overflow: hidden;
    `,
    ConnectorLabel: Ae`
      display: block;
      text-overflow: ellipsis;
      max-width: 100%;
      overflow: hidden;
      padding: 10px 0 0;
      color: var(--ck-body-color);
      font-size: 13px;
      line-height: 15px;
      font-weight: 500;
      opacity: 0.75;
    `,
    ConnectorIcon: Ae`
      position: relative;
      margin: 0 auto;
      width: 60px;
      height: 60px;
      overflow: hidden;
      svg,
      img {
        display: block;
        position: relative;
        width: 100%;
        height: auto;
      }
      &[data-small='true'] {
        svg,
        img {
          transform: scale(0.8);
        }
      }

      &[data-shape='squircle'] {
        border-radius: 22.5%;
        &:before {
          content: '';
          z-index: -1;
          position: absolute;
          inset: 0;
          border-radius: inherit;
          box-shadow: inset 0 0 0 1px var(--ck-body-background-tertiary);
        }
      }
      &[data-shape='circle'] {
        border-radius: 100%;
      }
      &[data-shape='square'] {
        border-radius: 0;
      }

      &[data-background='true'] {
        border-radius: 22.5%;
        background: var(--ck-body-background-tertiary);
        padding: 8%;
      }
    `
  }
};
var RecentlyUsedTag = styled(motion.span)`
  position: relative;
  top: var(--ck-recent-badge-top-offset, 0.5px);
  display: inline-block;
  padding: 10px 7px;
  line-height: 0;
  font-size: 13px;
  font-weight: 400;
  border-radius: var(--ck-recent-badge-border-radius, var(--border-radius));
  color: var(
    --ck-recent-badge-color,
    var(--ck-accent-color, var(--ck-body-color-muted, currentColor))
  );
  background: var(--ck-recent-badge-background, transparent);
  overflow: hidden;
  span {
    display: inline-block;
    position: relative;
  }
  &:before {
    z-index: 1;
    content: '';
    position: absolute;
    inset: 0;
    opacity: 0.4;
    box-shadow: var(--ck-recent-badge-box-shadow, inset 0 0 0 1px currentColor);
    border-radius: inherit;
  }
  &:after {
    z-index: 2;
    content: '';
    position: absolute;
    inset: -10%;
    top: -110%;
    aspect-ratio: 1/1;
    opacity: 0.7;
    background: linear-gradient(
      170deg,
      transparent 10%,
      var(--ck-recent-badge-background, var(--bg)) 50%,
      transparent 90%
    );
    animation: ${Shimmer} 2s linear infinite;
  }
`;
var ConnectorsContainer = styled.div`
  transition: opacity 300ms ease;
  min-width: fit-content;

  ${(props) => props.$disabled && Ae`
      pointer-events: none;
      opacity: 0.4;
    `}

  ${(props) => !props.$mobile ? Ae`
          display: flex;
          flex-direction: column;
          gap: 12px;

          ${ConnectorButton} {
            ${styles.desktop.ConnectorButton}
            ${ConnectorLabel} {
              ${styles.desktop.ConnectorLabel}
            }
            ${ConnectorIcon} {
              ${styles.desktop.ConnectorIcon}
            }
          }
        ` : Ae`
          display: flex;
          align-items: flex-start;
          justify-content: space-around;
          gap: 22px 6px;
          //margin: 0px -10px -20px;
          padding: 14px 0px 28px;

          ${ConnectorButton} {
            flex-shrink: 0;
            width: 80px;
            ${styles.mobile.ConnectorButton}
            ${ConnectorLabel} {
              ${styles.mobile.ConnectorLabel}
              ${RecentlyUsedTag} {
                display: none;
                width: fit-content;
                margin: 0 auto;
              }
            }
            ${ConnectorIcon} {
              ${styles.mobile.ConnectorIcon}
            }
          }
        `}
`;
function useChains2() {
  var _a2;
  const wagmi = useConfig();
  const chains = (_a2 = wagmi === null || wagmi === void 0 ? void 0 : wagmi.chains) !== null && _a2 !== void 0 ? _a2 : [];
  return chains.map((c3) => c3);
}
function useConnect2({ ...props } = {}) {
  const context = useContext21();
  const { connect: connect3, connectAsync, connectors, ...rest } = useConnect({
    ...props,
    mutation: {
      ...props.mutation,
      onError(err) {
        if (err.message) {
          if (err.message !== "User rejected request") {
            context.log(err.message, err);
          }
        } else {
          context.log(`Could not connect.`, err);
        }
      }
    }
  });
  return {
    connect: ({ connector, chainId, mutation }) => {
      var _a2;
      return connect3({
        connector,
        chainId: chainId !== null && chainId !== void 0 ? chainId : (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.initialChainId
      }, mutation);
    },
    connectAsync: async ({ connector, chainId, mutation }) => {
      var _a2;
      return connectAsync({
        connector,
        chainId: chainId !== null && chainId !== void 0 ? chainId : (_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.initialChainId
      }, mutation);
    },
    connectors,
    ...rest
  };
}
function useWalletConnectUri({ enabled } = {
  enabled: true
}) {
  const { log } = useContext21();
  const [uri, setUri] = (0, import_react70.useState)(void 0);
  const connector = useWalletConnectConnector();
  const { isConnected: isConnected2 } = useAccount();
  const { connectAsync } = useConnect2();
  (0, import_react70.useEffect)(() => {
    if (!enabled)
      return;
    async function handleMessage(message) {
      const { type: type6, data } = message;
      log("WC Message", type6, data);
      if (type6 === "display_uri") {
        setUri(data);
      }
    }
    async function handleDisconnect() {
      log("WC Disconnect");
      if (connector)
        connectWallet(connector);
    }
    async function connectWallet(connector2) {
      const result = await connectAsync({ connector: connector2 });
      if (result)
        return result;
      return false;
    }
    async function connectWalletConnect(connector2) {
      try {
        await connectWallet(connector2);
      } catch (error) {
        log("catch error");
        log(error);
        if (error.code) {
          switch (error.code) {
            case 4001:
              log("error.code - User rejected");
              connectWalletConnect(connector2);
              break;
            default:
              log("error.code - Unknown Error");
              break;
          }
        } else {
          log("WalletConnect cannot connect.", error);
        }
      }
    }
    if (isConnected2) {
      setUri(void 0);
    } else {
      if (!connector || uri)
        return;
      if (connector && !isConnected2) {
        connectWalletConnect(connector);
        log("add wc listeners");
        connector.emitter.on("message", handleMessage);
        connector.emitter.on("disconnect", handleDisconnect);
        return () => {
          log("remove wc listeners");
          connector.emitter.off("message", handleMessage);
          connector.emitter.off("disconnect", handleDisconnect);
        };
      }
    }
  }, [enabled, connector, isConnected2]);
  return {
    uri
  };
}
function useChainIsSupported(chainId) {
  const { chains } = useConfig();
  if (!chainId)
    return false;
  return chains.some((x2) => x2.id === chainId);
}
var Web3Context = import_react70.default.createContext({
  connect: {
    getUri: () => ""
  },
  dapp: {
    chains: []
  },
  account: void 0
});
var Web3ContextProvider = ({ enabled, children }) => {
  const { uri: walletConnectUri } = useWalletConnectUri({
    enabled
  });
  const { address: currentAddress, chain: chain2 } = useAccount();
  const chainIsSupported = useChainIsSupported(chain2 === null || chain2 === void 0 ? void 0 : chain2.id);
  const chains = useChains2();
  const value = {
    connect: {
      getUri: (id3) => {
        return walletConnectUri;
      }
    },
    dapp: {
      chains
    },
    account: currentAddress ? {
      chain: chain2,
      chainIsSupported,
      address: currentAddress
    } : void 0
  };
  return (0, import_jsx_runtime.jsx)(Web3Context.Provider, { value, children });
};
var useWeb3 = () => import_react70.default.useContext(Web3Context);
function useIsMobile() {
  const [mobile, setMobile] = (0, import_react70.useState)(isMobile());
  (0, import_react70.useEffect)(() => {
    const handleResize = () => {
      setMobile(isMobile());
    };
    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return mobile;
}
var ScrollContainer = styled.div`
  position: relative;
`;
var fadeIn = We`
0%{ opacity:0; }
100%{ opacity:1; }
`;
var MoreIndicator = styled.div`
  z-index: 9;
  position: absolute;
  left: 0;
  right: 0;
  bottom: 0.75rem;
  display: flex;
  justify-content: center;

  transition: opacity 300ms ease;

  span {
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    gap: 0.25rem;
    padding: 0.3075rem 0.9375rem 0.375rem;
    border-radius: 6rem;
    background: var(--ck-tooltip-background);
    color: var(--ck-tooltip-color);
    font-weight: 500;
    font-size: 0.8125rem;
    letter-spacing: -0.01rem;
    box-shadow: var(--ck-tooltip-shadow);
    animation: ${fadeIn} 300ms ease 1000ms both;

    transition: transform 100ms ease;

    &:hover {
      transform: scale(1.02);
    }
    &:active {
      transform: scale(0.98);
    }
    svg {
      display: block;
      transform: translateX(-0.1875rem);
    }
  }

  &.hide {
    opacity: 0;
    pointer-events: none;
  }
`;
var ScrollAreaContainer = styled.div`
  --bg: ${({ $backgroundColor }) => $backgroundColor || "var(--ck-body-background)"};
  --fade-height: 1px;
  position: relative;
  z-index: 1;

  ${({ $mobile, $height, $mobileDirection }) => $mobile && $mobileDirection === "horizontal" ? Ae`
          overflow-x: scroll;
          margin: 0 -24px;
          padding: 0 24px;

          &:before,
          &:after {
            pointer-events: none;
            z-index: 10;
            content: '';
            display: block;
            position: sticky;
            top: 0;
            bottom: 0;
            width: var(--fade-height);
            background: var(
              --ck-body-divider-secondary,
              var(--ck-body-divider)
            );
            box-shadow: var(--ck-body-divider-box-shadow);
            transition: opacity 300ms ease;
          }
          &:before {
            left: 0;
          }
          &:after {
            right: 0;
          }

          &.scroll-start {
            &:before {
              opacity: 0;
            }
          }

          &.scroll-end {
            &:after {
              opacity: 0;
            }
          }
        ` : Ae`
          max-height: ${$height ? `${$height}px` : "310px"};
          overflow-y: scroll;
          padding: 0 10px;
          margin: calc(var(--fade-height) * -1) -16px 0 -10px;

          &:before,
          &:after {
            pointer-events: none;
            z-index: 10;
            content: '';
            display: block;
            position: sticky;
            left: 0;
            right: 0;
            height: var(--fade-height);
            background: var(
              --ck-body-divider-secondary,
              var(--ck-body-divider)
            );
            box-shadow: var(--ck-body-divider-box-shadow);
            transition: opacity 300ms ease;
          }
          &:before {
            top: 0;
          }
          &:after {
            bottom: 0;
          }

          &.scroll-start {
            &:before {
              opacity: 0;
            }
          }

          &.scroll-end {
            &:after {
              opacity: 0;
            }
          }
        `}

  &::-webkit-scrollbar {
    width: 6px;
    height: 6px;
  }
  &::-webkit-scrollbar-track {
    background: transparent;
  }
  &::-webkit-scrollbar-thumb {
    background: rgba(0, 0, 0, 0);
    border-radius: 100px;
  }
  &:hover::-webkit-scrollbar-thumb {
    background: var(--ck-body-color-muted);
  }
  &::-webkit-scrollbar-thumb:hover {
    background: var(--ck-body-color-muted-hover);
  }
`;
var ArrowDown = () => (0, import_jsx_runtime.jsx)("svg", { width: "11", height: "12", viewBox: "0 0 11 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)("path", { d: "M5.49438 1L5.49438 11M5.49438 11L9.5 7M5.49438 11L1.5 7", stroke: "currentColor", strokeWidth: "1.75", strokeLinecap: "round", strokeLinejoin: "round" }) });
var ScrollArea = ({ children, height, backgroundColor, mobileDirection }) => {
  const ref = (0, import_react70.useRef)(null);
  const moreRef = (0, import_react70.useRef)(null);
  const isMobile2 = useIsMobile();
  (0, import_react70.useEffect)(() => {
    const el2 = ref.current;
    if (!el2)
      return;
    if (el2.scrollHeight > el2.clientHeight) {
      if (moreRef.current) {
        moreRef.current.classList.remove("hide");
      }
    }
    const handleScroll = (e2) => {
      const { scrollTop, scrollHeight, clientHeight, scrollLeft, scrollWidth, clientWidth } = e2.target;
      if (moreRef.current) {
        if (scrollTop > 0) {
          moreRef.current.classList.add("hide");
        }
      }
      if (scrollTop === 0 && scrollLeft === 0) {
        el2.classList.add("scroll-start");
      } else {
        el2.classList.remove("scroll-start");
      }
      if (scrollHeight - scrollTop === clientHeight && scrollWidth - scrollLeft === clientWidth) {
        el2.classList.add("scroll-end");
      } else {
        el2.classList.remove("scroll-end");
      }
    };
    el2.addEventListener("scroll", handleScroll);
    handleScroll({ target: el2 });
    return () => {
      el2.removeEventListener("scroll", handleScroll);
    };
  }, [ref.current]);
  return (0, import_jsx_runtime.jsxs)(ScrollContainer, { children: [(0, import_jsx_runtime.jsx)(ScrollAreaContainer, { ref, "$mobile": isMobile2, "$height": height, "$backgroundColor": backgroundColor, "$mobileDirection": mobileDirection, children }), (0, import_jsx_runtime.jsx)(MoreIndicator, { ref: moreRef, className: "hide", onClick: () => {
    if (ref.current) {
      ref.current.scrollTo({
        top: ref.current.scrollHeight,
        behavior: "smooth"
      });
    }
  }, children: (0, import_jsx_runtime.jsxs)("span", { children: [(0, import_jsx_runtime.jsx)(ArrowDown, {}), " More Available"] }) })] });
};
var AlertContainer = styled(motion.div)`
  display: flex;
  gap: 8px;
  position: relative;
  border-radius: 9px;
  margin: 0 auto;
  padding: 10px;
  text-align: left;
  font-size: 14px;
  line-height: 17px;
  font-weight: 400;
  max-width: 260px;
  min-width: 100%;

  border-radius: var(--ck-alert-border-radius, 12px);
  color: var(--ck-alert-color, var(--ck-body-color-muted));
  background: var(--ck-alert-background, var(--ck-body-background-secondary));
  box-shadow: var(--ck-alert-box-shadow, var(--ck-body-box-shadow));

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    padding: 16px;
    font-size: 16px;
    line-height: 21px;
    border-radius: 24px;
    text-align: center;
  }

  ${($error) => {
  if ($error)
    return Ae`
        color: #fff;
        background: var(--ck-body-color-danger, red);
      `;
}}
`;
var IconContainer$4 = styled(motion.div)`
  width: 24px;
  height: 24px;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    display: block;
    width: 100%;
    height: auto;
  }
`;
var Alert = ({ children, error, icon }) => {
  return (0, import_jsx_runtime.jsxs)(AlertContainer, { "$error": error, children: [icon && (0, import_jsx_runtime.jsx)(IconContainer$4, { children: icon }), (0, import_jsx_runtime.jsx)("div", { children })] });
};
Alert.displayName = "Alert";
var useLastConnector = () => {
  const { storage } = useConfig();
  const [lastConnectorId, setLastConnectorId] = (0, import_react70.useState)(null);
  (0, import_react70.useEffect)(() => {
    const init2 = async () => {
      const id3 = await (storage === null || storage === void 0 ? void 0 : storage.getItem("recentConnectorId"));
      setLastConnectorId(id3 !== null && id3 !== void 0 ? id3 : "");
    };
    init2();
  }, []);
  const update = (id3) => {
    storage === null || storage === void 0 ? void 0 : storage.setItem("recentConnectorId", id3);
  };
  return {
    lastConnectorId,
    updateLastConnectorId: update
  };
};
var ConnectorList = () => {
  var _a2;
  const context = useContext21();
  const isMobile2 = useIsMobile();
  const wallets2 = useWallets();
  const { lastConnectorId } = useLastConnector();
  const familyConnector = useFamilyConnector();
  const familyAccountsConnector2 = useFamilyAccountsConnector();
  let filteredWallets = wallets2.filter((wallet) => wallet.id !== (familyAccountsConnector2 === null || familyAccountsConnector2 === void 0 ? void 0 : familyAccountsConnector2.id));
  if (familyConnector && isFamily()) {
    filteredWallets = filteredWallets.filter((wallet) => wallet.id !== (familyConnector === null || familyConnector === void 0 ? void 0 : familyConnector.id));
  }
  const walletsToDisplay = ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.hideRecentBadge) || lastConnectorId === "walletConnect" ? filteredWallets : [
    // move last used wallet to top of list
    // using .filter and spread to avoid mutating original array order with .sort
    ...filteredWallets.filter((wallet) => lastConnectorId === wallet.connector.id),
    ...filteredWallets.filter((wallet) => lastConnectorId !== wallet.connector.id)
  ];
  return (0, import_jsx_runtime.jsxs)(ScrollArea, { mobileDirection: "horizontal", children: [walletsToDisplay.length === 0 && (0, import_jsx_runtime.jsx)(Alert, { error: true, children: "No connectors found in ConnectKit config." }), walletsToDisplay.length > 0 && (0, import_jsx_runtime.jsx)(ConnectorsContainer, { "$mobile": isMobile2, "$totalResults": walletsToDisplay.length, children: walletsToDisplay.map((wallet) => (0, import_jsx_runtime.jsx)(ConnectorItem, { wallet, isRecent: wallet.id === lastConnectorId }, wallet.id)) })] });
};
var ConnectorItem = ({ wallet, isRecent }) => {
  var _a2, _b, _c2, _d;
  const { connect: { getUri } } = useWeb3();
  const uri = getUri();
  const isMobile2 = useIsMobile();
  const context = useContext21();
  const { connect: connect3 } = useConnect2();
  let deeplink = !wallet.isInstalled && isMobile2 || wallet.shouldDeeplinkDesktop && !isMobile2 ? (_a2 = wallet.getWalletConnectDeeplink) === null || _a2 === void 0 ? void 0 : _a2.call(wallet, uri !== null && uri !== void 0 ? uri : "") : void 0;
  const redirectToMoreWallets = isMobile2 && isWalletConnectConnector(wallet.id);
  const shouldConnectImmediately = (detectBrowser() === "safari" || detectBrowser() === "ios") && isCoinbaseWalletConnector(wallet.connector.id);
  if (redirectToMoreWallets || shouldConnectImmediately)
    deeplink = void 0;
  return (0, import_jsx_runtime.jsxs)(ConnectorButton, { type: "button", as: deeplink ? "a" : void 0, href: deeplink ? deeplink : void 0, disabled: context.route !== routes.CONNECTORS, onClick: deeplink ? void 0 : () => {
    if (redirectToMoreWallets) {
      context.setRoute(routes.MOBILECONNECTORS);
    } else {
      if (shouldConnectImmediately) {
        connect3({ connector: wallet === null || wallet === void 0 ? void 0 : wallet.connector });
      }
      context.setRoute(routes.CONNECT);
      context.setConnector({ id: wallet.id });
    }
  }, children: [(0, import_jsx_runtime.jsx)(ConnectorIcon, { "data-small": wallet.iconShouldShrink, "data-shape": wallet.iconShape, "data-background": redirectToMoreWallets, children: (_b = wallet.iconConnector) !== null && _b !== void 0 ? _b : wallet.icon }), (0, import_jsx_runtime.jsxs)(ConnectorLabel, { children: [isMobile2 ? (_c2 = wallet.shortName) !== null && _c2 !== void 0 ? _c2 : wallet.name : wallet.name, !((_d = context.options) === null || _d === void 0 ? void 0 : _d.hideRecentBadge) && isRecent && (0, import_jsx_runtime.jsx)(RecentlyUsedTag, { children: (0, import_jsx_runtime.jsx)("span", { children: "Recent" }) })] })] });
};
var ButtonContainerInner = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  inset: 0;
  height: 100%;
`;
var ButtonContainer$1 = styled.button`
  --color: #ffffff;
  --background: var(--ck-family-accounts-brand);
  --box-shadow: var(--ck-primary-button-box-shadow);
  --border-radius: var(--ck-primary-button-border-radius);
  --font-weight: var(--ck-primary-button-font-weight, 500);

  --hover-color: var(--ck-button-primary-hover-color, var(--color));
  --hover-background: var(
    --ck-primary-button-hover-background,
    var(--background)
  );
  --hover-box-shadow: var(
    --ck-primary-button-hover-box-shadow,
    var(--box-shadow)
  );
  --hover-border-radius: var(
    --ck-primary-button-hover-border-radius,
    var(--border-radius)
  );
  --hover-font-weight: var(--ck-primary-button-font-weight, var(--font-weight));

  appearance: none;
  cursor: pointer;
  user-select: none;
  min-width: fit-content;
  width: 100%;
  display: block;
  text-align: center;
  height: 48px;
  margin: 18px 0 2px;
  line-height: 48px;
  padding: 0 4px;
  font-size: 16px;
  font-weight: var(--font-weight, 500);
  text-decoration: none;
  white-space: nowrap;
  transition: 100ms ease;
  transition-property: box-shadow, background-color;
  color: var(--color);
  background: var(--background);
  border-radius: var(--border-radius);
  box-shadow: var(--box-shadow);
  will-change: transform, box-shadow, background-color, color;
`;
var InnerContainer = styled.div`
  transform: translateZ(0); // Shifting fix
  position: relative;
  display: inline-block;
  vertical-align: middle;
  max-width: calc(100% - 42px);
  transition: opacity 300ms ease;
`;
var IconContainer$3 = styled.div`
  position: relative;
  display: inline-block;
  vertical-align: middle;
  max-width: 20px;
  max-height: 20px;
  margin: 0 12px 0 0;
  svg {
    display: block;
    position: relative;
    max-width: 100%;
    height: auto;
  }
`;
var FamilyLogo = () => (0, import_jsx_runtime.jsx)("svg", { width: "20", height: "20", viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M19.0204 1.00451C19.6474 1.63141 19.9997 2.4816 20 3.36818C20.0008 4.14967 19.726 4.90643 19.2239 5.50535C18.7218 6.10427 18.0246 6.50698 17.2549 6.64267V6.70894C18.019 6.85794 18.7076 7.26796 19.2026 7.86877C19.6976 8.46958 19.9683 9.2238 19.9683 10.0022C19.9683 10.7807 19.6976 11.5349 19.2026 12.1357C18.7076 12.7365 18.019 13.1465 17.2549 13.2955V13.3613C18.0719 13.5195 18.8007 13.9762 19.2994 14.6424C19.798 15.3086 20.0308 16.1365 19.9523 16.9649C19.8738 17.7933 19.4896 18.5628 18.8747 19.1234C18.2598 19.6841 17.4581 19.9958 16.626 19.9977C15.0203 19.9977 13.6632 18.8411 13.3487 17.3187H13.266C13.1161 18.0763 12.707 18.7581 12.1091 19.247C11.5112 19.7358 10.7617 20.0013 9.98928 19.9977C8.38358 19.9977 7.02654 18.8411 6.71207 17.3187H6.62934C6.5085 17.9135 6.22824 18.4642 5.81854 18.912C5.40885 19.3597 4.88513 19.6877 4.3034 19.8609C3.72166 20.034 3.1038 20.0458 2.5159 19.8949C1.92799 19.7441 1.39216 19.4362 0.965705 19.0044C0.539251 18.5726 0.238219 18.0329 0.0948058 17.4432C-0.0486071 16.8535 -0.0290062 16.2359 0.151512 15.6565C0.332031 15.0771 0.666676 14.5576 1.11966 14.1537C1.57264 13.7497 2.12691 13.4765 2.7232 13.3632V13.2974C1.95907 13.1484 1.27053 12.7384 0.775518 12.1376C0.280502 11.5368 0.0098111 10.7826 0.0098111 10.0041C0.0098111 9.22568 0.280502 8.47147 0.775518 7.87065C1.27053 7.26984 1.95907 6.85982 2.7232 6.71082V6.64455C2.12752 6.52895 1.57437 6.2539 1.12271 5.84872C0.671047 5.44354 0.337805 4.92342 0.158498 4.34378C-0.0208088 3.76414 -0.0394594 3.14672 0.104534 2.55732C0.248527 1.96792 0.549768 1.42863 0.976148 0.996935C1.40253 0.565238 1.93807 0.257312 2.52569 0.105976C3.11331 -0.0453591 3.73098 -0.0344317 4.31288 0.137594C4.89478 0.309619 5.41909 0.636296 5.82993 1.0828C6.24077 1.52931 6.52274 2.07892 6.64579 2.67304H6.72852C6.8865 1.9201 7.29921 1.24463 7.89713 0.760429C8.49504 0.276232 9.2416 0.0129149 10.011 0.0148468C10.7804 0.0167787 11.5257 0.283841 12.1211 0.771035C12.7166 1.25823 13.1259 1.93577 13.2801 2.68949H13.3629C13.6952 1.16716 15.0348 0.00860963 16.6565 0.0250597C17.5432 0.0253088 18.3935 0.377609 19.0204 1.00451ZM5.93783 5.07571C5.33116 5.0757 4.84252 5.57305 4.85166 6.17966C4.86836 7.28867 4.89073 9.01161 4.89073 10.2871C4.89073 11.5614 4.8684 13.2824 4.8517 14.3916C4.84255 14.9997 5.3327 15.4985 5.94094 15.4985H14.2263C14.8345 15.4985 15.3247 14.9997 15.3155 14.3916C15.2988 13.2824 15.2765 11.5614 15.2765 10.2871C15.2765 9.01161 15.2988 7.28867 15.3155 6.17966C15.3247 5.57305 14.8367 5.0757 14.23 5.07571L9.99998 5.07576L5.93783 5.07571Z", fill: "currentColor" }) });
var FamilyAccountsButton = ({ onClick }) => {
  const locales = useLocales();
  return (0, import_jsx_runtime.jsx)(ButtonContainer$1, { onClick, children: (0, import_jsx_runtime.jsxs)(ButtonContainerInner, { children: [(0, import_jsx_runtime.jsx)(IconContainer$3, { children: (0, import_jsx_runtime.jsx)(FamilyLogo, {}) }), (0, import_jsx_runtime.jsx)(InnerContainer, { children: (0, import_jsx_runtime.jsx)(FitText, { children: locales.continueWithFamily }) })] }) });
};
var Wallets = () => {
  var _a2, _b, _c2, _d, _e2;
  const context = useContext21();
  const locales = useLocales({});
  const isMobile2 = useIsMobile();
  const familyConnector = useFamilyConnector();
  const familyAccountsConnector2 = useFamilyAccountsConnector();
  return (0, import_jsx_runtime.jsx)(PageContent, { style: {
    width: 312,
    paddingTop: familyAccountsConnector2 ? 32 : void 0
  }, children: (0, import_jsx_runtime.jsxs)(Container$7, { children: [familyAccountsConnector2 && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(FamilyAccountsButton, { onClick: () => {
    if (familyConnector && isFamily()) {
      context.setConnector(familyConnector);
    } else {
      context.setConnector(familyAccountsConnector2);
    }
    context.setRoute(routes.CONNECT);
  } }), (0, import_jsx_runtime.jsx)(OrDivider, { hideHr: true, children: locales.orSelectWallet })] }), (0, import_jsx_runtime.jsxs)("div", { children: [(0, import_jsx_runtime.jsx)(ConnectorList, {}), isMobile2 ? (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsxs)(InfoBox, { children: [(0, import_jsx_runtime.jsxs)(ModalContent, { style: { padding: 0, textAlign: "left" }, children: [(0, import_jsx_runtime.jsx)(ModalH1, { "$small": true, children: locales.connectorsScreen_h1 }), (0, import_jsx_runtime.jsx)(ModalBody, { children: locales.connectorsScreen_p })] }), (0, import_jsx_runtime.jsxs)(InfoBoxButtons, { children: [!((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.hideQuestionMarkCTA) && (0, import_jsx_runtime.jsx)(Button, { variant: "tertiary", onClick: () => context.setRoute(routes.ABOUT), children: locales.learnMore }), !((_b = context.options) === null || _b === void 0 ? void 0 : _b.hideNoWalletCTA) && (0, import_jsx_runtime.jsx)(Button, { variant: "tertiary", onClick: () => context.setRoute(routes.ONBOARDING), children: locales.getWallet })] })] }) }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: !((_c2 = context.options) === null || _c2 === void 0 ? void 0 : _c2.hideNoWalletCTA) && (0, import_jsx_runtime.jsx)(LearnMoreContainer, { children: (0, import_jsx_runtime.jsxs)(LearnMoreButton, { onClick: () => context.setRoute(routes.ONBOARDING), children: [(0, import_jsx_runtime.jsx)(WalletIcon$1, {}), " ", locales.connectorsScreen_newcomer] }) }) }), ((_d = context.options) === null || _d === void 0 ? void 0 : _d.disclaimer) && (0, import_jsx_runtime.jsx)(Disclaimer, { style: { visibility: "hidden", pointerEvents: "none" }, children: (0, import_jsx_runtime.jsx)("div", { children: (_e2 = context.options) === null || _e2 === void 0 ? void 0 : _e2.disclaimer }) })] })] }) });
};
var WalletItem = styled.div`
  text-align: center;
  transition: opacity 100ms ease;
  opacity: ${(props) => props.$waiting ? 0.4 : 1};
`;
var WalletIcon = styled.div`
  z-index: 9;
  position: relative;
  margin: 0 auto 10px;
  border-radius: 16px;
  width: 60px;
  height: 60px;
  overflow: hidden;
  background: rgba(0, 0, 0, 0.04);
  ${(props) => props.$outline && `
  &:before {
    content: '';
    z-index: 2;
    position: absolute;
    inset: 0;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px var(--ck-body-background-tertiary);
  }`}
  svg {
    display: block;
    position: relative;
    width: 100%;
    height: auto;
  }
`;
var WalletLabel = styled.div`
  color: var(--ck-body-color);
  font-size: 13px;
  line-height: 15px;
  font-weight: 500;
  opacity: 0.75;
`;
var PulseKeyframes = We`
  0%,100% { opacity:1; }
  50% { opacity:0.5; }
`;
var WalletList = styled.div`
  display: grid;
  grid-template-columns: repeat(4, 1fr);
  gap: 22px 8px;
  margin: 0 -10px;
  padding: 4px 0 0;
  transition: opacity 300ms ease;
  ${(props) => props.$disabled && Ae`
      pointer-events: none;
      opacity: 0.4;
      ${WalletItem} {
        animation: ${PulseKeyframes} 1s infinite ease-in-out;
      }
    `}
`;
var Container$6 = styled.div``;
function useWalletConnectModal() {
  const { log } = useContext21();
  const { connectAsync, connectors } = useConnect2();
  const [isOpen, setIsOpen] = (0, import_react70.useState)(false);
  return {
    isOpen,
    open: async () => {
      const w3mcss = document.createElement("style");
      w3mcss.innerHTML = `w3m-modal, wcm-modal{ --wcm-z-index: 2147483647; --w3m-z-index:2147483647; }`;
      document.head.appendChild(w3mcss);
      const clientConnector = connectors.find((c3) => isWalletConnectConnector(c3.id));
      if (clientConnector) {
        try {
          const provider = await clientConnector.getProvider();
          const projectId = provider.rpc.projectId;
          const connector = walletConnect({
            projectId,
            showQrModal: true
          });
          setIsOpen(true);
          try {
            await connectAsync({ connector });
          } catch (err) {
            log("WalletConnect", err);
          }
          setIsOpen(false);
          document.head.removeChild(w3mcss);
        } catch (err) {
          log("Could not get WalletConnect provider", err);
        }
      } else {
        log("No WalletConnect connector available");
      }
    }
  };
}
var IconContainer$2 = styled(motion.div)`
  transition: all 220ms cubic-bezier(0.175, 0.885, 0.32, 1.1);
  display: flex;
  align-items: center;
  justify-content: center;
  width: 16px;
  svg {
    display: block;
  }
  svg,
  svg path,
  svg rect {
    transition: inherit;
  }
  svg path:first-child {
    transform-origin: 50% 50%;
    fill: var(--bg);
    stroke: var(--color);
  }
  svg rect {
    transform-origin: 53% 63%;
    fill: var(--bg);
    stroke: var(--color);
  }
  svg path:last-child {
    opacity: 0;
    stroke: var(--bg);
    transform: translate(11.75px, 10px) rotate(90deg) scale(0.6);
  }
  ${(props) => props.$clipboard ? Ae`
          --color: var(--ck-focus-color) !important;
          --bg: var(--ck-body-background);
          svg {
            transition-delay: 0ms;
            path:first-child {
              opacity: 0;
              transform: rotate(-90deg) scale(0.2);
            }
            rect {
              rx: 10px;
              fill: var(--color);
              transform: rotate(-90deg) scale(1.45);
            }
            path:last-child {
              transition-delay: 100ms;
              opacity: 1;
              transform: translate(7.75px, 9.5px);
            }
          }
        ` : Ae`
          &:hover {
          }
          &:hover:active {
          }
        `}
`;
var CopyToClipboardIcon = ({ copied, small }) => (0, import_jsx_runtime.jsx)(IconContainer$2, { "$clipboard": copied, children: (0, import_jsx_runtime.jsx)(CopyToClipboardIcon$1, { style: {
  transform: small ? "scale(1)" : "translateX(3px) scale(1.5)",
  opacity: small || copied ? 1 : 0.3
} }) });
var Container$5 = styled.div`
  --color: var(--ck-copytoclipboard-stroke);
  --bg: var(--ck-body-background);
  transition: all 220ms cubic-bezier(0.175, 0.885, 0.32, 1.1);

  cursor: pointer;
  display: inline-flex;
  align-items: center;
  justify-content: center;

  ${(props) => props.$disabled ? Ae`
          cursor: not-allowed;
          opacity: 0.4;
        ` : Ae`
          &:hover {
            --color: var(--ck-body-color-muted);
          }
        `}
`;
var OffsetContainer = styled.div`
  display: block;
  position: relative;
  transition: inherit;
  svg {
    position: absolute;
    left: 100%;
    display: block;
    top: -1px;
    margin: 0;
    margin-left: 4px;
  }
`;
var CopyToClipboard = ({ string, children, variant }) => {
  const [clipboard, setClipboard] = (0, import_react70.useState)(false);
  let timeout;
  const onCopy = () => {
    if (!string)
      return;
    const str = string.trim();
    if (navigator.clipboard) {
      navigator.clipboard.writeText(str);
    }
    setClipboard(true);
    clearTimeout(timeout);
    timeout = setTimeout(() => setClipboard(false), 1e3);
  };
  if (variant === "button")
    return (0, import_jsx_runtime.jsx)(Button, { disabled: !string, onClick: onCopy, icon: (0, import_jsx_runtime.jsx)(CopyToClipboardIcon, { copied: clipboard }), children });
  return (0, import_jsx_runtime.jsx)(Container$5, { onClick: onCopy, "$disabled": !string, children: (0, import_jsx_runtime.jsxs)(OffsetContainer, { children: [children, (0, import_jsx_runtime.jsx)(CopyToClipboardIcon, { copied: clipboard, small: true })] }) });
};
var MoreIcon = (0, import_jsx_runtime.jsx)("svg", { width: "60", height: "60", viewBox: "0 0 60 60", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)("path", { d: "M30 42V19M19 30.5H42", stroke: "var(--ck-body-color-muted)", strokeWidth: "3", strokeLinecap: "round" }) });
var MobileConnectors = () => {
  var _a2, _b;
  const context = useContext21();
  const locales = useLocales();
  const { connect: { getUri } } = useWeb3();
  const wcUri = getUri();
  const { open: openW3M, isOpen: isOpenW3M } = useWalletConnectModal();
  const wallets2 = useWallets();
  const walletsIdsToDisplay = (_a2 = Object.keys(walletConfigs).filter((walletId) => {
    const wallet = walletConfigs[walletId];
    if (wallets2.find((w2) => w2.connector.id === walletId))
      return false;
    if (!wallet.getWalletConnectDeeplink)
      return false;
    return true;
  })) !== null && _a2 !== void 0 ? _a2 : [];
  const connectWallet = (wallet) => {
    var _a3;
    const uri = (_a3 = wallet.getWalletConnectDeeplink) === null || _a3 === void 0 ? void 0 : _a3.call(wallet, wcUri);
    if (uri)
      window.location.href = uri;
  };
  return (0, import_jsx_runtime.jsx)(PageContent, { style: { width: 312 }, children: (0, import_jsx_runtime.jsxs)(Container$6, { children: [(0, import_jsx_runtime.jsx)(ModalContent, { style: { paddingBottom: 0 }, children: (0, import_jsx_runtime.jsx)(ScrollArea, { height: 340, children: (0, import_jsx_runtime.jsxs)(WalletList, { "$disabled": !wcUri, children: [walletsIdsToDisplay.sort(
    // sort by name
    (a3, b4) => {
      var _a3, _b2, _c2, _d;
      const walletA = walletConfigs[a3];
      const walletB = walletConfigs[b4];
      const nameA = (_b2 = (_a3 = walletA.name) !== null && _a3 !== void 0 ? _a3 : walletA.shortName) !== null && _b2 !== void 0 ? _b2 : a3;
      const nameB = (_d = (_c2 = walletB.name) !== null && _c2 !== void 0 ? _c2 : walletB.shortName) !== null && _d !== void 0 ? _d : b4;
      return nameA.localeCompare(nameB);
    }
  ).filter((walletId) => !(walletId === "coinbaseWallet" || walletId === "com.coinbase.wallet")).map((walletId, i2) => {
    const wallet = walletConfigs[walletId];
    const { name, shortName, iconConnector, icon } = wallet;
    return (0, import_jsx_runtime.jsxs)(WalletItem, { onClick: () => connectWallet(wallet), style: {
      animationDelay: `${i2 * 50}ms`
    }, children: [(0, import_jsx_runtime.jsx)(WalletIcon, { "$outline": true, children: iconConnector !== null && iconConnector !== void 0 ? iconConnector : icon }), (0, import_jsx_runtime.jsx)(WalletLabel, { children: shortName !== null && shortName !== void 0 ? shortName : name })] }, i2);
  }), (0, import_jsx_runtime.jsxs)(WalletItem, { onClick: openW3M, "$waiting": isOpenW3M, children: [(0, import_jsx_runtime.jsx)(WalletIcon, { style: { background: "var(--ck-body-background-secondary)" }, children: isOpenW3M ? (0, import_jsx_runtime.jsx)("div", { style: {
    position: "absolute",
    inset: 0,
    display: "flex",
    alignItems: "center",
    justifyContent: "center"
  }, children: (0, import_jsx_runtime.jsx)("div", { style: {
    width: "50%"
  }, children: (0, import_jsx_runtime.jsx)(Spinner$4, {}) }) }) : MoreIcon }), (0, import_jsx_runtime.jsx)(WalletLabel, { children: locales.more })] })] }) }) }), ((_b = context.options) === null || _b === void 0 ? void 0 : _b.walletConnectCTA) !== "modal" && (0, import_jsx_runtime.jsx)("div", { style: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 14,
    paddingTop: 8
  }, children: (0, import_jsx_runtime.jsx)(CopyToClipboard, { variant: "button", string: wcUri, children: locales.copyToClipboard }) })] }) });
};
var Content = styled(motion.div)`
  display: flex;
  flex-direction: column;
  gap: 6px;
  position: relative;
  left: 0;
  right: 0;
  ${ModalContent} {
    padding: 0 8px 32px;
    gap: 12px;
  }
`;
var dist$1 = 2;
var shakeKeyframes = We`
  0%{ transform:none; }
  25%{ transform:translateX(${dist$1}px); }
  50%{ transform:translateX(-${dist$1}px); }
  75%{ transform:translateX(${dist$1}px); }
  100%{ transform:none; }
`;
var outlineKeyframes = We`
  0%{ opacity:1; }
  100%{ opacity:0; }
`;
var Container$4 = styled(motion.div)`
  /*
  background: var(
    --ck-body-background
  ); // To stop the overlay issue during transition for the squircle spinner
  */
`;
var ConnectingContainer = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 10px auto 16px;
  height: 120px;
  //transform: scale(1.001); // fixes shifting issue between states
`;
var ConnectingAnimation = styled(motion.div)`
  user-select: none;
  position: relative;
  --spinner-error-opacity: 0;
  &:before {
    content: '';
    position: absolute;
    inset: 1px;
    opacity: 0;
    background: var(--ck-body-color-danger);
    ${(props) => props.$circle && Ae`
        inset: -5px;
        border-radius: 50%;
        background: none;
        box-shadow: inset 0 0 0 3.5px var(--ck-body-color-danger);
      `}
  }
  ${(props) => props.$shake && Ae`
      animation: ${shakeKeyframes} 220ms ease-out both;
      &:before {
        animation: ${outlineKeyframes} 220ms ease-out 750ms both;
      }
    `}
`;
var RetryButton = styled(motion.button)`
  z-index: 5;
  appearance: none;
  position: absolute;
  right: 2px;
  bottom: 2px;
  padding: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 32px;
  height: 32px;
  border-radius: 16px;
  cursor: pointer;
  overflow: hidden;
  background: none;

  color: var(--ck-body-background);
  transition: color 200ms ease;
  box-shadow: 0px 2px 6px rgba(0, 0, 0, 0.15);

  &:before {
    z-index: 3;
    content: '';
    position: absolute;
    inset: 0;
    opacity: 0;
    transition: opacity 200ms ease;
    background: var(--ck-body-color);
  }

  &:hover:before {
    opacity: 0.1;
  }
`;
var RetryIconContainer = styled(motion.div)`
  position: absolute;
  inset: 0;

  &:before {
    z-index: 1;
    content: '';
    position: absolute;
    inset: 3px;
    border-radius: 16px;
    background: conic-gradient(
      from 90deg,
      currentColor 10%,
      var(--ck-body-color) 80%
    );
  }

  svg {
    z-index: 2;
    display: block;
    position: relative;
    width: 100%;
    height: 100%;
  }
`;
var TooltipWindow = styled(motion.div)`
  z-index: 2147483647;
  position: fixed;
  inset: 0;
  pointer-events: none;
`;
var TooltipContainer = styled(motion.div)`
  --shadow: var(--ck-tooltip-shadow);
  z-index: 2147483647;
  position: absolute;
  top: 0;
  left: 0;
  display: flex;
  gap: 8px;
  width: fit-content;
  align-items: center;
  justify-content: center;
  border-radius: var(
    --ck-tooltip-border-radius,
    ${(props) => props.$size === "small" ? 11 : 14}px
  );
  border-radius: ;
  padding: 10px 16px 10px 12px;
  font-size: 14px;
  line-height: 19px;
  font-weight: 500;
  letter-spacing: -0.1px;
  color: var(--ck-tooltip-color);
  background: var(--ck-tooltip-background);
  box-shadow: var(--shadow);
  > span {
    z-index: 3;
    position: relative;
  }
  > div {
    margin: -4px 0; // offset for icon
  }
  strong {
    color: var(--ck-spinner-color);
  }

  .ck-tt-logo {
    display: inline-block;
    vertical-align: text-bottom;
    height: 1em;
    width: 1.25em;
    svg {
      display: block;
      height: 100%;
      transform: translate(0.5px, -1px) scale(1.75);
    }
  }
`;
var TooltipTail = styled(motion.div)`
  z-index: 2;
  position: absolute;
  display: flex;
  align-items: center;
  justify-content: center;
  width: ${(props) => props.$size === "small" ? 14 : 18}px;
  right: 100%;
  top: 0;
  bottom: 0;
  overflow: hidden;
  &:before {
    content: '';
    position: absolute;
    box-shadow: var(--shadow);
    width: ${(props) => props.$size === "small" ? 14 : 18}px;
    height: ${(props) => props.$size === "small" ? 14 : 18}px;
    transform: translate(75%, 0) rotate(45deg);
    background: var(--ck-tooltip-background);
    border-radius: ${(props) => props.$size === "small" ? 2 : 3}px 0 0 0;
  }
`;
var Tooltip = ({ children, message, open, xOffset = 0, yOffset = 0, delay: delay2 }) => {
  var _a2;
  const context = useContext21();
  const themeContext = useThemeContext();
  if ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.hideTooltips)
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children });
  const [isOpen, setIsOpen] = (0, import_react70.useState)(false);
  const [outOfBounds, setOutOfBounds] = (0, import_react70.useState)(false);
  const [size5, setSize] = (0, import_react70.useState)("small");
  const [ready, setReady] = (0, import_react70.useState)(false);
  const [currentRoute] = (0, import_react70.useState)(context.route);
  const targetRef = (0, import_react70.useRef)(null);
  const [ref, bounds] = j2({
    debounce: !ready ? 220 : 0,
    // fix alignment initial state
    offsetSize: true,
    scroll: true
  });
  const checkBounds = () => {
    let flag = false;
    const x2 = xOffset + bounds.left + bounds.width;
    const y2 = yOffset + bounds.top + bounds.height * 0.5;
    if (x2 > window.innerWidth || x2 < 0 || y2 > window.innerHeight || y2 < 0) {
      flag = true;
    }
    return flag;
  };
  const useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? import_react70.useLayoutEffect : import_react70.useEffect;
  const refreshLayout = () => {
    if (!targetRef.current || bounds.top + bounds.bottom + bounds.left + bounds.right + bounds.height + bounds.width === 0)
      return;
    const x2 = xOffset + bounds.left + bounds.width;
    const y2 = yOffset + bounds.top + bounds.height * 0.5;
    if (!ready && x2 !== 0 && y2 !== 0)
      setReady(true);
    targetRef.current.style.left = `${x2}px`;
    targetRef.current.style.top = `${y2}px`;
    setSize(targetRef.current.offsetHeight <= 40 ? "small" : "large");
    setOutOfBounds(checkBounds());
  };
  useIsomorphicLayoutEffect3(refreshLayout, [bounds, open, isOpen]);
  (0, import_react70.useEffect)(() => {
    if (!context.open)
      setIsOpen(false);
  }, [context.open]);
  (0, import_react70.useEffect)(() => {
    setIsOpen(!!open);
  }, [open]);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(motion.div, { ref, style: open === void 0 ? {
    cursor: "help"
  } : {}, onHoverStart: () => setIsOpen(true), onHoverEnd: () => setIsOpen(false), onClick: () => setIsOpen(false), children }), (0, import_jsx_runtime.jsx)(Portal, { children: (0, import_jsx_runtime.jsx)(AnimatePresence, { children: currentRoute === context.route && !outOfBounds && isOpen && (0, import_jsx_runtime.jsx)(ResetContainer, { "$useTheme": themeContext.theme, "$useMode": themeContext.mode, "$customTheme": themeContext.customTheme, children: (0, import_jsx_runtime.jsx)(TooltipWindow, { children: (0, import_jsx_runtime.jsxs)(TooltipContainer, { role: "tooltip", "$size": size5, ref: targetRef, initial: "collapsed", animate: ready ? "open" : {}, exit: "collapsed", variants: {
    collapsed: {
      transformOrigin: "20px 50%",
      opacity: 0,
      scale: 0.9,
      z: 0.01,
      y: "-50%",
      x: 20,
      transition: {
        duration: 0.1
      }
    },
    open: {
      willChange: "opacity,transform",
      opacity: 1,
      scale: 1,
      z: 0.01,
      y: "-50%",
      x: 20,
      transition: {
        ease: [0.76, 0, 0.24, 1],
        duration: 0.15,
        delay: delay2 ? delay2 : 0.5
      }
    }
  }, children: [message, (0, import_jsx_runtime.jsx)(TooltipTail, { "$size": size5 })] }) }) }) }) })] });
};
var LogoContainer$4 = styled(motion.div)`
  z-index: 4;
  position: relative;
  overflow: hidden;
  svg {
    z-index: 3;
    position: relative;
    display: block;
  }
`;
var Logo$1 = styled(motion.div)`
  z-index: 2;
  position: absolute;
  overflow: hidden;
  inset: 6px;
  border-radius: 24px;
  background: var(--ck-body-background);
  svg,
  img {
    pointer-events: none;
    display: block;
    width: 100%;
    height: 100%;
  }
`;
var SpinnerContainer$1 = styled(motion.div)`
  position: absolute;
  inset: 1px;
  overflow: hidden;
`;
var Spinner$3 = styled(motion.div)`
  pointer-events: none;
  user-select: none;
  z-index: 1;
  position: absolute;
  inset: -25%;
  &:before {
    content: '';
    position: absolute;
    inset: 0;
    background: conic-gradient(
      from -90deg,
      transparent,
      transparent,
      transparent,
      transparent,
      transparent,
      var(--ck-spinner-color)
    );
    animation: rotateSpinner 1200ms linear infinite;
  }
  @keyframes rotateSpinner {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
var SquircleSpinner = ({ logo, connecting = true }) => {
  return (0, import_jsx_runtime.jsxs)(LogoContainer$4, { transition: { duration: 0.5, ease: [0.175, 0.885, 0.32, 0.98] }, children: [(0, import_jsx_runtime.jsx)(Logo$1, { children: logo }), (0, import_jsx_runtime.jsx)(SpinnerContainer$1, { children: (0, import_jsx_runtime.jsx)(AnimatePresence, { children: connecting && (0, import_jsx_runtime.jsx)(Spinner$3, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: {
    opacity: 0,
    transition: {
      duration: 0
    }
  } }, "Spinner") }) }), (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "102", height: "102", viewBox: "0 0 102 102", fill: "none", children: [(0, import_jsx_runtime.jsx)("rect", { x: "7.57895", y: "7.57895", width: "86.8421", height: "86.8421", rx: "19.2211", stroke: "black", strokeOpacity: "0.02", strokeWidth: "1.15789" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M0 0H102V102H0V0ZM7 38.284C7 27.5684 7 22.2106 9.01905 18.0892C10.9522 14.1431 14.1431 10.9522 18.0892 9.01905C22.2106 7 27.5684 7 38.284 7H63.716C74.4316 7 79.7894 7 83.9108 9.01905C87.8569 10.9522 91.0478 14.1431 92.9809 18.0892C95 22.2106 95 27.5684 95 38.284V63.716C95 74.4316 95 79.7894 92.9809 83.9108C91.0478 87.8569 87.8569 91.0478 83.9108 92.9809C79.7894 95 74.4316 95 63.716 95H38.284C27.5684 95 22.2106 95 18.0892 92.9809C14.1431 91.0478 10.9522 87.8569 9.01905 83.9108C7 79.7894 7 74.4316 7 63.716V38.284ZM41.5 0.5H41.4325C34.7246 0.499996 29.6023 0.499994 25.5104 0.823325C21.388 1.14906 18.1839 1.80986 15.3416 3.20227C10.0602 5.78959 5.78959 10.0602 3.20227 15.3416C1.80986 18.1839 1.14906 21.388 0.823325 25.5104C0.499994 29.6023 0.499996 34.7246 0.5 41.4325V41.5V55.5938C0.5 55.6808 0.507407 55.766 0.521624 55.849C0.507407 55.9319 0.5 56.0172 0.5 56.1042V60.5V60.5675C0.499996 67.2754 0.499994 72.3977 0.823325 76.4896C1.14906 80.612 1.80986 83.8161 3.20227 86.6584C5.78959 91.9398 10.0602 96.2104 15.3416 98.7977C18.1839 100.19 21.388 100.851 25.5104 101.177C29.6022 101.5 34.7244 101.5 41.432 101.5H41.4324H41.5H43.4227H60.5H60.5675H60.568C67.2756 101.5 72.3977 101.5 76.4896 101.177C80.612 100.851 83.8161 100.19 86.6584 98.7977C91.9398 96.2104 96.2104 91.9398 98.7977 86.6584C100.19 83.8161 100.851 80.612 101.177 76.4896C101.5 72.3978 101.5 67.2756 101.5 60.568V60.5676V60.5V41.5V41.4324V41.432C101.5 34.7244 101.5 29.6022 101.177 25.5104C100.851 21.388 100.19 18.1839 98.7977 15.3416C96.2104 10.0602 91.9398 5.78959 86.6584 3.20227C83.8161 1.80986 80.612 1.14906 76.4896 0.823325C72.3977 0.499994 67.2754 0.499996 60.5675 0.5H60.5H41.5ZM3.5 56.1042C3.5 56.0172 3.49259 55.9319 3.47838 55.849C3.49259 55.766 3.5 55.6808 3.5 55.5938V41.5C3.5 34.7112 3.50109 29.7068 3.814 25.7467C4.1256 21.8032 4.73946 19.0229 5.89635 16.6614C8.19077 11.9779 11.9779 8.19077 16.6614 5.89635C19.0229 4.73946 21.8032 4.1256 25.7467 3.814C29.7068 3.50109 34.7112 3.5 41.5 3.5H60.5C67.2888 3.5 72.2932 3.50109 76.2533 3.814C80.1968 4.1256 82.977 4.73946 85.3386 5.89635C90.022 8.19077 93.8092 11.9779 96.1036 16.6614C97.2605 19.0229 97.8744 21.8032 98.186 25.7467C98.4989 29.7068 98.5 34.7112 98.5 41.5V60.5C98.5 67.2888 98.4989 72.2932 98.186 76.2533C97.8744 80.1968 97.2605 82.9771 96.1036 85.3386C93.8092 90.022 90.022 93.8092 85.3386 96.1036C82.977 97.2605 80.1968 97.8744 76.2533 98.186C72.2932 98.4989 67.2888 98.5 60.5 98.5H43.4227H41.5C34.7112 98.5 29.7068 98.4989 25.7467 98.186C21.8032 97.8744 19.0229 97.2605 16.6614 96.1036C11.9779 93.8092 8.19077 90.022 5.89635 85.3386C4.73946 82.9771 4.1256 80.1968 3.814 76.2533C3.50109 72.2932 3.5 67.2888 3.5 60.5V56.1042Z", fill: "var(--ck-body-background)" })] })] });
};
var BrowserIconContainer = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  max-width: 32px;
  max-height: 32px;
  width: 100%;
  height: 100%;
  svg {
    display: block;
    width: 100%;
    height: 100%;
  }
`;
var Chrome = (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("g", { filter: "url(#filter0_ii_927_5781)", children: (0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#clip0_927_5781)", children: [(0, import_jsx_runtime.jsx)("path", { d: "M1.58771 0V12.2727H6.06498L10.0002 5.45455H20.0002V0H1.58771Z", fill: "#DB4437" }), (0, import_jsx_runtime.jsx)("path", { d: "M1.58771 0V12.2727H6.06498L10.0002 5.45455H20.0002V0H1.58771Z", fill: "url(#paint0_linear_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M6.17038 12.2272L1.64538 4.46582L1.57947 4.57946L6.07265 12.284L6.17038 12.2272Z", fill: "black", fillOpacity: "0.15" }), (0, import_jsx_runtime.jsx)("path", { d: "M0 20.0003H9.51932L13.9375 15.5821V12.273H6.0625L0 1.87305V20.0003Z", fill: "#0F9D58" }), (0, import_jsx_runtime.jsx)("path", { d: "M0 20.0003H9.51932L13.9375 15.5821V12.273H6.0625L0 1.87305V20.0003Z", fill: "url(#paint1_linear_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M13.8412 12.4208L13.7469 12.3662L9.38324 19.9969H9.51392L13.8435 12.4242L13.8412 12.4208Z", fill: "#263238", fillOpacity: "0.15" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.0006 5.45459L13.9381 12.2728L9.51996 20H20.0006V5.45459H10.0006Z", fill: "#FFCD40" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.0006 5.45459L13.9381 12.2728L9.51996 20H20.0006V5.45459H10.0006Z", fill: "url(#paint2_linear_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M9.9996 5.45459L13.9371 12.2728L9.51892 20H19.9996V5.45459H9.9996Z", fill: "#FFCD40" }), (0, import_jsx_runtime.jsx)("path", { d: "M9.9996 5.45459L13.9371 12.2728L9.51892 20H19.9996V5.45459H9.9996Z", fill: "url(#paint3_linear_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M1.58691 0V12.2727H6.06419L9.99941 5.45455H19.9994V0H1.58691Z", fill: "#DB4437" }), (0, import_jsx_runtime.jsx)("path", { d: "M1.58691 0V12.2727H6.06419L9.99941 5.45455H19.9994V0H1.58691Z", fill: "url(#paint4_linear_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M10 5.45459V7.83527L18.9091 5.45459H10Z", fill: "url(#paint5_radial_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M0 19.9998H9.51932L11.9318 15.9089L13.9375 12.2726H6.0625L0 1.87256V19.9998Z", fill: "#0F9D58" }), (0, import_jsx_runtime.jsx)("path", { d: "M0 19.9998H9.51932L12.1023 15.5112L13.9375 12.2726H6.0625L0 1.87256V19.9998Z", fill: "url(#paint6_linear_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M1.58771 4.59668L8.09339 11.1012L6.06384 12.2728L1.58771 4.59668Z", fill: "url(#paint7_radial_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M9.52661 19.9884L11.9084 11.1021L13.938 12.2725L9.52661 19.9884Z", fill: "url(#paint8_radial_927_5781)" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.0003 14.5455C12.5107 14.5455 14.5458 12.5104 14.5458 10C14.5458 7.48966 12.5107 5.45459 10.0003 5.45459C7.48996 5.45459 5.4549 7.48966 5.4549 10C5.4549 12.5104 7.48996 14.5455 10.0003 14.5455Z", fill: "#F1F1F1" }), (0, import_jsx_runtime.jsx)("path", { d: "M9.99995 13.6365C12.0083 13.6365 13.6363 12.0084 13.6363 10.0001C13.6363 7.99183 12.0083 6.36377 9.99995 6.36377C7.99164 6.36377 6.36359 7.99183 6.36359 10.0001C6.36359 12.0084 7.99164 13.6365 9.99995 13.6365Z", fill: "#4285F4" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.0003 5.34082C7.48899 5.34082 5.4549 7.37491 5.4549 9.88628V9.99991C5.4549 7.48855 7.48899 5.45446 10.0003 5.45446H20.0003V5.34082H10.0003Z", fill: "black", fillOpacity: "0.2" }), (0, import_jsx_runtime.jsx)("path", { d: "M13.9318 12.273C13.1455 13.6299 11.6818 14.5458 10 14.5458C8.31818 14.5458 6.85227 13.6299 6.06818 12.273H6.06364L0 1.87305V1.98668L6.06818 12.3867C6.85455 13.7435 8.31818 14.6594 10 14.6594C11.6818 14.6594 13.1455 13.7446 13.9318 12.3867H13.9375V12.273H13.9307H13.9318Z", fill: "white", fillOpacity: "0.1" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.1", d: "M10.1133 5.45459C10.094 5.45459 10.0758 5.45686 10.0565 5.458C12.5406 5.48868 14.5452 7.50913 14.5452 10C14.5452 12.491 12.5406 14.5114 10.0565 14.5421C10.0758 14.5421 10.094 14.5455 10.1133 14.5455C12.6247 14.5455 14.6588 12.5114 14.6588 10C14.6588 7.48868 12.6247 5.45459 10.1133 5.45459Z", fill: "black" }), (0, import_jsx_runtime.jsx)("path", { d: "M13.9769 12.4204C14.3632 11.7522 14.5871 10.9795 14.5871 10.1522C14.5874 9.68602 14.5157 9.22262 14.3746 8.77832C14.4826 9.16696 14.5451 9.57377 14.5451 9.99764C14.5451 10.8249 14.3212 11.5976 13.9348 12.2658L13.9371 12.2704L9.51892 19.9976H9.65074L13.9769 12.4204Z", fill: "white", fillOpacity: "0.2" }), (0, import_jsx_runtime.jsx)("path", { d: "M10 0.113636C15.5034 0.113636 19.9682 4.56023 20 10.0568C20 10.0375 20.0011 10.0193 20.0011 10C20.0011 4.47727 15.5239 0 10.0011 0C4.47841 0 0 4.47727 0 10C0 10.0193 0.00113639 10.0375 0.00113639 10.0568C0.0318182 4.56023 4.49659 0.113636 10 0.113636Z", fill: "white", fillOpacity: "0.2" }), (0, import_jsx_runtime.jsx)("path", { d: "M10 19.8865C15.5034 19.8865 19.9682 15.4399 20 9.94336C20 9.96268 20.0011 9.98086 20.0011 10.0002C20.0011 15.5229 15.5239 20.0002 10.0011 20.0002C4.47841 20.0002 0 15.5229 0 10.0002C0 9.98086 0.00113639 9.96268 0.00113639 9.94336C0.0318182 15.4399 4.49659 19.8865 10.0011 19.8865H10Z", fill: "black", fillOpacity: "0.15" })] }) }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("filter", { id: "filter0_ii_927_5781", x: 0, y: "-0.235294", width: 20, height: "20.4706", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [(0, import_jsx_runtime.jsx)("feFlood", { floodOpacity: 0, result: "BackgroundImageFix" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), (0, import_jsx_runtime.jsx)("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), (0, import_jsx_runtime.jsx)("feOffset", { dy: "0.235294" }), (0, import_jsx_runtime.jsx)("feGaussianBlur", { stdDeviation: "0.235294" }), (0, import_jsx_runtime.jsx)("feComposite", { in2: "hardAlpha", operator: "arithmetic", k2: -1, k3: 1 }), (0, import_jsx_runtime.jsx)("feColorMatrix", { type: "matrix", values: "0 0 0 0 1 0 0 0 0 1 0 0 0 0 1 0 0 0 0.25 0" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in2: "shape", result: "effect1_innerShadow_927_5781" }), (0, import_jsx_runtime.jsx)("feColorMatrix", { in: "SourceAlpha", type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 127 0", result: "hardAlpha" }), (0, import_jsx_runtime.jsx)("feOffset", { dy: "-0.235294" }), (0, import_jsx_runtime.jsx)("feGaussianBlur", { stdDeviation: "0.235294" }), (0, import_jsx_runtime.jsx)("feComposite", { in2: "hardAlpha", operator: "arithmetic", k2: -1, k3: 1 }), (0, import_jsx_runtime.jsx)("feColorMatrix", { type: "matrix", values: "0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0.12 0" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in2: "effect1_innerShadow_927_5781", result: "effect2_innerShadow_927_5781" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_927_5781", x1: "2.42521", y1: "7.61591", x2: "8.39112", y2: "4.13068", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#A52714", stopOpacity: "0.6" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.66", stopColor: "#A52714", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint1_linear_927_5781", x1: "11.6932", y1: "17.7844", x2: "5.06136", y2: "13.8981", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#055524", stopOpacity: "0.4" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.33", stopColor: "#055524", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint2_linear_927_5781", x1: "12.9438", y1: "4.75004", x2: "14.6143", y2: "12.0569", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#EA6100", stopOpacity: "0.3" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.66", stopColor: "#EA6100", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint3_linear_927_5781", x1: "12.9428", y1: "4.75004", x2: "14.6132", y2: "12.0569", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#EA6100", stopOpacity: "0.3" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.66", stopColor: "#EA6100", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint4_linear_927_5781", x1: "2.42441", y1: "7.61591", x2: "8.39032", y2: "4.13068", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#A52714", stopOpacity: "0.6" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.66", stopColor: "#A52714", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint5_radial_927_5781", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.56818 5.44891) scale(9.55455)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#3E2723", stopOpacity: "0.2" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#3E2723", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint6_linear_927_5781", x1: "11.6932", y1: "17.7839", x2: "5.06136", y2: "13.8976", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#055524", stopOpacity: "0.4" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.33", stopColor: "#055524", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint7_radial_927_5781", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(1.57975 4.60463) scale(8.86818)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#3E2723", stopOpacity: "0.2" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#3E2723", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint8_radial_927_5781", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.97775 10.0157) scale(9.98523)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#263238", stopOpacity: "0.2" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#263238", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsx)("clipPath", { id: "clip0_927_5781", children: (0, import_jsx_runtime.jsx)("rect", { width: 20, height: 20, rx: 10, fill: "white" }) })] })] });
var FireFox = (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#clip0_927_5847)", children: [(0, import_jsx_runtime.jsx)("path", { d: "M19.011 6.71023C18.5898 5.69685 17.7355 4.60269 17.0665 4.25681C17.5436 5.18063 17.8747 6.17276 18.0481 7.19792L18.0499 7.21417C16.954 4.48315 15.0963 3.38023 13.5782 0.981835C13.5014 0.860539 13.4246 0.738994 13.3498 0.610696C13.3071 0.537418 13.2728 0.471393 13.2431 0.410621C13.1801 0.288713 13.1316 0.159878 13.0985 0.0267267C13.0985 0.0205825 13.0963 0.0146369 13.0923 0.0100242C13.0882 0.00541151 13.0826 0.00245454 13.0765 0.00171737C13.0705 7.85858e-05 13.0642 7.85858e-05 13.0582 0.00171737C13.057 0.00171737 13.055 0.00396821 13.0535 0.0044684C13.052 0.00496859 13.0487 0.00721943 13.0465 0.00821981L13.0502 0.00171737C10.6156 1.42725 9.78901 4.06574 9.71399 5.38624C8.74136 5.45292 7.81141 5.81121 7.04549 6.41437C6.96561 6.34671 6.88212 6.28343 6.79539 6.2248C6.57456 5.45174 6.56514 4.6336 6.76813 3.85566C5.87401 4.28877 5.07954 4.90279 4.43501 5.65884H4.43051C4.04636 5.17191 4.07337 3.5663 4.09538 3.23093C3.98174 3.2766 3.87326 3.33419 3.77176 3.40274C3.43264 3.64477 3.11562 3.91635 2.8244 4.2143C2.49255 4.55075 2.18946 4.91441 1.91831 5.30146V5.30296V5.3012C1.29521 6.18444 0.853213 7.18234 0.617826 8.23731L0.604821 8.30133C0.586564 8.38661 0.52079 8.81377 0.509535 8.90656C0.509535 8.91381 0.508035 8.92056 0.507285 8.92781C0.42244 9.36882 0.369864 9.81542 0.349976 10.2641V10.3141C0.354259 12.7396 1.26772 15.0754 2.91002 16.8604C4.55233 18.6454 6.80415 19.7498 9.22094 19.9556C11.6377 20.1615 14.0439 19.4538 15.9644 17.9723C17.8849 16.4908 19.1803 14.3431 19.5947 11.9532C19.6109 11.8282 19.6242 11.7044 19.6387 11.5781C19.8384 9.92791 19.6222 8.25404 19.01 6.70873L19.011 6.71023ZM7.83928 14.2981C7.88455 14.3198 7.92707 14.3433 7.97358 14.3641L7.98034 14.3684C7.93332 14.3458 7.8863 14.3224 7.83928 14.2981ZM18.0501 7.21692V7.20767L18.0519 7.21792L18.0501 7.21692Z", fill: "url(#paint0_linear_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M19.0109 6.71026C18.5898 5.69688 17.7354 4.60272 17.0664 4.25684C17.5435 5.18066 17.8746 6.17278 18.0481 7.19794V7.20719L18.0498 7.21745C18.797 9.35551 18.689 11.6997 17.7482 13.7599C16.6373 16.1435 13.9493 18.5867 9.7402 18.4667C5.19349 18.3379 1.18699 14.9629 0.439211 10.5437C0.30291 9.84668 0.439211 9.4933 0.507737 8.92684C0.414265 9.36685 0.362102 9.81463 0.351929 10.2643V10.3144C0.356212 12.7399 1.26967 15.0757 2.91198 16.8607C4.55429 18.6456 6.8061 19.7501 9.2229 19.9559C11.6397 20.1617 14.0458 19.4541 15.9664 17.9725C17.8869 16.491 19.1822 14.3434 19.5966 11.9535C19.6129 11.8284 19.6262 11.7046 19.6407 11.5783C19.8403 9.92819 19.6242 8.25431 19.0119 6.70901L19.0109 6.71026Z", fill: "url(#paint1_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M19.0109 6.71026C18.5898 5.69688 17.7354 4.60272 17.0664 4.25684C17.5435 5.18066 17.8746 6.17278 18.0481 7.19794V7.20719L18.0498 7.21745C18.797 9.35551 18.689 11.6997 17.7482 13.7599C16.6373 16.1435 13.9493 18.5867 9.7402 18.4667C5.19349 18.3379 1.18699 14.9629 0.439211 10.5437C0.30291 9.84668 0.439211 9.4933 0.507737 8.92684C0.414265 9.36685 0.362102 9.81463 0.351929 10.2643V10.3144C0.356212 12.7399 1.26967 15.0757 2.91198 16.8607C4.55429 18.6456 6.8061 19.7501 9.2229 19.9559C11.6397 20.1617 14.0458 19.4541 15.9664 17.9725C17.8869 16.491 19.1822 14.3434 19.5966 11.9535C19.6129 11.8284 19.6262 11.7046 19.6407 11.5783C19.8403 9.92819 19.6242 8.25431 19.0119 6.70901L19.0109 6.71026Z", fill: "url(#paint2_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M14.2993 7.84794C14.3203 7.8627 14.3398 7.87745 14.3595 7.89221C14.1161 7.46047 13.813 7.06519 13.4592 6.71802C10.4456 3.70439 12.6696 0.18557 13.0445 0.00550206L13.0483 0C10.6136 1.42553 9.78706 4.06402 9.71204 5.38452C9.82508 5.37677 9.93712 5.36726 10.0527 5.36726C10.9164 5.36893 11.7644 5.59929 12.5103 6.03492C13.2562 6.47055 13.8734 7.09592 14.2993 7.84744V7.84794Z", fill: "url(#paint3_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.0577 8.45061C10.0417 8.6917 9.18992 9.52326 8.89206 9.52326C6.13602 9.52326 5.68835 11.1906 5.68835 11.1906C5.8104 12.5947 6.78877 13.7516 7.97146 14.3618C8.02548 14.3898 8.08025 14.4151 8.13502 14.4399C8.22989 14.4819 8.32476 14.5207 8.41963 14.5564C8.82553 14.7 9.25065 14.7821 9.68085 14.7997C14.5127 15.0263 15.448 9.02257 11.9615 7.27942C12.7839 7.1724 13.6168 7.37463 14.2986 7.84688C13.8727 7.09536 13.2555 6.46999 12.5096 6.03436C11.7637 5.59873 10.9158 5.36837 10.052 5.3667C9.93695 5.3667 9.82441 5.3762 9.71136 5.38396C8.73874 5.45064 7.80879 5.80893 7.04286 6.41209C7.19067 6.53714 7.35748 6.7042 7.70886 7.05058C8.36661 7.69857 10.0535 8.36983 10.0572 8.44861L10.0577 8.45061Z", fill: "url(#paint4_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M10.0577 8.45061C10.0417 8.6917 9.18992 9.52326 8.89206 9.52326C6.13602 9.52326 5.68835 11.1906 5.68835 11.1906C5.8104 12.5947 6.78877 13.7516 7.97146 14.3618C8.02548 14.3898 8.08025 14.4151 8.13502 14.4399C8.22989 14.4819 8.32476 14.5207 8.41963 14.5564C8.82553 14.7 9.25065 14.7821 9.68085 14.7997C14.5127 15.0263 15.448 9.02257 11.9615 7.27942C12.7839 7.1724 13.6168 7.37463 14.2986 7.84688C13.8727 7.09536 13.2555 6.46999 12.5096 6.03436C11.7637 5.59873 10.9158 5.36837 10.052 5.3667C9.93695 5.3667 9.82441 5.3762 9.71136 5.38396C8.73874 5.45064 7.80879 5.80893 7.04286 6.41209C7.19067 6.53714 7.35748 6.7042 7.70886 7.05058C8.36661 7.69857 10.0535 8.36983 10.0572 8.44861L10.0577 8.45061Z", fill: "url(#paint5_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M6.59134 6.0923C6.66987 6.14231 6.73464 6.18583 6.79141 6.2251C6.57058 5.45204 6.56117 4.63389 6.76415 3.85596C5.87003 4.28907 5.07556 4.90308 4.43103 5.65913C4.4783 5.65788 5.88432 5.63262 6.59134 6.0923Z", fill: "url(#paint6_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M0.437567 10.5439C1.1856 14.963 5.19185 18.3393 9.73855 18.4668C13.9476 18.5859 16.6361 16.1425 17.7466 13.7601C18.6873 11.6998 18.7954 9.35569 18.0482 7.21762V7.20837C18.0482 7.20111 18.0467 7.19686 18.0482 7.19911L18.0499 7.21537C18.3938 9.46046 17.2519 11.6345 15.4665 13.1076L15.4609 13.1201C11.9821 15.9536 8.6534 14.8292 7.98064 14.3706C7.93363 14.348 7.88661 14.3246 7.83959 14.3003C5.81158 13.3309 4.97352 11.4842 5.15358 9.89862C4.67218 9.90573 4.19905 9.77307 3.79151 9.51672C3.38397 9.26038 3.05952 8.89134 2.85747 8.45433C3.38987 8.1282 3.99692 7.94382 4.62077 7.91878C5.24461 7.89374 5.86448 8.02887 6.42131 8.31128C7.56906 8.83225 8.87507 8.8836 10.0602 8.45433C10.0564 8.37555 8.36954 7.70405 7.71179 7.05631C7.36041 6.70993 7.1936 6.54312 7.04579 6.41782C6.96591 6.35016 6.88243 6.28688 6.7957 6.22825C6.73818 6.18898 6.6734 6.14647 6.59562 6.09545C5.88861 5.63578 4.48258 5.66104 4.43607 5.66229H4.43156C4.04742 5.17535 4.07443 3.56975 4.09644 3.23438C3.9828 3.28005 3.87431 3.33764 3.77282 3.40619C3.4337 3.64822 3.11667 3.91979 2.82546 4.21774C2.49242 4.55325 2.18808 4.91607 1.91562 5.3024V5.3039V5.30215C1.29252 6.18539 0.850521 7.18329 0.615133 8.23825C0.610381 8.25801 0.266002 9.76357 0.435816 10.5444L0.437567 10.5439Z", fill: "url(#paint7_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M13.459 6.71761C13.8128 7.06516 14.1159 7.46087 14.3593 7.89305C14.4126 7.93331 14.4624 7.97333 14.5046 8.01209C16.7022 10.0378 15.5508 12.9014 15.465 13.104C17.2502 11.6332 18.3911 9.45763 18.0485 7.21179C16.952 4.47826 15.0923 3.37535 13.5768 0.976952C13.5 0.855657 13.4232 0.734111 13.3484 0.605813C13.3057 0.532535 13.2714 0.466511 13.2417 0.405738C13.1787 0.283831 13.1302 0.154995 13.0971 0.0218439C13.0971 0.0156997 13.0949 0.0097541 13.0909 0.0051414C13.0868 0.000528701 13.0812 -0.00242828 13.0751 -0.00316545C13.0691 -0.00480423 13.0628 -0.00480423 13.0568 -0.00316545C13.0556 -0.00316545 13.0536 -0.000914601 13.0521 -0.000414413C13.0506 8.57743e-05 13.0473 0.00233662 13.0451 0.00333699C12.6702 0.181154 10.4466 3.70222 13.4602 6.71335L13.459 6.71761Z", fill: "url(#paint8_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M14.5043 8.01315C14.462 7.97439 14.4122 7.93437 14.359 7.8941C14.3392 7.87935 14.3197 7.86459 14.2987 7.84984C13.6169 7.37759 12.784 7.17536 11.9616 7.28238C15.4479 9.02553 14.5125 15.0278 9.68095 14.8027C9.25075 14.785 8.82562 14.703 8.41973 14.5594C8.32486 14.5238 8.22999 14.485 8.13512 14.4428C8.08035 14.4178 8.02558 14.3928 7.97156 14.3648L7.97831 14.369C8.65206 14.829 11.9798 15.9526 15.4586 13.1186L15.4641 13.1061C15.5509 12.9035 16.7023 10.0399 14.5038 8.01415L14.5043 8.01315Z", fill: "url(#paint9_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M5.68842 11.1892C5.68842 11.1892 6.13583 9.52179 8.89212 9.52179C9.18998 9.52179 10.0425 8.69023 10.0578 8.44914C8.8727 8.8784 7.56669 8.82706 6.41894 8.30608C5.86211 8.02367 5.24224 7.88855 4.61839 7.91359C3.99455 7.93863 3.3875 8.123 2.8551 8.44914C3.05715 8.88615 3.3816 9.25518 3.78914 9.51153C4.19668 9.76787 4.66981 9.90053 5.15121 9.89343C4.97165 11.4783 5.80946 13.3247 7.83722 14.2951C7.88249 14.3168 7.925 14.3403 7.97152 14.3611C6.78783 13.7496 5.81046 12.5932 5.68842 11.1899V11.1892Z", fill: "url(#paint10_radial_927_5847)" }), (0, import_jsx_runtime.jsx)("path", { d: "M19.0112 6.71023C18.59 5.69685 17.7357 4.60269 17.0667 4.25681C17.5438 5.18063 17.8749 6.17276 18.0483 7.19792L18.0501 7.21417C16.9542 4.48315 15.0965 3.38023 13.5784 0.981835C13.5016 0.860539 13.4249 0.738994 13.3501 0.610696C13.3073 0.537418 13.2731 0.471393 13.2433 0.410621C13.1803 0.288713 13.1318 0.159878 13.0987 0.0267267C13.0988 0.0205825 13.0966 0.0146369 13.0925 0.0100242C13.0884 0.00541151 13.0828 0.00245454 13.0767 0.00171737C13.0708 7.85859e-05 13.0644 7.85859e-05 13.0585 0.00171737C13.0572 0.00171737 13.0552 0.00396821 13.0537 0.0044684C13.0522 0.00496859 13.049 0.00721943 13.0467 0.00821981L13.0505 0.00171737C10.6158 1.42725 9.78925 4.06574 9.71422 5.38624C9.82726 5.37848 9.9393 5.36898 10.0548 5.36898C10.9186 5.37065 11.7666 5.60101 12.5125 6.03664C13.2584 6.47227 13.8756 7.09764 14.3014 7.84916C13.6196 7.37691 12.7868 7.17468 11.9643 7.2817C15.4506 9.02485 14.5153 15.0271 9.68371 14.802C9.25351 14.7843 8.82838 14.7023 8.42248 14.5587C8.32761 14.5232 8.23275 14.4843 8.13788 14.4421C8.08311 14.4171 8.02834 14.3921 7.97432 14.3641L7.98107 14.3684C7.93405 14.3458 7.88703 14.3224 7.84002 14.2981C7.88528 14.3198 7.9278 14.3433 7.97432 14.3641C6.79062 13.7524 5.81326 12.5959 5.69121 11.1929C5.69121 11.1929 6.13863 9.52554 8.89491 9.52554C9.19277 9.52554 10.0453 8.69398 10.0606 8.45289C10.0568 8.37411 8.36996 7.7026 7.71222 7.05486C7.36084 6.70848 7.19402 6.54167 7.04622 6.41637C6.96634 6.34871 6.88285 6.28543 6.79612 6.2268C6.57529 5.45374 6.56588 4.6356 6.76886 3.85766C5.87474 4.29077 5.08027 4.90479 4.43574 5.66084H4.43124C4.04709 5.17391 4.0741 3.5683 4.09611 3.23293C3.98247 3.2786 3.87399 3.33619 3.77249 3.40474C3.43337 3.64677 3.11635 3.91835 2.82514 4.2163C2.49328 4.55275 2.19019 4.91641 1.91905 5.30345V5.30496V5.30321C1.29595 6.18644 0.853946 7.18434 0.618558 8.23931L0.605554 8.30333C0.587297 8.38861 0.505516 8.82177 0.493762 8.91481C0.418959 9.36194 0.371188 9.81318 0.350708 10.2661V10.3161C0.354992 12.7416 1.26845 15.0774 2.91076 16.8624C4.55307 18.6474 6.80488 19.7518 9.22168 19.9576C11.6385 20.1635 14.0446 19.4558 15.9652 17.9743C17.8857 16.4928 19.181 14.3451 19.5954 11.9552C19.6117 11.8302 19.6249 11.7064 19.6394 11.5801C19.8391 9.92991 19.623 8.25604 19.0107 6.71073L19.0112 6.71023ZM18.0496 7.20817L18.0513 7.21842L18.0496 7.20817Z", fill: "url(#paint11_linear_927_5847)" })] }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_927_5847", x1: "17.728", y1: "3.09786", x2: "1.63621", y2: "18.6237", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.048", stopColor: "#FFF44F" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.111", stopColor: "#FFE847" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.225", stopColor: "#FFC830" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.368", stopColor: "#FF980E" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.401", stopColor: "#FF8B16" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.462", stopColor: "#FF672A" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.534", stopColor: "#FF3647" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.705", stopColor: "#E31587" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint1_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(17.1052 2.25108) scale(20.2076)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.129", stopColor: "#FFBD4F" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.186", stopColor: "#FFAC31" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.247", stopColor: "#FF9D17" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.283", stopColor: "#FF980E" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.403", stopColor: "#FF563B" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.467", stopColor: "#FF3750" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.71", stopColor: "#F5156C" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.782", stopColor: "#EB0878" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.86", stopColor: "#E50080" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint2_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.6024 10.5042) scale(20.2076)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.3", stopColor: "#960E18" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.351", stopColor: "#B11927", stopOpacity: "0.74" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.435", stopColor: "#DB293D", stopOpacity: "0.343" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.497", stopColor: "#F5334B", stopOpacity: "0.094" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.53", stopColor: "#FF3750", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint3_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.1034 -2.25084) scale(14.638)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.132", stopColor: "#FFF44F" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.252", stopColor: "#FFDC3E" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.506", stopColor: "#FF9D12" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.526", stopColor: "#FF980E" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint4_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(7.35173 15.7558) scale(9.62111)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.353", stopColor: "#3A8EE6" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.472", stopColor: "#5C79F0" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.669", stopColor: "#9059FF" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#C139E6" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint5_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(10.5799 8.76923) rotate(-13.5916) scale(5.10194 5.97309)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.206", stopColor: "#9059FF", stopOpacity: 0 }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.278", stopColor: "#8C4FF3", stopOpacity: "0.064" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.747", stopColor: "#7716A8", stopOpacity: "0.45" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.975", stopColor: "#6E008B", stopOpacity: "0.6" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint6_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.35238 1.50057) scale(6.9226)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#FFE226" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.121", stopColor: "#FFDB27" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.295", stopColor: "#FFC82A" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.502", stopColor: "#FFA930" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.732", stopColor: "#FF7E37" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.792", stopColor: "#FF7139" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint7_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.8545 -3.00121) scale(29.5361)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.113", stopColor: "#FFF44F" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.456", stopColor: "#FF980E" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.622", stopColor: "#FF5634" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.716", stopColor: "#FF3647" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.904", stopColor: "#E31587" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint8_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.3996 -1.36343) rotate(83.976) scale(21.6445 14.2051)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#FFF44F" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.06", stopColor: "#FFE847" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.168", stopColor: "#FFC830" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.304", stopColor: "#FF980E" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.356", stopColor: "#FF8B16" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.455", stopColor: "#FF672A" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.57", stopColor: "#FF3647" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.737", stopColor: "#E31587" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint9_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(9.35233 4.00165) scale(18.4369)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.137", stopColor: "#FFF44F" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.48", stopColor: "#FF980E" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.592", stopColor: "#FF5634" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.655", stopColor: "#FF3647" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.904", stopColor: "#E31587" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint10_radial_927_5847", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(14.1041 5.00184) scale(20.1801)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.094", stopColor: "#FFF44F" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.231", stopColor: "#FFE141" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.509", stopColor: "#FFAF1E" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.626", stopColor: "#FF980E" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint11_linear_927_5847", x1: "17.5331", y1: "3.01533", x2: "3.84302", y2: "16.708", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.167", stopColor: "#FFF44F", stopOpacity: "0.8" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.266", stopColor: "#FFF44F", stopOpacity: "0.634" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.489", stopColor: "#FFF44F", stopOpacity: "0.217" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.6", stopColor: "#FFF44F", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsx)("clipPath", { id: "clip0_927_5847", children: (0, import_jsx_runtime.jsx)("rect", { width: 20, height: 20, fill: "white" }) })] })] });
var Brave = (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { d: "M17.2924 5.22043L17.7256 4.15905L16.4982 2.8883C15.8339 2.22404 14.4187 2.61393 14.4187 2.61393L12.8158 0.794434H7.16242L5.55231 2.62115C5.55231 2.62115 4.13715 2.23848 3.47289 2.8883L2.24545 4.15183L2.67866 5.21321L2.13715 6.78721L3.9422 13.6681C4.31765 15.141 4.57036 15.7114 5.63173 16.4623L8.93137 18.7006C9.24906 18.8955 9.63895 19.2349 9.99274 19.2349C10.3465 19.2349 10.7364 18.8955 11.0541 18.7006L14.3538 16.4623C15.4151 15.7114 15.6678 15.141 16.0433 13.6681L17.8483 6.78721L17.2924 5.22043Z", fill: "url(#paint0_linear_927_5861)" }), (0, import_jsx_runtime.jsx)("path", { d: "M13.9711 3.78343C13.9711 3.78343 16.0433 6.28884 16.0433 6.81592C16.0433 7.35744 15.7834 7.49462 15.5234 7.77621L13.9711 9.43686C13.8267 9.58126 13.5162 9.82675 13.6967 10.2527C13.8772 10.686 14.1299 11.2203 13.8411 11.769C13.5523 12.3249 13.0469 12.6932 12.722 12.6354C12.2387 12.4786 11.7777 12.2602 11.3502 11.9856C11.0758 11.8051 10.1949 11.0758 10.1949 10.7943C10.1949 10.5127 11.1047 10 11.278 9.89895C11.444 9.78343 12.2166 9.33577 12.231 9.16249C12.2455 8.9892 12.2455 8.94588 12.0144 8.51267C11.7834 8.07946 11.379 7.50184 11.4368 7.12639C11.509 6.75094 12.1588 6.54877 12.6426 6.36827L14.1372 5.80509C14.2527 5.74733 14.2238 5.69679 13.8772 5.66068C13.5307 5.6318 12.5559 5.50184 12.1155 5.62458C11.6751 5.74733 10.9386 5.93505 10.8664 6.03614C10.8086 6.13722 10.7509 6.13722 10.8159 6.48379L11.2346 8.75816C11.2635 9.04697 11.3213 9.24191 11.018 9.31411C10.7003 9.38632 10.1733 9.50906 9.99276 9.50906C9.81225 9.50906 9.27796 9.38632 8.96749 9.31411C8.65702 9.24191 8.71478 9.04697 8.75088 8.75816C8.77976 8.46935 9.09745 6.82314 9.16243 6.48379C9.23464 6.13722 9.16965 6.13722 9.11189 6.03614C9.03969 5.93505 8.29601 5.74733 7.85558 5.62458C7.42236 5.50184 6.44041 5.6318 6.09384 5.66791C5.74727 5.69679 5.71839 5.74011 5.83391 5.81231L7.3285 6.36827C7.80503 6.54877 8.46929 6.75094 8.53428 7.12639C8.60648 7.50906 8.19493 8.07946 7.95666 8.51267C7.71839 8.94588 7.72561 8.9892 7.74005 9.16249C7.75449 9.33577 8.53428 9.78343 8.69312 9.89895C8.86641 10.0073 9.77615 10.5127 9.77615 10.7943C9.77615 11.0758 8.91695 11.8051 8.62814 11.9856C8.20063 12.2602 7.73957 12.4786 7.2563 12.6354C6.93139 12.6932 6.42597 12.3249 6.12994 11.769C5.84113 11.2203 6.10106 10.686 6.27435 10.2527C6.45485 9.81953 6.1516 9.58848 5.99998 9.43686L4.44763 7.77621C4.19493 7.50906 3.935 7.36466 3.935 6.83036C3.935 6.29606 6.0072 3.79787 6.0072 3.79787L7.97832 4.11556C8.20937 4.11556 8.722 3.92061 9.19132 3.75455C9.66063 3.61014 9.98554 3.5957 9.98554 3.5957C9.98554 3.5957 10.3032 3.5957 10.7798 3.75455C11.2563 3.91339 11.7617 4.11556 11.9928 4.11556C12.231 4.11556 13.9783 3.77621 13.9783 3.77621L13.9711 3.78343ZM12.4188 13.3719C12.5487 13.4441 12.4693 13.6029 12.3465 13.6896L10.5126 15.1192C10.3682 15.2636 10.1372 15.4802 9.98554 15.4802C9.83391 15.4802 9.61009 15.2636 9.45846 15.1192C8.8506 14.6351 8.23683 14.1586 7.61731 13.6896C7.50178 13.6029 7.42236 13.4513 7.54511 13.3719L8.62814 12.7943C9.05864 12.5665 9.51417 12.3897 9.98554 12.2672C10.0938 12.2672 10.7798 12.5127 11.3357 12.7943L12.4188 13.3719Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M14.4332 2.62115L12.8159 0.794434H7.16243L5.55232 2.62115C5.55232 2.62115 4.13716 2.23848 3.4729 2.8883C3.4729 2.8883 5.35016 2.72223 5.99998 3.77638L7.99276 4.11573C8.2238 4.11573 8.73644 3.92079 9.20575 3.75472C9.67507 3.61032 9.99998 3.59588 9.99998 3.59588C9.99998 3.59588 10.3177 3.59588 10.7942 3.75472C11.2707 3.91357 11.7761 4.11573 12.0072 4.11573C12.2455 4.11573 13.9928 3.77638 13.9928 3.77638C14.6426 2.72223 16.5198 2.8883 16.5198 2.8883C15.8556 2.22404 14.4404 2.61393 14.4404 2.61393", fill: "url(#paint1_linear_927_5861)" }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_927_5861", x1: "2.13715", y1: "10.1991", x2: "17.8483", y2: "10.1991", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.4", stopColor: "#FF5500" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.6", stopColor: "#FF2000" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint1_linear_927_5861", x1: "3.73384", y1: "2.4883", x2: "16.5198", y2: "2.4883", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#FF452A" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#FF2000" })] })] })] });
var Edge = (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: 20, height: 20, viewBox: "0 0 20 20", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsxs)("g", { clipPath: "url(#clip0_927_5865)", children: [(0, import_jsx_runtime.jsx)("path", { d: "M18.0547 14.8828C17.7865 15.0222 17.5099 15.1448 17.2266 15.25C16.3293 15.584 15.3792 15.7533 14.4219 15.75C10.7266 15.75 7.50781 13.2109 7.50781 9.94531C7.51262 9.50803 7.63385 9.07993 7.85905 8.70506C8.08424 8.33019 8.40526 8.0221 8.78906 7.8125C5.44531 7.95312 4.58594 11.4375 4.58594 13.4766C4.58594 19.2578 9.90625 19.8359 11.0547 19.8359C11.6719 19.8359 12.6016 19.6562 13.1641 19.4766L13.2656 19.4453C15.4183 18.7014 17.2534 17.2465 18.4688 15.3203C18.5041 15.2618 18.5192 15.1933 18.5119 15.1253C18.5046 15.0574 18.4752 14.9937 18.4282 14.944C18.3812 14.8944 18.3192 14.8615 18.2518 14.8505C18.1843 14.8394 18.1151 14.8508 18.0547 14.8828Z", fill: "url(#paint0_linear_927_5865)" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.35", d: "M18.0547 14.8828C17.7865 15.0222 17.5099 15.1448 17.2266 15.25C16.3293 15.584 15.3792 15.7533 14.4219 15.75C10.7266 15.75 7.50781 13.2109 7.50781 9.94531C7.51262 9.50803 7.63385 9.07993 7.85905 8.70506C8.08424 8.33019 8.40526 8.0221 8.78906 7.8125C5.44531 7.95312 4.58594 11.4375 4.58594 13.4766C4.58594 19.2578 9.90625 19.8359 11.0547 19.8359C11.6719 19.8359 12.6016 19.6562 13.1641 19.4766L13.2656 19.4453C15.4183 18.7014 17.2534 17.2465 18.4688 15.3203C18.5041 15.2618 18.5192 15.1933 18.5119 15.1253C18.5046 15.0574 18.4752 14.9937 18.4282 14.944C18.3812 14.8944 18.3192 14.8615 18.2518 14.8505C18.1843 14.8394 18.1151 14.8508 18.0547 14.8828Z", fill: "url(#paint1_radial_927_5865)" }), (0, import_jsx_runtime.jsx)("path", { d: "M8.2578 18.8516C7.56239 18.4196 6.95961 17.854 6.48436 17.1875C5.94166 16.4447 5.56809 15.5921 5.38987 14.6896C5.21165 13.787 5.23311 12.8565 5.45272 11.9631C5.67234 11.0697 6.08479 10.2353 6.66115 9.51826C7.23751 8.80123 7.96379 8.21903 8.78905 7.8125C9.03905 7.69531 9.45311 7.49219 10.0078 7.5C10.3981 7.50302 10.7824 7.59627 11.1308 7.77245C11.4791 7.94864 11.7819 8.20299 12.0156 8.51562C12.3299 8.93835 12.5023 9.4498 12.5078 9.97656C12.5078 9.96094 14.4219 3.75781 6.2578 3.75781C2.82811 3.75781 0.00780015 7.00781 0.00780015 9.86719C-0.00584162 11.3776 0.317079 12.8721 0.953112 14.2422C1.99473 16.4602 3.81447 18.2185 6.06689 19.1834C8.3193 20.1483 10.8476 20.2526 13.1719 19.4766C12.3576 19.7337 11.4972 19.811 10.6501 19.7031C9.80297 19.5952 8.98941 19.3047 8.26561 18.8516H8.2578Z", fill: "url(#paint2_linear_927_5865)" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.41", d: "M8.2578 18.8516C7.56239 18.4196 6.95961 17.854 6.48436 17.1875C5.94166 16.4447 5.56809 15.5921 5.38987 14.6896C5.21165 13.787 5.23311 12.8565 5.45272 11.9631C5.67234 11.0697 6.08479 10.2353 6.66115 9.51826C7.23751 8.80123 7.96379 8.21903 8.78905 7.8125C9.03905 7.69531 9.45311 7.49219 10.0078 7.5C10.3981 7.50302 10.7824 7.59627 11.1308 7.77245C11.4791 7.94864 11.7819 8.20299 12.0156 8.51562C12.3299 8.93835 12.5023 9.4498 12.5078 9.97656C12.5078 9.96094 14.4219 3.75781 6.2578 3.75781C2.82811 3.75781 0.00780015 7.00781 0.00780015 9.86719C-0.00584162 11.3776 0.317079 12.8721 0.953112 14.2422C1.99473 16.4602 3.81447 18.2185 6.06689 19.1834C8.3193 20.1483 10.8476 20.2526 13.1719 19.4766C12.3576 19.7337 11.4972 19.811 10.6501 19.7031C9.80297 19.5952 8.98941 19.3047 8.26561 18.8516H8.2578Z", fill: "url(#paint3_radial_927_5865)" }), (0, import_jsx_runtime.jsx)("path", { d: "M11.9062 11.625C11.8359 11.7031 11.6406 11.8203 11.6406 12.0625C11.6406 12.2656 11.7734 12.4688 12.0156 12.6328C13.1328 13.4141 15.25 13.3047 15.2578 13.3047C16.0907 13.3041 16.9081 13.0802 17.625 12.6562C18.3467 12.2341 18.9456 11.6307 19.3622 10.9057C19.7788 10.1808 19.9986 9.35955 20 8.52344C20.0234 6.77344 19.375 5.60937 19.1172 5.09375C17.4531 1.85937 13.8828 4.89564e-08 10 4.89564e-08C7.37202 -0.00025981 4.84956 1.03398 2.97819 2.87904C1.10682 4.7241 0.0369559 7.23166 0 9.85938C0.0390625 7.00781 2.875 4.70312 6.25 4.70312C6.52344 4.70312 8.08594 4.72656 9.53125 5.48438C10.5466 5.98895 11.3875 6.78627 11.9453 7.77344C12.4219 8.60156 12.5078 9.65625 12.5078 10.0781C12.5078 10.5 12.2969 11.1172 11.8984 11.6328L11.9062 11.625Z", fill: "url(#paint4_radial_927_5865)" }), (0, import_jsx_runtime.jsx)("path", { d: "M11.9062 11.625C11.8359 11.7031 11.6406 11.8203 11.6406 12.0625C11.6406 12.2656 11.7734 12.4688 12.0156 12.6328C13.1328 13.4141 15.25 13.3047 15.2578 13.3047C16.0907 13.3041 16.9081 13.0802 17.625 12.6562C18.3467 12.2341 18.9456 11.6307 19.3622 10.9057C19.7788 10.1808 19.9986 9.35955 20 8.52344C20.0234 6.77344 19.375 5.60937 19.1172 5.09375C17.4531 1.85937 13.8828 4.89564e-08 10 4.89564e-08C7.37202 -0.00025981 4.84956 1.03398 2.97819 2.87904C1.10682 4.7241 0.0369559 7.23166 0 9.85938C0.0390625 7.00781 2.875 4.70312 6.25 4.70312C6.52344 4.70312 8.08594 4.72656 9.53125 5.48438C10.5466 5.98895 11.3875 6.78627 11.9453 7.77344C12.4219 8.60156 12.5078 9.65625 12.5078 10.0781C12.5078 10.5 12.2969 11.1172 11.8984 11.6328L11.9062 11.625Z", fill: "url(#paint5_radial_927_5865)" })] }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_927_5865", x1: "4.58594", y1: "13.8281", x2: "18.5234", y2: "13.8281", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#0C59A4" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#114A8B" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint1_radial_927_5865", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(12.2813 13.9332) scale(7.45313 7.08047)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.7", stopOpacity: 0 }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.9", stopOpacity: "0.5" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1 })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint2_linear_927_5865", x1: "11.9297", y1: "7.78125", x2: "3.23436", y2: "17.2578", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#1B9DE2" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.2", stopColor: "#1595DF" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.7", stopColor: "#0680D7" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#0078D4" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint3_radial_927_5865", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(5.51209 15.5419) rotate(-81.3844) scale(11.202 9.05011)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.8", stopOpacity: 0 }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.9", stopOpacity: "0.5" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1 })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint4_radial_927_5865", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(2.02266 3.69656) rotate(92.2906) scale(15.8251 33.7043)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#35C1F1" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.1", stopColor: "#34C1ED" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.2", stopColor: "#2FC2DF" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.3", stopColor: "#2BC3D2" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.7", stopColor: "#36C752" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint5_radial_927_5865", cx: 0, cy: 0, r: 1, gradientUnits: "userSpaceOnUse", gradientTransform: "translate(18.7547 6.03906) rotate(73.7398) scale(7.60156 6.18159)", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "#66EB6E" }), (0, import_jsx_runtime.jsx)("stop", { offset: 1, stopColor: "#66EB6E", stopOpacity: 0 })] }), (0, import_jsx_runtime.jsx)("clipPath", { id: "clip0_927_5865", children: (0, import_jsx_runtime.jsx)("rect", { width: 20, height: 20, fill: "white" }) })] })] });
var browsers = { Chrome, FireFox, Brave, Edge };
var BrowserIcon = import_react70.default.forwardRef(({ browser }, ref) => {
  const currentBrowser = browser !== null && browser !== void 0 ? browser : detectBrowser();
  let icon;
  switch (currentBrowser) {
    case "chrome":
      icon = browsers.Chrome;
      break;
    case "firefox":
      icon = browsers.FireFox;
      break;
    case "edge":
      icon = browsers.Edge;
      break;
  }
  if (!icon)
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, {});
  return (0, import_jsx_runtime.jsx)(BrowserIconContainer, { children: icon });
});
BrowserIcon.displayName = "BrowserIcon";
var LogoContainer$3 = styled(motion.div)`
  z-index: 4;
  position: relative;
  width: 100px;
  height: 100px;
  svg {
    z-index: 3;
    position: relative;
    display: block;
  }
`;
var Logo2 = styled(motion.div)`
  z-index: 2;
  position: absolute;
  overflow: hidden;
  inset: 6px;
  border-radius: 50px;
  background: var(--ck-body-background);
  display: flex;
  align-items: center;
  justify-content: center;
  svg,
  img {
    pointer-events: none;
    display: block;
    margin: 0 auto;
    width: 100%;
    height: 100%;
    ${(props) => props.$small && Ae`
        width: 85%;
        height: 85%;
      `}
  }
`;
var SpinnerContainer = styled(motion.div)`
  position: absolute;
  inset: -5px;
`;
var ExpiringSpinner = styled(motion.div)`
  pointer-events: none;
  user-select: none;
  z-index: 1;
  position: absolute;
  inset: -25%;
  background: var(--ck-body-background);
  div:first-child {
    position: absolute;
    left: 50%;
    right: 0;
    top: 0;
    bottom: 0;
    overflow: hidden;
    &:before {
      position: absolute;
      content: '';
      inset: 0;
      background: var(--ck-spinner-color);
      transform-origin: 0% 50%;
      animation: rotateExpiringSpinner 5000ms ease-in both;
    }
  }
  div:last-child {
    position: absolute;
    left: 0;
    right: 50%;
    top: 0;
    bottom: 0;
    overflow: hidden;
    &:before {
      position: absolute;
      content: '';
      inset: 0;
      background: var(--ck-spinner-color);
      transform-origin: 100% 50%;
      animation: rotateExpiringSpinner 5000ms ease-out 5000ms both;
    }
  }
  @keyframes rotateExpiringSpinner {
    0% {
      transform: rotate(-180deg);
    }
    100% {
      transform: rotate(0deg);
    }
  }
`;
var Spinner$2 = styled(motion.div)`
  pointer-events: none;
  user-select: none;
  z-index: 1;
  position: absolute;
  inset: 0;
  svg {
    display: block;
    position: absolute;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    animation: rotateSpinner 1200ms linear infinite;
  }
  @keyframes rotateSpinner {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
var CircleSpinner = ({ logo, smallLogo, connecting = true, unavailable = false, countdown = false }) => {
  return (0, import_jsx_runtime.jsxs)(LogoContainer$3, { transition: { duration: 0.5, ease: [0.175, 0.885, 0.32, 0.98] }, children: [(0, import_jsx_runtime.jsx)(Logo2, { "$small": !unavailable && smallLogo, style: unavailable ? { borderRadius: 0 } : void 0, children: logo }), (0, import_jsx_runtime.jsx)(SpinnerContainer, { children: (0, import_jsx_runtime.jsxs)(AnimatePresence, { children: [connecting && (0, import_jsx_runtime.jsx)(Spinner$2, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: {
    opacity: 0,
    transition: {
      duration: countdown ? 1 : 0
    }
  }, children: (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "102", height: "102", viewBox: "0 0 102 102", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { d: "M52 100C24.3858 100 2 77.6142 2 50", stroke: "url(#paint0_linear_1943_4139)", strokeWidth: "3.5", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_1943_4139", x1: "2", y1: "48.5", x2: "53", y2: "100", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-spinner-color)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-spinner-color)", stopOpacity: "0" })] }) })] }) }, "Spinner"), countdown && (0, import_jsx_runtime.jsxs)(ExpiringSpinner, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.25 }, children: [(0, import_jsx_runtime.jsx)("div", {}), (0, import_jsx_runtime.jsx)("div", {})] }, "ExpiringSpinner")] }) })] });
};
var states$1 = {
  CONNECTED: "connected",
  CONNECTING: "connecting",
  EXPIRING: "expiring",
  FAILED: "failed",
  REJECTED: "rejected",
  NOTCONNECTED: "notconnected",
  UNAVAILABLE: "unavailable"
};
var contentVariants$1 = {
  initial: {
    willChange: "transform,opacity",
    position: "relative",
    opacity: 0,
    scale: 0.95
  },
  animate: {
    position: "relative",
    opacity: 1,
    scale: 1,
    transition: {
      ease: [0.16, 1, 0.3, 1],
      duration: 0.4,
      delay: 0.05,
      position: { delay: 0 }
    }
  },
  exit: {
    position: "absolute",
    opacity: 0,
    scale: 0.95,
    transition: {
      ease: [0.16, 1, 0.3, 1],
      duration: 0.3
    }
  }
};
var ConnectWithInjector = ({ switchConnectMethod, forceState }) => {
  var _a2, _b, _c2, _d, _e2, _f, _g, _h;
  const { connect: connect3 } = useConnect2({
    mutation: {
      onMutate: (connector) => {
        if (connector.connector) {
          setStatus(states$1.CONNECTING);
        } else {
          setStatus(states$1.UNAVAILABLE);
        }
      },
      onError(err) {
        console.error(err);
      },
      onSettled(data, error) {
        if (error) {
          setShowTryAgainTooltip(true);
          setTimeout(() => setShowTryAgainTooltip(false), 3500);
          if (error.code) {
            switch (error.code) {
              case -32002:
                setStatus(states$1.NOTCONNECTED);
                break;
              case 4001:
                setStatus(states$1.REJECTED);
                break;
              default:
                setStatus(states$1.FAILED);
                break;
            }
          } else {
            if (error.message) {
              switch (error.message) {
                case "User rejected request":
                  setStatus(states$1.REJECTED);
                  break;
                default:
                  setStatus(states$1.FAILED);
                  break;
              }
            }
          }
        }
        setTimeout(triggerResize, 100);
      }
    }
  });
  const { triggerResize, connector: c3 } = useContext21();
  const id3 = c3.id;
  const wallet = useWallet(id3);
  const walletInfo = {
    name: wallet === null || wallet === void 0 ? void 0 : wallet.name,
    shortName: (_a2 = wallet === null || wallet === void 0 ? void 0 : wallet.shortName) !== null && _a2 !== void 0 ? _a2 : wallet === null || wallet === void 0 ? void 0 : wallet.name,
    icon: (_b = wallet === null || wallet === void 0 ? void 0 : wallet.iconConnector) !== null && _b !== void 0 ? _b : wallet === null || wallet === void 0 ? void 0 : wallet.icon,
    iconShape: (_c2 = wallet === null || wallet === void 0 ? void 0 : wallet.iconShape) !== null && _c2 !== void 0 ? _c2 : "circle",
    iconShouldShrink: wallet === null || wallet === void 0 ? void 0 : wallet.iconShouldShrink
  };
  const [showTryAgainTooltip, setShowTryAgainTooltip] = (0, import_react70.useState)(false);
  const expiryDefault = 9;
  (0, import_react70.useState)(expiryDefault);
  const browser = detectBrowser();
  const extensionUrl = (_d = wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls) === null || _d === void 0 ? void 0 : _d[browser];
  const suggestedExtension = (wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls) ? {
    name: Object.keys(wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)[0],
    label: ((_e2 = Object.keys(wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)[0]) === null || _e2 === void 0 ? void 0 : _e2.charAt(0).toUpperCase()) + ((_f = Object.keys(wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)[0]) === null || _f === void 0 ? void 0 : _f.slice(1)),
    // Capitalise first letter, but this might be better suited as a lookup table
    url: wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls[Object.keys(wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls)[0]]
  } : void 0;
  const [status, setStatus] = (0, import_react70.useState)(forceState ? forceState : !(wallet === null || wallet === void 0 ? void 0 : wallet.isInstalled) ? states$1.UNAVAILABLE : states$1.CONNECTING);
  const locales = useLocales({
    CONNECTORNAME: walletInfo.name,
    CONNECTORSHORTNAME: (_g = walletInfo.shortName) !== null && _g !== void 0 ? _g : walletInfo.name,
    SUGGESTEDEXTENSIONBROWSER: (_h = suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.label) !== null && _h !== void 0 ? _h : "your browser"
  });
  const runConnect = async () => {
    if ((wallet === null || wallet === void 0 ? void 0 : wallet.isInstalled) && (wallet === null || wallet === void 0 ? void 0 : wallet.connector)) {
      connect3({ connector: wallet === null || wallet === void 0 ? void 0 : wallet.connector });
    } else {
      setStatus(states$1.UNAVAILABLE);
    }
  };
  let connectTimeout;
  (0, import_react70.useEffect)(() => {
    if (status === states$1.UNAVAILABLE)
      return;
    connectTimeout = setTimeout(runConnect, 600);
    return () => {
      clearTimeout(connectTimeout);
    };
  }, []);
  if (!wallet) {
    return (0, import_jsx_runtime.jsx)(PageContent, { children: (0, import_jsx_runtime.jsxs)(Container$4, { children: [(0, import_jsx_runtime.jsx)(ModalHeading, { children: "Invalid State" }), (0, import_jsx_runtime.jsx)(ModalContent, { children: (0, import_jsx_runtime.jsx)(Alert, { children: "No connectors match the id given. This state should never happen." }) })] }) });
  }
  if (isWalletConnectConnector(wallet === null || wallet === void 0 ? void 0 : wallet.connector.id)) {
    return (0, import_jsx_runtime.jsx)(PageContent, { children: (0, import_jsx_runtime.jsxs)(Container$4, { children: [(0, import_jsx_runtime.jsx)(ModalHeading, { children: "Invalid State" }), (0, import_jsx_runtime.jsx)(ModalContent, { children: (0, import_jsx_runtime.jsx)(Alert, { children: "WalletConnect does not have an injection flow. This state should never happen." }) })] }) });
  }
  return (0, import_jsx_runtime.jsx)(PageContent, { children: (0, import_jsx_runtime.jsxs)(Container$4, { children: [(0, import_jsx_runtime.jsx)(ConnectingContainer, { children: (0, import_jsx_runtime.jsxs)(ConnectingAnimation, { "$shake": status === states$1.FAILED || status === states$1.REJECTED, "$circle": walletInfo.iconShape === "circle", children: [(0, import_jsx_runtime.jsx)(AnimatePresence, { children: (status === states$1.FAILED || status === states$1.REJECTED) && (0, import_jsx_runtime.jsx)(RetryButton, { "aria-label": "Retry", initial: { opacity: 0, scale: 0.8 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.8 }, whileTap: { scale: 0.9 }, transition: { duration: 0.1 }, onClick: runConnect, children: (0, import_jsx_runtime.jsx)(RetryIconContainer, { children: (0, import_jsx_runtime.jsx)(Tooltip, { open: showTryAgainTooltip && (status === states$1.FAILED || status === states$1.REJECTED), message: locales.tryAgainQuestion, xOffset: -6, children: (0, import_jsx_runtime.jsx)(RetryIconCircle, {}) }) }) }) }), walletInfo.iconShape === "circle" ? (0, import_jsx_runtime.jsx)(CircleSpinner, { logo: status === states$1.UNAVAILABLE ? (0, import_jsx_runtime.jsx)("div", { style: {
    transform: "scale(1.14)",
    position: "relative",
    width: "100%"
  }, children: walletInfo.icon }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: walletInfo.icon }), smallLogo: walletInfo.iconShouldShrink, connecting: status === states$1.CONNECTING, unavailable: status === states$1.UNAVAILABLE }) : (0, import_jsx_runtime.jsx)(SquircleSpinner, { logo: status === states$1.UNAVAILABLE ? (0, import_jsx_runtime.jsx)("div", { style: {
    transform: "scale(1.14)",
    position: "relative",
    width: "100%"
  }, children: walletInfo.icon }) : (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: walletInfo.icon }), connecting: status === states$1.CONNECTING })] }) }), (0, import_jsx_runtime.jsx)(ModalContentContainer, { children: (0, import_jsx_runtime.jsxs)(AnimatePresence, { initial: false, children: [status === states$1.FAILED && (0, import_jsx_runtime.jsxs)(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: [(0, import_jsx_runtime.jsxs)(ModalContent, { children: [(0, import_jsx_runtime.jsxs)(ModalH1, { "$error": true, children: [(0, import_jsx_runtime.jsx)(AlertIcon, {}), locales.injectionScreen_failed_h1] }), (0, import_jsx_runtime.jsx)(ModalBody, { children: locales.injectionScreen_failed_p })] }), isFamilyAccountsConnector(wallet.id) && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(OrDivider, {}), (0, import_jsx_runtime.jsx)(Button, { onClick: () => switchConnectMethod(id3), children: locales.connectWithFamilyIOS })] })] }, states$1.FAILED), status === states$1.REJECTED && (0, import_jsx_runtime.jsxs)(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: [(0, import_jsx_runtime.jsxs)(ModalContent, { style: isFamilyAccountsConnector(wallet.connector.id) ? { paddingBottom: 12 } : {
    paddingBottom: 28
  }, children: [(0, import_jsx_runtime.jsx)(ModalH1, { children: locales.injectionScreen_rejected_h1 }), (0, import_jsx_runtime.jsx)(ModalBody, { children: locales.injectionScreen_rejected_p })] }), isFamilyAccountsConnector(wallet.id) && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(OrDivider, {}), (0, import_jsx_runtime.jsx)(Button, { onClick: () => switchConnectMethod(id3), children: locales.connectWithFamilyIOS })] })] }, states$1.REJECTED), (status === states$1.CONNECTING || status === states$1.EXPIRING) && (0, import_jsx_runtime.jsx)(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: (0, import_jsx_runtime.jsxs)(ModalContent, { style: {
    paddingBottom: 28
  }, children: [(0, import_jsx_runtime.jsx)(ModalH1, { children: wallet.connector.id === "injected" ? locales.injectionScreen_connecting_injected_h1 : locales.injectionScreen_connecting_h1 }), (0, import_jsx_runtime.jsx)(ModalBody, { children: wallet.connector.id === "injected" ? locales.injectionScreen_connecting_injected_p : locales.injectionScreen_connecting_p })] }) }, states$1.CONNECTING), status === states$1.CONNECTED && (0, import_jsx_runtime.jsx)(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: (0, import_jsx_runtime.jsxs)(ModalContent, { children: [(0, import_jsx_runtime.jsxs)(ModalH1, { "$valid": true, children: [(0, import_jsx_runtime.jsx)(TickIcon, {}), " ", locales.injectionScreen_connected_h1] }), (0, import_jsx_runtime.jsx)(ModalBody, { children: locales.injectionScreen_connected_p })] }) }, states$1.CONNECTED), status === states$1.NOTCONNECTED && (0, import_jsx_runtime.jsx)(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: (0, import_jsx_runtime.jsxs)(ModalContent, { children: [(0, import_jsx_runtime.jsx)(ModalH1, { children: locales.injectionScreen_notconnected_h1 }), (0, import_jsx_runtime.jsx)(ModalBody, { children: locales.injectionScreen_notconnected_p })] }) }, states$1.NOTCONNECTED), status === states$1.UNAVAILABLE && (0, import_jsx_runtime.jsx)(Content, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$1, children: !extensionUrl ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)(ModalContent, { style: { paddingBottom: 12 }, children: [(0, import_jsx_runtime.jsx)(ModalH1, { children: locales.injectionScreen_unavailable_h1 }), (0, import_jsx_runtime.jsx)(ModalBody, { children: locales.injectionScreen_unavailable_p })] }), !wallet.isInstalled && suggestedExtension && (0, import_jsx_runtime.jsxs)(Button, { href: suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.url, icon: (0, import_jsx_runtime.jsx)(BrowserIcon, { browser: suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.name }), children: ["Install on ", suggestedExtension === null || suggestedExtension === void 0 ? void 0 : suggestedExtension.label] })] }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsxs)(ModalContent, { style: { paddingBottom: 18 }, children: [(0, import_jsx_runtime.jsx)(ModalH1, { children: locales.injectionScreen_install_h1 }), (0, import_jsx_runtime.jsx)(ModalBody, { children: locales.injectionScreen_install_p })] }), !wallet.isInstalled && extensionUrl && (0, import_jsx_runtime.jsx)(Button, { href: extensionUrl, icon: (0, import_jsx_runtime.jsx)(BrowserIcon, {}), children: locales.installTheExtension })] }) }, states$1.UNAVAILABLE)] }) })] }) });
};
var QRCodeContainer = styled(motion.div)`
  z-index: 3;
  position: relative;
  overflow: hidden;
  height: 0;
  padding-bottom: 100% !important;
  display: flex;
  align-items: center;
  justify-content: center;
  margin: 1px 0 2px;
  border-radius: var(--ck-qr-border-radius, 24px);
  background: var(--ck-qr-background, transparent);
  box-shadow: 0 0 0 1px var(--ck-qr-border-color);
  backface-visibility: hidden;
  svg {
    display: block;
    max-width: 100%;
    width: 100%;
    height: auto;
  }
`;
var QRCodeContent = styled(motion.div)`
  position: absolute;
  inset: 13px;
  svg {
    width: 100% !important;
    height: auto !important;
  }
`;
var PlaceholderKeyframes$2 = We`
  0%{ background-position: 100% 0; }
  100%{ background-position: -100% 0; }
`;
var QRPlaceholder = styled(motion.div)`
  --color: var(--ck-qr-dot-color);
  --bg: var(--ck-qr-background, var(--ck-body-background));

  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  > div {
    z-index: 4;
    position: relative;
    width: 28%;
    height: 28%;
    border-radius: 20px;
    background: var(--bg);
    box-shadow: 0 0 0 7px var(--bg);
  }
  > span {
    z-index: 4;
    position: absolute;
    background: var(--color);
    border-radius: 12px;
    width: 13.25%;
    height: 13.25%;
    box-shadow: 0 0 0 4px var(--bg);
    &:before {
      content: '';
      position: absolute;
      inset: 9px;
      border-radius: 3px;
      box-shadow: 0 0 0 4px var(--bg);
    }
    &:nth-child(1) {
      top: 0;
      left: 0;
    }
    &:nth-child(2) {
      top: 0;
      right: 0;
    }
    &:nth-child(3) {
      bottom: 0;
      left: 0;
    }
  }
  &:before {
    z-index: 3;
    content: '';
    position: absolute;
    inset: 0;
    background: repeat;
    background-size: 1.888% 1.888%;
    background-image: radial-gradient(var(--color) 41%, transparent 41%);
  }
  &:after {
    z-index: 5;
    content: '';
    position: absolute;
    inset: 0;
    transform: scale(1.5) rotate(45deg);
    background-image: linear-gradient(
      90deg,
      rgba(255, 255, 255, 0) 50%,
      rgba(255, 255, 255, 1),
      rgba(255, 255, 255, 0)
    );
    background-size: 200% 100%;
    animation: ${PlaceholderKeyframes$2} 1000ms linear infinite both;
  }
`;
var LogoContainer$2 = styled(motion.div)`
  z-index: 6;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  transform: translateY(50%) scale(0.9999); // Shifting fix
`;
var LogoIcon = styled(motion.div)`
  z-index: 6;
  position: absolute;
  left: 50%;
  overflow: hidden;

  transform: translate(-50%, -50%) scale(0.9999); // Shifting fix

  svg {
    display: block;
    position: relative;
    width: 100%;
    height: 100%;
  }

  ${(props) => props.$wcLogo ? Ae`
          width: 29%;
          height: 20.5%;
        ` : Ae`
          width: 28%;
          height: 28%;
          border-radius: 17px;
          &:before {
            pointer-events: none;
            z-index: 2;
            content: '';
            position: absolute;
            inset: 0;
            border-radius: inherit;
            box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.02);
          }
        `}
`;
var generateMatrix = (value, errorCorrectionLevel) => {
  const arr = Array.prototype.slice.call(import_qrcode.default.create(value, { errorCorrectionLevel }).modules.data, 0);
  const sqrt = Math.sqrt(arr.length);
  return arr.reduce((rows, key, index5) => (index5 % sqrt === 0 ? rows.push([key]) : rows[rows.length - 1].push(key)) && rows, []);
};
function QRCode({ ecl = "M", size: sizeProp = 200, uri, clearArea = false, image, imageBackground = "transparent" }) {
  const logoSize = clearArea ? 76 : 0;
  const size5 = sizeProp - 10 * 2;
  const dots = (0, import_react70.useMemo)(() => {
    const dots2 = [];
    const matrix = generateMatrix(uri, ecl);
    const cellSize = size5 / matrix.length;
    let qrList = [
      { x: 0, y: 0 },
      { x: 1, y: 0 },
      { x: 0, y: 1 }
    ];
    qrList.forEach(({ x: x2, y: y2 }) => {
      const x1 = (matrix.length - 7) * cellSize * x2;
      const y1 = (matrix.length - 7) * cellSize * y2;
      for (let i2 = 0; i2 < 3; i2++) {
        dots2.push((0, import_jsx_runtime.jsx)("rect", { fill: i2 % 2 !== 0 ? "var(--ck-qr-background, var(--ck-body-background))" : "var(--ck-qr-dot-color)", rx: (i2 - 2) * -5 + (i2 === 0 ? 2 : 3), ry: (i2 - 2) * -5 + (i2 === 0 ? 2 : 3), width: cellSize * (7 - i2 * 2), height: cellSize * (7 - i2 * 2), x: x1 + cellSize * i2, y: y1 + cellSize * i2 }, `${i2}-${x2}-${y2}`));
      }
    });
    if (image) {
      const x1 = (matrix.length - 7) * cellSize * 1;
      const y1 = (matrix.length - 7) * cellSize * 1;
      dots2.push((0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("rect", { fill: imageBackground, rx: (0 - 2) * -5 + 2, ry: (0 - 2) * -5 + 2, width: cellSize * (7 - 0 * 2), height: cellSize * (7 - 0 * 2), x: x1 + cellSize * 0, y: y1 + cellSize * 0 }), (0, import_jsx_runtime.jsx)("foreignObject", { width: cellSize * (7 - 0 * 2), height: cellSize * (7 - 0 * 2), x: x1 + cellSize * 0, y: y1 + cellSize * 0, children: (0, import_jsx_runtime.jsx)("div", { style: { borderRadius: (0 - 2) * -5 + 2, overflow: "hidden" }, children: image }) })] }));
    }
    const clearArenaSize = Math.floor((logoSize + 25) / cellSize);
    const matrixMiddleStart = matrix.length / 2 - clearArenaSize / 2;
    const matrixMiddleEnd = matrix.length / 2 + clearArenaSize / 2 - 1;
    matrix.forEach((row, i2) => {
      row.forEach((_2, j3) => {
        if (matrix[i2][j3]) {
          if (!(i2 < 7 && j3 < 7 || i2 > matrix.length - 8 && j3 < 7 || i2 < 7 && j3 > matrix.length - 8)) {
            if (image || !(i2 > matrixMiddleStart && i2 < matrixMiddleEnd && j3 > matrixMiddleStart && j3 < matrixMiddleEnd)) {
              dots2.push((0, import_jsx_runtime.jsx)("circle", { cx: i2 * cellSize + cellSize / 2, cy: j3 * cellSize + cellSize / 2, fill: "var(--ck-qr-dot-color)", r: cellSize / 3 }, `circle-${i2}-${j3}`));
            }
          }
        }
      });
    });
    return dots2;
  }, [ecl, size5, uri]);
  return (0, import_jsx_runtime.jsxs)("svg", { height: size5, width: size5, viewBox: `0 0 ${size5} ${size5}`, style: {
    width: size5,
    height: size5
  }, children: [(0, import_jsx_runtime.jsx)("rect", { fill: "transparent", height: size5, width: size5 }), dots] });
}
function useWindowSize() {
  const [windowSize, setWindowSize] = (0, import_react70.useState)({
    width: 0,
    height: 0
  });
  (0, import_react70.useEffect)(() => {
    function handleResize() {
      setWindowSize({
        width: window.innerWidth,
        height: window.innerHeight
      });
    }
    window.addEventListener("resize", handleResize);
    handleResize();
    return () => window.removeEventListener("resize", handleResize);
  }, []);
  return windowSize;
}
function CustomQRCode({ value, image, imageBackground, imagePosition = "center", tooltipMessage }) {
  const windowSize = useWindowSize();
  const Logo3 = windowSize.width > 920 && tooltipMessage ? (0, import_jsx_runtime.jsx)(Tooltip, { xOffset: 139, yOffset: 5, delay: 0.1, message: tooltipMessage, children: image }) : image;
  return (0, import_jsx_runtime.jsx)(QRCodeContainer, { children: (0, import_jsx_runtime.jsxs)(QRCodeContent, { children: [image && (0, import_jsx_runtime.jsx)(LogoContainer$2, { children: (0, import_jsx_runtime.jsx)(LogoIcon, { "$wcLogo": imagePosition !== "center", style: {
    background: imagePosition === "center" ? imageBackground : void 0
  }, children: Logo3 }) }), (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: value ? (0, import_jsx_runtime.jsx)(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0, position: "absolute", inset: [0, 0] }, transition: {
    duration: 0.2
  }, children: (0, import_jsx_runtime.jsx)(QRCode, { uri: value, size: 288, ecl: "M", clearArea: !!(imagePosition === "center" && image) }) }, value) : (0, import_jsx_runtime.jsxs)(QRPlaceholder, { initial: { opacity: 0.1 }, animate: { opacity: 0.1 }, exit: { opacity: 0, position: "absolute", inset: [0, 0] }, transition: {
    duration: 0.2
  }, children: [(0, import_jsx_runtime.jsx)("span", {}), (0, import_jsx_runtime.jsx)("span", {}), (0, import_jsx_runtime.jsx)("span", {}), (0, import_jsx_runtime.jsx)("div", {})] }) })] }) });
}
CustomQRCode.displayName = "CustomQRCode";
var IconContainer$1 = styled(motion.div)`
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 47px;
  height: 52px;
  min-width: 47px;
  min-height: 52px;
  svg {
    display: block;
    max-width: 100%;
    height: auto;
  }
`;
var ScanIconWithLogos = ({ logo }) => {
  const logoList = [
    (0, import_jsx_runtime.jsx)(Logos.MetaMask, { background: true }),
    (0, import_jsx_runtime.jsx)(Logos.Coinbase, { background: true }),
    (0, import_jsx_runtime.jsx)(Logos.Crypto, {}),
    (0, import_jsx_runtime.jsx)(Logos.ImToken, {}),
    (0, import_jsx_runtime.jsx)(Logos.Argent, {}),
    (0, import_jsx_runtime.jsx)(Logos.Trust, {})
  ];
  return (0, import_jsx_runtime.jsx)(IconContainer$1, { children: (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "47", height: "52", viewBox: "0 0 47 52", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsxs)("g", { mask: "url(#gradient-mask)", children: [(0, import_jsx_runtime.jsx)("path", { d: "M7 14.5C7 11.4624 9.46243 9 12.5 9H31.5C34.5376 9 37 11.4624 37 14.5V47H7V14.5Z", fill: "var(--ck-graphic-scaniconwithlogos-04)" }), logo ? (0, import_jsx_runtime.jsx)("foreignObject", { x: "13", y: "21", width: "18", height: "18", rx: "5", children: (0, import_jsx_runtime.jsx)("div", { style: { overflow: "hidden", borderRadius: 5 }, children: logo }) }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("foreignObject", { x: "12", y: "15", width: "9", height: "9", rx: "2.5", children: (0, import_jsx_runtime.jsx)("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[0] }) }), (0, import_jsx_runtime.jsx)("foreignObject", { x: "23", y: "15", width: "9", height: "9", rx: "2.5", children: (0, import_jsx_runtime.jsx)("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[1] }) }), (0, import_jsx_runtime.jsx)("foreignObject", { x: "12", y: "26", width: "9", height: "9", rx: "2.5", children: (0, import_jsx_runtime.jsx)("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: (0, import_jsx_runtime.jsx)("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[2] }) }) }), (0, import_jsx_runtime.jsx)("foreignObject", { x: "23", y: "26", width: "9", height: "9", rx: "2.5", children: (0, import_jsx_runtime.jsx)("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[3] }) }), (0, import_jsx_runtime.jsx)("foreignObject", { x: "12", y: "37", width: "9", height: "9", rx: "2.5", children: (0, import_jsx_runtime.jsx)("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[4] }) }), (0, import_jsx_runtime.jsx)("foreignObject", { x: "23", y: "37", width: "9", height: "9", rx: "2.5", children: (0, import_jsx_runtime.jsx)("div", { style: { overflow: "hidden", borderRadius: 2.5 }, children: logoList[5] }) })] }), (0, import_jsx_runtime.jsx)("path", { d: "M36 47V13.7143C36 11.1107 33.8893 9 31.2857 9H12.7143C10.1107 9 8 11.1107 8 13.7143V47", stroke: "url(#paint0_linear_924_12568)", strokeWidth: "2" }), (0, import_jsx_runtime.jsx)("path", { d: "M15 10H29C29 11.1046 28.1046 12 27 12H17C15.8954 12 15 11.1046 15 10Z", fill: "var(--ck-graphic-scaniconwithlogos-01)" }), (0, import_jsx_runtime.jsx)("rect", { x: "1", y: "47", width: "43", height: "5", fill: "var(--ck-tooltip-background)" }), (0, import_jsx_runtime.jsx)("rect", { x: "22", y: "1", width: "24", height: "24", rx: "12", fill: "var(--ck-graphic-scaniconwithlogos-03)", stroke: "var(--ck-tooltip-background)", strokeWidth: "2" }), (0, import_jsx_runtime.jsx)("rect", { x: "34.5", y: "10", width: "2.5", height: "2.5", rx: "0.75", fill: "#373737" }), (0, import_jsx_runtime.jsx)("rect", { x: "31", y: "10", width: "2.5", height: "2.5", rx: "0.75", fill: "#373737" }), (0, import_jsx_runtime.jsx)("rect", { x: "31", y: "13.5", width: "2.5", height: "2.5", rx: "0.75", fill: "#373737" }), (0, import_jsx_runtime.jsx)("rect", { x: "34.5", y: "13.5", width: "2.5", height: "2.5", rx: "0.75", fill: "#373737" }), (0, import_jsx_runtime.jsx)("path", { d: "M28.5 10.5V9C28.5 8.17157 29.1716 7.5 30 7.5H31.5", stroke: "#373737", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M36.5 7.5L38 7.5C38.8284 7.5 39.5 8.17157 39.5 9L39.5 10.5", stroke: "#373737", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M39.5 15.5L39.5 17C39.5 17.8284 38.8284 18.5 38 18.5L36.5 18.5", stroke: "#373737", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" }), (0, import_jsx_runtime.jsx)("path", { d: "M31.5 18.5L30 18.5C29.1716 18.5 28.5 17.8284 28.5 17L28.5 15.5", stroke: "#373737", strokeWidth: "1.5", strokeLinecap: "round", strokeLinejoin: "round" })] }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_924_12568", x1: "22", y1: "8.2549", x2: "22", y2: "47", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-graphic-scaniconwithlogos-01)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-graphic-scaniconwithlogos-02)" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "linear-gradient-mask", x1: "47", y1: "42", x2: "47", y2: "47", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "white" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "black", stopOpacity: "0" })] }), (0, import_jsx_runtime.jsx)("mask", { id: "gradient-mask", children: (0, import_jsx_runtime.jsx)("rect", { x: "0", y: "0", width: "47", height: "52", fill: "url(#linear-gradient-mask)" }) })] })] }) });
};
var ConnectWithQRCode = ({ switchConnectMethod }) => {
  var _a2, _b, _c2, _d, _e2, _f, _g, _h;
  const context = useContext21();
  const id3 = context.connector.id;
  const wallet = useWallet(context.connector.id);
  const { open: openW3M, isOpen: isOpenW3M } = useWalletConnectModal();
  const { connect: { getUri } } = useWeb3();
  const wcUri = getUri(id3);
  const uri = wcUri ? (_b = (_a2 = wallet === null || wallet === void 0 ? void 0 : wallet.getWalletConnectDeeplink) === null || _a2 === void 0 ? void 0 : _a2.call(wallet, wcUri)) !== null && _b !== void 0 ? _b : wcUri : void 0;
  const locales = useLocales({
    CONNECTORNAME: wallet === null || wallet === void 0 ? void 0 : wallet.name
  });
  if (!wallet)
    return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: ["Wallet not found ", context.connector.id] });
  const downloads = wallet === null || wallet === void 0 ? void 0 : wallet.downloadUrls;
  const extensions = {
    chrome: downloads === null || downloads === void 0 ? void 0 : downloads.chrome,
    firefox: downloads === null || downloads === void 0 ? void 0 : downloads.firefox,
    brave: downloads === null || downloads === void 0 ? void 0 : downloads.brave,
    edge: downloads === null || downloads === void 0 ? void 0 : downloads.edge,
    safari: downloads === null || downloads === void 0 ? void 0 : downloads.safari
  };
  detectBrowser();
  const hasApps = downloads && Object.keys(downloads).length !== 0;
  extensions ? {
    name: Object.keys(extensions)[0],
    label: ((_c2 = Object.keys(extensions)[0]) === null || _c2 === void 0 ? void 0 : _c2.charAt(0).toUpperCase()) + ((_d = Object.keys(extensions)[0]) === null || _d === void 0 ? void 0 : _d.slice(1)),
    // Capitalise first letter, but this might be better suited as a lookup table
    url: extensions[Object.keys(extensions)[0]]
  } : void 0;
  const showAdditionalOptions = isWalletConnectConnector(id3);
  return (0, import_jsx_runtime.jsxs)(PageContent, { children: [(0, import_jsx_runtime.jsxs)(ModalContent, { style: { paddingBottom: 8, gap: 14 }, children: [(0, import_jsx_runtime.jsx)(CustomQRCode, { value: uri, image: wallet === null || wallet === void 0 ? void 0 : wallet.icon, tooltipMessage: isWalletConnectConnector(id3) ? (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(ScanIconWithLogos, {}), (0, import_jsx_runtime.jsx)("span", { children: locales.scanScreen_tooltip_walletConnect })] }) : (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(ScanIconWithLogos, { logo: wallet === null || wallet === void 0 ? void 0 : wallet.icon }), (0, import_jsx_runtime.jsx)("span", { children: locales.scanScreen_tooltip_default })] }) }), showAdditionalOptions ? (0, import_jsx_runtime.jsx)(OrDivider, {}) : hasApps && (0, import_jsx_runtime.jsx)(OrDivider, { children: locales.dontHaveTheApp })] }), showAdditionalOptions && // for walletConnect
  (0, import_jsx_runtime.jsxs)("div", { style: {
    display: "flex",
    alignItems: "center",
    justifyContent: "center",
    gap: 14
  }, children: [((_e2 = context.options) === null || _e2 === void 0 ? void 0 : _e2.walletConnectCTA) !== "modal" && (0, import_jsx_runtime.jsx)(CopyToClipboard, { variant: "button", string: uri, children: ((_f = context.options) === null || _f === void 0 ? void 0 : _f.walletConnectCTA) === "link" ? locales.copyToClipboard : locales.copyCode }), ((_g = context.options) === null || _g === void 0 ? void 0 : _g.walletConnectCTA) !== "link" && (0, import_jsx_runtime.jsx)(Button, { icon: (0, import_jsx_runtime.jsx)(ExternalLinkIcon, {}), onClick: openW3M, disabled: isOpenW3M, waiting: isOpenW3M, children: ((_h = context.options) === null || _h === void 0 ? void 0 : _h.walletConnectCTA) === "modal" ? locales.useWalletConnectModal : locales.useModal })] }), isFamilyAccountsConnector(wallet.id) && (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)(OrDivider, {}), (0, import_jsx_runtime.jsx)(Button, { onClick: () => switchConnectMethod(id3), children: locales.loginWithEmailOrPhone })] }), hasApps && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(Button, {
    onClick: () => {
      context.setRoute(routes.DOWNLOAD);
    },
    /*
    icon={
      <div style={{ background: connectorInfo?.icon }}>
        {connectorInfo?.logos.default}
      </div>
    }
    roundedIcon
    */
    download: true,
    children: locales.getWalletName
  }) })] });
};
var states = {
  QRCODE: "qrcode",
  INJECTOR: "injector"
};
var ConnectUsing = () => {
  const context = useContext21();
  const wallet = useWallet(context.connector.id);
  const isQrCode = !(wallet === null || wallet === void 0 ? void 0 : wallet.isInstalled) && (wallet === null || wallet === void 0 ? void 0 : wallet.getWalletConnectDeeplink);
  const [status, setStatus] = (0, import_react70.useState)(isQrCode ? states.QRCODE : states.INJECTOR);
  (0, import_react70.useEffect)(() => {
    const checkProvider = async () => {
      const res = await (wallet === null || wallet === void 0 ? void 0 : wallet.connector.getProvider());
      if (!res) {
        setStatus(states.QRCODE);
        setTimeout(context.triggerResize, 10);
      }
    };
    if (status === states.INJECTOR)
      checkProvider();
  }, []);
  if (!wallet)
    return (0, import_jsx_runtime.jsxs)(Alert, { children: ["Connector not found ", context.connector.id] });
  return (0, import_jsx_runtime.jsxs)(AnimatePresence, { children: [status === states.QRCODE && (0, import_jsx_runtime.jsx)(motion.div, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$2, children: (0, import_jsx_runtime.jsx)(ConnectWithQRCode, { switchConnectMethod: (id3) => {
    setStatus(states.INJECTOR);
    setTimeout(context.triggerResize, 10);
  } }) }, states.QRCODE), status === states.INJECTOR && (0, import_jsx_runtime.jsx)(motion.div, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants$2, children: (0, import_jsx_runtime.jsx)(ConnectWithInjector, { switchConnectMethod: (id3) => {
    setStatus(states.QRCODE);
    setTimeout(context.triggerResize, 10);
  } }) }, states.INJECTOR)] });
};
var DownloadApp = () => {
  var _a2, _b, _c2;
  const context = useContext21();
  const wallet = useWallet(context.connector.id);
  const locales = useLocales({
    CONNECTORNAME: wallet === null || wallet === void 0 ? void 0 : wallet.name
  });
  if (!wallet)
    return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: "Wallet not found" });
  const downloads = {
    ios: (_a2 = wallet.downloadUrls) === null || _a2 === void 0 ? void 0 : _a2.ios,
    android: (_b = wallet.downloadUrls) === null || _b === void 0 ? void 0 : _b.android,
    redirect: (_c2 = wallet.downloadUrls) === null || _c2 === void 0 ? void 0 : _c2.download
  };
  const bodycopy = downloads.ios && downloads.android ? locales.downloadAppScreen_iosAndroid : downloads.ios ? locales.downloadAppScreen_ios : locales.downloadAppScreen_android;
  return (0, import_jsx_runtime.jsx)(PageContent, { children: (0, import_jsx_runtime.jsxs)(ModalContent, { style: { paddingBottom: 4, gap: 14 }, children: [downloads.redirect && (0, import_jsx_runtime.jsx)(CustomQRCode, { value: downloads.redirect }), !downloads.redirect && (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: "No download link available" }), (0, import_jsx_runtime.jsx)(ModalBody, { style: { fontSize: 15, lineHeight: "20px", padding: "0 12px" }, children: bodycopy })] }) });
};
var AvatarContainer = styled(motion.div)`
  padding: 18px 0 20px;
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    padding: 16px 0 20px;
  }
`;
var AvatarInner = styled(motion.div)`
  position: relative;
  display: inline-block;
`;
var ChainSelectorContainer = styled(motion.div)`
  z-index: 3;
  position: absolute;
  bottom: 0px;
  right: -16px;
`;
var BalanceContainer = styled(motion.div)`
  position: relative;
`;
var Balance$1 = styled(motion.div)`
  position: relative;
`;
var PlaceholderKeyframes$1 = We`
  0%{ background-position: 100% 0; }
  100%{ background-position: -100% 0; }
`;
var LoadingBalance = styled(motion.div)`
  width: 25%;
  margin: 0 auto;
  position: relative;
  overflow: hidden;
  border-radius: 10px;
  background: var(--ck-body-background-secondary);
  inset: 0;
  &:before {
    z-index: 4;
    content: '';
    position: absolute;
    inset: 0;
    background-image: linear-gradient(
      90deg,
      var(--ck-body-background-transparent) 50%,
      var(--ck-body-background),
      var(--ck-body-background-transparent)
    );
    opacity: 0.75;
    background-size: 200% 100%;
    animation: ${PlaceholderKeyframes$1} 1000ms linear infinite both;
  }
`;
function addressToNumber(address) {
  return address.split("").map((l3) => l3.charCodeAt(0)).reduce((a3, b4) => a3 + b4) % 100 / 100;
}
var EnsAvatar = styled(motion.div)`
  will-change: transform; // Needed for Safari
  pointer-events: none;
  user-select: none;
  position: relative;
  overflow: hidden;
  margin: 0;
  border-radius: ${(props) => `${props.$radius}px`};
  width: ${(props) => `${props.$size}px`};
  height: ${(props) => `${props.$size}px`};
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.08);
  &:before {
    content: '';
    z-index: 1;
    position: absolute;
    inset: 0;
    border-radius: inherit;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.02);
  }
  ${(props) => {
  if (props.$seed) {
    const id3 = Math.ceil(addressToNumber(props.$seed) * 8);
    const ensColor = `0${id3 === 0 ? 1 : id3}`;
    return Ae`
        background: var(--ck-ens-${ensColor}-start);
        background: linear-gradient(
          180deg,
          var(--ck-ens-${ensColor}-start) 0%,
          var(--ck-ens-${ensColor}-stop) 100%
        );
      `;
  }
}}
`;
var ImageContainer = styled(motion.img)`
  display: block;
  position: relative;
  width: 100%;
  height: 100%;
  opacity: ${(props) => props.$loaded ? 1 : 0};
  will-change: opacity; // Needed for Safari
  transition: opacity 500ms ease;
  transform: scale(1.01); // fixes background color bleeding
`;
function useIsMounted2() {
  const [mounted, setMounted] = (0, import_react70.useState)(false);
  (0, import_react70.useEffect)(() => setMounted(true), []);
  return mounted;
}
var ensFallbackConfig = createConfig({
  chains: [mainnet],
  transports: {
    [mainnet.id]: http()
  }
});
function useEnsFallbackConfig() {
  return !useChainIsSupported(1) ? ensFallbackConfig : void 0;
}
var Avatar = ({ address, name, size: size5 = 96, radius = 96 }) => {
  var _a2, _b, _c2;
  const isMounted = useIsMounted2();
  const context = useContext21();
  const imageRef = (0, import_react70.useRef)(null);
  const [loaded, setLoaded] = (0, import_react70.useState)(true);
  const ensFallbackConfig2 = useEnsFallbackConfig();
  const { data: ensAddress } = useEnsAddress({
    chainId: 1,
    name,
    config: ensFallbackConfig2
  });
  const { data: ensName } = useEnsName({
    chainId: 1,
    address: (_a2 = address !== null && address !== void 0 ? address : ensAddress) !== null && _a2 !== void 0 ? _a2 : void 0,
    config: ensFallbackConfig2
  });
  const { data: ensAvatar } = useEnsAvatar({
    chainId: 1,
    name: normalize4(ensName !== null && ensName !== void 0 ? ensName : ""),
    config: ensFallbackConfig2
  });
  const ens = {
    address: ensAddress !== null && ensAddress !== void 0 ? ensAddress : address,
    name: ensName !== null && ensName !== void 0 ? ensName : name,
    avatar: ensAvatar !== null && ensAvatar !== void 0 ? ensAvatar : void 0
  };
  (0, import_react70.useEffect)(() => {
    if (!(imageRef.current && imageRef.current.complete && imageRef.current.naturalHeight !== 0)) {
      setLoaded(false);
    }
  }, [ensAvatar]);
  if (!isMounted)
    return (0, import_jsx_runtime.jsx)("div", { style: { width: size5, height: size5, borderRadius: radius } });
  if ((_b = context.options) === null || _b === void 0 ? void 0 : _b.customAvatar)
    return (0, import_jsx_runtime.jsx)("div", { style: {
      width: size5,
      height: size5,
      borderRadius: radius,
      overflow: "hidden"
    }, children: (_c2 = context.options) === null || _c2 === void 0 ? void 0 : _c2.customAvatar({
      address: address !== null && address !== void 0 ? address : ens === null || ens === void 0 ? void 0 : ens.address,
      ensName: name !== null && name !== void 0 ? name : ens === null || ens === void 0 ? void 0 : ens.name,
      ensImage: ens === null || ens === void 0 ? void 0 : ens.avatar,
      size: size5,
      radius
    }) });
  if (!ens.name || !ens.avatar)
    return (0, import_jsx_runtime.jsx)(ResetContainer, { style: { pointerEvents: "none" }, children: (0, import_jsx_runtime.jsx)(EnsAvatar, { "$size": size5, "$seed": ens.address, "$radius": radius }) });
  return (0, import_jsx_runtime.jsx)(ResetContainer, { style: { pointerEvents: "none" }, children: (0, import_jsx_runtime.jsx)(EnsAvatar, { "$size": size5, "$seed": ens.address, "$radius": radius, children: (0, import_jsx_runtime.jsx)(ImageContainer, { ref: imageRef, src: ens.avatar, alt: ens.name, onLoad: () => setLoaded(true), "$loaded": loaded }) }) });
};
var KnownChain = ({ testnet, ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "black"
}, children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M20.5611 8.12948C21.0082 7.90729 21.5007 7.79167 22 7.79167C22.4993 7.79167 22.9919 7.90729 23.439 8.12948L23.4408 8.1304L33.0387 12.9293C33.577 13.197 34.031 13.61 34.3478 14.121C34.6649 14.6323 34.833 15.2218 34.8333 15.8234V27.2595C34.833 27.8611 34.6649 28.4511 34.3478 28.9624C34.031 29.4733 33.578 29.8858 33.0398 30.1535L23.4411 34.9528C22.9919 35.1775 22.4963 35.2947 21.994 35.2947C21.4918 35.2947 20.9964 35.1777 20.5472 34.9529L10.9475 30.1531L10.9452 30.1519C10.4071 29.8808 9.95535 29.4646 9.6411 28.9504C9.32739 28.437 9.16312 27.8464 9.16673 27.2448L9.16675 27.2417L10.0004 27.2475H9.16673V27.2448V15.8239C9.16705 15.2223 9.33518 14.6322 9.65222 14.121C9.96906 13.61 10.4221 13.1976 10.9604 12.9298L20.5592 8.1304L20.5611 8.12948ZM21.3031 9.62267L11.8706 14.3389L22 19.4036L32.1294 14.3389L22.697 9.62267C22.4806 9.51531 22.2416 9.45905 22 9.45905C21.7585 9.45905 21.5194 9.51534 21.3031 9.62267ZM10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241ZM22.8337 33.3923L32.2967 28.6608C32.5576 28.5312 32.7772 28.3313 32.9308 28.0836C33.0844 27.836 33.1658 27.5504 33.166 27.259V15.8243C33.1659 15.7786 33.1639 15.7331 33.1599 15.6878L22.8337 20.8509V33.3923Z", fill: "url(#paint0_linear_3546_7073)" }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M10.8341 15.8241C10.8341 15.7785 10.8362 15.733 10.8401 15.6878L21.1663 20.8509V33.3983L11.6955 28.6629C11.4352 28.5315 11.2159 28.3297 11.0638 28.0809C10.9116 27.8318 10.8321 27.5452 10.8341 27.2533L10.8341 27.2475V15.8241Z", fill: "url(#paint1_linear_3546_7073)", fillOpacity: "0.3" }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_3546_7073", x1: "22", y1: "7.79167", x2: "22", y2: "35.2947", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "white" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "white", stopOpacity: "0.7" })] }), (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint1_linear_3546_7073", x1: "22", y1: "7.79167", x2: "22", y2: "35.2947", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "white" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "white", stopOpacity: "0.7" })] })] })] });
var UnknownChain = ({ testnet, ...props }) => {
  return (0, import_jsx_runtime.jsx)(KnownChain, { testnet: true, ...props });
};
var Ethereum = ({ testnet, ...props }) => {
  let bg = "var(--ck-chain-ethereum-01, #25292E)";
  let fill = "var(--ck-chain-ethereum-02, #ffffff)";
  if (testnet) {
    bg = "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)";
    fill = "#fff";
  }
  return (0, import_jsx_runtime.jsxs)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    background: bg
  }, children: [(0, import_jsx_runtime.jsx)("path", { d: "M21.9967 6.99621L21.7955 7.67987V27.5163L21.9967 27.7171L31.2044 22.2744L21.9967 6.99621Z", fill }), (0, import_jsx_runtime.jsx)("path", { d: "M21.9957 6.99621L12.7878 22.2744L21.9957 27.7171V18.0891V6.99621Z", fill }), (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M21.9959 36.9996L21.9959 36.9997V36.9995L31.2091 24.0243L21.9959 29.4642L12.788 24.0243L21.9957 36.9993L21.9958 36.9997L21.9959 36.9996Z", fill }), (0, import_jsx_runtime.jsx)("path", { d: "M21.996 27.7181L31.2037 22.2753L21.996 18.09V27.7181Z", fill }), (0, import_jsx_runtime.jsx)("path", { d: "M12.7878 22.2753L21.9957 27.7181V18.09L12.7878 22.2753Z", fill })] });
};
var LensChain = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#2C2D30"
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M30.4076 17.2002C29.1337 17.2002 27.9906 17.6998 27.1194 18.506L27.0299 18.4612C26.8302 15.8187 24.6817 13.7344 21.9891 13.7344C19.2966 13.7344 17.1481 15.8187 16.9484 18.4612L16.8589 18.506C15.9877 17.6998 14.8446 17.2002 13.5706 17.2002C10.7438 17.2002 8.45068 19.4947 8.45068 22.3267C8.45068 24.7727 10.8781 26.8709 11.4807 27.3532C14.3144 29.6098 18.0054 30.9293 21.9891 30.9293C25.9729 30.9293 29.6639 29.6098 32.4976 27.3532C33.1036 26.8709 35.5276 24.7762 35.5276 22.3267C35.5276 19.4947 33.2345 17.2002 30.4042 17.2002H30.4076Z", fill: "white" }) });
var Polygon = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#6F41D8"
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M29.0015 17.4529C28.4941 17.1572 27.8355 17.1572 27.2773 17.4529L23.3186 19.7271L20.6305 21.2094L16.6719 23.4822C16.1645 23.7792 15.5059 23.7792 14.9476 23.4822L11.8016 21.703C11.2943 21.4074 10.9395 20.8642 10.9395 20.2702V16.7612C10.9395 16.1686 11.2434 15.6255 11.8016 15.3285L14.8954 13.5988C15.4041 13.3018 16.0641 13.3018 16.6224 13.5988L19.7161 15.3285C20.2249 15.6255 20.5796 16.1686 20.5796 16.7612V19.0355L23.2678 17.5024V15.2295C23.2707 14.9343 23.1917 14.6441 23.0395 14.3911C22.8873 14.1381 22.6679 13.9324 22.4056 13.7968L16.6719 10.5353C16.1645 10.2382 15.5059 10.2382 14.9476 10.5353L9.11214 13.7968C8.84992 13.9324 8.63049 14.1381 8.47828 14.3911C8.32607 14.6441 8.24705 14.9343 8.25002 15.2295V21.802C8.25002 22.396 8.55389 22.9391 9.11214 23.2361L14.9476 26.4976C15.455 26.7932 16.115 26.7932 16.6719 26.4976L20.6305 24.2729L23.3186 22.7411L27.2773 20.5177C27.7846 20.2207 28.4433 20.2207 29.0015 20.5177L32.0966 22.2475C32.6054 22.5431 32.9588 23.0863 32.9588 23.6803V27.1893C32.9588 27.7819 32.6563 28.325 32.0966 28.622L29.0029 30.4013C28.4941 30.6983 27.8341 30.6983 27.2773 30.4013L24.1821 28.6715C23.6734 28.3745 23.3186 27.8314 23.3186 27.2387V24.9645L20.6305 26.4976V28.7705C20.6305 29.3631 20.9344 29.9076 21.4926 30.2032L27.3281 33.4647C27.8355 33.7617 28.4941 33.7617 29.0524 33.4647L34.8879 30.2032C35.3953 29.9076 35.75 29.3645 35.75 28.7705V22.198C35.753 21.9028 35.674 21.6126 35.5218 21.3596C35.3695 21.1066 35.1501 20.9009 34.8879 20.7653L29.0029 17.4529H29.0015Z", fill: "white" }) });
var Optimism = ({ testnet, ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#FF0420"
}, children: [(0, import_jsx_runtime.jsx)("path", { d: "M15.5877 27.8473C14.2777 27.8473 13.2045 27.539 12.3679 26.9226C11.5422 26.2952 11.1294 25.4035 11.1294 24.2477C11.1294 24.0055 11.157 23.7082 11.212 23.356C11.3552 22.5634 11.5588 21.6112 11.823 20.4994C12.5715 17.4722 14.5034 15.9586 17.6187 15.9586C18.4664 15.9586 19.2259 16.1017 19.8974 16.3879C20.5689 16.663 21.0973 17.0814 21.4826 17.6428C21.8678 18.1932 22.0605 18.8537 22.0605 19.6242C22.0605 19.8554 22.033 20.1471 21.9779 20.4994C21.8128 21.4791 21.6146 22.4313 21.3835 23.356C20.9982 24.8641 20.3322 25.9924 19.3855 26.741C18.4388 27.4785 17.1729 27.8473 15.5877 27.8473ZM15.8189 25.4695C16.4354 25.4695 16.9582 25.2879 17.3876 24.9247C17.8279 24.5614 18.1416 24.0055 18.3287 23.257C18.5819 22.2222 18.7746 21.3195 18.9067 20.5489C18.9507 20.3178 18.9727 20.0811 18.9727 19.8389C18.9727 18.8372 18.4498 18.3363 17.4041 18.3363C16.7876 18.3363 16.2592 18.5179 15.8189 18.8812C15.3896 19.2445 15.0813 19.8004 14.8943 20.5489C14.6961 21.2865 14.4979 22.1892 14.2998 23.257C14.2557 23.477 14.2337 23.7082 14.2337 23.9504C14.2337 24.9632 14.7622 25.4695 15.8189 25.4695Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M22.8188 27.6815C22.6977 27.6815 22.6041 27.6429 22.5381 27.5659C22.483 27.4778 22.4665 27.3788 22.4885 27.2687L24.7672 16.5358C24.7892 16.4147 24.8498 16.3156 24.9489 16.2385C25.0479 16.1615 25.1525 16.1229 25.2626 16.1229H29.6548C30.8767 16.1229 31.8564 16.3761 32.5939 16.8825C33.3426 17.3889 33.7168 18.1209 33.7168 19.0786C33.7168 19.3538 33.6838 19.64 33.6177 19.9372C33.3426 21.2032 32.7867 22.1389 31.95 22.7443C31.1244 23.3498 29.9905 23.6525 28.5485 23.6525H26.3194L25.5598 27.2687C25.5377 27.3898 25.4772 27.4888 25.3782 27.5659C25.2791 27.6429 25.1745 27.6815 25.0645 27.6815H22.8188ZM28.6641 21.3738C29.1264 21.3738 29.5282 21.2472 29.8695 20.994C30.2217 20.7408 30.4529 20.3776 30.563 19.9042C30.596 19.717 30.6125 19.552 30.6125 19.4089C30.6125 19.0896 30.519 18.8474 30.3318 18.6823C30.1446 18.5062 29.8255 18.4182 29.3741 18.4182H27.3926L26.7652 21.3738H28.6641Z", fill: "white" }), (0, import_jsx_runtime.jsx)("rect", { x: "5.5", y: "5.5", width: "33", height: "33", rx: "16.5", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M38.5 22C38.5 12.8924 31.0968 5.52416 22 5.5C12.879 5.5 5.5 12.8924 5.5 22C5.5 31.1076 12.9032 38.4758 22 38.5C31.121 38.5 38.5 31.1076 38.5 22ZM21.9758 30.2379V37.7994C15.3226 37.7994 9.92742 32.4122 9.92742 25.7687C9.92742 19.1252 15.3226 13.7379 21.9758 13.7379V6.17643C28.629 6.17643 34.0242 11.5637 34.0242 18.2072C34.0242 24.8507 28.629 30.2379 21.9758 30.2379Z", fill: "#FF0420" }), (0, import_jsx_runtime.jsx)("path", { d: "M22.0239 16.3223H21.9271C20.6691 18.8347 18.8062 20.6949 16.29 21.9511V22.0477C18.8062 23.304 20.6691 25.1641 21.9271 27.6766H22.0239C23.282 25.1641 25.1449 23.304 27.661 22.0477V21.9511C25.1449 20.6949 23.282 18.8347 22.0239 16.3223Z", fill: "#FF0420" })] });
var Arbitrum = ({ testnet, ...props }) => {
  const fill = testnet ? "#ffffff" : "#28A0F0";
  const outlineFill = testnet ? "#ffffff" : "#96BEDC";
  return (0, import_jsx_runtime.jsxs)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
    background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#2C364F"
  }, children: [!testnet && (0, import_jsx_runtime.jsx)("path", { d: "M25.7948 20.5826L28.2683 16.3854L34.9355 26.7696L34.9386 28.7625L34.9168 15.0491C34.9011 14.7137 34.7231 14.407 34.4391 14.2261L22.4357 7.32182C22.1551 7.1838 21.7989 7.18546 21.5187 7.32618C21.4807 7.34524 21.4453 7.36576 21.4113 7.38835L21.3694 7.41467L9.71816 14.1664L9.67298 14.1871C9.61474 14.2137 9.55609 14.2479 9.50076 14.2872C9.27983 14.4456 9.1331 14.68 9.08564 14.9425C9.07859 14.9823 9.0732 15.023 9.07092 15.064L9.08916 26.239L15.2994 16.6138C16.0811 15.3376 17.7847 14.9262 19.3662 14.9488L21.2221 14.9977L10.2862 32.5356L11.5753 33.2778L22.6422 15.0155L27.5338 14.9977L16.4956 33.7209L21.0955 36.3668L21.6451 36.6827C21.8776 36.7772 22.1516 36.7819 22.386 36.6972L34.5581 29.6433L32.2309 30.9918L25.7948 20.5826ZM26.7384 34.175L22.0925 26.8829L24.9287 22.0702L31.0303 31.6876L26.7384 34.175Z", fill: "#2D374B" }), (0, import_jsx_runtime.jsx)("path", { d: "M22.0924 26.8832L26.7385 34.1751L31.0302 31.6879L24.9286 22.0705L22.0924 26.8832Z", fill }), (0, import_jsx_runtime.jsx)("path", { d: "M34.9387 28.7627L34.9356 26.7698L28.2684 16.3856L25.7949 20.5828L32.2312 30.992L34.5584 29.6435C34.7866 29.4582 34.9248 29.1861 34.9393 28.8926L34.9387 28.7627Z", fill }), (0, import_jsx_runtime.jsx)("path", { d: "M7 30.642L10.2863 32.5356L21.2222 14.9976L19.3663 14.9487C17.785 14.9263 16.0814 15.3375 15.2995 16.6137L9.08927 26.239L7 29.449V30.642V30.642Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M27.534 14.9977L22.6423 15.0155L11.5754 33.2778L15.4437 35.5049L16.4955 33.7209L27.534 14.9977Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M37 14.9723C36.9592 13.9493 36.4052 13.013 35.5377 12.4677L23.377 5.47434C22.5187 5.04223 21.4466 5.04161 20.5868 5.47414C20.4852 5.52533 8.76078 12.3251 8.76078 12.3251C8.5985 12.4029 8.44224 12.4955 8.2953 12.6008C7.52081 13.156 7.0487 14.0186 7 14.9661V29.4492L9.08927 26.2392L9.07103 15.0639C9.07352 15.0231 9.0787 14.9827 9.08575 14.9431C9.133 14.6801 9.27994 14.4457 9.50086 14.2872C9.5562 14.2478 21.4806 7.34517 21.5186 7.32611C21.799 7.18538 22.155 7.18373 22.4356 7.32175L34.439 14.226C34.723 14.4069 34.901 14.7137 34.9167 15.049V28.8921C34.9022 29.1856 34.7862 29.4577 34.558 29.643L32.2308 30.9916L31.03 31.6875L26.7383 34.1747L22.3859 36.6969C22.1515 36.7817 21.8773 36.7769 21.645 36.6824L16.4955 33.7206L15.4435 35.5046L20.0713 38.169C20.2243 38.256 20.3607 38.3331 20.4726 38.3961C20.6458 38.4933 20.764 38.5582 20.8056 38.5785C21.1345 38.7383 21.6077 38.8311 22.0342 38.8311C22.4251 38.8311 22.8064 38.7594 23.1672 38.6181L35.8092 31.2971C36.5347 30.7348 36.9617 29.8869 37 28.9686V14.9723Z", fill: outlineFill })] });
};
var Telos = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#571AFF"
}, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M26.1834 8.14754C25.6606 8.23504 25.3644 8.50235 24.9216 9.28591C24.5651 9.91722 24.4762 10.0244 24.2024 10.1592L23.9832 10.2668L19.2967 10.286L14.6097 10.3057L14.3875 10.3902C13.7059 10.6492 13.6192 10.7135 11.6291 12.4407C9.72243 14.0953 9.64893 14.1723 9.59249 14.5836C9.54437 14.9362 9.78981 15.6327 10.5191 17.2143C11.2847 18.8737 11.2839 18.8641 10.7444 19.5256C10.2645 20.1136 10.2269 20.2588 10.2041 21.5915C10.1717 23.502 10.2487 27.6023 10.3222 27.8591C10.3572 27.9816 10.7908 29.204 11.2861 30.5755C11.7813 31.9471 12.4192 33.715 12.704 34.5038C13.4281 36.5107 13.4814 36.5986 14.0392 36.7237C14.3066 36.7837 14.3206 36.781 18.9677 35.7258C24.4395 34.4837 23.7264 34.709 25.0739 33.7968C29.8732 30.5475 29.7337 30.66 29.8969 29.9083C30.0583 29.1642 30.1082 29.1379 31.8267 28.8999C34.6122 28.5145 34.6328 28.5083 34.8831 28.0109C35.0182 27.7423 35.7786 23.3406 35.8136 22.6209C35.8504 21.8828 36.042 22.221 33.3816 18.3395C30.022 13.4382 30.2381 13.7777 30.2399 13.4041C30.2407 13.1735 30.3366 12.9736 31.3236 11.1418C31.8236 10.2134 32.2742 9.35241 32.3254 9.22904C32.5236 8.74691 32.4204 8.3921 32.0301 8.21622L31.8267 8.12391L29.1102 8.11822C27.6048 8.11516 26.2997 8.12829 26.1834 8.14754ZM30.0474 9.4876C30.5623 9.72297 30.5382 9.82447 29.5119 11.7398C28.4317 13.7558 28.3157 13.2711 30.7154 16.7707C31.639 18.1173 32.8076 19.8218 33.3124 20.5581C34.6844 22.5592 34.6048 22.1799 34.1831 24.6903C33.7858 27.0602 33.7792 27.0817 33.3759 27.282C33.1506 27.394 33.2276 27.3813 30.8493 27.7117C28.9147 27.9803 28.8543 28.017 28.6719 29.0338C28.5778 29.557 28.4606 29.8169 28.2243 30.0247C28.0808 30.1512 24.8682 32.368 23.9451 32.9778C23.2587 33.4311 23.6861 33.3152 17.7471 34.6574C17.1997 34.7812 16.4079 34.9632 15.987 35.0617C14.4588 35.4195 14.4299 35.4033 13.8804 33.8948C12.9188 31.2528 11.6811 27.7957 11.6194 27.5787C11.5534 27.3463 11.549 27.1202 11.549 24.059V20.7878L11.6501 20.5966C11.7056 20.4912 11.8671 20.2759 12.0088 20.118C12.8418 19.19 12.8383 19.1183 11.8601 16.9907C10.7663 14.612 10.6797 14.9992 12.697 13.2501C14.2418 11.91 14.3048 11.8593 14.5905 11.7237L14.8394 11.6055L19.6983 11.5854C23.5417 11.5692 24.5891 11.5543 24.7103 11.515C25.1465 11.3728 25.4086 11.1094 25.7975 10.4203C26.3851 9.38041 26.3111 9.40797 28.4597 9.41891C29.6996 9.42547 29.9332 9.43554 30.0474 9.4876Z", fill: "#F7F5FC" }) });
var Aurora = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#6CD544"
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M22.0006 7.292C22.6198 7.29004 23.2271 7.46144 23.754 7.7868C24.2808 8.11216 24.706 8.57848 24.9816 9.133L34.3566 27.883C34.611 28.3912 34.7312 28.956 34.7058 29.5238C34.6805 30.0915 34.5103 30.6433 34.2116 31.1268C33.9129 31.6103 33.4956 32.0094 32.9992 32.2861C32.5028 32.5629 31.9439 32.7081 31.3756 32.708H12.6256C12.0573 32.7079 11.4985 32.5626 11.0023 32.2858C10.506 32.009 10.0888 31.6099 9.79022 31.1264C9.49163 30.6429 9.3216 30.0912 9.29628 29.5235C9.27096 28.9558 9.39119 28.3911 9.64556 27.883L19.0196 9.133C19.2951 8.57848 19.7203 8.11216 20.2472 7.7868C20.774 7.46144 21.3814 7.29004 22.0006 7.292ZM22.0006 5C20.9561 4.9999 19.9322 5.29059 19.0437 5.83952C18.1551 6.38846 17.4369 7.17394 16.9696 8.108L7.59456 26.858C7.16544 27.7156 6.96271 28.6687 7.00564 29.6268C7.04856 30.5848 7.33572 31.516 7.83982 32.3318C8.34392 33.1476 9.04823 33.821 9.88584 34.288C10.7235 34.755 11.6666 35.0001 12.6256 35H31.3756C32.3345 34.9999 33.2775 34.7547 34.1149 34.2876C34.9524 33.8206 35.6566 33.1472 36.1606 32.3314C36.6645 31.5156 36.9516 30.5845 36.9945 29.6265C37.0374 28.6686 36.8346 27.7156 36.4056 26.858L27.0316 8.108C26.5642 7.17394 25.846 6.38846 24.9574 5.83952C24.0689 5.29059 23.045 4.9999 22.0006 5Z", fill: "white" }) });
var Avalanche = ({ testnet, ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#E84142"
}, children: [(0, import_jsx_runtime.jsx)("path", { d: "M11.0188 32.1528H15.4825C16.5334 32.1528 17.0589 32.1528 17.5278 32.023C18.042 31.8701 18.511 31.5991 18.9009 31.2261C19.2589 30.885 19.5173 30.4328 20.0269 29.5409L20.0272 29.5404L20.0422 29.5142L25.8314 19.2804C26.3456 18.3821 26.5999 17.93 26.7129 17.4554C26.8372 16.9412 26.8372 16.3988 26.7129 15.8847C26.6007 15.4136 26.3439 14.9648 25.8373 14.0798L25.8258 14.0597L23.56 10.1045C23.0911 9.27958 22.8538 8.86711 22.5543 8.71456C22.2323 8.55071 21.848 8.55071 21.526 8.71456C21.2265 8.86711 20.9892 9.27958 20.5202 10.1045L9.49892 29.5311C9.03561 30.3447 8.80392 30.7517 8.82089 31.0849C8.84349 31.4466 9.02994 31.7743 9.33507 31.9721C9.61756 32.1528 10.0809 32.1528 11.0188 32.1528Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M33.1506 32.1528H26.7547C25.8111 32.1528 25.3365 32.1528 25.0596 31.9721C24.7545 31.7743 24.5681 31.4411 24.5455 31.0794C24.5286 30.7486 24.7621 30.3456 25.2294 29.539L25.2295 29.5388L25.2404 29.5199L28.4328 24.0392C28.9018 23.2313 29.1391 22.8301 29.4329 22.6776C29.7548 22.5137 30.1336 22.5137 30.4555 22.6776C30.7472 22.8261 30.9744 23.2102 31.4241 23.9708L31.4248 23.9719L31.4613 24.0336L34.665 29.5143C34.6806 29.5413 34.696 29.5678 34.7113 29.5939L34.7113 29.594C35.1554 30.3603 35.382 30.7514 35.3657 31.0739C35.3486 31.4353 35.1566 31.7688 34.8515 31.9666C34.5689 32.1528 34.0942 32.1528 33.1506 32.1528Z", fill: "white" })] });
var Celo = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#FCFE72"
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M9 9H34.5183V18.112H30.3564C28.896 14.7687 25.6102 12.4171 21.777 12.4171C16.593 12.4171 12.3948 16.6422 12.3948 21.823C12.3948 27.0039 16.593 31.2654 21.777 31.2654C25.5373 31.2654 28.8231 28.9876 30.2829 25.7172H34.5178V34.682H9V9Z", fill: testnet ? "#ffffff" : "black" }) });
var Gnosis = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#009CB4"
}, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M12.3439 11.8664C17.9374 6.53462 26.7953 6.74397 32.1271 12.3374C32.4738 12.7038 32.8075 13.0832 33.1084 13.4823L22 24.5972L10.8916 13.4823C11.1991 13.0832 11.5262 12.7038 11.8729 12.3374C12.0234 12.1804 12.1804 12.0234 12.3439 11.8664ZM30.6094 13.3972C28.3196 11.0944 25.271 9.83182 22 9.83182C18.729 9.83182 15.6804 11.0944 13.3907 13.3972L22 22.0066L30.6094 13.3972ZM33.9785 14.7446L31.7215 17.0016C33.5402 19.1801 33.2523 22.425 31.0738 24.2437C29.1636 25.84 26.3897 25.84 24.4794 24.2437L22 26.7231L19.5271 24.2502C17.3486 26.0689 14.1037 25.7811 12.285 23.6026C10.6888 21.6923 10.6888 18.9185 12.285 17.0082L11.1271 15.8502L10.028 14.7446C8.7 16.9297 8 19.4418 8 21.9998C8 29.7325 14.2673 35.9998 22 35.9998C29.7327 35.9998 36 29.7325 36 21.9998C36.0065 19.4418 35.3 16.9297 33.9785 14.7446ZM30.6486 18.0747C31.1392 18.7093 31.4075 19.4943 31.4075 20.299C31.4075 21.1037 31.1392 21.8887 30.6486 22.5233C29.4187 24.113 27.1355 24.4074 25.5458 23.1775L30.6486 18.0747ZM18.4542 23.1839C17.8196 23.6745 17.0346 23.9427 16.2299 23.9427C15.4252 23.9427 14.6467 23.6745 14.0056 23.1904C12.4159 21.9605 12.1215 19.6708 13.3514 18.0811L18.4542 23.1839Z", fill: "white" }) });
var Evmos = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#2D2A25"
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M18.4916 12.6668C12.9416 14.806 12.4332 20.2846 10.8418 22.8432C9.23155 25.4322 5.54251 26.8607 6.04698 28.1801C6.55143 29.4994 10.2449 28.0824 13.1669 28.9242C16.0543 29.7561 20.0831 33.4862 25.633 31.3469C28.4603 30.2573 30.5076 28.0143 31.449 25.3574C31.5502 25.0723 31.361 24.7673 31.0606 24.7391C30.874 24.7215 30.6948 24.8196 30.6106 24.9877C29.759 26.6908 28.2981 28.0934 26.3864 28.8301C23.2303 30.0465 19.777 29.0915 17.6562 26.6961C17.1746 26.1522 16.7626 25.533 16.4374 24.8487C16.348 24.6603 16.2629 24.4689 16.1875 24.2708C16.1117 24.0728 16.0473 23.8735 15.9881 23.6732C17.6562 22.8925 19.5812 22.0656 21.7635 21.2246C23.903 20.3999 25.8505 19.731 27.5841 19.1958C28.7571 18.8341 29.8322 18.5331 30.8029 18.2871C30.8732 18.2695 30.9423 18.2519 31.0112 18.2347C31.158 18.1982 31.3088 18.2769 31.363 18.4186L31.364 18.4213C31.396 18.5053 31.4236 18.5898 31.4535 18.6743C31.6453 19.2196 31.7892 19.7706 31.8841 20.3229C31.9258 20.5645 32.1888 20.6961 32.4044 20.5799C33.2014 20.1504 33.9302 19.7314 34.5814 19.3283C37.0083 17.8276 38.3538 16.5549 38.0776 15.8336C37.802 15.1119 35.9541 15.0705 33.1503 15.5854C32.2593 15.7491 31.2716 15.9691 30.207 16.2416C30.0229 16.2886 29.8365 16.3375 29.6481 16.3877C28.7522 16.6262 27.8073 16.8995 26.8234 17.2053C24.9936 17.7744 23.0305 18.4561 21.0038 19.2372C19.1078 19.9682 17.3109 20.726 15.6629 21.4812C15.6428 18.2761 17.5725 15.2461 20.7286 14.0297C22.6399 13.293 24.6605 13.3533 26.4285 14.0473C26.6029 14.116 26.8015 14.0684 26.9291 13.9298C27.1331 13.7076 27.0706 13.3537 26.8053 13.2094C24.3353 11.8685 21.319 11.5771 18.4916 12.6668Z", fill: "#FAF1E4" }) });
var BinanceSmartChain = ({ testnet, ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#16181A"
}, children: [(0, import_jsx_runtime.jsx)("path", { d: "M16.0445 19.6063L21.8705 13.7805L27.6996 19.6093L31.0896 16.2193L21.8705 7L12.6545 16.2163L16.0445 19.6063Z", fill: testnet ? "#fff" : "#F3BA2F" }), (0, import_jsx_runtime.jsx)("path", { d: "M13.6505 21.9995L10.2606 18.6096L6.87046 21.9997L10.2604 25.3896L13.6505 21.9995Z", fill: testnet ? "#fff" : "#F3BA2F" }), (0, import_jsx_runtime.jsx)("path", { d: "M16.0445 24.3937L21.8705 30.2195L27.6994 24.3909L31.0913 27.779L31.0896 27.7809L21.8705 37L12.6542 27.7839L12.6495 27.7792L16.0445 24.3937Z", fill: testnet ? "#fff" : "#F3BA2F" }), (0, import_jsx_runtime.jsx)("path", { d: "M33.4808 25.3911L36.8709 22.001L33.481 18.6111L30.0909 22.0012L33.4808 25.3911Z", fill: testnet ? "#fff" : "#F3BA2F" }), (0, import_jsx_runtime.jsx)("path", { d: "M25.3091 21.9982H25.3105L21.8705 18.5582L19.3283 21.1004H19.3281L19.0362 21.3926L18.4336 21.9951L18.4289 21.9999L18.4336 22.0048L21.8705 25.4418L25.3105 22.0018L25.3122 21.9999L25.3091 21.9982Z", fill: testnet ? "#fff" : "#F3BA2F" })] });
var Canto = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "white"
}, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M35 8V36H9L13.875 35.9998V31.0586H9V12.9412H13.875V8H35ZM17.9373 12.9414H30.1247V17.8826H17.9373V12.9414ZM30.1247 26.9414H17.9373V17.8826L13.0623 17.8828V26.9416L17.9373 26.9414V31.8826H30.1247V26.9414Z", fill: "#06FC99" }) });
var Fantom = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#0911EF"
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M20.92 9.25864C21.5933 8.91379 22.6178 8.91379 23.2911 9.25864L30.1616 12.7775C30.5671 12.9852 30.7898 13.2947 30.8297 13.6142H30.8363V31.302C30.8274 31.6504 30.6025 31.9966 30.1616 32.2225L23.2911 35.7413C22.6178 36.0862 21.5933 36.0862 20.92 35.7413L14.0495 32.2225C13.6104 31.9976 13.3997 31.6489 13.3893 31.302C13.3883 31.2678 13.3881 31.2393 13.3891 31.2157L13.3891 13.7278C13.3884 13.7086 13.3883 13.6895 13.3889 13.6705L13.3893 13.6142L13.3924 13.6142C13.4229 13.2912 13.6355 12.9896 14.0495 12.7775L20.92 9.25864ZM29.7547 23.4821L23.2911 26.7926C22.6178 27.1374 21.5933 27.1374 20.92 26.7926L14.4706 23.4895V31.2669L20.92 34.5527C21.2842 34.7415 21.6622 34.9254 22.0318 34.9488L22.1056 34.9512C22.4907 34.9524 22.8646 34.7628 23.2438 34.5833L29.7547 31.2387V23.4821ZM11.3214 31.8437C11.3214 32.5212 11.4026 32.9667 11.5639 33.2806C11.6976 33.5407 11.8981 33.7394 12.2643 33.9813L12.2852 33.9951C12.3656 34.0476 12.4541 34.1026 12.5619 34.1672L12.689 34.2427L13.0792 34.4711L12.5195 35.3685L12.0827 35.1126L12.0093 35.0689C11.883 34.9932 11.7783 34.9284 11.6807 34.8645C10.637 34.1822 10.2478 33.4384 10.2401 31.8907L10.24 31.8437H11.3214ZM21.5647 18.7412C21.5147 18.7579 21.4678 18.7772 21.4251 18.7991L14.5546 22.318C14.5474 22.3216 14.5405 22.3253 14.534 22.3289L14.5281 22.3322L14.5389 22.3382L14.5546 22.3464L21.4251 25.8653C21.4678 25.8872 21.5147 25.9065 21.5647 25.9231V18.7412ZM22.6465 18.7412V25.9231C22.6965 25.9065 22.7433 25.8872 22.7861 25.8653L29.6566 22.3464C29.6638 22.3427 29.6707 22.3391 29.6772 22.3355L29.683 22.3322L29.6722 22.3262L29.6566 22.318L22.7861 18.7991C22.7433 18.7772 22.6965 18.7579 22.6465 18.7412ZM29.7547 14.8689L23.5915 18.0256L29.7547 21.1822V14.8689ZM14.4706 14.8763V21.1749L20.6195 18.0256L14.4706 14.8763ZM22.7861 10.1859C22.4288 10.0029 21.7824 10.0029 21.4251 10.1859L14.5546 13.7048C14.5474 13.7085 14.5405 13.7122 14.534 13.7158L14.5281 13.719L14.5389 13.725L14.5546 13.7333L21.4251 17.2522C21.7824 17.4352 22.4288 17.4352 22.7861 17.2522L29.6566 13.7333C29.6638 13.7296 29.6707 13.7259 29.6772 13.7223L29.683 13.719L29.6722 13.7131L29.6566 13.7048L22.7861 10.1859ZM31.7205 9.64552L32.1573 9.90132L32.2307 9.94503C32.357 10.0206 32.4616 10.0856 32.5593 10.1494C33.603 10.8317 33.9922 11.5756 33.9998 13.1231L34 13.1703H32.9186C32.9186 12.4926 32.8373 12.0472 32.6761 11.7334C32.5424 11.4733 32.3419 11.2745 31.9757 11.0327L31.9547 11.0189C31.8744 10.9664 31.7858 10.9113 31.6781 10.8466L31.551 10.7712L31.1608 10.5428L31.7205 9.64552Z", fill: "white" }) });
var Filecoin = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#0090FF"
}, children: (0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M23.75 19.3069L23.15 22.5069L28.85 23.3069L28.45 24.8069L22.85 24.0069C22.45 25.3069 22.25 26.7069 21.75 27.9069C21.25 29.3069 20.75 30.7069 20.15 32.0069C19.35 33.7069 17.95 34.9069 16.05 35.2069C14.95 35.4069 13.75 35.3069 12.85 34.6069C12.55 34.4069 12.25 34.0069 12.25 33.7069C12.25 33.3069 12.45 32.8069 12.75 32.6069C12.95 32.5069 13.45 32.6069 13.75 32.7069C14.05 33.0069 14.35 33.4069 14.55 33.8069C15.15 34.6069 15.95 34.7069 16.75 34.1069C17.65 33.3069 18.15 32.2069 18.45 31.1069C19.05 28.7069 19.65 26.4069 20.15 24.0069V23.6069L14.85 22.8069L15.05 21.3069L20.55 22.1069L21.25 19.0069L15.55 18.1069L15.75 16.5069L21.65 17.3069C21.85 16.7069 21.95 16.2069 22.15 15.7069C22.65 13.9069 23.15 12.1069 24.35 10.5069C25.55 8.90687 26.95 7.90687 29.05 8.00687C29.95 8.00687 30.85 8.30687 31.45 9.00687C31.55 9.10687 31.75 9.30687 31.75 9.50687C31.75 9.90687 31.75 10.4069 31.45 10.7069C31.05 11.0069 30.55 10.9069 30.15 10.5069C29.85 10.2069 29.65 9.90687 29.35 9.60687C28.75 8.80687 27.85 8.70687 27.15 9.40687C26.65 9.90687 26.15 10.6069 25.85 11.3069C25.15 13.4069 24.65 15.6069 23.95 17.8069L29.45 18.6069L29.05 20.1069L23.75 19.3069Z", fill: "white" }) });
var IoTeX = ({ testnet, ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#00D4D5"
}, children: [(0, import_jsx_runtime.jsx)("path", { d: "M23.7136 6.875V14.3784L30.2284 10.6315L23.7136 6.875Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.9", d: "M30.2284 10.6316V18.135L36.7418 14.3785L30.2284 10.6316Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.8", d: "M23.7136 14.3784V21.8818L30.2284 18.1349L23.7136 14.3784ZM30.2284 18.1349V25.6383L36.7417 21.8818L30.2284 18.1349Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.8", d: "M23.7136 21.8817V29.385L30.2284 25.6382L23.7136 21.8817Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M30.2284 25.6382V33.1416L36.7418 29.3851L30.2284 25.6382Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.4", d: "M6.87537 14.1253V21.6287L13.3901 17.8722L6.87537 14.1253Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.2", d: "M15.0938 16.9153V24.4186L21.5975 20.6718L15.0938 16.9153Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.3", d: "M10.2648 21.6604V29.1638L16.7781 25.4073L10.2648 21.6604Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.9", d: "M14.5575 27.3226V34.826L21.0612 31.0695L14.5575 27.3226Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.7", d: "M23.66 30.5525V38.0572L30.1637 34.2993L23.66 30.5525Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.9", d: "M16.1786 13.2097V20.7145L22.6824 16.9676L16.1786 13.2097Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.8", d: "M23.7136 6.875V14.3784L17.1989 10.6315L23.7136 6.875Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.6", d: "M16.1786 10.0649V17.5669L9.66248 13.8104L16.1786 10.0649Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.6", d: "M22.6934 13.7775V21.2823L16.1786 17.5244L22.6934 13.7775Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.95", d: "M15.0635 16.9153V24.4186L8.54877 20.6718L15.0635 16.9153Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.6", d: "M23.7136 21.8817V29.385L17.2099 25.6382L23.7136 21.8817Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.55", d: "M10.2648 23.6295V31.1328L3.75 27.375L10.2648 23.6295Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M36.7418 14.3784V21.8818L30.2284 18.1349L36.7418 14.3784Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.95", d: "M30.2284 18.1362V25.6382L23.7136 21.8817L30.2284 18.1362Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.9", d: "M36.7418 21.8817V29.385L30.2284 25.6382L36.7418 21.8817Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.7", d: "M30.2284 25.6382V33.1416L23.7136 29.3851L30.2284 25.6382Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { opacity: "0.4", d: "M22.2712 28.7651V36.2684L15.7579 32.5216L22.2712 28.7651Z", fill: "white" }), (0, import_jsx_runtime.jsx)("path", { d: "M30.2284 10.6316V18.135L23.7136 14.3785L30.2284 10.6316Z", fill: "white" })] });
var Metis = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, "aria-hidden": "true", width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#2F3140"
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M37.5175 22.0531C37.4579 19.2923 36.6563 16.5985 35.1968 14.2542C33.7374 11.91 31.674 10.0017 29.223 8.72965C26.772 7.45759 24.0238 6.86863 21.2668 7.02455C18.5098 7.18047 15.8456 8.07553 13.5537 9.61582C11.2617 11.1561 9.42659 13.2849 8.24079 15.7787C7.05498 18.2725 6.56222 21.0396 6.81419 23.7895C7.06617 26.5394 8.05359 29.1708 9.67288 31.4076C11.2922 33.6444 13.4836 35.4042 16.0173 36.5023C16.7657 35.3775 17.3385 34.1453 17.716 32.848C18.0245 32.0632 18.3595 31.2913 18.7067 30.5446C19.5444 30.7955 20.4345 30.8143 21.282 30.5989C22.1295 30.3835 22.9026 29.942 23.5188 29.3215L23.5704 29.2699C22.8136 28.9884 21.9979 28.9032 21.1993 29.022C20.4006 29.1408 19.6451 29.4598 19.0029 29.9494C19.4276 29.0613 19.891 28.1997 20.3667 27.3632C21.189 27.6541 22.075 27.7156 22.9296 27.541C23.7842 27.3665 24.5751 26.9626 25.2175 26.3726L25.2692 26.3209C24.538 26.0116 23.7416 25.8885 22.9513 25.9626C22.1609 26.0368 21.4013 26.3058 20.7404 26.7456C21.216 25.9608 21.7053 25.1889 22.2203 24.468C23.0713 24.6915 23.9672 24.6777 24.811 24.4282C25.6547 24.1787 26.414 23.703 27.0066 23.0526L27.0453 23.001C26.3425 22.7718 25.5958 22.7106 24.8651 22.8224C24.1344 22.9341 23.4401 23.2157 22.838 23.6444C22.8767 23.5928 22.9283 23.5289 22.9664 23.4773C23.2749 23.0784 23.5969 22.6796 23.9177 22.2936C24.8969 21.9731 25.7703 21.3916 26.4436 20.6117C27.117 19.8318 27.5649 18.883 27.7391 17.8674L27.752 17.79H27.7391C26.7194 18.0552 25.7944 18.6007 25.0689 19.3648C24.3434 20.1288 23.8464 21.0808 23.6343 22.1129C23.3258 22.4859 23.0167 22.8603 22.7211 23.2449C22.9706 22.5925 23.0724 21.893 23.0191 21.1966C22.9657 20.5002 22.7586 19.8243 22.4126 19.2176L22.3739 19.2692C21.8489 19.9862 21.5326 20.8345 21.4599 21.7201C21.3873 22.6058 21.5611 23.4942 21.9621 24.2872C21.4729 24.9823 20.9972 25.6897 20.5467 26.4357C20.6918 25.6858 20.6542 24.9118 20.4369 24.1795C20.2196 23.4471 19.8291 22.7779 19.2985 22.2284L19.2727 22.2929C18.9445 23.1107 18.8477 24.0031 18.9929 24.8723C19.1382 25.7415 19.5199 26.5539 20.0962 27.2205C19.6457 28.0054 19.2211 28.816 18.8093 29.6524C18.9344 28.8712 18.8712 28.0715 18.6251 27.3196C18.3789 26.5677 17.9568 25.8855 17.3939 25.3295L17.3681 25.3941C17.0745 26.2514 17.0201 27.1724 17.2105 28.0583C17.401 28.9442 17.8292 29.7614 18.4492 30.4223C18.1774 31.0012 17.9219 31.5774 17.6773 32.1849C17.61 32.1231 17.5313 32.0751 17.4456 32.0435C17.0066 31.916 16.5867 31.7299 16.1974 31.4904C15.8754 31.2994 15.5337 31.144 15.1781 31.027C13.7886 30.5765 13.9945 29.9079 13.2756 28.5564C13.0416 28.2781 12.7931 28.0125 12.5309 27.7607C12.2876 27.603 12.0884 27.386 11.9519 27.1302C11.7934 26.8107 11.6931 26.4656 11.6557 26.1109C11.6514 25.9148 11.5858 25.7249 11.4681 25.5679C11.3504 25.4109 11.1864 25.2948 10.9993 25.2358C8.95338 24.5284 9.86728 21.8778 9.94406 21.5299C9.91262 21.08 9.81271 20.6375 9.64781 20.2178C9.63057 20.1632 9.61763 20.1073 9.60908 20.0506C9.55449 19.776 9.56444 19.4924 9.63813 19.2223C9.71183 18.9521 9.84726 18.7028 10.0338 18.4939C10.2784 18.2493 11.1277 17.8505 11.3078 17.6188C11.4879 17.387 11.6163 17.1295 11.797 16.9114C12.3687 16.3412 13.0291 15.8675 13.7526 15.509C14.3444 15.1876 14.4477 14.364 14.6787 14.1065C15.0647 13.6689 15.6565 13.6689 16.0941 13.283C16.3129 13.09 16.6377 12.9867 16.8415 12.7815C17.8692 11.8403 19.1644 11.2423 20.5474 11.0706C21.5064 10.9924 22.4717 11.0795 23.4012 11.3281C23.5358 11.3507 23.669 11.3809 23.8001 11.4185C25.9228 11.4959 28.4709 11.9328 29.397 12.8338C29.8555 13.2744 30.1961 13.8229 30.3877 14.4293C30.5382 14.8988 30.7456 15.3481 31.0054 15.7672L31.5714 16.6933C31.932 17.2773 32.0475 17.9801 31.8928 18.6489C31.7885 18.974 31.7795 19.3223 31.8669 19.6525C32.1655 20.1031 32.5152 20.5177 32.9093 20.8878C33.0658 21.0427 33.2382 21.1807 33.4236 21.2995C33.8592 21.5594 34.2802 21.8429 34.6848 22.1489C34.698 22.2729 34.6775 22.3982 34.6254 22.5115C34.5732 22.6247 34.4914 22.7218 34.3885 22.7924C34.0284 23.1137 33.3333 23.6159 33.3333 23.6159C33.3584 23.758 33.4016 23.8964 33.4617 24.0276C33.5643 24.2077 33.796 24.4911 33.7192 24.735C33.6424 24.9789 33.1403 25.1855 33.2816 25.4552C33.423 25.7386 33.7831 25.8154 33.6805 26.0729C33.5779 26.3175 33.0757 26.7524 33.1274 26.9352C33.179 27.1179 33.5908 28.8377 32.6382 29.1353C31.4592 29.3685 30.2627 29.5019 29.0614 29.5342C28.8675 29.5454 28.6797 29.6055 28.5155 29.709C28.3513 29.8125 28.216 29.956 28.1223 30.126C27.9399 30.4661 27.8222 30.837 27.7751 31.22C27.4275 32.5896 26.9671 33.928 26.3985 35.2215C26.3985 35.2215 26.3597 35.2989 26.3081 35.4144C26.1833 35.6687 26.1048 35.9432 26.0764 36.2251C26.1573 36.4321 26.2799 36.6204 26.4365 36.7782C26.519 36.8726 26.6271 36.9411 26.7477 36.9753C26.8683 37.0096 26.9962 37.0081 27.116 36.9711C30.1997 35.8965 32.8655 33.8757 34.7332 31.197C36.601 28.5182 37.5754 25.3182 37.5175 22.0531Z", fill: testnet ? "#ffffff" : "#00DACC" }) });
var Base = ({ testnet, ...props }) => (0, import_jsx_runtime.jsx)("svg", { ...props, width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  background: testnet ? "linear-gradient(180deg, #8995A9 0%, #424D5F 99.48%)" : "#0052FF"
}, children: (0, import_jsx_runtime.jsx)("path", { d: "M21.9756 36C29.721 36 36 29.732 36 22C36 14.268 29.721 8 21.9756 8C14.6271 8 8.59871 13.6419 8 20.8232H26.5371V23.1768H8C8.59871 30.3581 14.6271 36 21.9756 36Z", fill: "white" }) });
var Zora = ({ testnet, ...props }) => (0, import_jsx_runtime.jsxs)("svg", { ...props, width: "44", height: "44", viewBox: "0 0 44 44", fill: "none", xmlns: "http://www.w3.org/2000/svg", style: {
  filter: testnet ? "grayscale(1)" : "none"
}, children: [(0, import_jsx_runtime.jsx)("mask", { id: "ck_zora_mask_a", style: {
  maskType: "alpha"
}, maskUnits: "userSpaceOnUse", x: "0", y: "0", width: "44", height: "44", children: (0, import_jsx_runtime.jsx)("path", { d: "M22 44C34.1503 44 44 34.1503 44 22C44 9.84974 34.1503 0 22 0C9.84974 0 0 9.84974 0 22C0 34.1503 9.84974 44 22 44Z", fill: "#D9D9D9" }) }), (0, import_jsx_runtime.jsxs)("g", { mask: "url(#ck_zora_mask_a)", children: [(0, import_jsx_runtime.jsx)("path", { d: "M51.4558 -9.56445H-6.78906V48.6804H51.4558V-9.56445Z", fill: "#A1723A" }), (0, import_jsx_runtime.jsx)("g", { filter: "url(#ck_zora_filter_a)", children: (0, import_jsx_runtime.jsx)("path", { d: "M23.6807 43.0752C36.6464 43.0752 47.157 32.5675 47.157 19.6058C47.157 6.64397 36.6464 -3.86365 23.6807 -3.86365C10.7152 -3.86365 0.20459 6.64397 0.20459 19.6058C0.20459 32.5675 10.7152 43.0752 23.6807 43.0752Z", fill: "#531002" }) }), (0, import_jsx_runtime.jsx)("g", { filter: "url(#ck_zora_filter_b)", children: (0, import_jsx_runtime.jsx)("path", { d: "M26.2112 35.6464C36.7271 35.6464 45.2521 27.1185 45.2521 16.5988C45.2521 6.07904 36.7271 -2.44885 26.2112 -2.44885C15.6953 -2.44885 7.17041 6.07904 7.17041 16.5988C7.17041 27.1185 15.6953 35.6464 26.2112 35.6464Z", fill: "#2B5DF0" }) }), (0, import_jsx_runtime.jsx)("g", { filter: "url(#ck_zora_filter_c)", children: (0, import_jsx_runtime.jsx)("path", { d: "M25.8644 36.7348C36.8276 36.7348 45.7149 27.8444 45.7149 16.8777C45.7149 5.91084 36.8276 -2.97949 25.8644 -2.97949C14.9015 -2.97949 6.01416 5.91084 6.01416 16.8777C6.01416 27.8444 14.9015 36.7348 25.8644 36.7348Z", fill: "url(#paint0_radial_3914_1946)" }) }), (0, import_jsx_runtime.jsx)("g", { filter: "url(#ck_zora_filter_d)", children: (0, import_jsx_runtime.jsx)("path", { d: "M29.1567 21.8779C34.6797 21.8779 39.1567 17.4008 39.1567 11.8779C39.1567 6.35509 34.6797 1.87793 29.1567 1.87793C23.6338 1.87793 19.1567 6.35509 19.1567 11.8779C19.1567 17.4008 23.6338 21.8779 29.1567 21.8779Z", fill: "#FCB8D4" }) }), (0, import_jsx_runtime.jsx)("g", { filter: "url(#ck_zora_filter_e)", children: (0, import_jsx_runtime.jsx)("path", { d: "M29.15 15.8642C31.3555 15.8642 33.1432 14.0765 33.1432 11.871C33.1432 9.66562 31.3555 7.87781 29.15 7.87781C26.9445 7.87781 25.1567 9.66562 25.1567 11.871C25.1567 14.0765 26.9445 15.8642 29.15 15.8642Z", fill: "white" }) }), (0, import_jsx_runtime.jsx)("g", { filter: "url(#ck_zora_filter_f)", children: (0, import_jsx_runtime.jsx)("path", { d: "M26.4967 51.7416C46.3151 51.7416 62.3811 35.6757 62.3811 15.8573C62.3811 -3.96109 46.3151 -20.0271 26.4967 -20.0271C6.67829 -20.0271 -9.3877 -3.96109 -9.3877 15.8573C-9.3877 35.6757 6.67829 51.7416 26.4967 51.7416Z", fill: "url(#paint1_radial_3914_1946)", fillOpacity: "0.9" }) })] }), (0, import_jsx_runtime.jsxs)("defs", { children: [(0, import_jsx_runtime.jsxs)("filter", { id: "ck_zora_filter_a", x: "-5.23758", y: "-9.30581", width: "57.837", height: "57.8232", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [(0, import_jsx_runtime.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), (0, import_jsx_runtime.jsx)("feGaussianBlur", { stdDeviation: "2.72108", result: "effect1_foregroundBlur_3914_1946" })] }), (0, import_jsx_runtime.jsxs)("filter", { id: "ck_zora_filter_b", x: "-3.71395", y: "-13.3332", width: "59.8503", height: "59.8639", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [(0, import_jsx_runtime.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), (0, import_jsx_runtime.jsx)("feGaussianBlur", { stdDeviation: "5.44218", result: "effect1_foregroundBlur_3914_1946" })] }), (0, import_jsx_runtime.jsxs)("filter", { id: "ck_zora_filter_c", x: "1.93251", y: "-7.06114", width: "47.864", height: "47.8775", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [(0, import_jsx_runtime.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), (0, import_jsx_runtime.jsx)("feGaussianBlur", { stdDeviation: "2.04082", result: "effect1_foregroundBlur_3914_1946" })] }), (0, import_jsx_runtime.jsxs)("filter", { id: "ck_zora_filter_d", x: "10.9935", y: "-6.28533", width: "36.3265", height: "36.3265", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [(0, import_jsx_runtime.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), (0, import_jsx_runtime.jsx)("feGaussianBlur", { stdDeviation: "4.08163", result: "effect1_foregroundBlur_3914_1946" })] }), (0, import_jsx_runtime.jsxs)("filter", { id: "ck_zora_filter_e", x: "19.7146", y: "2.43564", width: "18.8707", height: "18.8708", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [(0, import_jsx_runtime.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), (0, import_jsx_runtime.jsx)("feGaussianBlur", { stdDeviation: "2.72108", result: "effect1_foregroundBlur_3914_1946" })] }), (0, import_jsx_runtime.jsxs)("filter", { id: "ck_zora_filter_f", x: "-13.4693", y: "-24.1087", width: "79.9318", height: "79.9321", filterUnits: "userSpaceOnUse", colorInterpolationFilters: "sRGB", children: [(0, import_jsx_runtime.jsx)("feFlood", { floodOpacity: "0", result: "BackgroundImageFix" }), (0, import_jsx_runtime.jsx)("feBlend", { mode: "normal", in: "SourceGraphic", in2: "BackgroundImageFix", result: "shape" }), (0, import_jsx_runtime.jsx)("feGaussianBlur", { stdDeviation: "2.04082", result: "effect1_foregroundBlur_3914_1946" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint0_radial_3914_1946", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(29.2127 11.2756) rotate(128.228) scale(37.4897 37.4867)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.286458", stopColor: "#387AFA" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.647782", stopColor: "#387AFA", stopOpacity: "0" })] }), (0, import_jsx_runtime.jsxs)("radialGradient", { id: "paint1_radial_3914_1946", cx: "0", cy: "0", r: "1", gradientUnits: "userSpaceOnUse", gradientTransform: "translate(26.4967 15.8573) rotate(90) scale(35.8844 35.8844)", children: [(0, import_jsx_runtime.jsx)("stop", { offset: "0.598958", stopOpacity: "0" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.671875" }), (0, import_jsx_runtime.jsx)("stop", { offset: "0.734375", stopOpacity: "0" })] })] })] });
var Chains = {
  UnknownChain,
  Base,
  LensChain,
  Ethereum,
  Polygon,
  Optimism,
  Arbitrum,
  Aurora,
  Avalanche,
  Celo,
  Telos,
  Gnosis,
  Evmos,
  BinanceSmartChain,
  Foundry: KnownChain,
  Sepolia: KnownChain,
  Taraxa: KnownChain,
  zkSync: KnownChain,
  Flare: KnownChain,
  Canto,
  Fantom,
  Filecoin,
  Metis,
  IoTeX,
  Zora
};
var chainConfigs = [
  {
    id: 1,
    name: "Ethereum",
    logo: (0, import_jsx_runtime.jsx)(Chains.Ethereum, {}),
    rpcUrls: {
      alchemy: {
        http: ["https://eth-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://eth-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://mainnet.infura.io/v3"],
        webSocket: ["wss://mainnet.infura.io/ws/v3"]
      }
    }
  },
  {
    id: 232,
    name: "Lens Chain",
    logo: (0, import_jsx_runtime.jsx)(Chains.LensChain, {})
  },
  {
    id: 37111,
    name: "Lens Chain Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.LensChain, { testnet: true })
  },
  {
    id: 3,
    name: "Rinkeby",
    logo: (0, import_jsx_runtime.jsx)(Chains.Ethereum, { testnet: true }),
    rpcUrls: {}
  },
  {
    id: 4,
    name: "Ropsten",
    logo: (0, import_jsx_runtime.jsx)(Chains.Ethereum, { testnet: true })
  },
  {
    id: 5,
    name: "Grli",
    logo: (0, import_jsx_runtime.jsx)(Chains.Ethereum, { testnet: true })
  },
  {
    id: 42,
    name: "Kovan",
    logo: (0, import_jsx_runtime.jsx)(Chains.Ethereum, { testnet: true })
  },
  {
    id: 10,
    name: "Optimism",
    logo: (0, import_jsx_runtime.jsx)(Chains.Optimism, {})
  },
  {
    id: 69,
    // nice
    name: "Optimism Kovan",
    logo: (0, import_jsx_runtime.jsx)(Chains.Optimism, { testnet: true })
  },
  {
    id: 420,
    // nice
    name: "Optimism Goerli",
    logo: (0, import_jsx_runtime.jsx)(Chains.Optimism, { testnet: true })
  },
  {
    id: 11155420,
    name: "Optimism Sepolia",
    logo: (0, import_jsx_runtime.jsx)(Chains.Optimism, { testnet: true })
  },
  {
    id: 137,
    name: "Polygon",
    logo: (0, import_jsx_runtime.jsx)(Chains.Polygon, {})
  },
  {
    id: 80001,
    name: "Polygon Mumbai",
    logo: (0, import_jsx_runtime.jsx)(Chains.Polygon, { testnet: true })
  },
  {
    id: 31337,
    name: "Hardhat",
    logo: (0, import_jsx_runtime.jsx)(Chains.Ethereum, { testnet: true })
  },
  {
    id: 1337,
    name: "Localhost",
    logo: (0, import_jsx_runtime.jsx)(Chains.Ethereum, { testnet: true })
  },
  {
    id: 42161,
    name: "Arbitrum",
    logo: (0, import_jsx_runtime.jsx)(Chains.Arbitrum, {}),
    rpcUrls: {
      alchemy: {
        http: ["https://arb-mainnet.g.alchemy.com/v2"],
        webSocket: ["wss://arb-mainnet.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://arbitrum-mainnet.infura.io/v3"],
        webSocket: ["wss://arbitrum-mainnet.infura.io/ws/v3"]
      }
    }
  },
  {
    id: 421611,
    name: "Arbitrum Rinkeby",
    logo: (0, import_jsx_runtime.jsx)(Chains.Arbitrum, { testnet: true })
  },
  {
    id: 421613,
    name: "Arbitrum Goerli",
    logo: (0, import_jsx_runtime.jsx)(Chains.Arbitrum, { testnet: true }),
    rpcUrls: {
      alchemy: {
        http: ["https://arb-goerli.g.alchemy.com/v2"],
        webSocket: ["wss://arb-goerli.g.alchemy.com/v2"]
      },
      infura: {
        http: ["https://arbitrum-goerli.infura.io/v3"],
        webSocket: ["wss://arbitrum-goerli.infura.io/ws/v3"]
      }
    }
  },
  {
    id: 40,
    name: "Telos",
    logo: (0, import_jsx_runtime.jsx)(Chains.Telos, {})
  },
  {
    id: 41,
    name: "Telos Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.Telos, { testnet: true })
  },
  {
    id: 1313161554,
    name: "Aurora",
    logo: (0, import_jsx_runtime.jsx)(Chains.Aurora, {})
  },
  {
    id: 1313161555,
    name: "Aurora Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.Aurora, { testnet: true })
  },
  {
    id: 43114,
    name: "Avalanche",
    logo: (0, import_jsx_runtime.jsx)(Chains.Avalanche, {})
  },
  {
    id: 43113,
    name: "Avalanche Fuji",
    logo: (0, import_jsx_runtime.jsx)(Chains.Avalanche, { testnet: true })
  },
  {
    id: 31337,
    name: "Foundry",
    logo: (0, import_jsx_runtime.jsx)(Chains.Foundry, { testnet: true })
  },
  {
    id: 100,
    name: "Gnosis",
    logo: (0, import_jsx_runtime.jsx)(Chains.Gnosis, {})
  },
  {
    id: 9001,
    name: "Evmos",
    logo: (0, import_jsx_runtime.jsx)(Chains.Evmos, {})
  },
  {
    id: 9e3,
    name: "Evmos Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.Evmos, { testnet: true })
  },
  {
    id: 56,
    name: "BNB Smart Chain",
    logo: (0, import_jsx_runtime.jsx)(Chains.BinanceSmartChain, {})
  },
  {
    id: 97,
    name: "Binance Smart Chain Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.BinanceSmartChain, { testnet: true })
  },
  {
    id: 11155111,
    name: "Sepolia",
    logo: (0, import_jsx_runtime.jsx)(Chains.Sepolia, {})
  },
  {
    id: 841,
    name: "Taraxa",
    logo: (0, import_jsx_runtime.jsx)(Chains.Taraxa, {})
  },
  {
    id: 842,
    name: "Taraxa Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.Taraxa, { testnet: true })
  },
  {
    id: 324,
    name: "zkSync",
    logo: (0, import_jsx_runtime.jsx)(Chains.zkSync, {})
  },
  {
    id: 280,
    name: "zkSync Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.zkSync, { testnet: true })
  },
  {
    id: 42220,
    name: "Celo",
    logo: (0, import_jsx_runtime.jsx)(Chains.Celo, {})
  },
  {
    id: 44787,
    name: "Celo Alfajores",
    logo: (0, import_jsx_runtime.jsx)(Chains.Celo, { testnet: true })
  },
  {
    id: 7700,
    name: "Canto",
    logo: (0, import_jsx_runtime.jsx)(Chains.Canto, {})
  },
  {
    id: 250,
    name: "Fantom",
    logo: (0, import_jsx_runtime.jsx)(Chains.Fantom, {})
  },
  {
    id: 4002,
    name: "Fantom Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.Fantom, { testnet: true })
  },
  {
    id: 14,
    name: "Flare",
    logo: (0, import_jsx_runtime.jsx)(Chains.Flare, {})
  },
  {
    id: 114,
    name: "Coston2",
    logo: (0, import_jsx_runtime.jsx)(Chains.Flare, {})
  },
  {
    id: 314,
    name: "Filecoin",
    logo: (0, import_jsx_runtime.jsx)(Chains.Filecoin, {})
  },
  {
    id: 3141,
    name: "Filecoin Hyperspace",
    logo: (0, import_jsx_runtime.jsx)(Chains.Filecoin, { testnet: true })
  },
  {
    id: 314159,
    name: "Filecoin Calibration",
    logo: (0, import_jsx_runtime.jsx)(Chains.Filecoin, { testnet: true })
  },
  {
    id: 1088,
    name: "Metis",
    logo: (0, import_jsx_runtime.jsx)(Chains.Metis, {})
  },
  {
    id: 599,
    name: "Metis Goerli",
    logo: (0, import_jsx_runtime.jsx)(Chains.Metis, { testnet: true })
  },
  {
    id: 4689,
    name: "IoTeX",
    logo: (0, import_jsx_runtime.jsx)(Chains.IoTeX, {})
  },
  {
    id: 4690,
    name: "IoTeX Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.IoTeX, { testnet: true })
  },
  {
    id: 8453,
    name: "Base",
    logo: (0, import_jsx_runtime.jsx)(Chains.Base, {})
  },
  {
    id: 84531,
    name: "Base Goerli",
    logo: (0, import_jsx_runtime.jsx)(Chains.Base, { testnet: true })
  },
  {
    id: 84532,
    name: "Base Sepolia",
    logo: (0, import_jsx_runtime.jsx)(Chains.Base, { testnet: true })
  },
  {
    id: 7777777,
    name: "Zora",
    logo: (0, import_jsx_runtime.jsx)(Chains.Zora, {})
  },
  {
    id: 999999999,
    name: "Zora Sepolia",
    logo: (0, import_jsx_runtime.jsx)(Chains.Zora, { testnet: true })
  },
  {
    id: 999,
    name: "Zora Goerli Testnet",
    logo: (0, import_jsx_runtime.jsx)(Chains.Zora, { testnet: true })
  }
];
var SwitchNetworksContainer = styled.div`
  display: flex;
  flex-direction: column;

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    flex-direction: column-reverse;
  }
`;
var ChainIcon = styled(motion.div)`
  display: block;
  position: relative;
  border-radius: 12px;
  overflow: hidden;
  width: 24px;
  height: 24px;
  min-width: 24px;
  min-height: 24px;
  background: var(--ck-body-background);
  svg {
    border-radius: inherit;
    display: block;
    position: relative;
    transform: translate3d(0, 0, 0);
    width: 100%;
    height: auto;
  }
  ${(props) => props.$empty && Ae`
      display: flex;
      align-items: center;
      justify-content: center;
      &:before {
        content: '?';
        color: var(--ck-body-color-muted);
        font-weight: bold;
        font-family: var(--ck-font-family);
      }
    `}
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    border-radius: 16px;
    width: 32px;
    height: 32px;
  }
`;
var ChainLogoContainer = styled(motion.div)`
  position: relative;
`;
var ChainLogoSpinner = styled(motion.div)`
  position: absolute;
  inset: -6px;
  animation: rotateSpinner 1200ms linear infinite;
  pointer-events: none;
  svg {
    display: block;
    position: relative;
    transform: translate3d(0, 0, 0);
    width: 100%;
    height: auto;
  }
  @keyframes rotateSpinner {
    0% {
      transform: rotate(0deg);
    }
    100% {
      transform: rotate(360deg);
    }
  }
`;
var ChainButtonContainer = styled.div`
  position: relative;
  margin: -8px -8px;
  &:after {
    border-radius: var(--border-radius, 0);
    z-index: 2;
    content: '';
    pointer-events: none;
    position: absolute;
    inset: 0 2px;
    box-shadow: inset 0 16px 8px -12px var(--background, var(--ck-body-background)),
      inset 0 -16px 8px -12px var(--background, var(--ck-body-background));
  }
`;
var ChainButtons = styled(motion.div)`
  padding: 8px;
  overflow-x: hidden;
  overflow-y: auto;
  max-height: 242px;

  -ms-overflow-style: none; /* Internet Explorer 10+ */
  scrollbar-width: none; /* Firefox */
  &::-webkit-scrollbar {
    display: none; /* Safari and Chrome */
  }

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    padding: 8px 14px;
    margin: 2px -2px 0;
    max-height: 60vh;
  }
`;
var ChainButton = styled(motion.button)`
  appearance: none;
  cursor: pointer;
  user-select: none;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
  width: 100%;
  border-radius: 11px;
  margin: 0 0 1px;
  padding: 8px 0;
  padding-right: 154px;
  font-size: 15px;
  line-height: 18px;
  font-weight: 500;
  text-decoration: none;
  color: var(--ck-body-color);
  background: none;
  white-space: nowrap;
  transition: transform 100ms ease, background-color 100ms ease;
  transform: translateZ(0px);
  &:before {
    content: '';
    background: currentColor;
    position: absolute;
    z-index: -1;
    inset: 0 var(--ck-dropdown-active-inset, -8px);
    border-radius: var(--ck-dropdown-active-border-radius, 12px);
    opacity: 0;
    transition: opacity 180ms ease;
  }
  &:after {
    content: '';
    position: absolute;
    z-index: -1;
    inset: 0 var(--ck-dropdown-active-inset, -8px);
    border-radius: 12px;
    opacity: 0;
    transition: opacity 180ms ease;
    outline: 2px solid var(--ck-focus-color);
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    font-size: 17px;
    padding: 8px 0;
  }
  @media only screen and (min-width: ${defaultTheme.mobileWidth}px) {
    &:hover {
      &:before {
        transition-duration: 80ms;
        opacity: 0.05;
      }
    }
  }
  &:active {
    transform: scale(0.99) translateZ(0px);
  }
  &:disabled {
    //opacity: 0.4;
    pointer-events: none;
  }
  &:focus-visible {
    outline: none !important;
    &:after {
      opacity: 1;
    }
  }
  ${(props) => props.$variant === "secondary" && Ae`
      padding: 12px 4px;
      margin: 0 0 8px;
      &:last-child {
        margin-bottom: 0;
      }
      &:before {
        opacity: 0.05;
      }
      &:hover:before {
        opacity: 0.1;
      }
    `}
`;
var ChainButtonStatus = styled(motion.div)`
  position: absolute;
  top: 0;
  bottom: 0;
  right: 0;
  display: flex;
  align-items: center;
  justify-content: center;

  color: var(--ck-body-color-muted);
  font-size: 15px;
  line-height: 18px;
  font-weight: 500;
  padding-right: 4px;
  span {
    display: block;
    position: relative;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    font-size: 17px;
    padding: 0;
  }
`;
var ChainButtonBg = styled(motion.div)`
  position: absolute;
  z-index: -1;
  inset: 0 var(--ck-dropdown-active-inset, -8px);
  background: var(--ck-dropdown-active-background, rgba(26, 136, 248, 0.1));
  box-shadow var(--ck-dropdown-active-box-shadow);
  border-radius: var(--ck-dropdown-active-border-radius, 12px);
  
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    inset: 0 var(--ck-dropdown-active-inset, -8px);
  }
`;
var Spinner$1 = (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "36", height: "36", viewBox: "0 0 36 36", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M2 16.75C2.69036 16.75 3.25 17.3096 3.25 18V19C3.25 26.5939 9.40609 32.75 17 32.75V35.25C8.02537 35.25 0.75 27.9746 0.75 19V18C0.75 17.3096 1.30964 16.75 2 16.75Z", fill: "url(#paint0_linear_1288_18701)" }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_1288_18701", x1: "2", y1: "19.4884", x2: "16.8752", y2: "33.7485", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-spinner-color)" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-spinner-color)", stopOpacity: "0" })] }) })] });
var ChainSelectList = ({ variant }) => {
  const { connector, chain: chain2 } = useAccount();
  const { chains, isPending, switchChain: switchChain3, error } = useSwitchChain();
  const [pendingChainId, setPendingChainId] = (0, import_react70.useState)(void 0);
  const locales = useLocales({});
  const mobile = isMobile();
  const isError = (error === null || error === void 0 ? void 0 : error["code"]) === 4902;
  const disabled = isError || !switchChain3;
  const handleSwitchNetwork = (chainId) => {
    if (switchChain3) {
      setPendingChainId(chainId);
      switchChain3({ chainId });
    }
  };
  const { triggerResize } = useContext21();
  return (0, import_jsx_runtime.jsxs)(SwitchNetworksContainer, { style: { marginBottom: switchChain3 !== void 0 ? -8 : 0 }, children: [(0, import_jsx_runtime.jsx)(ChainButtonContainer, { children: (0, import_jsx_runtime.jsx)(ChainButtons, { children: chains.map((x2) => {
    var _a2;
    const c3 = chainConfigs.find((ch2) => ch2.id === x2.id);
    const ch = { ...c3, ...x2 };
    return (0, import_jsx_runtime.jsxs)(ChainButton, { "$variant": variant, disabled: disabled || ch.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) || isPending && pendingChainId === ch.id, onClick: () => handleSwitchNetwork === null || handleSwitchNetwork === void 0 ? void 0 : handleSwitchNetwork(ch.id), style: {
      opacity: disabled && ch.id !== (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) ? 0.4 : void 0
    }, children: [(0, import_jsx_runtime.jsxs)("span", { style: {
      display: "flex",
      alignItems: "center",
      justifyContent: "flex-start",
      gap: 12,
      color: ch.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) ? "var(--ck-dropdown-active-color, inherit)" : "inherit"
    }, children: [(0, import_jsx_runtime.jsxs)(ChainLogoContainer, { children: [(0, import_jsx_runtime.jsx)(ChainLogoSpinner, { initial: { opacity: 0 }, animate: {
      opacity: isPending && pendingChainId === ch.id ? 1 : 0
    }, transition: {
      ease: [0.76, 0, 0.24, 1],
      duration: 0.15,
      delay: 0.1
    }, children: (0, import_jsx_runtime.jsx)(motion.div, { animate: (
      // UI fix for Coinbase Wallet on mobile does not remove isPending on rejection event
      mobile && isCoinbaseWalletConnector(connector === null || connector === void 0 ? void 0 : connector.id) && isPending && pendingChainId === ch.id ? {
        opacity: [1, 0],
        transition: { delay: 4, duration: 3 }
      } : { opacity: 1 }
    ), children: Spinner$1 }, `${ch === null || ch === void 0 ? void 0 : ch.id}-${ch === null || ch === void 0 ? void 0 : ch.name}`) }), (0, import_jsx_runtime.jsx)(ChainIcon, { children: (_a2 = ch.logo) !== null && _a2 !== void 0 ? _a2 : (0, import_jsx_runtime.jsx)(Chains.UnknownChain, {}) })] }), ch.name] }), variant !== "secondary" && (0, import_jsx_runtime.jsx)(ChainButtonStatus, { children: (0, import_jsx_runtime.jsxs)(AnimatePresence, { initial: false, exitBeforeEnter: true, children: [ch.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) && (0, import_jsx_runtime.jsx)(motion.span, { style: {
      color: "var(--ck-dropdown-active-color, var(--ck-focus-color))",
      display: "block",
      position: "relative"
    }, initial: { opacity: 0, x: -4 }, animate: { opacity: 1, x: 0 }, exit: {
      opacity: 0,
      x: 4,
      transition: { duration: 0.1, delay: 0 }
    }, transition: {
      ease: [0.76, 0, 0.24, 1],
      duration: 0.3,
      delay: 0.2
    }, children: locales.connected }, "connectedText"), isPending && pendingChainId === ch.id && (0, import_jsx_runtime.jsx)(motion.span, { style: {
      color: "var(--ck-dropdown-pending-color, inherit)",
      display: "block",
      position: "relative"
    }, initial: {
      opacity: 0,
      x: -4
    }, animate: { opacity: 1, x: 0 }, exit: { opacity: 0, x: 4 }, transition: {
      ease: [0.76, 0, 0.24, 1],
      duration: 0.3,
      delay: 0.1
    }, children: (0, import_jsx_runtime.jsx)(motion.span, { animate: (
      // UI fix for Coinbase Wallet on mobile does not remove isLoading on rejection event
      mobile && isCoinbaseWalletConnector(connector === null || connector === void 0 ? void 0 : connector.id) && {
        opacity: [1, 0],
        transition: { delay: 4, duration: 4 }
      }
    ), children: locales.approveInWallet }) }, "approveText")] }) }), variant === "secondary" ? (0, import_jsx_runtime.jsx)(ChainButtonBg, { initial: false, animate: {
      opacity: ch.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) ? 1 : 0
    }, transition: {
      duration: 0.3,
      ease: "easeOut"
    } }) : (
      //hover === ch.name && (
      ch.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id) && (0, import_jsx_runtime.jsx)(ChainButtonBg, { layoutId: "activeChain", layout: "position", transition: {
        duration: 0.3,
        ease: "easeOut"
      } })
    )] }, `${ch === null || ch === void 0 ? void 0 : ch.id}-${ch === null || ch === void 0 ? void 0 : ch.name}`);
  }) }) }), (0, import_jsx_runtime.jsx)(AnimatePresence, { children: isError && (0, import_jsx_runtime.jsx)(motion.div, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: {
    ease: [0.76, 0, 0.24, 1],
    duration: 0.3
  }, onAnimationStart: triggerResize, onAnimationComplete: triggerResize, children: (0, import_jsx_runtime.jsx)("div", { style: { paddingTop: 10, paddingBottom: 8 }, children: (0, import_jsx_runtime.jsxs)(Alert, { children: [locales.warnings_walletSwitchingUnsupported, " ", locales.warnings_walletSwitchingUnsupportedResolve] }) }) }) })] });
};
var DropdownWindow = styled(motion.div)`
  z-index: 2147483647;
  position: fixed;
  inset: 0;
`;
var DropdownOverlay = styled(motion.div)`
  position: absolute;
  inset: 0;
`;
var DropdownContainer = styled(motion.div)`
  --shadow: 0px 2px 15px rgba(0, 0, 0, 0.15);
  --background: var(--ck-dropdown-background, var(--ck-tooltip-background));
  --border-radius: var(
    --ck-dropdown-border-radius,
    var(--ck-tooltip-border-radius, 12px)
  );

  pointer-events: auto;
  z-index: 2147483647;
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  max-width: fit-content;
  padding: 14px 16px 16px;
  color: var(--ck-dropdown-color, var(--ck-tooltip-color));
  background: var(--background);
  box-shadow: var(
    --ck-dropdown-box-shadow,
    var(--ck-tooltip-shadow, var(--shadow))
  );
  border-radius: var(--border-radius);
`;
var DropdownHeading = styled(motion.div)`
  padding: 0 0 6px;
  font-size: 14px;
  line-height: 20px;
  font-weight: 400;
  user-select: none;
  color: var(--ck-dropdown-color, var(--ck-tooltip-color));
`;
var ChainSelectDropdown = ({ children, open, onClose, offsetX = 0, offsetY = 8 }) => {
  var _a2, _b, _c2;
  const context = useContext21();
  const themeContext = useThemeContext();
  const locales = useLocales();
  const [offset, setOffset] = (0, import_react70.useState)({ x: 0, y: 0 });
  useLockBodyScroll(open);
  const contentRef = (0, import_react70.useRef)(null);
  (0, import_react70.useEffect)(() => {
    const listener = (e2) => {
      var _a3, _b2, _c3;
      if (!open)
        return;
      if (e2.key === "Escape")
        onClose();
      if (e2.key === "ArrowDown" || e2.key === "ArrowUp") {
        if (!contentRef.current)
          return;
        e2.preventDefault();
        const focusableEls = (_a3 = contentRef.current) === null || _a3 === void 0 ? void 0 : _a3.querySelectorAll(`
            a[href]:not(:disabled),
            button:not(:disabled),
            textarea:not(:disabled),
            input[type="text"]:not(:disabled),
            input[type="radio"]:not(:disabled),
            input[type="checkbox"]:not(:disabled),
            select:not(:disabled)
          `), firstFocusableEl = focusableEls[0], lastFocusableEl = focusableEls[focusableEls.length - 1];
        if (e2.key === "ArrowUp") {
          if (document.activeElement === firstFocusableEl) {
            lastFocusableEl.focus();
          } else {
            let focusItem = (_b2 = document === null || document === void 0 ? void 0 : document.activeElement) === null || _b2 === void 0 ? void 0 : _b2.previousSibling;
            if (!focusItem)
              focusItem = lastFocusableEl;
            while (focusItem.disabled)
              focusItem = focusItem.previousSibling;
            focusItem.focus();
          }
        } else {
          if (document.activeElement === lastFocusableEl) {
            firstFocusableEl.focus();
          } else {
            let focusItem = (_c3 = document === null || document === void 0 ? void 0 : document.activeElement) === null || _c3 === void 0 ? void 0 : _c3.nextSibling;
            if (!focusItem)
              focusItem = firstFocusableEl;
            while (focusItem.disabled)
              focusItem = focusItem.nextSibling;
            focusItem.focus();
          }
        }
      }
    };
    document.addEventListener("keydown", listener);
    return () => {
      document.removeEventListener("keydown", listener);
    };
  }, [open]);
  const targetRef = (0, import_react70.useRef)(null);
  const innerRef = (0, import_react70.useCallback)((node) => {
    if (!node)
      return;
    targetRef.current = node;
    refresh();
  }, [open]);
  const [ref, bounds] = j2({
    debounce: 120,
    // waits until modal transition has finished before measuring
    offsetSize: true,
    scroll: true
  });
  const refresh = () => {
    if (!targetRef.current || bounds.top + bounds.bottom + bounds.left + bounds.right + bounds.height + bounds.width === 0) {
      return;
    }
    let x2 = bounds.left + offsetX;
    let y2 = bounds.top + bounds.height + offsetY;
    targetRef.current.style.left = `${x2}px`;
    targetRef.current.style.top = `${y2}px`;
  };
  const useIsomorphicLayoutEffect3 = typeof window !== "undefined" ? import_react70.useLayoutEffect : import_react70.useEffect;
  useIsomorphicLayoutEffect3(refresh, [targetRef.current, bounds, open]);
  (0, import_react70.useEffect)(refresh, [open, targetRef.current]);
  const onScroll = onClose;
  const onResize = onClose;
  (0, import_react70.useEffect)(() => {
    refresh();
    window.addEventListener("scroll", onScroll);
    window.addEventListener("resize", onResize);
    return () => {
      window.removeEventListener("scroll", onScroll);
      window.removeEventListener("resize", onResize);
    };
  }, []);
  return (0, import_jsx_runtime.jsxs)(import_jsx_runtime.Fragment, { children: [(0, import_jsx_runtime.jsx)("div", { ref, children }), (0, import_jsx_runtime.jsx)(AnimatePresence, { children: open && (0, import_jsx_runtime.jsx)(Portal, { children: (0, import_jsx_runtime.jsx)(ResetContainer, { "$useTheme": (_a2 = themeContext.theme) !== null && _a2 !== void 0 ? _a2 : context.theme, "$useMode": (_b = themeContext.mode) !== null && _b !== void 0 ? _b : context.mode, "$customTheme": (_c2 = themeContext.customTheme) !== null && _c2 !== void 0 ? _c2 : context.customTheme, children: (0, import_jsx_runtime.jsx)(FocusTrap, { children: (0, import_jsx_runtime.jsxs)(DropdownWindow, { ref: contentRef, children: [(0, import_jsx_runtime.jsx)(DropdownOverlay, { onClick: onClose }), (0, import_jsx_runtime.jsxs)(DropdownContainer, { ref: innerRef, style: {
    left: offset.x,
    top: offset.y
  }, initial: "collapsed", animate: "open", exit: "collapsed", variants: {
    collapsed: {
      transformOrigin: "0 0",
      opacity: 0,
      scale: 0.96,
      z: 0.01,
      y: -4,
      x: 0,
      transition: {
        duration: 0.1
      }
    },
    open: {
      transformOrigin: "0 0",
      willChange: "opacity,transform",
      opacity: 1,
      scale: 1,
      z: 0.01,
      y: 0,
      x: 0,
      transition: {
        ease: [0.76, 0, 0.24, 1],
        duration: 0.15
      }
    }
  }, children: [(0, import_jsx_runtime.jsx)(DropdownHeading, { children: locales.switchNetworks }), (0, import_jsx_runtime.jsx)(ChainSelectList, {})] })] }) }) }) }) })] });
};
var ChainContainer = styled.div`
  --bg: transparent;
  --color: #333;
  ${(props) => typeof props.size === "string" ? Ae`
          --width: ${props.size};
          --height: ${props.size};
        ` : Ae`
          --width: ${props.size >= 0 ? `${props.size}px` : "24px"};
          --height: ${props.size >= 0 ? `${props.size}px` : "24px"};
        `};
  ${(props) => typeof props.radius === "string" ? Ae`
          --radius: ${props.radius};
        ` : Ae`
          --radius: ${props.radius >= 0 ? `${props.radius}px` : "24px"};
        `};
  display: block;
  position: relative;
  width: var(--width);
  height: var(--height);
  min-width: var(--width);
  min-height: var(--height);
  border-radius: var(--radius);
  background: var(--ck-body-background-secondary);
  pointer-events: none;
  user-select: none;
  svg {
    display: block;
    width: 100%;
    height: auto;
  }
  > div {
    display: flex;
    align-items: center;
    justify-content: center;
  }
`;
var LogoContainer$1 = styled(motion.div)`
  display: block;
  position: absolute;
  inset: 0;
  overflow: hidden;
  border-radius: inherit;
  user-select: none;
  display: flex;
  align-items: center;
  justify-content: center;
  svg {
    display: block;
    width: 100%;
    height: auto;
  }
`;
var Spin = We`
  0%{ transform: rotate(0deg); }
  100%{ transform: rotate(360deg); }
`;
var LoadingContainer = styled(motion.div)`
  position: absolute;
  inset: 0;
  animation: ${Spin} 1s linear infinite;
  svg {
    display: block;
    position: absolute;
    inset: 0;
  }
`;
var Unsupported = styled(motion.div)`
  z-index: 2;
  position: absolute;
  top: 0;
  right: 0;
  width: 40%;
  height: 40%;
  min-width: 13px;
  min-height: 13px;
  color: var(--ck-body-color-danger, red);
  svg {
    display: block;
    position: relative;
    top: -30%;
    right: -30%;
  }
`;
var Spinner = (0, import_jsx_runtime.jsxs)("svg", { "aria-hidden": "true", width: "36", height: "36", viewBox: "0 0 36 36", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { fillRule: "evenodd", clipRule: "evenodd", d: "M11.3592 30.1654C10.0472 29.4491 8.85718 28.524 7.83713 27.424C6.81708 26.324 5.98425 25.0677 5.36889 23.7054C5.20157 23.335 5.05033 22.9567 4.91578 22.5717C4.51465 21.4237 4.26735 20.2308 4.17794 19.0239C4.16599 18.8626 4.13894 18.7041 4.09809 18.5507C3.85023 17.6197 3.09399 16.8738 2.11531 16.7999C0.975331 16.7138 -0.0310983 17.5702 0.0141657 18.7125C0.0223289 18.9185 0.0340286 19.1243 0.049253 19.3298C0.165374 20.8971 0.486545 22.4464 1.00749 23.9373C1.10424 24.2142 1.20764 24.4884 1.31755 24.7596C2.13617 26.7799 3.31595 28.6371 4.80146 30.239C6.28696 31.841 8.04998 33.1573 10.0029 34.1258C10.2651 34.2558 10.5307 34.3796 10.7995 34.4969C12.247 35.1287 13.7676 35.5656 15.3217 35.7995C15.5255 35.8301 15.7298 35.8573 15.9346 35.881C17.0703 36.0122 18.0001 35.0731 18.0001 33.9299C18.0001 32.9484 17.3133 32.1381 16.4036 31.8208C16.2537 31.7685 16.0977 31.7296 15.9377 31.7056C14.7411 31.5255 13.5702 31.1891 12.4556 30.7026C12.0818 30.5394 11.716 30.3601 11.3592 30.1654Z", fill: "url(#paint0_linear_1288_1870)" }), (0, import_jsx_runtime.jsx)("defs", { children: (0, import_jsx_runtime.jsxs)("linearGradient", { id: "paint0_linear_1288_1870", x1: "2", y1: "19.4884", x2: "16.8752", y2: "33.7485", gradientUnits: "userSpaceOnUse", children: [(0, import_jsx_runtime.jsx)("stop", { stopColor: "var(--ck-connectbutton-balance-color,currentColor)", stopOpacity: "0.7" }), (0, import_jsx_runtime.jsx)("stop", { offset: "1", stopColor: "var(--ck-connectbutton-balance-color,currentColor)", stopOpacity: "0" })] }) })] });
var Chain = ({ id: id3, unsupported: controlledUnsupported, radius = "50%", size: size5 = 24 }) => {
  var _a2;
  const isChainSupported = useChainIsSupported(id3);
  const unsupported = controlledUnsupported !== null && controlledUnsupported !== void 0 ? controlledUnsupported : !isChainSupported;
  const chain2 = chainConfigs.find((c3) => c3.id === id3);
  const isMounted = useIsMounted2();
  if (!isMounted)
    return (0, import_jsx_runtime.jsx)("div", { style: {
      width: size5,
      height: size5
    } });
  return (0, import_jsx_runtime.jsx)(ChainContainer, { size: size5, radius, children: (0, import_jsx_runtime.jsxs)(AnimatePresence, { initial: false, children: [unsupported && (0, import_jsx_runtime.jsx)(Unsupported, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: (0, import_jsx_runtime.jsxs)("svg", { width: "13", height: "12", viewBox: "0 0 13 12", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: [(0, import_jsx_runtime.jsx)("path", { d: "M2.61317 11.2501H9.46246C10.6009 11.2501 11.3256 10.3506 11.3256 9.3549C11.3256 9.05145 11.255 8.73244 11.0881 8.43303L7.65903 2.14708C7.659 2.14702 7.65897 2.14696 7.65893 2.1469C7.65889 2.14682 7.65884 2.14673 7.65879 2.14664C7.31045 1.50746 6.6741 1.17871 6.04 1.17871C5.41478 1.17871 4.763 1.50043 4.41518 2.14968L0.993416 8.43476C0.828865 8.72426 0.75 9.04297 0.75 9.3549C0.75 10.3506 1.47471 11.2501 2.61317 11.2501Z", fill: "currentColor", stroke: "var(--ck-body-background, #fff)", strokeWidth: "1.5" }), (0, import_jsx_runtime.jsx)("path", { d: "M6.03258 7.43916C5.77502 7.43916 5.63096 7.29153 5.62223 7.02311L5.55675 4.96973C5.54802 4.69684 5.74446 4.5 6.02821 4.5C6.3076 4.5 6.51277 4.70131 6.50404 4.9742L6.43856 7.01864C6.42546 7.29153 6.2814 7.43916 6.03258 7.43916ZM6.03258 9.11676C5.7401 9.11676 5.5 8.9065 5.5 8.60677C5.5 8.30704 5.7401 8.09678 6.03258 8.09678C6.32506 8.09678 6.56515 8.30256 6.56515 8.60677C6.56515 8.91097 6.32069 9.11676 6.03258 9.11676Z", fill: "white" })] }) }), id3 ? (0, import_jsx_runtime.jsx)(LogoContainer$1, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.3 }, children: (_a2 = chain2 === null || chain2 === void 0 ? void 0 : chain2.logo) !== null && _a2 !== void 0 ? _a2 : (0, import_jsx_runtime.jsx)(Chains.UnknownChain, {}) }, `${chain2 === null || chain2 === void 0 ? void 0 : chain2.id}-${chain2 === null || chain2 === void 0 ? void 0 : chain2.name}-${id3}`) : (0, import_jsx_runtime.jsx)(LoadingContainer, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.3 }, children: Spinner }, "loading")] }) });
};
var Container$3 = styled(motion.div)``;
var SwitchChainButton = styled(motion.button)`
  --color: var(
    --ck-dropdown-button-color,
    var(--ck-button-primary-color, var(--ck-body-color))
  );
  --background: var(
    --ck-dropdown-button-background,
    var(--ck-secondary-button-background, var(--ck-body-background-secondary))
  );
  --box-shadow: var(
    --ck-dropdown-button-box-shadow,
    var(
      --ck-secondary-button-box-shadow,
      var(--ck-button-primary-box-shadow),
      none
    )
  );

  --hover-color: var(--ck-dropdown-button-hover-color, var(--color));
  --hover-background: var(
    --ck-dropdown-button-hover-background,
    var(--background)
  );
  --hover-box-shadow: var(
    --ck-dropdown-button-hover-box-shadow,
    var(--box-shadow)
  );

  --active-color: var(--ck-dropdown-button-active-color, var(--hover-color));
  --active-background: var(
    --ck-dropdown-button-active-background,
    var(--hover-background)
  );
  --active-box-shadow: var(
    --ck-dropdown-button-active-box-shadow,
    var(--hover-box-shadow)
  );

  appearance: none;
  user-select: none;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: space-between;
  border-radius: 15px;
  width: 52px;
  height: 30px;
  padding: 2px 6px 2px 3px;
  font-size: 16px;
  line-height: 19px;
  font-weight: 500;
  text-decoration: none;
  white-space: nowrap;
  transform: translateZ(0px);

  transition: 100ms ease;
  transition-property: transform, background-color, box-shadow, color;

  color: var(--color);
  background: var(--background);
  box-shadow: var(--box-shadow);

  svg {
    position: relative;
    display: block;
  }

  ${(props) => props.disabled ? Ae`
          width: auto;
          padding: 3px;
          position: relative;
          left: -22px;
        ` : Ae`
          cursor: pointer;

          @media only screen and (min-width: ${defaultTheme.mobileWidth + 1}px) {
            &:hover,
            &:focus-visible {
              color: var(--hover-color);
              background: var(--hover-background);
              box-shadow: var(--hover-box-shadow);
            }
            &:active {
              color: var(--active-color);
              background: var(--active-background);
              box-shadow: var(--active-box-shadow);
            }
          }
        `}
`;
var ChevronDown = ({ ...props }) => (0, import_jsx_runtime.jsx)("svg", { "aria-hidden": "true", width: "11", height: "6", viewBox: "0 0 11 6", fill: "none", xmlns: "http://www.w3.org/2000/svg", ...props, children: (0, import_jsx_runtime.jsx)("path", { d: "M1.5 1L5.5 5L9.5 1", stroke: "currentColor", strokeWidth: "2", strokeLinecap: "round", strokeLinejoin: "round" }) });
var ChainSelector = () => {
  const context = useContext21();
  const [isOpen, setIsOpen] = (0, import_react70.useState)(false);
  const { chain: chain2 } = useAccount();
  const { chains } = useSwitchChain();
  const locales = useLocales({
    CHAIN: chain2 === null || chain2 === void 0 ? void 0 : chain2.name
  });
  const mobile = isMobile() || (window === null || window === void 0 ? void 0 : window.innerWidth) < defaultTheme.mobileWidth;
  (0, import_react70.useEffect)(() => {
    if (!context.open)
      setIsOpen(false);
  }, [context.open]);
  const disabled = chains.length <= 1;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(Container$3, { children: (0, import_jsx_runtime.jsx)(ChainSelectDropdown, { offsetX: -12, open: !mobile && isOpen, onClose: () => setIsOpen(false), children: (0, import_jsx_runtime.jsxs)(SwitchChainButton, { "aria-label": flattenChildren(locales.switchNetworks).toString(), disabled, onClick: () => {
    if (mobile) {
      context.setRoute(routes.SWITCHNETWORKS);
    } else {
      setIsOpen(!isOpen);
    }
  }, children: [disabled ? (0, import_jsx_runtime.jsx)(Tooltip, { message: locales.chainNetwork, xOffset: -6, delay: 0.01, children: (0, import_jsx_runtime.jsx)(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id }) }) : (0, import_jsx_runtime.jsx)(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id }), !disabled && (0, import_jsx_runtime.jsx)(ChevronDown, { style: { top: 1, left: -3 } })] }) }) }) });
};
var Profile = ({ closeModal }) => {
  var _a2, _b, _c2;
  const context = useContext21();
  const themeContext = useThemeContext();
  const locales = useLocales();
  const { reset: reset2 } = useConnect();
  const { disconnect: disconnect3 } = useDisconnect();
  const { address, isConnected: isConnected2, connector, chain: chain2 } = useAccount();
  const ensFallbackConfig2 = useEnsFallbackConfig();
  const { data: ensName } = useEnsName({
    chainId: 1,
    address,
    config: ensFallbackConfig2
  });
  const { data: balance } = useBalance({
    address
    //watch: true,
  });
  const [shouldDisconnect, setShouldDisconnect] = (0, import_react70.useState)(false);
  (0, import_react70.useEffect)(() => {
    if (!isConnected2)
      context.setOpen(false);
  }, [isConnected2]);
  (0, import_react70.useEffect)(() => {
    if (!shouldDisconnect)
      return;
    if (closeModal) {
      closeModal();
    } else {
      context.setOpen(false);
    }
    return () => {
      disconnect3();
      reset2();
    };
  }, [shouldDisconnect, disconnect3, reset2]);
  const separator = ["web95", "rounded", "minimal"].includes((_b = (_a2 = themeContext.theme) !== null && _a2 !== void 0 ? _a2 : context.theme) !== null && _b !== void 0 ? _b : "") ? "...." : void 0;
  return (0, import_jsx_runtime.jsxs)(PageContent, { children: [(0, import_jsx_runtime.jsxs)(ModalContent, { style: { paddingBottom: 22, gap: 6 }, children: [(0, import_jsx_runtime.jsx)(AvatarContainer, { children: (0, import_jsx_runtime.jsxs)(AvatarInner, { children: [(0, import_jsx_runtime.jsx)(ChainSelectorContainer, { children: (0, import_jsx_runtime.jsx)(ChainSelector, {}) }), (0, import_jsx_runtime.jsx)(Avatar, { address })] }) }), (0, import_jsx_runtime.jsx)(ModalH1, { children: (0, import_jsx_runtime.jsx)(CopyToClipboard, { string: address, children: ensName !== null && ensName !== void 0 ? ensName : truncateEthAddress(address, separator) }) }), ((_c2 = context === null || context === void 0 ? void 0 : context.options) === null || _c2 === void 0 ? void 0 : _c2.hideBalance) ? null : (0, import_jsx_runtime.jsx)(ModalBody, { children: (0, import_jsx_runtime.jsx)(BalanceContainer, { children: (0, import_jsx_runtime.jsxs)(AnimatePresence, { exitBeforeEnter: true, initial: false, children: [balance && (0, import_jsx_runtime.jsxs)(Balance$1, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.2 }, children: [nFormatter(Number(balance === null || balance === void 0 ? void 0 : balance.formatted)), ` `, balance === null || balance === void 0 ? void 0 : balance.symbol] }, `chain-${chain2 === null || chain2 === void 0 ? void 0 : chain2.id}`), !balance && (0, import_jsx_runtime.jsx)(LoadingBalance, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, transition: { duration: 0.2 }, children: "" })] }) }) })] }), !isSafeConnector(connector === null || connector === void 0 ? void 0 : connector.id) && (0, import_jsx_runtime.jsx)(Button, { onClick: () => setShouldDisconnect(true), icon: (0, import_jsx_runtime.jsx)(DisconnectIcon, {}), children: locales.disconnect })] });
};
var SwitchNetworks = () => {
  const { reset: reset2 } = useConnect();
  const { disconnect: disconnect3 } = useDisconnect();
  const { connector, chain: chain2 } = useAccount();
  const isChainSupported = useChainIsSupported(chain2 === null || chain2 === void 0 ? void 0 : chain2.id);
  const locales = useLocales({});
  const onDisconnect = () => {
    disconnect3();
    reset2();
  };
  return (0, import_jsx_runtime.jsx)(PageContent, { style: { width: 278 }, children: (0, import_jsx_runtime.jsxs)(ModalContent, { style: { padding: 0, marginTop: -10 }, children: [!isChainSupported && (0, import_jsx_runtime.jsxs)(ModalBody, { children: [locales.warnings_chainUnsupported, " ", locales.warnings_chainUnsupportedResolve] }), (0, import_jsx_runtime.jsx)("div", { style: { padding: "6px 8px" }, children: (0, import_jsx_runtime.jsx)(ChainSelectList, { variant: "secondary" }) }), !isChainSupported && !isSafeConnector(connector === null || connector === void 0 ? void 0 : connector.id) && (0, import_jsx_runtime.jsxs)("div", { style: { paddingTop: 12 }, children: [(0, import_jsx_runtime.jsx)(OrDivider, {}), (0, import_jsx_runtime.jsx)(Button, { icon: (0, import_jsx_runtime.jsx)(DisconnectIcon, {}), variant: "secondary", onClick: onDisconnect, children: locales.disconnect })] })] }) });
};
var spinKeyframes = We`
  from{ transform: rotate(0deg); }
  to{   transform: rotate(360deg); }
`;
var lineKeyframes = We`
  from{ background-position: 0 0; }
  to{ background-position: 100% 0; }
`;
var ContentContainer = styled.div`
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    margin: 5px auto 24px;
    padding: 16px 16px;
    border-radius: var(--ck-tertiary-border-radius, 24px);
    box-shadow: var(--ck-tertiary-box-shadow, none);
    background: var(--ck-body-background-tertiary);
  }
`;
var LogoContainer = styled(motion.div)`
  z-index: 2;
  overflow: hidden;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 52px;
  height: 52px;
  border-radius: 100%;
  transition: inherit;
  background: var(--ck-body-background-secondary);
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.04);
  svg,
  img {
    display: block;
    width: 100%;
    height: 100%;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    width: 64px;
    height: 64px;
  }
`;
var StatusIcon = styled(motion.div)`
  z-index: 2;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  width: 52px;
  height: 52px;
  color: currentColor;
  border-radius: 100%;
  transition: inherit;
  svg {
    z-index: 3;
    position: relative;
    transform: scale(0.89);
    transition: inherit;
    opacity: 0.5;
  }
  &:before {
    z-index: 1;
    content: '';
    position: absolute;
    inset: 10px;
    border-radius: inherit;
    border: 1px dashed var(--border-color);
    background: var(--ck-body-background);
    transition: inherit;
    animation: ${spinKeyframes} 10s linear infinite;
  }
  &:after {
    z-index: 2;
    content: '';
    position: absolute;
    inset: 0;
    border-radius: inherit;
    background: #34c759;
    box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.04);
    transform: scale(0);
    transition: inherit;
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    width: 64px;
    height: 64px;
    svg {
      transform: scale(1.1);
    }
  }
`;
var StatusGraphicBgSvg = styled(motion.svg)`
  display: block;
  position: relative;
  margin: 0 auto;
  transition: inherit;
  overflow: visible;
  rect {
    stroke: var(--border-color);
    rx: var(--ck-border-radius);
  }
  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    display: none;
  }
`;
var StatusGraphic = styled(motion.div)`
  --border-color: var(--ck-siwe-border, var(--ck-body-divider));
  --border-size: 0;
  --border-style: dashed;

  user-select: none;
  pointer-events: none;
  position: relative;
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 14px;
  width: 100%;
  margin: 12px auto;
  padding: 42px 32px;
  transition: all 320ms cubic-bezier(0.175, 0.885, 0.32, 1.1);
  border: var(--border-size) var(--border-style) var(--border-color);
  border-radius: var(--ck-border-radius);

  @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
    --border-size: 1px;
    margin: 0 auto 20px;
    padding: 38px 0;
    gap: 18px;
    + div {
      // easier than wrapping in another styled component
      padding-bottom: 10px;
    }
  }

  > div {
    z-index: 2;
    position: relative;
    transition: inherit;
  }

  &:before,
  &:after {
    z-index: 1;
    content: '';
    position: absolute;
    top: 50%;
    left: 50%;
    width: 120px;
    height: 1px;
    margin-left: -60px;
    transition: inherit;
    animation: ${lineKeyframes} 10s linear infinite;
    background: linear-gradient(
      90deg,
      var(--border-color),
      var(--border-color) 50%,
      transparent 50%,
      transparent 100%
    );
    background-size: 6px 1px;
  }

  &:after {
    background: var(--border-color);
    transform: scaleX(0);
  }

  ${({ $connected }) => $connected && Ae`
      &:before {
        opacity: 0;
      }
      &:after {
        transform: none;
      }
      ${StatusGraphicBgSvg} {
        rect {
          stroke-dasharray: 0 0;
        }
      }
      ${LogoContainer} {
        transform: scale(0.62);
      }
      ${StatusIcon} {
        svg {
          transform: scale(1.5);
          opacity: 1;
          color: #fff;
        }
        &:before {
          transform: scale(0);
        }
        &:after {
          transform: scale(1);
        }
      }
      @media only screen and (max-width: ${defaultTheme.mobileWidth}px) {
        --border-size: 1px;
        --border-style: solid;
        ${StatusIcon} {
          svg {
            transform: scale(1.75);
          }
        }
      }
    `};
`;
var SIWEButton = ({ showSignOutButton, onSignIn, onSignOut }) => {
  const isMounted = useIsMounted2();
  const locales = useLocales();
  const { setOpen } = useModal();
  const { isSignedIn, isReady, isLoading, isRejected, isSuccess, isError, signIn, signOut, error } = useSIWE({
    onSignIn: (data) => onSignIn === null || onSignIn === void 0 ? void 0 : onSignIn(data),
    onSignOut: () => onSignOut === null || onSignOut === void 0 ? void 0 : onSignOut()
  });
  const { address: connectedAddress } = useAccount();
  function getButtonLabel() {
    if (isSuccess)
      return locales.signedIn;
    if (isRejected)
      return locales.tryAgain;
    if (isLoading)
      return locales.awaitingConfirmation;
    if (isError)
      return error !== null && error !== void 0 ? error : "Unknown Error";
    if (isReady)
      return locales.signIn;
    return locales.signIn;
  }
  if (!isMounted) {
    return (0, import_jsx_runtime.jsx)(Button, { style: { margin: 0 }, disabled: true }, "loading");
  }
  if (showSignOutButton && isSignedIn) {
    return (0, import_jsx_runtime.jsx)(Button, { style: { margin: 0 }, onClick: signOut, icon: (0, import_jsx_runtime.jsx)(DisconnectIcon, {}), children: locales.signOut }, "button");
  }
  if (!connectedAddress) {
    return (0, import_jsx_runtime.jsx)(Button, { style: { margin: 0 }, onClick: () => setOpen(true), arrow: true, children: locales.walletNotConnected }, "button");
  }
  return (0, import_jsx_runtime.jsx)(Button, { style: { margin: 0 }, arrow: !isSignedIn ? !isLoading && !isRejected : false, onClick: !isLoading && !isSuccess ? signIn : void 0, disabled: isLoading, waiting: isLoading, icon: isRejected && (0, import_jsx_runtime.jsx)(motion.div, { initial: {
    rotate: -270
  }, animate: {
    rotate: 0
  }, transition: {
    duration: 1,
    ease: [0.175, 0.885, 0.32, 0.98]
  }, children: (0, import_jsx_runtime.jsx)(RetryIcon, { style: { opacity: 0.4 } }) }), children: getButtonLabel() }, "button");
};
var LazyImage = ({ src, alt, width, height }) => {
  const imageRef = (0, import_react70.useRef)(null);
  const [loaded, setLoaded] = (0, import_react70.useState)(true);
  (0, import_react70.useEffect)(() => {
    if (!(imageRef.current && imageRef.current.complete && imageRef.current.naturalHeight !== 0)) {
      setLoaded(false);
    }
  }, [src]);
  return (0, import_jsx_runtime.jsx)("div", { style: {
    width,
    height,
    background: "rgba(0,0,0,0.02)",
    boxShadow: "inset 0 0 0 1px rgba(0,0,0,0.02)"
  }, children: (0, import_jsx_runtime.jsx)("img", { ref: imageRef, src, alt, width, height, onLoad: () => setLoaded(true), style: { transition: "opacity 0.2s ease", opacity: loaded ? 1 : 0 } }) });
};
var transition = { duration: 0.2, ease: [0.26, 0.08, 0.25, 1] };
var copyTransition = { duration: 0.16, ease: [0.26, 0.08, 0.25, 1] };
var SignInWithEthereum = () => {
  var _a2, _b;
  const context = useContext21();
  const { isSignedIn, reset: reset2 } = useSIWE();
  const mobile = isMobile();
  const [status, setStatus] = (0, import_react70.useState)(isSignedIn ? "signedIn" : "signedOut");
  const locales = useLocales({});
  const copy = status === "signedIn" ? {
    heading: locales.signInWithEthereumScreen_signedIn_heading,
    h1: locales.signInWithEthereumScreen_signedIn_h1,
    p: locales.signInWithEthereumScreen_signedIn_p,
    button: locales.signInWithEthereumScreen_signedIn_button
  } : {
    heading: locales.signInWithEthereumScreen_signedOut_heading,
    h1: locales.signInWithEthereumScreen_signedOut_h1,
    p: locales.signInWithEthereumScreen_signedOut_p,
    button: locales.signInWithEthereumScreen_signedOut_button
  };
  (0, import_react70.useEffect)(() => {
    if (isSignedIn)
      setStatus("signedIn");
  }, []);
  (0, import_react70.useEffect)(() => {
    if (!isSignedIn)
      setStatus("signedOut");
  }, [isSignedIn]);
  const { address } = useAccount();
  const getFavicons = () => {
    const favicons2 = {
      svg: null,
      default: null
    };
    const nodeList = document.getElementsByTagName("link");
    Array.from(nodeList).forEach((node) => {
      if ((node.getAttribute("rel") === "icon" || node.getAttribute("rel") === "shortcut icon") && node.getAttribute("href")) {
        if (node.getAttribute("type") === "image/svg+xml") {
          favicons2.svg = node.getAttribute("href");
        } else {
          favicons2.default = node.getAttribute("href");
        }
      }
    });
    return favicons2;
  };
  const favicons = getFavicons();
  const favicon = (_b = (_a2 = getAppIcon()) !== null && _a2 !== void 0 ? _a2 : favicons.svg) !== null && _b !== void 0 ? _b : favicons.default;
  return (0, import_jsx_runtime.jsx)(PageContent, { style: { width: 278 }, children: (0, import_jsx_runtime.jsxs)(ModalContent, { style: { padding: 0, marginTop: -10 }, children: [(0, import_jsx_runtime.jsx)(ContentContainer, { children: (0, import_jsx_runtime.jsx)(AnimatePresence, { exitBeforeEnter: true, children: (0, import_jsx_runtime.jsx)(motion.div, { initial: mobile ? false : { opacity: 0, scale: 0.94 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.94 }, transition: copyTransition, children: (0, import_jsx_runtime.jsx)(ModalBody, { style: { height: 42 }, children: (0, import_jsx_runtime.jsx)(FitText, { children: copy.h1 }) }) }, flattenChildren(copy.h1).toString()) }) }), (0, import_jsx_runtime.jsxs)(StatusGraphic, { "$connected": isSignedIn, children: [(0, import_jsx_runtime.jsx)("div", { style: { position: "absolute", inset: 0 }, children: (0, import_jsx_runtime.jsx)(StatusGraphicBgSvg, { width: "262", height: "134", viewBox: "0 0 262 134", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)(motion.rect, { x: "0", y: "0", rx: "12", width: "262", height: "134", strokeDasharray: "3 3", animate: {
    strokeDashoffset: [0, -6]
  }, transition: {
    duration: 0.4,
    ease: "linear",
    repeat: Infinity
  } }) }) }), (0, import_jsx_runtime.jsx)(motion.div, { initial: mobile ? false : {
    opacity: 0,
    x: 50,
    scale: 0.8
  }, animate: {
    opacity: 1,
    x: 0,
    scale: 1
  }, transition, children: (0, import_jsx_runtime.jsx)(LogoContainer, { children: (0, import_jsx_runtime.jsx)(Avatar, { address, size: 64 }) }) }, "avatarImage"), (0, import_jsx_runtime.jsx)(motion.div, { initial: mobile ? false : {
    scale: 0.6
  }, animate: {
    scale: 1
  }, transition: {
    ...transition
  }, children: (0, import_jsx_runtime.jsx)(StatusIcon, { children: (0, import_jsx_runtime.jsx)(TickIcon, {}) }) }, "tickIcon"), (0, import_jsx_runtime.jsx)(motion.div, { initial: mobile ? false : {
    opacity: 0,
    x: -40,
    scale: 0.8
  }, animate: {
    opacity: 1,
    x: 0,
    scale: 1
  }, transition: {
    ...transition
  }, children: (0, import_jsx_runtime.jsx)(LogoContainer, { children: favicon ? (0, import_jsx_runtime.jsx)(LazyImage, { src: favicon, alt: "app" }) : (0, import_jsx_runtime.jsx)(Chains.UnknownChain, {}) }) }, "appLogo")] }, "status"), (0, import_jsx_runtime.jsx)(AnimatePresence, { exitBeforeEnter: true, children: (0, import_jsx_runtime.jsx)(motion.div, { style: { paddingBottom: mobile ? 24 : 12 }, initial: mobile ? false : { opacity: 0, scale: 0.94 }, animate: { opacity: 1, scale: 1 }, exit: { opacity: 0, scale: 0.94 }, transition: copyTransition, children: (0, import_jsx_runtime.jsx)(ModalBody, { style: { height: 42, marginTop: -1, marginBottom: -3 }, children: (0, import_jsx_runtime.jsx)(FitText, { children: copy.p }) }) }, flattenChildren(copy.p).toString()) }), (0, import_jsx_runtime.jsx)(SIWEButton, { showSignOutButton: status === "signedIn", onSignIn: () => {
    setTimeout(() => {
      context.setOpen(false);
    }, 1e3);
  } })] }) });
};
var customThemeDefault$1 = {};
var ConnectModal$1 = ({ mode: mode3 = "auto", theme = "auto", customTheme = customThemeDefault$1, lang = "en-US" }) => {
  var _a2;
  const context = useContext21();
  const { isConnected: isConnected2, chain: chain2 } = useAccount();
  const chainIsSupported = useChainIsSupported(chain2 === null || chain2 === void 0 ? void 0 : chain2.id);
  const closeable = !(((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.enforceSupportedChains) && isConnected2 && !chainIsSupported);
  const showBackButton = closeable && context.route !== routes.CONNECTORS && context.route !== routes.PROFILE;
  const showInfoButton = closeable && context.route !== routes.PROFILE;
  const onBack = () => {
    if (context.route === routes.SIGNINWITHETHEREUM) {
      context.setRoute(routes.PROFILE);
    } else if (context.route === routes.SWITCHNETWORKS) {
      context.setRoute(routes.PROFILE);
    } else if (context.route === routes.DOWNLOAD) {
      context.setRoute(routes.CONNECT);
    } else {
      context.setRoute(routes.CONNECTORS);
    }
  };
  const pages = {
    onboarding: (0, import_jsx_runtime.jsx)(Introduction, {}),
    about: (0, import_jsx_runtime.jsx)(About, {}),
    download: (0, import_jsx_runtime.jsx)(DownloadApp, {}),
    connectors: (0, import_jsx_runtime.jsx)(Wallets, {}),
    mobileConnectors: (0, import_jsx_runtime.jsx)(MobileConnectors, {}),
    connect: (0, import_jsx_runtime.jsx)(ConnectUsing, {}),
    profile: (0, import_jsx_runtime.jsx)(Profile, {}),
    switchNetworks: (0, import_jsx_runtime.jsx)(SwitchNetworks, {}),
    signInWithEthereum: (0, import_jsx_runtime.jsx)(SignInWithEthereum, {})
  };
  function hide() {
    context.setOpen(false);
  }
  (0, import_react70.useEffect)(() => {
    var _a3;
    if (isConnected2) {
      if (context.route !== routes.PROFILE || context.route !== routes.SIGNINWITHETHEREUM) {
        if (context.signInWithEthereum && !((_a3 = context.options) === null || _a3 === void 0 ? void 0 : _a3.disableSiweRedirect)) {
          context.setRoute(routes.SIGNINWITHETHEREUM);
        } else {
          hide();
        }
      }
    } else {
      hide();
    }
  }, [isConnected2]);
  (0, import_react70.useEffect)(() => context.setMode(mode3), [mode3]);
  (0, import_react70.useEffect)(() => context.setTheme(theme), [theme]);
  (0, import_react70.useEffect)(() => context.setCustomTheme(customTheme), [customTheme]);
  (0, import_react70.useEffect)(() => context.setLang(lang), [lang]);
  (0, import_react70.useEffect)(() => {
    const appName = getAppName();
    if (!appName || !context.open)
      return;
    const title = document.createElement("meta");
    title.setAttribute("property", "og:title");
    title.setAttribute("content", appName);
    document.head.prepend(title);
    return () => {
      document.head.removeChild(title);
    };
  }, [context.open]);
  return (0, import_jsx_runtime.jsx)(ConnectKitThemeProvider, { theme, customTheme, mode: mode3, children: (0, import_jsx_runtime.jsx)(Modal, { open: context.open, pages, pageId: context.route, onClose: closeable ? hide : void 0, onInfo: showInfoButton ? () => context.setRoute(routes.ABOUT) : void 0, onBack: showBackButton ? onBack : void 0 }) });
};
function useGoogleFont(font) {
  (0, import_react70.useEffect)(() => {
    if (!font)
      return;
    font = font.replace(/ /g, "+");
    const googleapis = document.createElement("link");
    googleapis.href = `https://fonts.googleapis.com`;
    googleapis.rel = "preconnect";
    const gstatic = document.createElement("link");
    gstatic.href = `https://fonts.gstatic.com`;
    gstatic.rel = "preconnect";
    gstatic.crossOrigin = "true";
    const link = document.createElement("link");
    link.href = `https://fonts.googleapis.com/css2?family=${font}:wght@400;500;600&display=swap`;
    link.rel = "stylesheet";
    document.head.appendChild(googleapis);
    document.head.appendChild(gstatic);
    document.head.appendChild(link);
    return () => {
      document.head.removeChild(googleapis);
      document.head.removeChild(gstatic);
      document.head.removeChild(link);
    };
  }, [font]);
}
function useThemeFont(theme) {
  var _a2;
  const themeFonts = {
    web95: "Lato",
    retro: "Nunito",
    midnight: "Inter",
    minimal: "Inter",
    rounded: "Nunito"
  };
  const font = (_a2 = themeFonts[theme]) !== null && _a2 !== void 0 ? _a2 : null;
  useGoogleFont(font !== null && font !== void 0 ? font : "");
}
var useConnectCallback = ({ onConnect, onDisconnect }) => {
  useAccountEffect({
    onConnect: ({ address, connector, isReconnected }) => {
      if (!isReconnected) {
        onConnect === null || onConnect === void 0 ? void 0 : onConnect({
          address,
          connectorId: connector === null || connector === void 0 ? void 0 : connector.id
        });
      }
    },
    onDisconnect: () => onDisconnect === null || onDisconnect === void 0 ? void 0 : onDisconnect()
  });
};
var routes = {
  ONBOARDING: "onboarding",
  ABOUT: "about",
  CONNECTORS: "connectors",
  MOBILECONNECTORS: "mobileConnectors",
  CONNECT: "connect",
  DOWNLOAD: "download",
  PROFILE: "profile",
  SWITCHNETWORKS: "switchNetworks",
  SIGNINWITHETHEREUM: "signInWithEthereum"
};
var Context = (0, import_react70.createContext)(null);
var ConnectKitProvider = ({ children, theme = "auto", mode: mode3 = "auto", customTheme, options, onConnect, onDisconnect, debugMode = false }) => {
  var _a2, _b, _c2, _d;
  if (!import_react70.default.useContext(WagmiContext)) {
    throw Error("ConnectKitProvider must be within a WagmiProvider");
  }
  if (import_react70.default.useContext(Context)) {
    throw new Error("Multiple, nested usages of ConnectKitProvider detected. Please use only one.");
  }
  useConnectCallback({
    onConnect,
    onDisconnect
  });
  const chains = useChains2();
  const injectedConnector = useConnector("injected");
  const defaultOptions = {
    language: "en-US",
    hideBalance: false,
    hideTooltips: false,
    hideQuestionMarkCTA: false,
    hideNoWalletCTA: false,
    walletConnectCTA: "link",
    hideRecentBadge: false,
    avoidLayoutShift: true,
    embedGoogleFonts: false,
    truncateLongENSAddress: true,
    walletConnectName: void 0,
    reducedMotion: false,
    disclaimer: null,
    bufferPolyfill: true,
    customAvatar: void 0,
    initialChainId: (_a2 = chains === null || chains === void 0 ? void 0 : chains[0]) === null || _a2 === void 0 ? void 0 : _a2.id,
    enforceSupportedChains: false,
    ethereumOnboardingUrl: void 0,
    walletOnboardingUrl: void 0,
    disableSiweRedirect: false
  };
  const opts = Object.assign({}, defaultOptions, options);
  if (typeof window !== "undefined") {
    if (opts.bufferPolyfill)
      window.Buffer = (_b = window.Buffer) !== null && _b !== void 0 ? _b : import_buffer.Buffer;
  }
  const [ckTheme, setTheme] = (0, import_react70.useState)(theme);
  const [ckMode, setMode] = (0, import_react70.useState)(mode3);
  const [ckCustomTheme, setCustomTheme] = (0, import_react70.useState)(customTheme !== null && customTheme !== void 0 ? customTheme : {});
  const [ckLang, setLang] = (0, import_react70.useState)("en-US");
  const [open, setOpen] = (0, import_react70.useState)(false);
  const [connector, setConnector] = (0, import_react70.useState)({
    id: ""
  });
  const [route, setRoute] = (0, import_react70.useState)(routes.CONNECTORS);
  const [errorMessage, setErrorMessage] = (0, import_react70.useState)("");
  const [resize2, onResize] = (0, import_react70.useState)(0);
  if (opts.embedGoogleFonts)
    useThemeFont(theme);
  (0, import_react70.useEffect)(() => setTheme(theme), [theme]);
  (0, import_react70.useEffect)(() => setLang(opts.language || "en-US"), [opts.language]);
  (0, import_react70.useEffect)(() => setErrorMessage(null), [route, open]);
  const { chain: chain2, isConnected: isConnected2 } = useAccount();
  const isChainSupported = useChainIsSupported(chain2 === null || chain2 === void 0 ? void 0 : chain2.id);
  (0, import_react70.useEffect)(() => {
    if (isConnected2 && opts.enforceSupportedChains && !isChainSupported) {
      setOpen(true);
      setRoute(routes.SWITCHNETWORKS);
    }
  }, [isConnected2, isChainSupported, chain2, route, open]);
  (0, import_react70.useEffect)(() => {
    if (isFamily()) {
      injectedConnector === null || injectedConnector === void 0 ? void 0 : injectedConnector.connect();
    }
  }, [injectedConnector]);
  const log = debugMode ? console.log : () => {
  };
  const value = {
    theme: ckTheme,
    setTheme,
    mode: ckMode,
    setMode,
    customTheme,
    setCustomTheme,
    lang: ckLang,
    setLang,
    open,
    setOpen,
    route,
    setRoute,
    connector,
    setConnector,
    signInWithEthereum: (_d = (_c2 = import_react70.default.useContext(SIWEContext)) === null || _c2 === void 0 ? void 0 : _c2.enabled) !== null && _d !== void 0 ? _d : false,
    onConnect,
    // Other configuration
    options: opts,
    errorMessage,
    debugMode,
    log,
    displayError: (message, code) => {
      setErrorMessage(message);
      console.log("---------CONNECTKIT DEBUG---------");
      console.log(message);
      if (code)
        console.table(code);
      console.log("---------/CONNECTKIT DEBUG---------");
    },
    resize: resize2,
    triggerResize: () => onResize((prev) => prev + 1)
  };
  return (0, import_react70.createElement)(Context.Provider, { value }, (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: (0, import_jsx_runtime.jsx)(Web3ContextProvider, { enabled: open, children: (0, import_jsx_runtime.jsxs)(Le, { theme: defaultTheme$1, children: [children, (0, import_jsx_runtime.jsx)(ConnectModal$1, { lang: ckLang, theme: ckTheme, mode: mode3, customTheme: ckCustomTheme })] }) }) }));
};
var useContext21 = () => {
  const context = import_react70.default.useContext(Context);
  if (!context)
    throw Error("ConnectKit Hook must be inside a Provider.");
  return context;
};
var safeRoutes = {
  disconnected: [
    routes.CONNECTORS,
    routes.ABOUT,
    routes.ONBOARDING,
    routes.MOBILECONNECTORS,
    routes.ONBOARDING
  ],
  connected: [routes.PROFILE, routes.SWITCHNETWORKS, routes.SIGNINWITHETHEREUM]
};
var allRoutes = [
  ...safeRoutes.connected,
  ...safeRoutes.disconnected
];
var useModal = ({ onConnect, onDisconnect } = {}) => {
  const context = useContext21();
  useConnectCallback({
    onConnect,
    onDisconnect
  });
  const { isConnected: isConnected2 } = useAccount();
  const { signIn } = useSIWE();
  const close = () => {
    context.setOpen(false);
  };
  const open = () => {
    context.setOpen(true);
  };
  const gotoAndOpen = (route) => {
    let validRoute = route;
    if (!allRoutes.includes(route)) {
      validRoute = isConnected2 ? routes.PROFILE : routes.CONNECTORS;
      context.log(`Route ${route} is not a valid route, navigating to ${validRoute} instead.`);
    } else {
      if (isConnected2) {
        if (!safeRoutes.connected.includes(route)) {
          validRoute = routes.PROFILE;
          context.log(`Route ${route} is not a valid route when connected, navigating to ${validRoute} instead.`);
        }
      } else {
        if (!safeRoutes.disconnected.includes(route)) {
          validRoute = routes.CONNECTORS;
          context.log(`Route ${route} is not a valid route when disconnected, navigating to ${validRoute} instead.`);
        }
      }
    }
    context.setRoute(validRoute);
    open();
  };
  return {
    open: context.open,
    setOpen: (show) => {
      if (show) {
        gotoAndOpen(isConnected2 ? routes.PROFILE : routes.CONNECTORS);
      } else {
        close();
      }
    },
    // Disconnected Routes
    openAbout: () => gotoAndOpen(routes.ABOUT),
    openOnboarding: () => gotoAndOpen(routes.ONBOARDING),
    // Connected Routes
    openProfile: () => gotoAndOpen(routes.PROFILE),
    openSwitchNetworks: () => gotoAndOpen(routes.SWITCHNETWORKS),
    openSIWE: (triggerSIWE) => {
      gotoAndOpen(routes.SIGNINWITHETHEREUM);
      if (triggerSIWE)
        signIn();
    }
  };
};
var TextContainer = styled(motion.div)`
  top: 0;
  bottom: 0;
  left: 0;
  display: inline-flex;
  align-items: center;
  justify-content: center;
  white-space: nowrap;
`;
styled(motion.div)`
  position: relative;
  width: 24px;
  height: 24px;
  border-radius: 12px;
  overflow: hidden;
  svg {
    display: block;
  }
`;
var IconContainer = styled(motion.div)`
  pointer-events: none;
  user-select: none;
  position: relative;
  width: 24px;
  height: 24px;
  margin-right: 8px;
`;
var UnsupportedNetworkContainer = styled(motion.div)`
  z-index: 1;
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  border-radius: 100%;
  box-shadow: inset 0 0 0 1px rgba(0, 0, 0, 0.02);
  background: var(--ck-body-color-danger, red);
  color: #fff;
  svg {
    display: block;
    position: relative;
    top: -1px;
  }
`;
var Container$2 = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: flex-start;
  position: relative;
  height: 40px;
  padding: 0;
  line-height: 0;
  letter-spacing: -0.2px;
  font-size: var(--ck-connectbutton-font-size, 16px);
  font-weight: var(--ck-connectbutton-font-weight, 500);
  text-align: center;
  transition: 100ms ease;
  transition-property: color, background, box-shadow, border-radius;

  color: var(--color);
  background: var(--background);
  box-shadow: var(--box-shadow);
  border-radius: var(--border-radius);

  &.primary {
    --color: var(--ck-connectbutton-color);
    --background: var(--ck-connectbutton-background);
    --box-shadow: var(--ck-connectbutton-box-shadow);
    --border-radius: var(--ck-connectbutton-border-radius, 12px);

    --hover-color: var(--ck-connectbutton-hover-color, var(--color));
    --hover-background: var(
      --ck-connectbutton-hover-background,
      var(--background)
    );
    --hover-box-shadow: var(
      --ck-connectbutton-hover-box-shadow,
      var(--box-shadow)
    );
    --hover-border-radius: var(
      --ck-connectbutton-hover-border-radius,
      var(--border-radius)
    );

    --active-color: var(--ck-connectbutton-active-color, var(--hover-color));
    --active-background: var(
      --ck-connectbutton-active-background,
      var(--hover-background)
    );
    --active-box-shadow: var(
      --ck-connectbutton-active-box-shadow,
      var(--hover-box-shadow)
    );
    --active-border-radius: var(
      --ck-connectbutton-active-border-radius,
      var(--hover-border-radius)
    );
  }
  &.secondary {
    --color: var(--ck-connectbutton-balance-color);
    --background: var(--ck-connectbutton-balance-background);
    --box-shadow: var(--ck-connectbutton-balance-box-shadow);
    --border-radius: var(
      --ck-connectbutton-balance-border-radius,
      var(--ck-connectbutton-border-radius, 12px)
    );

    --hover-color: var(--ck-connectbutton-balance-hover-color, var(--color));
    --hover-background: var(
      --ck-connectbutton-balance-hover-background,
      var(--background)
    );
    --hover-box-shadow: var(
      --ck-connectbutton-balance-hover-box-shadow,
      var(--box-shadow)
    );
    --hover-border-radius: var(
      --ck-connectbutton-balance-hover-border-radius,
      var(--border-radius)
    );

    --active-color: var(
      --ck-connectbutton-balance-active-color,
      var(--hover-color)
    );
    --active-background: var(
      --ck-connectbutton-balance-active-background,
      var(--hover-background)
    );
    --active-box-shadow: var(
      --ck-connectbutton-balance-active-box-shadow,
      var(--hover-box-shadow)
    );
    --active-border-radius: var(
      --ck-connectbutton-balance-active-border-radius,
      var(--hover-border-radius)
    );
  }
`;
var ThemeContainer = styled.button`
  all: initial;
  appearance: none;
  user-select: none;
  position: relative;
  padding: 0;
  margin: 0;
  background: none;
  border-radius: var(--ck-border-radius);

  &:disabled {
    pointer-events: none;
    opacity: 0.3;
  }

  display: flex;
  flex-wrap: nowrap;
  background: none;
  cursor: pointer;
  * {
    cursor: pointer;
  }
  &:hover {
    ${Container$2} {
      color: var(--hover-color, var(--color));
      background: var(--hover-background, var(--background));
      box-shadow: var(--hover-box-shadow, var(--box-shadow));
      border-radius: var(--hover-border-radius, var(--border-radius));
    }
  }
  &:active {
    ${Container$2} {
      color: var(--active-color, var(--hover-color, var(--color)));
      background: var(
        --active-background,
        var(--hover-background, var(--background))
      );
      box-shadow: var(
        --active-box-shadow,
        var(--hover-box-shadow, var(--box-shadow))
      );
      border-radius: var(
        --active-border-radius,
        var(--hover-border-radius, var(--border-radius))
      );
    }
  }
  &:focus-visible {
    outline: 2px solid var(--ck-family-brand);
  }
`;
var ThemedButton = ({ children, variant = "primary", autoSize = true, duration = 0.3, style: style2 }) => {
  const [contentRef, bounds] = j2();
  return (0, import_jsx_runtime.jsx)(Container$2, { className: variant, initial: false, animate: autoSize ? {
    width: bounds.width > 10 ? bounds.width : "auto"
  } : void 0, transition: {
    duration,
    ease: [0.25, 1, 0.5, 1],
    delay: 0.01
  }, style: style2, children: (0, import_jsx_runtime.jsx)("div", { ref: contentRef, style: {
    whiteSpace: "nowrap",
    width: "fit-content",
    position: "relative",
    padding: "0 12px"
  }, children }) });
};
var Container$1 = styled(motion.div)`
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 8px;
`;
var PlaceholderKeyframes = We`
  0%,100%{ opacity: 0.1; transform: scale(0.75); }
  50%{ opacity: 0.75; transform: scale(1.2) }
`;
var PulseContainer = styled.div`
  pointer-events: none;
  user-select: none;
  padding: 0 5px;
  span {
    display: inline-block;
    vertical-align: middle;
    margin: 0 2px;
    width: 3px;
    height: 3px;
    border-radius: 4px;
    background: currentColor;
    animation: ${PlaceholderKeyframes} 1000ms ease infinite both;
  }
`;
var Balance = ({ hideIcon, hideSymbol }) => {
  const isMounted = useIsMounted2();
  const [isInitial, setIsInitial] = (0, import_react70.useState)(true);
  const { address, chain: chain2 } = useAccount();
  useChains2();
  const isChainSupported = useChainIsSupported(chain2 === null || chain2 === void 0 ? void 0 : chain2.id);
  const queryClient = useQueryClient();
  const { data: blockNumber } = useBlockNumber({ watch: true });
  const { data: balance, queryKey } = useBalance({
    address,
    chainId: chain2 === null || chain2 === void 0 ? void 0 : chain2.id
  });
  (0, import_react70.useEffect)(() => {
    if (blockNumber !== null && blockNumber !== void 0 ? blockNumber : 0 % 5 === 0)
      queryClient.invalidateQueries({ queryKey });
  }, [blockNumber, queryKey]);
  const currentChain = chainConfigs.find((c3) => c3.id === (chain2 === null || chain2 === void 0 ? void 0 : chain2.id));
  const state = `${!isMounted || (balance === null || balance === void 0 ? void 0 : balance.formatted) === void 0 ? `balance-loading` : `balance-${currentChain === null || currentChain === void 0 ? void 0 : currentChain.id}-${balance === null || balance === void 0 ? void 0 : balance.formatted}`}`;
  (0, import_react70.useEffect)(() => {
    setIsInitial(false);
  }, []);
  return (0, import_jsx_runtime.jsx)("div", { style: { position: "relative" }, children: (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: (0, import_jsx_runtime.jsx)(motion.div, { initial: (balance === null || balance === void 0 ? void 0 : balance.formatted) !== void 0 && isInitial ? {
    opacity: 1
  } : { opacity: 0, position: "absolute", top: 0, left: 0, bottom: 0 }, animate: { opacity: 1, position: "relative" }, exit: {
    opacity: 0,
    position: "absolute",
    top: 0,
    left: 0,
    bottom: 0
  }, transition: {
    duration: 0.4,
    ease: [0.25, 1, 0.5, 1],
    delay: 0.4
  }, children: !address || !isMounted || (balance === null || balance === void 0 ? void 0 : balance.formatted) === void 0 ? (0, import_jsx_runtime.jsxs)(Container$1, { children: [!hideIcon && (0, import_jsx_runtime.jsx)(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id }), (0, import_jsx_runtime.jsx)("span", { style: { minWidth: 32 }, children: (0, import_jsx_runtime.jsxs)(PulseContainer, { children: [(0, import_jsx_runtime.jsx)("span", { style: { animationDelay: "0ms" } }), (0, import_jsx_runtime.jsx)("span", { style: { animationDelay: "50ms" } }), (0, import_jsx_runtime.jsx)("span", { style: { animationDelay: "100ms" } })] }) })] }) : !isChainSupported ? (0, import_jsx_runtime.jsxs)(Container$1, { children: [!hideIcon && (0, import_jsx_runtime.jsx)(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id }), (0, import_jsx_runtime.jsx)("span", { style: { minWidth: 32 }, children: "???" })] }) : (0, import_jsx_runtime.jsxs)(Container$1, { children: [!hideIcon && (0, import_jsx_runtime.jsx)(Chain, { id: chain2 === null || chain2 === void 0 ? void 0 : chain2.id }), (0, import_jsx_runtime.jsx)("span", { style: { minWidth: 32 }, children: nFormatter(Number(balance === null || balance === void 0 ? void 0 : balance.formatted)) }), !hideSymbol && ` ${balance === null || balance === void 0 ? void 0 : balance.symbol}`] }) }, state) }) });
};
var contentVariants = {
  initial: {
    zIndex: 2,
    opacity: 0,
    x: "-100%"
  },
  animate: {
    opacity: 1,
    x: 0.1,
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  },
  exit: {
    zIndex: 1,
    opacity: 0,
    x: "-100%",
    pointerEvents: "none",
    position: "absolute",
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  }
};
var addressVariants = {
  initial: {
    zIndex: 2,
    opacity: 0,
    x: "100%"
  },
  animate: {
    x: 0.2,
    opacity: 1,
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  },
  exit: {
    zIndex: 1,
    x: "100%",
    opacity: 0,
    pointerEvents: "none",
    position: "absolute",
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  }
};
var textVariants = {
  initial: {
    opacity: 0
  },
  animate: {
    opacity: 1,
    transition: {
      duration: 0.3,
      ease: [0.25, 1, 0.5, 1]
    }
  },
  exit: {
    position: "absolute",
    opacity: 0,
    transition: {
      duration: 0.3,
      ease: [0.25, 1, 0.5, 1]
    }
  }
};
var ConnectButtonRenderer = ({ children }) => {
  const isMounted = useIsMounted2();
  const context = useContext21();
  const { open, setOpen } = useModal();
  const { address, isConnected: isConnected2, chain: chain2 } = useAccount();
  const isChainSupported = useChainIsSupported(chain2 === null || chain2 === void 0 ? void 0 : chain2.id);
  const ensFallbackConfig2 = useEnsFallbackConfig();
  const { data: ensName } = useEnsName({
    chainId: 1,
    address,
    config: ensFallbackConfig2
  });
  function hide() {
    setOpen(false);
  }
  function show() {
    setOpen(true);
    context.setRoute(isConnected2 ? routes.PROFILE : routes.CONNECTORS);
  }
  if (!children)
    return null;
  if (!isMounted)
    return null;
  return (0, import_jsx_runtime.jsx)(import_jsx_runtime.Fragment, { children: children({
    show,
    hide,
    chain: chain2,
    unsupported: !isChainSupported,
    isConnected: !!address,
    isConnecting: open,
    // Using `open` to determine if connecting as wagmi isConnecting only is set to true when an active connector is awaiting connection
    address,
    truncatedAddress: address ? truncateEthAddress(address) : void 0,
    ensName: ensName === null || ensName === void 0 ? void 0 : ensName.toString()
  }) });
};
ConnectButtonRenderer.displayName = "ConnectKitButton.Custom";
function ConnectKitButtonInner({ label, showAvatar, separator }) {
  var _a2;
  const locales = useLocales({});
  const context = useContext21();
  const { isSignedIn } = useSIWE();
  const { address, chain: chain2 } = useAccount();
  const isChainSupported = useChainIsSupported(chain2 === null || chain2 === void 0 ? void 0 : chain2.id);
  const ensFallbackConfig2 = useEnsFallbackConfig();
  const { data: ensName } = useEnsName({
    chainId: 1,
    address,
    config: ensFallbackConfig2
  });
  const defaultLabel = locales.connectWallet;
  return (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: address ? (0, import_jsx_runtime.jsxs)(TextContainer, { initial: "initial", animate: "animate", exit: "exit", variants: addressVariants, style: {
    height: 40
    //padding: !showAvatar ? '0 5px' : undefined,
  }, children: [showAvatar && (0, import_jsx_runtime.jsxs)(IconContainer, { children: [(0, import_jsx_runtime.jsxs)(AnimatePresence, { initial: false, children: [isSignedIn && (0, import_jsx_runtime.jsx)(motion.div, { style: {
    zIndex: 2,
    position: "absolute",
    bottom: 0,
    right: 0
  }, initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: (0, import_jsx_runtime.jsx)(AuthIcon, {}) }), !isChainSupported && (0, import_jsx_runtime.jsx)(UnsupportedNetworkContainer, { initial: { opacity: 0 }, animate: { opacity: 1 }, exit: { opacity: 0 }, children: (0, import_jsx_runtime.jsx)("svg", { width: "14", height: "14", viewBox: "0 0 14 14", fill: "none", xmlns: "http://www.w3.org/2000/svg", children: (0, import_jsx_runtime.jsx)("path", { d: "M1.68831 13.5H12.0764C13.1026 13.5 13.7647 12.7197 13.7647 11.763C13.7647 11.4781 13.6985 11.1863 13.5462 10.9149L8.34225 1.37526C8.02445 0.791754 7.45505 0.5 6.88566 0.5C6.31627 0.5 5.73364 0.791754 5.42246 1.37526L0.225108 10.9217C0.0728291 11.1863 0 11.4781 0 11.763C0 12.7197 0.662083 13.5 1.68831 13.5ZM6.88566 8.8048C6.49503 8.8048 6.27655 8.5809 6.26331 8.1738L6.16399 5.0595C6.15075 4.64562 6.44869 4.34708 6.87904 4.34708C7.30278 4.34708 7.61396 4.6524 7.60071 5.06628L7.5014 8.16701C7.48154 8.5809 7.26305 8.8048 6.88566 8.8048ZM6.88566 11.3492C6.44207 11.3492 6.07792 11.0303 6.07792 10.5757C6.07792 10.1211 6.44207 9.80219 6.88566 9.80219C7.32926 9.80219 7.69341 10.1143 7.69341 10.5757C7.69341 11.0371 7.32264 11.3492 6.88566 11.3492Z", fill: "currentColor" }) }) })] }), (0, import_jsx_runtime.jsx)(Avatar, { size: 24, address })] }), (0, import_jsx_runtime.jsx)("div", { style: {
    position: "relative",
    paddingRight: showAvatar ? 1 : 0
  }, children: (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: ensName ? (0, import_jsx_runtime.jsx)(TextContainer, { initial: "initial", animate: "animate", exit: "exit", variants: textVariants, style: {
    position: ensName ? "relative" : "absolute"
  }, children: ((_a2 = context.options) === null || _a2 === void 0 ? void 0 : _a2.truncateLongENSAddress) ? truncateENSAddress(ensName, 20) : ensName }, "ckEnsName") : (0, import_jsx_runtime.jsxs)(TextContainer, { initial: "initial", animate: "animate", exit: "exit", variants: textVariants, style: {
    position: ensName ? "absolute" : "relative"
  }, children: [truncateEthAddress(address, separator), " "] }, "ckTruncatedAddress") }) })] }, "connectedText") : (0, import_jsx_runtime.jsx)(TextContainer, { initial: "initial", animate: "animate", exit: "exit", variants: contentVariants, style: {
    height: 40
    //padding: '0 5px',
  }, children: label ? label : defaultLabel }, "connectWalletText") });
}
function ConnectKitButton({
  // Options
  label,
  showBalance = false,
  showAvatar = true,
  // Theming
  theme,
  mode: mode3,
  customTheme,
  // Events
  onClick
}) {
  var _a2;
  const isMounted = useIsMounted2();
  const context = useContext21();
  const { isConnected: isConnected2, address, chain: chain2 } = useAccount();
  const chainIsSupported = useChainIsSupported(chain2 === null || chain2 === void 0 ? void 0 : chain2.id);
  function show() {
    context.setOpen(true);
    context.setRoute(isConnected2 ? routes.PROFILE : routes.CONNECTORS);
  }
  const separator = ["web95", "rounded", "minimal"].includes((_a2 = theme !== null && theme !== void 0 ? theme : context.theme) !== null && _a2 !== void 0 ? _a2 : "") ? "...." : void 0;
  if (!isMounted)
    return null;
  const shouldShowBalance = showBalance && chainIsSupported;
  const willShowBalance = address && shouldShowBalance;
  return (0, import_jsx_runtime.jsx)(ResetContainer, { "$useTheme": theme !== null && theme !== void 0 ? theme : context.theme, "$useMode": mode3 !== null && mode3 !== void 0 ? mode3 : context.mode, "$customTheme": customTheme !== null && customTheme !== void 0 ? customTheme : context.customTheme, children: (0, import_jsx_runtime.jsxs)(ThemeContainer, { onClick: () => {
    if (onClick) {
      onClick(show);
    } else {
      show();
    }
  }, children: [shouldShowBalance && (0, import_jsx_runtime.jsx)(AnimatePresence, { initial: false, children: willShowBalance && (0, import_jsx_runtime.jsx)(motion.div, { initial: {
    opacity: 0,
    x: "100%",
    width: 0,
    marginRight: 0
  }, animate: {
    opacity: 1,
    x: 0,
    width: "auto",
    marginRight: -24,
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  }, exit: {
    opacity: 0,
    x: "100%",
    width: 0,
    marginRight: 0,
    transition: {
      duration: 0.4,
      ease: [0.25, 1, 0.5, 1]
    }
  }, children: (0, import_jsx_runtime.jsx)(ThemedButton, { variant: "secondary", theme: theme !== null && theme !== void 0 ? theme : context.theme, mode: mode3 !== null && mode3 !== void 0 ? mode3 : context.mode, customTheme: customTheme !== null && customTheme !== void 0 ? customTheme : context.customTheme, style: { overflow: "hidden" }, children: (0, import_jsx_runtime.jsx)(motion.div, { style: { paddingRight: 24 }, children: (0, import_jsx_runtime.jsx)(Balance, { hideSymbol: true }) }) }) }, "balance") }), (0, import_jsx_runtime.jsx)(ThemedButton, { theme: theme !== null && theme !== void 0 ? theme : context.theme, mode: mode3 !== null && mode3 !== void 0 ? mode3 : context.mode, customTheme: customTheme !== null && customTheme !== void 0 ? customTheme : context.customTheme, style: shouldShowBalance && showBalance && address && (theme === "retro" || context.theme === "retro") ? {
    /** Special fix for the retro theme... not happy about this one */
    boxShadow: "var(--ck-connectbutton-balance-connectbutton-box-shadow)",
    borderRadius: "var(--ck-connectbutton-balance-connectbutton-border-radius)",
    overflow: "hidden"
  } : {
    overflow: "hidden"
  }, children: (0, import_jsx_runtime.jsx)(ConnectKitButtonInner, { separator, showAvatar, label }) })] }) });
}
ConnectKitButton.Custom = ConnectButtonRenderer;
var dist = 8;
var shake = We`
  0%{ transform:none; }
  25%{ transform:translateX(${dist}px); }
  50%{ transform:translateX(-${dist}px); }
  75%{ transform:translateX(${dist}px); }
  100%{ transform:none; }
`;
var cursorIn = We`
  0%{ transform:translate(500%,100%); opacity:0; }
  60%{ transform:translate(25%,-20%); opacity:1; }
  70%{ transform:translate(25%,-20%); }
  85%{ transform:translate(25%,-20%) scale(0.9); }
  100%{ transform:translate(25%,-20%) scale(1); opacity:1; }
`;
var Cursor = styled.div`
  z-index: 2;
  position: absolute;
  top: 50%;
  left: 50%;
  width: 32px;
  height: 32px;
  border-radius: 50%;
  background: rgba(0, 0, 0, 0.5);
  box-shadow: 0 0 0 2px rgba(255, 255, 255, 0.4), 0 4px 6px rgba(0, 0, 0, 0.1);
  opacity: 0;
  &.play {
    animation: ${cursorIn} 1300ms 200ms cubic-bezier(0.16, 1, 0.6, 1) both;
  }
`;
var Container = styled.div`
  z-index: 1;
  position: absolute;
  inset: 0;
  &.shake {
    animation: ${shake} 300ms 100ms cubic-bezier(0.16, 1, 0.6, 1) both;
  }
`;
var ButtonContainer = styled.div`
  z-index: 1;
  position: absolute;
  inset: 0;
  display: flex;
  align-items: center;
  justify-content: center;
  &:before {
    z-index: 9;
    content: '';
    position: absolute;
    inset: 0;
  }
`;
var CONNECTKIT_VERSION = "1.9.0";

// node_modules/@bedrock_org/passport/dist/index.es.js
var import_siwe = __toESM(require_siwe());

// node_modules/axios/lib/helpers/bind.js
function bind(fn2, thisArg) {
  return function wrap2() {
    return fn2.apply(thisArg, arguments);
  };
}

// node_modules/axios/lib/utils.js
var { toString: toString5 } = Object.prototype;
var { getPrototypeOf } = Object;
var { iterator, toStringTag } = Symbol;
var kindOf = /* @__PURE__ */ ((cache) => (thing) => {
  const str = toString5.call(thing);
  return cache[str] || (cache[str] = str.slice(8, -1).toLowerCase());
})(/* @__PURE__ */ Object.create(null));
var kindOfTest = (type6) => {
  type6 = type6.toLowerCase();
  return (thing) => kindOf(thing) === type6;
};
var typeOfTest = (type6) => (thing) => typeof thing === type6;
var { isArray } = Array;
var isUndefined = typeOfTest("undefined");
function isBuffer(val) {
  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor) && isFunction(val.constructor.isBuffer) && val.constructor.isBuffer(val);
}
var isArrayBuffer = kindOfTest("ArrayBuffer");
function isArrayBufferView(val) {
  let result;
  if (typeof ArrayBuffer !== "undefined" && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && isArrayBuffer(val.buffer);
  }
  return result;
}
var isString4 = typeOfTest("string");
var isFunction = typeOfTest("function");
var isNumber2 = typeOfTest("number");
var isObject = (thing) => thing !== null && typeof thing === "object";
var isBoolean = (thing) => thing === true || thing === false;
var isPlainObject3 = (val) => {
  if (kindOf(val) !== "object") {
    return false;
  }
  const prototype3 = getPrototypeOf(val);
  return (prototype3 === null || prototype3 === Object.prototype || Object.getPrototypeOf(prototype3) === null) && !(toStringTag in val) && !(iterator in val);
};
var isDate = kindOfTest("Date");
var isFile = kindOfTest("File");
var isBlob = kindOfTest("Blob");
var isFileList = kindOfTest("FileList");
var isStream = (val) => isObject(val) && isFunction(val.pipe);
var isFormData = (thing) => {
  let kind;
  return thing && (typeof FormData === "function" && thing instanceof FormData || isFunction(thing.append) && ((kind = kindOf(thing)) === "formdata" || // detect form-data instance
  kind === "object" && isFunction(thing.toString) && thing.toString() === "[object FormData]"));
};
var isURLSearchParams = kindOfTest("URLSearchParams");
var [isReadableStream, isRequest, isResponse, isHeaders] = ["ReadableStream", "Request", "Response", "Headers"].map(kindOfTest);
var trim2 = (str) => str.trim ? str.trim() : str.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, "");
function forEach(obj, fn2, { allOwnKeys = false } = {}) {
  if (obj === null || typeof obj === "undefined") {
    return;
  }
  let i2;
  let l3;
  if (typeof obj !== "object") {
    obj = [obj];
  }
  if (isArray(obj)) {
    for (i2 = 0, l3 = obj.length; i2 < l3; i2++) {
      fn2.call(null, obj[i2], i2, obj);
    }
  } else {
    const keys = allOwnKeys ? Object.getOwnPropertyNames(obj) : Object.keys(obj);
    const len = keys.length;
    let key;
    for (i2 = 0; i2 < len; i2++) {
      key = keys[i2];
      fn2.call(null, obj[key], key, obj);
    }
  }
}
function findKey(obj, key) {
  key = key.toLowerCase();
  const keys = Object.keys(obj);
  let i2 = keys.length;
  let _key;
  while (i2-- > 0) {
    _key = keys[i2];
    if (key === _key.toLowerCase()) {
      return _key;
    }
  }
  return null;
}
var _global = (() => {
  if (typeof globalThis !== "undefined") return globalThis;
  return typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : global;
})();
var isContextDefined = (context) => !isUndefined(context) && context !== _global;
function merge() {
  const { caseless } = isContextDefined(this) && this || {};
  const result = {};
  const assignValue = (val, key) => {
    const targetKey = caseless && findKey(result, key) || key;
    if (isPlainObject3(result[targetKey]) && isPlainObject3(val)) {
      result[targetKey] = merge(result[targetKey], val);
    } else if (isPlainObject3(val)) {
      result[targetKey] = merge({}, val);
    } else if (isArray(val)) {
      result[targetKey] = val.slice();
    } else {
      result[targetKey] = val;
    }
  };
  for (let i2 = 0, l3 = arguments.length; i2 < l3; i2++) {
    arguments[i2] && forEach(arguments[i2], assignValue);
  }
  return result;
}
var extend = (a3, b4, thisArg, { allOwnKeys } = {}) => {
  forEach(b4, (val, key) => {
    if (thisArg && isFunction(val)) {
      a3[key] = bind(val, thisArg);
    } else {
      a3[key] = val;
    }
  }, { allOwnKeys });
  return a3;
};
var stripBOM = (content) => {
  if (content.charCodeAt(0) === 65279) {
    content = content.slice(1);
  }
  return content;
};
var inherits = (constructor, superConstructor, props, descriptors2) => {
  constructor.prototype = Object.create(superConstructor.prototype, descriptors2);
  constructor.prototype.constructor = constructor;
  Object.defineProperty(constructor, "super", {
    value: superConstructor.prototype
  });
  props && Object.assign(constructor.prototype, props);
};
var toFlatObject = (sourceObj, destObj, filter3, propFilter) => {
  let props;
  let i2;
  let prop;
  const merged = {};
  destObj = destObj || {};
  if (sourceObj == null) return destObj;
  do {
    props = Object.getOwnPropertyNames(sourceObj);
    i2 = props.length;
    while (i2-- > 0) {
      prop = props[i2];
      if ((!propFilter || propFilter(prop, sourceObj, destObj)) && !merged[prop]) {
        destObj[prop] = sourceObj[prop];
        merged[prop] = true;
      }
    }
    sourceObj = filter3 !== false && getPrototypeOf(sourceObj);
  } while (sourceObj && (!filter3 || filter3(sourceObj, destObj)) && sourceObj !== Object.prototype);
  return destObj;
};
var endsWith = (str, searchString, position) => {
  str = String(str);
  if (position === void 0 || position > str.length) {
    position = str.length;
  }
  position -= searchString.length;
  const lastIndex = str.indexOf(searchString, position);
  return lastIndex !== -1 && lastIndex === position;
};
var toArray = (thing) => {
  if (!thing) return null;
  if (isArray(thing)) return thing;
  let i2 = thing.length;
  if (!isNumber2(i2)) return null;
  const arr = new Array(i2);
  while (i2-- > 0) {
    arr[i2] = thing[i2];
  }
  return arr;
};
var isTypedArray = /* @__PURE__ */ ((TypedArray) => {
  return (thing) => {
    return TypedArray && thing instanceof TypedArray;
  };
})(typeof Uint8Array !== "undefined" && getPrototypeOf(Uint8Array));
var forEachEntry = (obj, fn2) => {
  const generator = obj && obj[iterator];
  const _iterator = generator.call(obj);
  let result;
  while ((result = _iterator.next()) && !result.done) {
    const pair = result.value;
    fn2.call(obj, pair[0], pair[1]);
  }
};
var matchAll = (regExp, str) => {
  let matches;
  const arr = [];
  while ((matches = regExp.exec(str)) !== null) {
    arr.push(matches);
  }
  return arr;
};
var isHTMLForm = kindOfTest("HTMLFormElement");
var toCamelCase = (str) => {
  return str.toLowerCase().replace(
    /[-_\s]([a-z\d])(\w*)/g,
    function replacer(m3, p1, p2) {
      return p1.toUpperCase() + p2;
    }
  );
};
var hasOwnProperty = (({ hasOwnProperty: hasOwnProperty2 }) => (obj, prop) => hasOwnProperty2.call(obj, prop))(Object.prototype);
var isRegExp = kindOfTest("RegExp");
var reduceDescriptors = (obj, reducer) => {
  const descriptors2 = Object.getOwnPropertyDescriptors(obj);
  const reducedDescriptors = {};
  forEach(descriptors2, (descriptor, name) => {
    let ret;
    if ((ret = reducer(descriptor, name, obj)) !== false) {
      reducedDescriptors[name] = ret || descriptor;
    }
  });
  Object.defineProperties(obj, reducedDescriptors);
};
var freezeMethods = (obj) => {
  reduceDescriptors(obj, (descriptor, name) => {
    if (isFunction(obj) && ["arguments", "caller", "callee"].indexOf(name) !== -1) {
      return false;
    }
    const value = obj[name];
    if (!isFunction(value)) return;
    descriptor.enumerable = false;
    if ("writable" in descriptor) {
      descriptor.writable = false;
      return;
    }
    if (!descriptor.set) {
      descriptor.set = () => {
        throw Error("Can not rewrite read-only method '" + name + "'");
      };
    }
  });
};
var toObjectSet = (arrayOrString, delimiter) => {
  const obj = {};
  const define = (arr) => {
    arr.forEach((value) => {
      obj[value] = true;
    });
  };
  isArray(arrayOrString) ? define(arrayOrString) : define(String(arrayOrString).split(delimiter));
  return obj;
};
var noop2 = () => {
};
var toFiniteNumber = (value, defaultValue) => {
  return value != null && Number.isFinite(value = +value) ? value : defaultValue;
};
function isSpecCompliantForm(thing) {
  return !!(thing && isFunction(thing.append) && thing[toStringTag] === "FormData" && thing[iterator]);
}
var toJSONObject = (obj) => {
  const stack = new Array(10);
  const visit = (source, i2) => {
    if (isObject(source)) {
      if (stack.indexOf(source) >= 0) {
        return;
      }
      if (!("toJSON" in source)) {
        stack[i2] = source;
        const target = isArray(source) ? [] : {};
        forEach(source, (value, key) => {
          const reducedValue = visit(value, i2 + 1);
          !isUndefined(reducedValue) && (target[key] = reducedValue);
        });
        stack[i2] = void 0;
        return target;
      }
    }
    return source;
  };
  return visit(obj, 0);
};
var isAsyncFn = kindOfTest("AsyncFunction");
var isThenable = (thing) => thing && (isObject(thing) || isFunction(thing)) && isFunction(thing.then) && isFunction(thing.catch);
var _setImmediate = ((setImmediateSupported, postMessageSupported) => {
  if (setImmediateSupported) {
    return setImmediate;
  }
  return postMessageSupported ? ((token, callbacks) => {
    _global.addEventListener("message", ({ source, data }) => {
      if (source === _global && data === token) {
        callbacks.length && callbacks.shift()();
      }
    }, false);
    return (cb2) => {
      callbacks.push(cb2);
      _global.postMessage(token, "*");
    };
  })(`axios@${Math.random()}`, []) : (cb2) => setTimeout(cb2);
})(
  typeof setImmediate === "function",
  isFunction(_global.postMessage)
);
var asap = typeof queueMicrotask !== "undefined" ? queueMicrotask.bind(_global) : typeof process !== "undefined" && process.nextTick || _setImmediate;
var isIterable = (thing) => thing != null && isFunction(thing[iterator]);
var utils_default = {
  isArray,
  isArrayBuffer,
  isBuffer,
  isFormData,
  isArrayBufferView,
  isString: isString4,
  isNumber: isNumber2,
  isBoolean,
  isObject,
  isPlainObject: isPlainObject3,
  isReadableStream,
  isRequest,
  isResponse,
  isHeaders,
  isUndefined,
  isDate,
  isFile,
  isBlob,
  isRegExp,
  isFunction,
  isStream,
  isURLSearchParams,
  isTypedArray,
  isFileList,
  forEach,
  merge,
  extend,
  trim: trim2,
  stripBOM,
  inherits,
  toFlatObject,
  kindOf,
  kindOfTest,
  endsWith,
  toArray,
  forEachEntry,
  matchAll,
  isHTMLForm,
  hasOwnProperty,
  hasOwnProp: hasOwnProperty,
  // an alias to avoid ESLint no-prototype-builtins detection
  reduceDescriptors,
  freezeMethods,
  toObjectSet,
  toCamelCase,
  noop: noop2,
  toFiniteNumber,
  findKey,
  global: _global,
  isContextDefined,
  isSpecCompliantForm,
  toJSONObject,
  isAsyncFn,
  isThenable,
  setImmediate: _setImmediate,
  asap,
  isIterable
};

// node_modules/axios/lib/core/AxiosError.js
function AxiosError(message, code, config, request, response) {
  Error.call(this);
  if (Error.captureStackTrace) {
    Error.captureStackTrace(this, this.constructor);
  } else {
    this.stack = new Error().stack;
  }
  this.message = message;
  this.name = "AxiosError";
  code && (this.code = code);
  config && (this.config = config);
  request && (this.request = request);
  if (response) {
    this.response = response;
    this.status = response.status ? response.status : null;
  }
}
utils_default.inherits(AxiosError, Error, {
  toJSON: function toJSON() {
    return {
      // Standard
      message: this.message,
      name: this.name,
      // Microsoft
      description: this.description,
      number: this.number,
      // Mozilla
      fileName: this.fileName,
      lineNumber: this.lineNumber,
      columnNumber: this.columnNumber,
      stack: this.stack,
      // Axios
      config: utils_default.toJSONObject(this.config),
      code: this.code,
      status: this.status
    };
  }
});
var prototype = AxiosError.prototype;
var descriptors = {};
[
  "ERR_BAD_OPTION_VALUE",
  "ERR_BAD_OPTION",
  "ECONNABORTED",
  "ETIMEDOUT",
  "ERR_NETWORK",
  "ERR_FR_TOO_MANY_REDIRECTS",
  "ERR_DEPRECATED",
  "ERR_BAD_RESPONSE",
  "ERR_BAD_REQUEST",
  "ERR_CANCELED",
  "ERR_NOT_SUPPORT",
  "ERR_INVALID_URL"
  // eslint-disable-next-line func-names
].forEach((code) => {
  descriptors[code] = { value: code };
});
Object.defineProperties(AxiosError, descriptors);
Object.defineProperty(prototype, "isAxiosError", { value: true });
AxiosError.from = (error, code, config, request, response, customProps) => {
  const axiosError = Object.create(prototype);
  utils_default.toFlatObject(error, axiosError, function filter3(obj) {
    return obj !== Error.prototype;
  }, (prop) => {
    return prop !== "isAxiosError";
  });
  AxiosError.call(axiosError, error.message, code, config, request, response);
  axiosError.cause = error;
  axiosError.name = error.name;
  customProps && Object.assign(axiosError, customProps);
  return axiosError;
};
var AxiosError_default = AxiosError;

// node_modules/axios/lib/helpers/null.js
var null_default = null;

// node_modules/axios/lib/helpers/toFormData.js
function isVisitable(thing) {
  return utils_default.isPlainObject(thing) || utils_default.isArray(thing);
}
function removeBrackets(key) {
  return utils_default.endsWith(key, "[]") ? key.slice(0, -2) : key;
}
function renderKey(path2, key, dots) {
  if (!path2) return key;
  return path2.concat(key).map(function each(token, i2) {
    token = removeBrackets(token);
    return !dots && i2 ? "[" + token + "]" : token;
  }).join(dots ? "." : "");
}
function isFlatArray(arr) {
  return utils_default.isArray(arr) && !arr.some(isVisitable);
}
var predicates = utils_default.toFlatObject(utils_default, {}, null, function filter2(prop) {
  return /^is[A-Z]/.test(prop);
});
function toFormData(obj, formData, options) {
  if (!utils_default.isObject(obj)) {
    throw new TypeError("target must be an object");
  }
  formData = formData || new (null_default || FormData)();
  options = utils_default.toFlatObject(options, {
    metaTokens: true,
    dots: false,
    indexes: false
  }, false, function defined(option, source) {
    return !utils_default.isUndefined(source[option]);
  });
  const metaTokens = options.metaTokens;
  const visitor = options.visitor || defaultVisitor;
  const dots = options.dots;
  const indexes = options.indexes;
  const _Blob = options.Blob || typeof Blob !== "undefined" && Blob;
  const useBlob = _Blob && utils_default.isSpecCompliantForm(formData);
  if (!utils_default.isFunction(visitor)) {
    throw new TypeError("visitor must be a function");
  }
  function convertValue(value) {
    if (value === null) return "";
    if (utils_default.isDate(value)) {
      return value.toISOString();
    }
    if (!useBlob && utils_default.isBlob(value)) {
      throw new AxiosError_default("Blob is not supported. Use a Buffer instead.");
    }
    if (utils_default.isArrayBuffer(value) || utils_default.isTypedArray(value)) {
      return useBlob && typeof Blob === "function" ? new Blob([value]) : Buffer.from(value);
    }
    return value;
  }
  function defaultVisitor(value, key, path2) {
    let arr = value;
    if (value && !path2 && typeof value === "object") {
      if (utils_default.endsWith(key, "{}")) {
        key = metaTokens ? key : key.slice(0, -2);
        value = JSON.stringify(value);
      } else if (utils_default.isArray(value) && isFlatArray(value) || (utils_default.isFileList(value) || utils_default.endsWith(key, "[]")) && (arr = utils_default.toArray(value))) {
        key = removeBrackets(key);
        arr.forEach(function each(el2, index5) {
          !(utils_default.isUndefined(el2) || el2 === null) && formData.append(
            // eslint-disable-next-line no-nested-ternary
            indexes === true ? renderKey([key], index5, dots) : indexes === null ? key : key + "[]",
            convertValue(el2)
          );
        });
        return false;
      }
    }
    if (isVisitable(value)) {
      return true;
    }
    formData.append(renderKey(path2, key, dots), convertValue(value));
    return false;
  }
  const stack = [];
  const exposedHelpers = Object.assign(predicates, {
    defaultVisitor,
    convertValue,
    isVisitable
  });
  function build(value, path2) {
    if (utils_default.isUndefined(value)) return;
    if (stack.indexOf(value) !== -1) {
      throw Error("Circular reference detected in " + path2.join("."));
    }
    stack.push(value);
    utils_default.forEach(value, function each(el2, key) {
      const result = !(utils_default.isUndefined(el2) || el2 === null) && visitor.call(
        formData,
        el2,
        utils_default.isString(key) ? key.trim() : key,
        path2,
        exposedHelpers
      );
      if (result === true) {
        build(el2, path2 ? path2.concat(key) : [key]);
      }
    });
    stack.pop();
  }
  if (!utils_default.isObject(obj)) {
    throw new TypeError("data must be an object");
  }
  build(obj);
  return formData;
}
var toFormData_default = toFormData;

// node_modules/axios/lib/helpers/AxiosURLSearchParams.js
function encode7(str) {
  const charMap = {
    "!": "%21",
    "'": "%27",
    "(": "%28",
    ")": "%29",
    "~": "%7E",
    "%20": "+",
    "%00": "\0"
  };
  return encodeURIComponent(str).replace(/[!'()~]|%20|%00/g, function replacer(match) {
    return charMap[match];
  });
}
function AxiosURLSearchParams(params, options) {
  this._pairs = [];
  params && toFormData_default(params, this, options);
}
var prototype2 = AxiosURLSearchParams.prototype;
prototype2.append = function append(name, value) {
  this._pairs.push([name, value]);
};
prototype2.toString = function toString6(encoder2) {
  const _encode = encoder2 ? function(value) {
    return encoder2.call(this, value, encode7);
  } : encode7;
  return this._pairs.map(function each(pair) {
    return _encode(pair[0]) + "=" + _encode(pair[1]);
  }, "").join("&");
};
var AxiosURLSearchParams_default = AxiosURLSearchParams;

// node_modules/axios/lib/helpers/buildURL.js
function encode8(val) {
  return encodeURIComponent(val).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]");
}
function buildURL(url, params, options) {
  if (!params) {
    return url;
  }
  const _encode = options && options.encode || encode8;
  if (utils_default.isFunction(options)) {
    options = {
      serialize: options
    };
  }
  const serializeFn = options && options.serialize;
  let serializedParams;
  if (serializeFn) {
    serializedParams = serializeFn(params, options);
  } else {
    serializedParams = utils_default.isURLSearchParams(params) ? params.toString() : new AxiosURLSearchParams_default(params, options).toString(_encode);
  }
  if (serializedParams) {
    const hashmarkIndex = url.indexOf("#");
    if (hashmarkIndex !== -1) {
      url = url.slice(0, hashmarkIndex);
    }
    url += (url.indexOf("?") === -1 ? "?" : "&") + serializedParams;
  }
  return url;
}

// node_modules/axios/lib/core/InterceptorManager.js
var InterceptorManager = class {
  constructor() {
    this.handlers = [];
  }
  /**
   * Add a new interceptor to the stack
   *
   * @param {Function} fulfilled The function to handle `then` for a `Promise`
   * @param {Function} rejected The function to handle `reject` for a `Promise`
   *
   * @return {Number} An ID used to remove interceptor later
   */
  use(fulfilled, rejected, options) {
    this.handlers.push({
      fulfilled,
      rejected,
      synchronous: options ? options.synchronous : false,
      runWhen: options ? options.runWhen : null
    });
    return this.handlers.length - 1;
  }
  /**
   * Remove an interceptor from the stack
   *
   * @param {Number} id The ID that was returned by `use`
   *
   * @returns {Boolean} `true` if the interceptor was removed, `false` otherwise
   */
  eject(id3) {
    if (this.handlers[id3]) {
      this.handlers[id3] = null;
    }
  }
  /**
   * Clear all interceptors from the stack
   *
   * @returns {void}
   */
  clear() {
    if (this.handlers) {
      this.handlers = [];
    }
  }
  /**
   * Iterate over all the registered interceptors
   *
   * This method is particularly useful for skipping over any
   * interceptors that may have become `null` calling `eject`.
   *
   * @param {Function} fn The function to call for each interceptor
   *
   * @returns {void}
   */
  forEach(fn2) {
    utils_default.forEach(this.handlers, function forEachHandler(h) {
      if (h !== null) {
        fn2(h);
      }
    });
  }
};
var InterceptorManager_default = InterceptorManager;

// node_modules/axios/lib/defaults/transitional.js
var transitional_default = {
  silentJSONParsing: true,
  forcedJSONParsing: true,
  clarifyTimeoutError: false
};

// node_modules/axios/lib/platform/browser/classes/URLSearchParams.js
var URLSearchParams_default = typeof URLSearchParams !== "undefined" ? URLSearchParams : AxiosURLSearchParams_default;

// node_modules/axios/lib/platform/browser/classes/FormData.js
var FormData_default = typeof FormData !== "undefined" ? FormData : null;

// node_modules/axios/lib/platform/browser/classes/Blob.js
var Blob_default = typeof Blob !== "undefined" ? Blob : null;

// node_modules/axios/lib/platform/browser/index.js
var browser_default = {
  isBrowser: true,
  classes: {
    URLSearchParams: URLSearchParams_default,
    FormData: FormData_default,
    Blob: Blob_default
  },
  protocols: ["http", "https", "file", "blob", "url", "data"]
};

// node_modules/axios/lib/platform/common/utils.js
var utils_exports = {};
__export(utils_exports, {
  hasBrowserEnv: () => hasBrowserEnv,
  hasStandardBrowserEnv: () => hasStandardBrowserEnv,
  hasStandardBrowserWebWorkerEnv: () => hasStandardBrowserWebWorkerEnv,
  navigator: () => _navigator,
  origin: () => origin
});
var hasBrowserEnv = typeof window !== "undefined" && typeof document !== "undefined";
var _navigator = typeof navigator === "object" && navigator || void 0;
var hasStandardBrowserEnv = hasBrowserEnv && (!_navigator || ["ReactNative", "NativeScript", "NS"].indexOf(_navigator.product) < 0);
var hasStandardBrowserWebWorkerEnv = (() => {
  return typeof WorkerGlobalScope !== "undefined" && // eslint-disable-next-line no-undef
  self instanceof WorkerGlobalScope && typeof self.importScripts === "function";
})();
var origin = hasBrowserEnv && window.location.href || "http://localhost";

// node_modules/axios/lib/platform/index.js
var platform_default = {
  ...utils_exports,
  ...browser_default
};

// node_modules/axios/lib/helpers/toURLEncodedForm.js
function toURLEncodedForm(data, options) {
  return toFormData_default(data, new platform_default.classes.URLSearchParams(), Object.assign({
    visitor: function(value, key, path2, helpers) {
      if (platform_default.isNode && utils_default.isBuffer(value)) {
        this.append(key, value.toString("base64"));
        return false;
      }
      return helpers.defaultVisitor.apply(this, arguments);
    }
  }, options));
}

// node_modules/axios/lib/helpers/formDataToJSON.js
function parsePropPath(name) {
  return utils_default.matchAll(/\w+|\[(\w*)]/g, name).map((match) => {
    return match[0] === "[]" ? "" : match[1] || match[0];
  });
}
function arrayToObject(arr) {
  const obj = {};
  const keys = Object.keys(arr);
  let i2;
  const len = keys.length;
  let key;
  for (i2 = 0; i2 < len; i2++) {
    key = keys[i2];
    obj[key] = arr[key];
  }
  return obj;
}
function formDataToJSON(formData) {
  function buildPath(path2, value, target, index5) {
    let name = path2[index5++];
    if (name === "__proto__") return true;
    const isNumericKey = Number.isFinite(+name);
    const isLast = index5 >= path2.length;
    name = !name && utils_default.isArray(target) ? target.length : name;
    if (isLast) {
      if (utils_default.hasOwnProp(target, name)) {
        target[name] = [target[name], value];
      } else {
        target[name] = value;
      }
      return !isNumericKey;
    }
    if (!target[name] || !utils_default.isObject(target[name])) {
      target[name] = [];
    }
    const result = buildPath(path2, value, target[name], index5);
    if (result && utils_default.isArray(target[name])) {
      target[name] = arrayToObject(target[name]);
    }
    return !isNumericKey;
  }
  if (utils_default.isFormData(formData) && utils_default.isFunction(formData.entries)) {
    const obj = {};
    utils_default.forEachEntry(formData, (name, value) => {
      buildPath(parsePropPath(name), value, obj, 0);
    });
    return obj;
  }
  return null;
}
var formDataToJSON_default = formDataToJSON;

// node_modules/axios/lib/defaults/index.js
function stringifySafely(rawValue, parser, encoder2) {
  if (utils_default.isString(rawValue)) {
    try {
      (parser || JSON.parse)(rawValue);
      return utils_default.trim(rawValue);
    } catch (e2) {
      if (e2.name !== "SyntaxError") {
        throw e2;
      }
    }
  }
  return (encoder2 || JSON.stringify)(rawValue);
}
var defaults2 = {
  transitional: transitional_default,
  adapter: ["xhr", "http", "fetch"],
  transformRequest: [function transformRequest(data, headers) {
    const contentType = headers.getContentType() || "";
    const hasJSONContentType = contentType.indexOf("application/json") > -1;
    const isObjectPayload = utils_default.isObject(data);
    if (isObjectPayload && utils_default.isHTMLForm(data)) {
      data = new FormData(data);
    }
    const isFormData2 = utils_default.isFormData(data);
    if (isFormData2) {
      return hasJSONContentType ? JSON.stringify(formDataToJSON_default(data)) : data;
    }
    if (utils_default.isArrayBuffer(data) || utils_default.isBuffer(data) || utils_default.isStream(data) || utils_default.isFile(data) || utils_default.isBlob(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (utils_default.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils_default.isURLSearchParams(data)) {
      headers.setContentType("application/x-www-form-urlencoded;charset=utf-8", false);
      return data.toString();
    }
    let isFileList2;
    if (isObjectPayload) {
      if (contentType.indexOf("application/x-www-form-urlencoded") > -1) {
        return toURLEncodedForm(data, this.formSerializer).toString();
      }
      if ((isFileList2 = utils_default.isFileList(data)) || contentType.indexOf("multipart/form-data") > -1) {
        const _FormData = this.env && this.env.FormData;
        return toFormData_default(
          isFileList2 ? { "files[]": data } : data,
          _FormData && new _FormData(),
          this.formSerializer
        );
      }
    }
    if (isObjectPayload || hasJSONContentType) {
      headers.setContentType("application/json", false);
      return stringifySafely(data);
    }
    return data;
  }],
  transformResponse: [function transformResponse(data) {
    const transitional2 = this.transitional || defaults2.transitional;
    const forcedJSONParsing = transitional2 && transitional2.forcedJSONParsing;
    const JSONRequested = this.responseType === "json";
    if (utils_default.isResponse(data) || utils_default.isReadableStream(data)) {
      return data;
    }
    if (data && utils_default.isString(data) && (forcedJSONParsing && !this.responseType || JSONRequested)) {
      const silentJSONParsing = transitional2 && transitional2.silentJSONParsing;
      const strictJSONParsing = !silentJSONParsing && JSONRequested;
      try {
        return JSON.parse(data);
      } catch (e2) {
        if (strictJSONParsing) {
          if (e2.name === "SyntaxError") {
            throw AxiosError_default.from(e2, AxiosError_default.ERR_BAD_RESPONSE, this, null, this.response);
          }
          throw e2;
        }
      }
    }
    return data;
  }],
  /**
   * A timeout in milliseconds to abort a request. If set to 0 (default) a
   * timeout is not created.
   */
  timeout: 0,
  xsrfCookieName: "XSRF-TOKEN",
  xsrfHeaderName: "X-XSRF-TOKEN",
  maxContentLength: -1,
  maxBodyLength: -1,
  env: {
    FormData: platform_default.classes.FormData,
    Blob: platform_default.classes.Blob
  },
  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  },
  headers: {
    common: {
      "Accept": "application/json, text/plain, */*",
      "Content-Type": void 0
    }
  }
};
utils_default.forEach(["delete", "get", "head", "post", "put", "patch"], (method) => {
  defaults2.headers[method] = {};
});
var defaults_default = defaults2;

// node_modules/axios/lib/helpers/parseHeaders.js
var ignoreDuplicateOf = utils_default.toObjectSet([
  "age",
  "authorization",
  "content-length",
  "content-type",
  "etag",
  "expires",
  "from",
  "host",
  "if-modified-since",
  "if-unmodified-since",
  "last-modified",
  "location",
  "max-forwards",
  "proxy-authorization",
  "referer",
  "retry-after",
  "user-agent"
]);
var parseHeaders_default = (rawHeaders) => {
  const parsed = {};
  let key;
  let val;
  let i2;
  rawHeaders && rawHeaders.split("\n").forEach(function parser(line) {
    i2 = line.indexOf(":");
    key = line.substring(0, i2).trim().toLowerCase();
    val = line.substring(i2 + 1).trim();
    if (!key || parsed[key] && ignoreDuplicateOf[key]) {
      return;
    }
    if (key === "set-cookie") {
      if (parsed[key]) {
        parsed[key].push(val);
      } else {
        parsed[key] = [val];
      }
    } else {
      parsed[key] = parsed[key] ? parsed[key] + ", " + val : val;
    }
  });
  return parsed;
};

// node_modules/axios/lib/core/AxiosHeaders.js
var $internals = Symbol("internals");
function normalizeHeader(header) {
  return header && String(header).trim().toLowerCase();
}
function normalizeValue(value) {
  if (value === false || value == null) {
    return value;
  }
  return utils_default.isArray(value) ? value.map(normalizeValue) : String(value);
}
function parseTokens(str) {
  const tokens = /* @__PURE__ */ Object.create(null);
  const tokensRE = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g;
  let match;
  while (match = tokensRE.exec(str)) {
    tokens[match[1]] = match[2];
  }
  return tokens;
}
var isValidHeaderName = (str) => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(str.trim());
function matchHeaderValue(context, value, header, filter3, isHeaderNameFilter) {
  if (utils_default.isFunction(filter3)) {
    return filter3.call(this, value, header);
  }
  if (isHeaderNameFilter) {
    value = header;
  }
  if (!utils_default.isString(value)) return;
  if (utils_default.isString(filter3)) {
    return value.indexOf(filter3) !== -1;
  }
  if (utils_default.isRegExp(filter3)) {
    return filter3.test(value);
  }
}
function formatHeader(header) {
  return header.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (w2, char, str) => {
    return char.toUpperCase() + str;
  });
}
function buildAccessors(obj, header) {
  const accessorName = utils_default.toCamelCase(" " + header);
  ["get", "set", "has"].forEach((methodName) => {
    Object.defineProperty(obj, methodName + accessorName, {
      value: function(arg1, arg2, arg3) {
        return this[methodName].call(this, header, arg1, arg2, arg3);
      },
      configurable: true
    });
  });
}
var AxiosHeaders = class {
  constructor(headers) {
    headers && this.set(headers);
  }
  set(header, valueOrRewrite, rewrite) {
    const self2 = this;
    function setHeader(_value, _header, _rewrite) {
      const lHeader = normalizeHeader(_header);
      if (!lHeader) {
        throw new Error("header name must be a non-empty string");
      }
      const key = utils_default.findKey(self2, lHeader);
      if (!key || self2[key] === void 0 || _rewrite === true || _rewrite === void 0 && self2[key] !== false) {
        self2[key || _header] = normalizeValue(_value);
      }
    }
    const setHeaders = (headers, _rewrite) => utils_default.forEach(headers, (_value, _header) => setHeader(_value, _header, _rewrite));
    if (utils_default.isPlainObject(header) || header instanceof this.constructor) {
      setHeaders(header, valueOrRewrite);
    } else if (utils_default.isString(header) && (header = header.trim()) && !isValidHeaderName(header)) {
      setHeaders(parseHeaders_default(header), valueOrRewrite);
    } else if (utils_default.isObject(header) && utils_default.isIterable(header)) {
      let obj = {}, dest, key;
      for (const entry of header) {
        if (!utils_default.isArray(entry)) {
          throw TypeError("Object iterator must return a key-value pair");
        }
        obj[key = entry[0]] = (dest = obj[key]) ? utils_default.isArray(dest) ? [...dest, entry[1]] : [dest, entry[1]] : entry[1];
      }
      setHeaders(obj, valueOrRewrite);
    } else {
      header != null && setHeader(valueOrRewrite, header, rewrite);
    }
    return this;
  }
  get(header, parser) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      if (key) {
        const value = this[key];
        if (!parser) {
          return value;
        }
        if (parser === true) {
          return parseTokens(value);
        }
        if (utils_default.isFunction(parser)) {
          return parser.call(this, value, key);
        }
        if (utils_default.isRegExp(parser)) {
          return parser.exec(value);
        }
        throw new TypeError("parser must be boolean|regexp|function");
      }
    }
  }
  has(header, matcher) {
    header = normalizeHeader(header);
    if (header) {
      const key = utils_default.findKey(this, header);
      return !!(key && this[key] !== void 0 && (!matcher || matchHeaderValue(this, this[key], key, matcher)));
    }
    return false;
  }
  delete(header, matcher) {
    const self2 = this;
    let deleted = false;
    function deleteHeader(_header) {
      _header = normalizeHeader(_header);
      if (_header) {
        const key = utils_default.findKey(self2, _header);
        if (key && (!matcher || matchHeaderValue(self2, self2[key], key, matcher))) {
          delete self2[key];
          deleted = true;
        }
      }
    }
    if (utils_default.isArray(header)) {
      header.forEach(deleteHeader);
    } else {
      deleteHeader(header);
    }
    return deleted;
  }
  clear(matcher) {
    const keys = Object.keys(this);
    let i2 = keys.length;
    let deleted = false;
    while (i2--) {
      const key = keys[i2];
      if (!matcher || matchHeaderValue(this, this[key], key, matcher, true)) {
        delete this[key];
        deleted = true;
      }
    }
    return deleted;
  }
  normalize(format6) {
    const self2 = this;
    const headers = {};
    utils_default.forEach(this, (value, header) => {
      const key = utils_default.findKey(headers, header);
      if (key) {
        self2[key] = normalizeValue(value);
        delete self2[header];
        return;
      }
      const normalized = format6 ? formatHeader(header) : String(header).trim();
      if (normalized !== header) {
        delete self2[header];
      }
      self2[normalized] = normalizeValue(value);
      headers[normalized] = true;
    });
    return this;
  }
  concat(...targets) {
    return this.constructor.concat(this, ...targets);
  }
  toJSON(asStrings) {
    const obj = /* @__PURE__ */ Object.create(null);
    utils_default.forEach(this, (value, header) => {
      value != null && value !== false && (obj[header] = asStrings && utils_default.isArray(value) ? value.join(", ") : value);
    });
    return obj;
  }
  [Symbol.iterator]() {
    return Object.entries(this.toJSON())[Symbol.iterator]();
  }
  toString() {
    return Object.entries(this.toJSON()).map(([header, value]) => header + ": " + value).join("\n");
  }
  getSetCookie() {
    return this.get("set-cookie") || [];
  }
  get [Symbol.toStringTag]() {
    return "AxiosHeaders";
  }
  static from(thing) {
    return thing instanceof this ? thing : new this(thing);
  }
  static concat(first, ...targets) {
    const computed = new this(first);
    targets.forEach((target) => computed.set(target));
    return computed;
  }
  static accessor(header) {
    const internals = this[$internals] = this[$internals] = {
      accessors: {}
    };
    const accessors = internals.accessors;
    const prototype3 = this.prototype;
    function defineAccessor(_header) {
      const lHeader = normalizeHeader(_header);
      if (!accessors[lHeader]) {
        buildAccessors(prototype3, _header);
        accessors[lHeader] = true;
      }
    }
    utils_default.isArray(header) ? header.forEach(defineAccessor) : defineAccessor(header);
    return this;
  }
};
AxiosHeaders.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]);
utils_default.reduceDescriptors(AxiosHeaders.prototype, ({ value }, key) => {
  let mapped = key[0].toUpperCase() + key.slice(1);
  return {
    get: () => value,
    set(headerValue) {
      this[mapped] = headerValue;
    }
  };
});
utils_default.freezeMethods(AxiosHeaders);
var AxiosHeaders_default = AxiosHeaders;

// node_modules/axios/lib/core/transformData.js
function transformData(fns, response) {
  const config = this || defaults_default;
  const context = response || config;
  const headers = AxiosHeaders_default.from(context.headers);
  let data = context.data;
  utils_default.forEach(fns, function transform2(fn2) {
    data = fn2.call(config, data, headers.normalize(), response ? response.status : void 0);
  });
  headers.normalize();
  return data;
}

// node_modules/axios/lib/cancel/isCancel.js
function isCancel(value) {
  return !!(value && value.__CANCEL__);
}

// node_modules/axios/lib/cancel/CanceledError.js
function CanceledError(message, config, request) {
  AxiosError_default.call(this, message == null ? "canceled" : message, AxiosError_default.ERR_CANCELED, config, request);
  this.name = "CanceledError";
}
utils_default.inherits(CanceledError, AxiosError_default, {
  __CANCEL__: true
});
var CanceledError_default = CanceledError;

// node_modules/axios/lib/core/settle.js
function settle(resolve, reject, response) {
  const validateStatus2 = response.config.validateStatus;
  if (!response.status || !validateStatus2 || validateStatus2(response.status)) {
    resolve(response);
  } else {
    reject(new AxiosError_default(
      "Request failed with status code " + response.status,
      [AxiosError_default.ERR_BAD_REQUEST, AxiosError_default.ERR_BAD_RESPONSE][Math.floor(response.status / 100) - 4],
      response.config,
      response.request,
      response
    ));
  }
}

// node_modules/axios/lib/helpers/parseProtocol.js
function parseProtocol(url) {
  const match = /^([-+\w]{1,25})(:?\/\/|:)/.exec(url);
  return match && match[1] || "";
}

// node_modules/axios/lib/helpers/speedometer.js
function speedometer(samplesCount, min) {
  samplesCount = samplesCount || 10;
  const bytes = new Array(samplesCount);
  const timestamps = new Array(samplesCount);
  let head = 0;
  let tail = 0;
  let firstSampleTS;
  min = min !== void 0 ? min : 1e3;
  return function push(chunkLength) {
    const now = Date.now();
    const startedAt = timestamps[tail];
    if (!firstSampleTS) {
      firstSampleTS = now;
    }
    bytes[head] = chunkLength;
    timestamps[head] = now;
    let i2 = tail;
    let bytesCount = 0;
    while (i2 !== head) {
      bytesCount += bytes[i2++];
      i2 = i2 % samplesCount;
    }
    head = (head + 1) % samplesCount;
    if (head === tail) {
      tail = (tail + 1) % samplesCount;
    }
    if (now - firstSampleTS < min) {
      return;
    }
    const passed = startedAt && now - startedAt;
    return passed ? Math.round(bytesCount * 1e3 / passed) : void 0;
  };
}
var speedometer_default = speedometer;

// node_modules/axios/lib/helpers/throttle.js
function throttle2(fn2, freq) {
  let timestamp = 0;
  let threshold = 1e3 / freq;
  let lastArgs;
  let timer;
  const invoke = (args, now = Date.now()) => {
    timestamp = now;
    lastArgs = null;
    if (timer) {
      clearTimeout(timer);
      timer = null;
    }
    fn2.apply(null, args);
  };
  const throttled = (...args) => {
    const now = Date.now();
    const passed = now - timestamp;
    if (passed >= threshold) {
      invoke(args, now);
    } else {
      lastArgs = args;
      if (!timer) {
        timer = setTimeout(() => {
          timer = null;
          invoke(lastArgs);
        }, threshold - passed);
      }
    }
  };
  const flush = () => lastArgs && invoke(lastArgs);
  return [throttled, flush];
}
var throttle_default = throttle2;

// node_modules/axios/lib/helpers/progressEventReducer.js
var progressEventReducer = (listener, isDownloadStream, freq = 3) => {
  let bytesNotified = 0;
  const _speedometer = speedometer_default(50, 250);
  return throttle_default((e2) => {
    const loaded = e2.loaded;
    const total = e2.lengthComputable ? e2.total : void 0;
    const progressBytes = loaded - bytesNotified;
    const rate = _speedometer(progressBytes);
    const inRange = loaded <= total;
    bytesNotified = loaded;
    const data = {
      loaded,
      total,
      progress: total ? loaded / total : void 0,
      bytes: progressBytes,
      rate: rate ? rate : void 0,
      estimated: rate && total && inRange ? (total - loaded) / rate : void 0,
      event: e2,
      lengthComputable: total != null,
      [isDownloadStream ? "download" : "upload"]: true
    };
    listener(data);
  }, freq);
};
var progressEventDecorator = (total, throttled) => {
  const lengthComputable = total != null;
  return [(loaded) => throttled[0]({
    lengthComputable,
    total,
    loaded
  }), throttled[1]];
};
var asyncDecorator = (fn2) => (...args) => utils_default.asap(() => fn2(...args));

// node_modules/axios/lib/helpers/isURLSameOrigin.js
var isURLSameOrigin_default = platform_default.hasStandardBrowserEnv ? /* @__PURE__ */ ((origin2, isMSIE) => (url) => {
  url = new URL(url, platform_default.origin);
  return origin2.protocol === url.protocol && origin2.host === url.host && (isMSIE || origin2.port === url.port);
})(
  new URL(platform_default.origin),
  platform_default.navigator && /(msie|trident)/i.test(platform_default.navigator.userAgent)
) : () => true;

// node_modules/axios/lib/helpers/cookies.js
var cookies_default = platform_default.hasStandardBrowserEnv ? (
  // Standard browser envs support document.cookie
  {
    write(name, value, expires, path2, domain, secure) {
      const cookie = [name + "=" + encodeURIComponent(value)];
      utils_default.isNumber(expires) && cookie.push("expires=" + new Date(expires).toGMTString());
      utils_default.isString(path2) && cookie.push("path=" + path2);
      utils_default.isString(domain) && cookie.push("domain=" + domain);
      secure === true && cookie.push("secure");
      document.cookie = cookie.join("; ");
    },
    read(name) {
      const match = document.cookie.match(new RegExp("(^|;\\s*)(" + name + ")=([^;]*)"));
      return match ? decodeURIComponent(match[3]) : null;
    },
    remove(name) {
      this.write(name, "", Date.now() - 864e5);
    }
  }
) : (
  // Non-standard browser env (web workers, react-native) lack needed support.
  {
    write() {
    },
    read() {
      return null;
    },
    remove() {
    }
  }
);

// node_modules/axios/lib/helpers/isAbsoluteURL.js
function isAbsoluteURL(url) {
  return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(url);
}

// node_modules/axios/lib/helpers/combineURLs.js
function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/?\/$/, "") + "/" + relativeURL.replace(/^\/+/, "") : baseURL;
}

// node_modules/axios/lib/core/buildFullPath.js
function buildFullPath(baseURL, requestedURL, allowAbsoluteUrls) {
  let isRelativeUrl = !isAbsoluteURL(requestedURL);
  if (baseURL && (isRelativeUrl || allowAbsoluteUrls == false)) {
    return combineURLs(baseURL, requestedURL);
  }
  return requestedURL;
}

// node_modules/axios/lib/core/mergeConfig.js
var headersToObject = (thing) => thing instanceof AxiosHeaders_default ? { ...thing } : thing;
function mergeConfig(config1, config2) {
  config2 = config2 || {};
  const config = {};
  function getMergedValue(target, source, prop, caseless) {
    if (utils_default.isPlainObject(target) && utils_default.isPlainObject(source)) {
      return utils_default.merge.call({ caseless }, target, source);
    } else if (utils_default.isPlainObject(source)) {
      return utils_default.merge({}, source);
    } else if (utils_default.isArray(source)) {
      return source.slice();
    }
    return source;
  }
  function mergeDeepProperties(a3, b4, prop, caseless) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(a3, b4, prop, caseless);
    } else if (!utils_default.isUndefined(a3)) {
      return getMergedValue(void 0, a3, prop, caseless);
    }
  }
  function valueFromConfig2(a3, b4) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(void 0, b4);
    }
  }
  function defaultToConfig2(a3, b4) {
    if (!utils_default.isUndefined(b4)) {
      return getMergedValue(void 0, b4);
    } else if (!utils_default.isUndefined(a3)) {
      return getMergedValue(void 0, a3);
    }
  }
  function mergeDirectKeys(a3, b4, prop) {
    if (prop in config2) {
      return getMergedValue(a3, b4);
    } else if (prop in config1) {
      return getMergedValue(void 0, a3);
    }
  }
  const mergeMap = {
    url: valueFromConfig2,
    method: valueFromConfig2,
    data: valueFromConfig2,
    baseURL: defaultToConfig2,
    transformRequest: defaultToConfig2,
    transformResponse: defaultToConfig2,
    paramsSerializer: defaultToConfig2,
    timeout: defaultToConfig2,
    timeoutMessage: defaultToConfig2,
    withCredentials: defaultToConfig2,
    withXSRFToken: defaultToConfig2,
    adapter: defaultToConfig2,
    responseType: defaultToConfig2,
    xsrfCookieName: defaultToConfig2,
    xsrfHeaderName: defaultToConfig2,
    onUploadProgress: defaultToConfig2,
    onDownloadProgress: defaultToConfig2,
    decompress: defaultToConfig2,
    maxContentLength: defaultToConfig2,
    maxBodyLength: defaultToConfig2,
    beforeRedirect: defaultToConfig2,
    transport: defaultToConfig2,
    httpAgent: defaultToConfig2,
    httpsAgent: defaultToConfig2,
    cancelToken: defaultToConfig2,
    socketPath: defaultToConfig2,
    responseEncoding: defaultToConfig2,
    validateStatus: mergeDirectKeys,
    headers: (a3, b4, prop) => mergeDeepProperties(headersToObject(a3), headersToObject(b4), prop, true)
  };
  utils_default.forEach(Object.keys(Object.assign({}, config1, config2)), function computeConfigValue(prop) {
    const merge2 = mergeMap[prop] || mergeDeepProperties;
    const configValue = merge2(config1[prop], config2[prop], prop);
    utils_default.isUndefined(configValue) && merge2 !== mergeDirectKeys || (config[prop] = configValue);
  });
  return config;
}

// node_modules/axios/lib/helpers/resolveConfig.js
var resolveConfig_default = (config) => {
  const newConfig = mergeConfig({}, config);
  let { data, withXSRFToken, xsrfHeaderName, xsrfCookieName, headers, auth } = newConfig;
  newConfig.headers = headers = AxiosHeaders_default.from(headers);
  newConfig.url = buildURL(buildFullPath(newConfig.baseURL, newConfig.url, newConfig.allowAbsoluteUrls), config.params, config.paramsSerializer);
  if (auth) {
    headers.set(
      "Authorization",
      "Basic " + btoa((auth.username || "") + ":" + (auth.password ? unescape(encodeURIComponent(auth.password)) : ""))
    );
  }
  let contentType;
  if (utils_default.isFormData(data)) {
    if (platform_default.hasStandardBrowserEnv || platform_default.hasStandardBrowserWebWorkerEnv) {
      headers.setContentType(void 0);
    } else if ((contentType = headers.getContentType()) !== false) {
      const [type6, ...tokens] = contentType ? contentType.split(";").map((token) => token.trim()).filter(Boolean) : [];
      headers.setContentType([type6 || "multipart/form-data", ...tokens].join("; "));
    }
  }
  if (platform_default.hasStandardBrowserEnv) {
    withXSRFToken && utils_default.isFunction(withXSRFToken) && (withXSRFToken = withXSRFToken(newConfig));
    if (withXSRFToken || withXSRFToken !== false && isURLSameOrigin_default(newConfig.url)) {
      const xsrfValue = xsrfHeaderName && xsrfCookieName && cookies_default.read(xsrfCookieName);
      if (xsrfValue) {
        headers.set(xsrfHeaderName, xsrfValue);
      }
    }
  }
  return newConfig;
};

// node_modules/axios/lib/adapters/xhr.js
var isXHRAdapterSupported = typeof XMLHttpRequest !== "undefined";
var xhr_default = isXHRAdapterSupported && function(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    const _config = resolveConfig_default(config);
    let requestData = _config.data;
    const requestHeaders = AxiosHeaders_default.from(_config.headers).normalize();
    let { responseType, onUploadProgress, onDownloadProgress } = _config;
    let onCanceled;
    let uploadThrottled, downloadThrottled;
    let flushUpload, flushDownload;
    function done() {
      flushUpload && flushUpload();
      flushDownload && flushDownload();
      _config.cancelToken && _config.cancelToken.unsubscribe(onCanceled);
      _config.signal && _config.signal.removeEventListener("abort", onCanceled);
    }
    let request = new XMLHttpRequest();
    request.open(_config.method.toUpperCase(), _config.url, true);
    request.timeout = _config.timeout;
    function onloadend() {
      if (!request) {
        return;
      }
      const responseHeaders = AxiosHeaders_default.from(
        "getAllResponseHeaders" in request && request.getAllResponseHeaders()
      );
      const responseData = !responseType || responseType === "text" || responseType === "json" ? request.responseText : request.response;
      const response = {
        data: responseData,
        status: request.status,
        statusText: request.statusText,
        headers: responseHeaders,
        config,
        request
      };
      settle(function _resolve(value) {
        resolve(value);
        done();
      }, function _reject(err) {
        reject(err);
        done();
      }, response);
      request = null;
    }
    if ("onloadend" in request) {
      request.onloadend = onloadend;
    } else {
      request.onreadystatechange = function handleLoad() {
        if (!request || request.readyState !== 4) {
          return;
        }
        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf("file:") === 0)) {
          return;
        }
        setTimeout(onloadend);
      };
    }
    request.onabort = function handleAbort() {
      if (!request) {
        return;
      }
      reject(new AxiosError_default("Request aborted", AxiosError_default.ECONNABORTED, config, request));
      request = null;
    };
    request.onerror = function handleError() {
      reject(new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request));
      request = null;
    };
    request.ontimeout = function handleTimeout() {
      let timeoutErrorMessage = _config.timeout ? "timeout of " + _config.timeout + "ms exceeded" : "timeout exceeded";
      const transitional2 = _config.transitional || transitional_default;
      if (_config.timeoutErrorMessage) {
        timeoutErrorMessage = _config.timeoutErrorMessage;
      }
      reject(new AxiosError_default(
        timeoutErrorMessage,
        transitional2.clarifyTimeoutError ? AxiosError_default.ETIMEDOUT : AxiosError_default.ECONNABORTED,
        config,
        request
      ));
      request = null;
    };
    requestData === void 0 && requestHeaders.setContentType(null);
    if ("setRequestHeader" in request) {
      utils_default.forEach(requestHeaders.toJSON(), function setRequestHeader(val, key) {
        request.setRequestHeader(key, val);
      });
    }
    if (!utils_default.isUndefined(_config.withCredentials)) {
      request.withCredentials = !!_config.withCredentials;
    }
    if (responseType && responseType !== "json") {
      request.responseType = _config.responseType;
    }
    if (onDownloadProgress) {
      [downloadThrottled, flushDownload] = progressEventReducer(onDownloadProgress, true);
      request.addEventListener("progress", downloadThrottled);
    }
    if (onUploadProgress && request.upload) {
      [uploadThrottled, flushUpload] = progressEventReducer(onUploadProgress);
      request.upload.addEventListener("progress", uploadThrottled);
      request.upload.addEventListener("loadend", flushUpload);
    }
    if (_config.cancelToken || _config.signal) {
      onCanceled = (cancel) => {
        if (!request) {
          return;
        }
        reject(!cancel || cancel.type ? new CanceledError_default(null, config, request) : cancel);
        request.abort();
        request = null;
      };
      _config.cancelToken && _config.cancelToken.subscribe(onCanceled);
      if (_config.signal) {
        _config.signal.aborted ? onCanceled() : _config.signal.addEventListener("abort", onCanceled);
      }
    }
    const protocol = parseProtocol(_config.url);
    if (protocol && platform_default.protocols.indexOf(protocol) === -1) {
      reject(new AxiosError_default("Unsupported protocol " + protocol + ":", AxiosError_default.ERR_BAD_REQUEST, config));
      return;
    }
    request.send(requestData || null);
  });
};

// node_modules/axios/lib/helpers/composeSignals.js
var composeSignals = (signals, timeout) => {
  const { length: length2 } = signals = signals ? signals.filter(Boolean) : [];
  if (timeout || length2) {
    let controller = new AbortController();
    let aborted;
    const onabort = function(reason) {
      if (!aborted) {
        aborted = true;
        unsubscribe();
        const err = reason instanceof Error ? reason : this.reason;
        controller.abort(err instanceof AxiosError_default ? err : new CanceledError_default(err instanceof Error ? err.message : err));
      }
    };
    let timer = timeout && setTimeout(() => {
      timer = null;
      onabort(new AxiosError_default(`timeout ${timeout} of ms exceeded`, AxiosError_default.ETIMEDOUT));
    }, timeout);
    const unsubscribe = () => {
      if (signals) {
        timer && clearTimeout(timer);
        timer = null;
        signals.forEach((signal2) => {
          signal2.unsubscribe ? signal2.unsubscribe(onabort) : signal2.removeEventListener("abort", onabort);
        });
        signals = null;
      }
    };
    signals.forEach((signal2) => signal2.addEventListener("abort", onabort));
    const { signal } = controller;
    signal.unsubscribe = () => utils_default.asap(unsubscribe);
    return signal;
  }
};
var composeSignals_default = composeSignals;

// node_modules/axios/lib/helpers/trackStream.js
var streamChunk = function* (chunk, chunkSize) {
  let len = chunk.byteLength;
  if (!chunkSize || len < chunkSize) {
    yield chunk;
    return;
  }
  let pos = 0;
  let end;
  while (pos < len) {
    end = pos + chunkSize;
    yield chunk.slice(pos, end);
    pos = end;
  }
};
var readBytes = async function* (iterable, chunkSize) {
  for await (const chunk of readStream(iterable)) {
    yield* streamChunk(chunk, chunkSize);
  }
};
var readStream = async function* (stream) {
  if (stream[Symbol.asyncIterator]) {
    yield* stream;
    return;
  }
  const reader = stream.getReader();
  try {
    for (; ; ) {
      const { done, value } = await reader.read();
      if (done) {
        break;
      }
      yield value;
    }
  } finally {
    await reader.cancel();
  }
};
var trackStream = (stream, chunkSize, onProgress, onFinish) => {
  const iterator2 = readBytes(stream, chunkSize);
  let bytes = 0;
  let done;
  let _onFinish = (e2) => {
    if (!done) {
      done = true;
      onFinish && onFinish(e2);
    }
  };
  return new ReadableStream({
    async pull(controller) {
      try {
        const { done: done2, value } = await iterator2.next();
        if (done2) {
          _onFinish();
          controller.close();
          return;
        }
        let len = value.byteLength;
        if (onProgress) {
          let loadedBytes = bytes += len;
          onProgress(loadedBytes);
        }
        controller.enqueue(new Uint8Array(value));
      } catch (err) {
        _onFinish(err);
        throw err;
      }
    },
    cancel(reason) {
      _onFinish(reason);
      return iterator2.return();
    }
  }, {
    highWaterMark: 2
  });
};

// node_modules/axios/lib/adapters/fetch.js
var isFetchSupported = typeof fetch === "function" && typeof Request === "function" && typeof Response === "function";
var isReadableStreamSupported = isFetchSupported && typeof ReadableStream === "function";
var encodeText = isFetchSupported && (typeof TextEncoder === "function" ? /* @__PURE__ */ ((encoder2) => (str) => encoder2.encode(str))(new TextEncoder()) : async (str) => new Uint8Array(await new Response(str).arrayBuffer()));
var test2 = (fn2, ...args) => {
  try {
    return !!fn2(...args);
  } catch (e2) {
    return false;
  }
};
var supportsRequestStream = isReadableStreamSupported && test2(() => {
  let duplexAccessed = false;
  const hasContentType = new Request(platform_default.origin, {
    body: new ReadableStream(),
    method: "POST",
    get duplex() {
      duplexAccessed = true;
      return "half";
    }
  }).headers.has("Content-Type");
  return duplexAccessed && !hasContentType;
});
var DEFAULT_CHUNK_SIZE = 64 * 1024;
var supportsResponseStream = isReadableStreamSupported && test2(() => utils_default.isReadableStream(new Response("").body));
var resolvers = {
  stream: supportsResponseStream && ((res) => res.body)
};
isFetchSupported && ((res) => {
  ["text", "arrayBuffer", "blob", "formData", "stream"].forEach((type6) => {
    !resolvers[type6] && (resolvers[type6] = utils_default.isFunction(res[type6]) ? (res2) => res2[type6]() : (_2, config) => {
      throw new AxiosError_default(`Response type '${type6}' is not supported`, AxiosError_default.ERR_NOT_SUPPORT, config);
    });
  });
})(new Response());
var getBodyLength = async (body) => {
  if (body == null) {
    return 0;
  }
  if (utils_default.isBlob(body)) {
    return body.size;
  }
  if (utils_default.isSpecCompliantForm(body)) {
    const _request = new Request(platform_default.origin, {
      method: "POST",
      body
    });
    return (await _request.arrayBuffer()).byteLength;
  }
  if (utils_default.isArrayBufferView(body) || utils_default.isArrayBuffer(body)) {
    return body.byteLength;
  }
  if (utils_default.isURLSearchParams(body)) {
    body = body + "";
  }
  if (utils_default.isString(body)) {
    return (await encodeText(body)).byteLength;
  }
};
var resolveBodyLength = async (headers, body) => {
  const length2 = utils_default.toFiniteNumber(headers.getContentLength());
  return length2 == null ? getBodyLength(body) : length2;
};
var fetch_default = isFetchSupported && (async (config) => {
  let {
    url,
    method,
    data,
    signal,
    cancelToken,
    timeout,
    onDownloadProgress,
    onUploadProgress,
    responseType,
    headers,
    withCredentials = "same-origin",
    fetchOptions
  } = resolveConfig_default(config);
  responseType = responseType ? (responseType + "").toLowerCase() : "text";
  let composedSignal = composeSignals_default([signal, cancelToken && cancelToken.toAbortSignal()], timeout);
  let request;
  const unsubscribe = composedSignal && composedSignal.unsubscribe && (() => {
    composedSignal.unsubscribe();
  });
  let requestContentLength;
  try {
    if (onUploadProgress && supportsRequestStream && method !== "get" && method !== "head" && (requestContentLength = await resolveBodyLength(headers, data)) !== 0) {
      let _request = new Request(url, {
        method: "POST",
        body: data,
        duplex: "half"
      });
      let contentTypeHeader;
      if (utils_default.isFormData(data) && (contentTypeHeader = _request.headers.get("content-type"))) {
        headers.setContentType(contentTypeHeader);
      }
      if (_request.body) {
        const [onProgress, flush] = progressEventDecorator(
          requestContentLength,
          progressEventReducer(asyncDecorator(onUploadProgress))
        );
        data = trackStream(_request.body, DEFAULT_CHUNK_SIZE, onProgress, flush);
      }
    }
    if (!utils_default.isString(withCredentials)) {
      withCredentials = withCredentials ? "include" : "omit";
    }
    const isCredentialsSupported = "credentials" in Request.prototype;
    request = new Request(url, {
      ...fetchOptions,
      signal: composedSignal,
      method: method.toUpperCase(),
      headers: headers.normalize().toJSON(),
      body: data,
      duplex: "half",
      credentials: isCredentialsSupported ? withCredentials : void 0
    });
    let response = await fetch(request);
    const isStreamResponse = supportsResponseStream && (responseType === "stream" || responseType === "response");
    if (supportsResponseStream && (onDownloadProgress || isStreamResponse && unsubscribe)) {
      const options = {};
      ["status", "statusText", "headers"].forEach((prop) => {
        options[prop] = response[prop];
      });
      const responseContentLength = utils_default.toFiniteNumber(response.headers.get("content-length"));
      const [onProgress, flush] = onDownloadProgress && progressEventDecorator(
        responseContentLength,
        progressEventReducer(asyncDecorator(onDownloadProgress), true)
      ) || [];
      response = new Response(
        trackStream(response.body, DEFAULT_CHUNK_SIZE, onProgress, () => {
          flush && flush();
          unsubscribe && unsubscribe();
        }),
        options
      );
    }
    responseType = responseType || "text";
    let responseData = await resolvers[utils_default.findKey(resolvers, responseType) || "text"](response, config);
    !isStreamResponse && unsubscribe && unsubscribe();
    return await new Promise((resolve, reject) => {
      settle(resolve, reject, {
        data: responseData,
        headers: AxiosHeaders_default.from(response.headers),
        status: response.status,
        statusText: response.statusText,
        config,
        request
      });
    });
  } catch (err) {
    unsubscribe && unsubscribe();
    if (err && err.name === "TypeError" && /Load failed|fetch/i.test(err.message)) {
      throw Object.assign(
        new AxiosError_default("Network Error", AxiosError_default.ERR_NETWORK, config, request),
        {
          cause: err.cause || err
        }
      );
    }
    throw AxiosError_default.from(err, err && err.code, config, request);
  }
});

// node_modules/axios/lib/adapters/adapters.js
var knownAdapters = {
  http: null_default,
  xhr: xhr_default,
  fetch: fetch_default
};
utils_default.forEach(knownAdapters, (fn2, value) => {
  if (fn2) {
    try {
      Object.defineProperty(fn2, "name", { value });
    } catch (e2) {
    }
    Object.defineProperty(fn2, "adapterName", { value });
  }
});
var renderReason = (reason) => `- ${reason}`;
var isResolvedHandle = (adapter) => utils_default.isFunction(adapter) || adapter === null || adapter === false;
var adapters_default = {
  getAdapter: (adapters) => {
    adapters = utils_default.isArray(adapters) ? adapters : [adapters];
    const { length: length2 } = adapters;
    let nameOrAdapter;
    let adapter;
    const rejectedReasons = {};
    for (let i2 = 0; i2 < length2; i2++) {
      nameOrAdapter = adapters[i2];
      let id3;
      adapter = nameOrAdapter;
      if (!isResolvedHandle(nameOrAdapter)) {
        adapter = knownAdapters[(id3 = String(nameOrAdapter)).toLowerCase()];
        if (adapter === void 0) {
          throw new AxiosError_default(`Unknown adapter '${id3}'`);
        }
      }
      if (adapter) {
        break;
      }
      rejectedReasons[id3 || "#" + i2] = adapter;
    }
    if (!adapter) {
      const reasons = Object.entries(rejectedReasons).map(
        ([id3, state]) => `adapter ${id3} ` + (state === false ? "is not supported by the environment" : "is not available in the build")
      );
      let s2 = length2 ? reasons.length > 1 ? "since :\n" + reasons.map(renderReason).join("\n") : " " + renderReason(reasons[0]) : "as no adapter specified";
      throw new AxiosError_default(
        `There is no suitable adapter to dispatch the request ` + s2,
        "ERR_NOT_SUPPORT"
      );
    }
    return adapter;
  },
  adapters: knownAdapters
};

// node_modules/axios/lib/core/dispatchRequest.js
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
  if (config.signal && config.signal.aborted) {
    throw new CanceledError_default(null, config);
  }
}
function dispatchRequest(config) {
  throwIfCancellationRequested(config);
  config.headers = AxiosHeaders_default.from(config.headers);
  config.data = transformData.call(
    config,
    config.transformRequest
  );
  if (["post", "put", "patch"].indexOf(config.method) !== -1) {
    config.headers.setContentType("application/x-www-form-urlencoded", false);
  }
  const adapter = adapters_default.getAdapter(config.adapter || defaults_default.adapter);
  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);
    response.data = transformData.call(
      config,
      config.transformResponse,
      response
    );
    response.headers = AxiosHeaders_default.from(response.headers);
    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);
      if (reason && reason.response) {
        reason.response.data = transformData.call(
          config,
          config.transformResponse,
          reason.response
        );
        reason.response.headers = AxiosHeaders_default.from(reason.response.headers);
      }
    }
    return Promise.reject(reason);
  });
}

// node_modules/axios/lib/env/data.js
var VERSION = "1.9.0";

// node_modules/axios/lib/helpers/validator.js
var validators = {};
["object", "boolean", "number", "function", "string", "symbol"].forEach((type6, i2) => {
  validators[type6] = function validator(thing) {
    return typeof thing === type6 || "a" + (i2 < 1 ? "n " : " ") + type6;
  };
});
var deprecatedWarnings = {};
validators.transitional = function transitional(validator, version7, message) {
  function formatMessage(opt, desc) {
    return "[Axios v" + VERSION + "] Transitional option '" + opt + "'" + desc + (message ? ". " + message : "");
  }
  return (value, opt, opts) => {
    if (validator === false) {
      throw new AxiosError_default(
        formatMessage(opt, " has been removed" + (version7 ? " in " + version7 : "")),
        AxiosError_default.ERR_DEPRECATED
      );
    }
    if (version7 && !deprecatedWarnings[opt]) {
      deprecatedWarnings[opt] = true;
      console.warn(
        formatMessage(
          opt,
          " has been deprecated since v" + version7 + " and will be removed in the near future"
        )
      );
    }
    return validator ? validator(value, opt, opts) : true;
  };
};
validators.spelling = function spelling(correctSpelling) {
  return (value, opt) => {
    console.warn(`${opt} is likely a misspelling of ${correctSpelling}`);
    return true;
  };
};
function assertOptions(options, schema, allowUnknown) {
  if (typeof options !== "object") {
    throw new AxiosError_default("options must be an object", AxiosError_default.ERR_BAD_OPTION_VALUE);
  }
  const keys = Object.keys(options);
  let i2 = keys.length;
  while (i2-- > 0) {
    const opt = keys[i2];
    const validator = schema[opt];
    if (validator) {
      const value = options[opt];
      const result = value === void 0 || validator(value, opt, options);
      if (result !== true) {
        throw new AxiosError_default("option " + opt + " must be " + result, AxiosError_default.ERR_BAD_OPTION_VALUE);
      }
      continue;
    }
    if (allowUnknown !== true) {
      throw new AxiosError_default("Unknown option " + opt, AxiosError_default.ERR_BAD_OPTION);
    }
  }
}
var validator_default = {
  assertOptions,
  validators
};

// node_modules/axios/lib/core/Axios.js
var validators2 = validator_default.validators;
var Axios = class {
  constructor(instanceConfig) {
    this.defaults = instanceConfig || {};
    this.interceptors = {
      request: new InterceptorManager_default(),
      response: new InterceptorManager_default()
    };
  }
  /**
   * Dispatch a request
   *
   * @param {String|Object} configOrUrl The config specific for this request (merged with this.defaults)
   * @param {?Object} config
   *
   * @returns {Promise} The Promise to be fulfilled
   */
  async request(configOrUrl, config) {
    try {
      return await this._request(configOrUrl, config);
    } catch (err) {
      if (err instanceof Error) {
        let dummy = {};
        Error.captureStackTrace ? Error.captureStackTrace(dummy) : dummy = new Error();
        const stack = dummy.stack ? dummy.stack.replace(/^.+\n/, "") : "";
        try {
          if (!err.stack) {
            err.stack = stack;
          } else if (stack && !String(err.stack).endsWith(stack.replace(/^.+\n.+\n/, ""))) {
            err.stack += "\n" + stack;
          }
        } catch (e2) {
        }
      }
      throw err;
    }
  }
  _request(configOrUrl, config) {
    if (typeof configOrUrl === "string") {
      config = config || {};
      config.url = configOrUrl;
    } else {
      config = configOrUrl || {};
    }
    config = mergeConfig(this.defaults, config);
    const { transitional: transitional2, paramsSerializer, headers } = config;
    if (transitional2 !== void 0) {
      validator_default.assertOptions(transitional2, {
        silentJSONParsing: validators2.transitional(validators2.boolean),
        forcedJSONParsing: validators2.transitional(validators2.boolean),
        clarifyTimeoutError: validators2.transitional(validators2.boolean)
      }, false);
    }
    if (paramsSerializer != null) {
      if (utils_default.isFunction(paramsSerializer)) {
        config.paramsSerializer = {
          serialize: paramsSerializer
        };
      } else {
        validator_default.assertOptions(paramsSerializer, {
          encode: validators2.function,
          serialize: validators2.function
        }, true);
      }
    }
    if (config.allowAbsoluteUrls !== void 0) {
    } else if (this.defaults.allowAbsoluteUrls !== void 0) {
      config.allowAbsoluteUrls = this.defaults.allowAbsoluteUrls;
    } else {
      config.allowAbsoluteUrls = true;
    }
    validator_default.assertOptions(config, {
      baseUrl: validators2.spelling("baseURL"),
      withXsrfToken: validators2.spelling("withXSRFToken")
    }, true);
    config.method = (config.method || this.defaults.method || "get").toLowerCase();
    let contextHeaders = headers && utils_default.merge(
      headers.common,
      headers[config.method]
    );
    headers && utils_default.forEach(
      ["delete", "get", "head", "post", "put", "patch", "common"],
      (method) => {
        delete headers[method];
      }
    );
    config.headers = AxiosHeaders_default.concat(contextHeaders, headers);
    const requestInterceptorChain = [];
    let synchronousRequestInterceptors = true;
    this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
      if (typeof interceptor.runWhen === "function" && interceptor.runWhen(config) === false) {
        return;
      }
      synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;
      requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);
    });
    const responseInterceptorChain = [];
    this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
      responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);
    });
    let promise;
    let i2 = 0;
    let len;
    if (!synchronousRequestInterceptors) {
      const chain2 = [dispatchRequest.bind(this), void 0];
      chain2.unshift.apply(chain2, requestInterceptorChain);
      chain2.push.apply(chain2, responseInterceptorChain);
      len = chain2.length;
      promise = Promise.resolve(config);
      while (i2 < len) {
        promise = promise.then(chain2[i2++], chain2[i2++]);
      }
      return promise;
    }
    len = requestInterceptorChain.length;
    let newConfig = config;
    i2 = 0;
    while (i2 < len) {
      const onFulfilled = requestInterceptorChain[i2++];
      const onRejected = requestInterceptorChain[i2++];
      try {
        newConfig = onFulfilled(newConfig);
      } catch (error) {
        onRejected.call(this, error);
        break;
      }
    }
    try {
      promise = dispatchRequest.call(this, newConfig);
    } catch (error) {
      return Promise.reject(error);
    }
    i2 = 0;
    len = responseInterceptorChain.length;
    while (i2 < len) {
      promise = promise.then(responseInterceptorChain[i2++], responseInterceptorChain[i2++]);
    }
    return promise;
  }
  getUri(config) {
    config = mergeConfig(this.defaults, config);
    const fullPath = buildFullPath(config.baseURL, config.url, config.allowAbsoluteUrls);
    return buildURL(fullPath, config.params, config.paramsSerializer);
  }
};
utils_default.forEach(["delete", "get", "head", "options"], function forEachMethodNoData(method) {
  Axios.prototype[method] = function(url, config) {
    return this.request(mergeConfig(config || {}, {
      method,
      url,
      data: (config || {}).data
    }));
  };
});
utils_default.forEach(["post", "put", "patch"], function forEachMethodWithData(method) {
  function generateHTTPMethod(isForm) {
    return function httpMethod(url, data, config) {
      return this.request(mergeConfig(config || {}, {
        method,
        headers: isForm ? {
          "Content-Type": "multipart/form-data"
        } : {},
        url,
        data
      }));
    };
  }
  Axios.prototype[method] = generateHTTPMethod();
  Axios.prototype[method + "Form"] = generateHTTPMethod(true);
});
var Axios_default = Axios;

// node_modules/axios/lib/cancel/CancelToken.js
var CancelToken = class _CancelToken {
  constructor(executor) {
    if (typeof executor !== "function") {
      throw new TypeError("executor must be a function.");
    }
    let resolvePromise;
    this.promise = new Promise(function promiseExecutor(resolve) {
      resolvePromise = resolve;
    });
    const token = this;
    this.promise.then((cancel) => {
      if (!token._listeners) return;
      let i2 = token._listeners.length;
      while (i2-- > 0) {
        token._listeners[i2](cancel);
      }
      token._listeners = null;
    });
    this.promise.then = (onfulfilled) => {
      let _resolve;
      const promise = new Promise((resolve) => {
        token.subscribe(resolve);
        _resolve = resolve;
      }).then(onfulfilled);
      promise.cancel = function reject() {
        token.unsubscribe(_resolve);
      };
      return promise;
    };
    executor(function cancel(message, config, request) {
      if (token.reason) {
        return;
      }
      token.reason = new CanceledError_default(message, config, request);
      resolvePromise(token.reason);
    });
  }
  /**
   * Throws a `CanceledError` if cancellation has been requested.
   */
  throwIfRequested() {
    if (this.reason) {
      throw this.reason;
    }
  }
  /**
   * Subscribe to the cancel signal
   */
  subscribe(listener) {
    if (this.reason) {
      listener(this.reason);
      return;
    }
    if (this._listeners) {
      this._listeners.push(listener);
    } else {
      this._listeners = [listener];
    }
  }
  /**
   * Unsubscribe from the cancel signal
   */
  unsubscribe(listener) {
    if (!this._listeners) {
      return;
    }
    const index5 = this._listeners.indexOf(listener);
    if (index5 !== -1) {
      this._listeners.splice(index5, 1);
    }
  }
  toAbortSignal() {
    const controller = new AbortController();
    const abort = (err) => {
      controller.abort(err);
    };
    this.subscribe(abort);
    controller.signal.unsubscribe = () => this.unsubscribe(abort);
    return controller.signal;
  }
  /**
   * Returns an object that contains a new `CancelToken` and a function that, when called,
   * cancels the `CancelToken`.
   */
  static source() {
    let cancel;
    const token = new _CancelToken(function executor(c3) {
      cancel = c3;
    });
    return {
      token,
      cancel
    };
  }
};
var CancelToken_default = CancelToken;

// node_modules/axios/lib/helpers/spread.js
function spread(callback) {
  return function wrap2(arr) {
    return callback.apply(null, arr);
  };
}

// node_modules/axios/lib/helpers/isAxiosError.js
function isAxiosError(payload) {
  return utils_default.isObject(payload) && payload.isAxiosError === true;
}

// node_modules/axios/lib/helpers/HttpStatusCode.js
var HttpStatusCode = {
  Continue: 100,
  SwitchingProtocols: 101,
  Processing: 102,
  EarlyHints: 103,
  Ok: 200,
  Created: 201,
  Accepted: 202,
  NonAuthoritativeInformation: 203,
  NoContent: 204,
  ResetContent: 205,
  PartialContent: 206,
  MultiStatus: 207,
  AlreadyReported: 208,
  ImUsed: 226,
  MultipleChoices: 300,
  MovedPermanently: 301,
  Found: 302,
  SeeOther: 303,
  NotModified: 304,
  UseProxy: 305,
  Unused: 306,
  TemporaryRedirect: 307,
  PermanentRedirect: 308,
  BadRequest: 400,
  Unauthorized: 401,
  PaymentRequired: 402,
  Forbidden: 403,
  NotFound: 404,
  MethodNotAllowed: 405,
  NotAcceptable: 406,
  ProxyAuthenticationRequired: 407,
  RequestTimeout: 408,
  Conflict: 409,
  Gone: 410,
  LengthRequired: 411,
  PreconditionFailed: 412,
  PayloadTooLarge: 413,
  UriTooLong: 414,
  UnsupportedMediaType: 415,
  RangeNotSatisfiable: 416,
  ExpectationFailed: 417,
  ImATeapot: 418,
  MisdirectedRequest: 421,
  UnprocessableEntity: 422,
  Locked: 423,
  FailedDependency: 424,
  TooEarly: 425,
  UpgradeRequired: 426,
  PreconditionRequired: 428,
  TooManyRequests: 429,
  RequestHeaderFieldsTooLarge: 431,
  UnavailableForLegalReasons: 451,
  InternalServerError: 500,
  NotImplemented: 501,
  BadGateway: 502,
  ServiceUnavailable: 503,
  GatewayTimeout: 504,
  HttpVersionNotSupported: 505,
  VariantAlsoNegotiates: 506,
  InsufficientStorage: 507,
  LoopDetected: 508,
  NotExtended: 510,
  NetworkAuthenticationRequired: 511
};
Object.entries(HttpStatusCode).forEach(([key, value]) => {
  HttpStatusCode[value] = key;
});
var HttpStatusCode_default = HttpStatusCode;

// node_modules/axios/lib/axios.js
function createInstance(defaultConfig2) {
  const context = new Axios_default(defaultConfig2);
  const instance = bind(Axios_default.prototype.request, context);
  utils_default.extend(instance, Axios_default.prototype, context, { allOwnKeys: true });
  utils_default.extend(instance, context, null, { allOwnKeys: true });
  instance.create = function create5(instanceConfig) {
    return createInstance(mergeConfig(defaultConfig2, instanceConfig));
  };
  return instance;
}
var axios = createInstance(defaults_default);
axios.Axios = Axios_default;
axios.CanceledError = CanceledError_default;
axios.CancelToken = CancelToken_default;
axios.isCancel = isCancel;
axios.VERSION = VERSION;
axios.toFormData = toFormData_default;
axios.AxiosError = AxiosError_default;
axios.Cancel = axios.CanceledError;
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = spread;
axios.isAxiosError = isAxiosError;
axios.mergeConfig = mergeConfig;
axios.AxiosHeaders = AxiosHeaders_default;
axios.formToJSON = (thing) => formDataToJSON_default(utils_default.isHTMLForm(thing) ? new FormData(thing) : thing);
axios.getAdapter = adapters_default.getAdapter;
axios.HttpStatusCode = HttpStatusCode_default;
axios.default = axios;
var axios_default = axios;

// node_modules/axios/index.js
var {
  Axios: Axios2,
  AxiosError: AxiosError2,
  CanceledError: CanceledError2,
  isCancel: isCancel2,
  CancelToken: CancelToken2,
  VERSION: VERSION2,
  all: all2,
  Cancel,
  isAxiosError: isAxiosError2,
  spread: spread2,
  toFormData: toFormData2,
  AxiosHeaders: AxiosHeaders2,
  HttpStatusCode: HttpStatusCode2,
  formToJSON,
  getAdapter,
  mergeConfig: mergeConfig2
} = axios_default;

// node_modules/zustand/esm/vanilla.mjs
var createStoreImpl2 = (createState2) => {
  let state;
  const listeners2 = /* @__PURE__ */ new Set();
  const setState = (partial, replace) => {
    const nextState = typeof partial === "function" ? partial(state) : partial;
    if (!Object.is(nextState, state)) {
      const previousState = state;
      state = (replace != null ? replace : typeof nextState !== "object" || nextState === null) ? nextState : Object.assign({}, state, nextState);
      listeners2.forEach((listener) => listener(state, previousState));
    }
  };
  const getState = () => state;
  const getInitialState = () => initialState;
  const subscribe2 = (listener) => {
    listeners2.add(listener);
    return () => listeners2.delete(listener);
  };
  const api = { setState, getState, getInitialState, subscribe: subscribe2 };
  const initialState = state = createState2(setState, getState, api);
  return api;
};
var createStore4 = (createState2) => createState2 ? createStoreImpl2(createState2) : createStoreImpl2;

// node_modules/zustand/esm/react.mjs
var import_react71 = __toESM(require_react(), 1);
var identity2 = (arg) => arg;
function useStore(api, selector = identity2) {
  const slice3 = import_react71.default.useSyncExternalStore(
    api.subscribe,
    () => selector(api.getState()),
    () => selector(api.getInitialState())
  );
  import_react71.default.useDebugValue(slice3);
  return slice3;
}
var createImpl = (createState2) => {
  const api = createStore4(createState2);
  const useBoundStore = (selector) => useStore(api, selector);
  Object.assign(useBoundStore, api);
  return useBoundStore;
};
var create4 = (createState2) => createState2 ? createImpl(createState2) : createImpl;

// node_modules/@bedrock_org/passport/dist/index.es.js
var or = { exports: {} };
var st = {};
var qr;
function gi() {
  return qr || (qr = 1, function() {
    var e2 = import_react72.default, t2 = Symbol.for("react.element"), r2 = Symbol.for("react.portal"), n2 = Symbol.for("react.fragment"), o2 = Symbol.for("react.strict_mode"), s2 = Symbol.for("react.profiler"), a3 = Symbol.for("react.provider"), i2 = Symbol.for("react.context"), d2 = Symbol.for("react.forward_ref"), u3 = Symbol.for("react.suspense"), p2 = Symbol.for("react.suspense_list"), m3 = Symbol.for("react.memo"), g3 = Symbol.for("react.lazy"), b4 = Symbol.for("react.offscreen"), E3 = Symbol.iterator, h = "@@iterator";
    function v2(c3) {
      if (c3 === null || typeof c3 != "object")
        return null;
      var y2 = E3 && c3[E3] || c3[h];
      return typeof y2 == "function" ? y2 : null;
    }
    var x2 = e2.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;
    function w2(c3) {
      {
        for (var y2 = arguments.length, C2 = new Array(y2 > 1 ? y2 - 1 : 0), A = 1; A < y2; A++)
          C2[A - 1] = arguments[A];
        P("error", c3, C2);
      }
    }
    function P(c3, y2, C2) {
      {
        var A = x2.ReactDebugCurrentFrame, F2 = A.getStackAddendum();
        F2 !== "" && (y2 += "%s", C2 = C2.concat([F2]));
        var M3 = C2.map(function(j3) {
          return String(j3);
        });
        M3.unshift("Warning: " + y2), Function.prototype.apply.call(console[c3], console, M3);
      }
    }
    var R2 = false, N2 = false, W3 = false, L2 = false, J2 = false, Z2;
    Z2 = Symbol.for("react.module.reference");
    function oe2(c3) {
      return !!(typeof c3 == "string" || typeof c3 == "function" || c3 === n2 || c3 === s2 || J2 || c3 === o2 || c3 === u3 || c3 === p2 || L2 || c3 === b4 || R2 || N2 || W3 || typeof c3 == "object" && c3 !== null && (c3.$$typeof === g3 || c3.$$typeof === m3 || c3.$$typeof === a3 || c3.$$typeof === i2 || c3.$$typeof === d2 || // This needs to include all possible module reference object
      // types supported by any Flight configuration anywhere since
      // we don't know which Flight build this will end up being used
      // with.
      c3.$$typeof === Z2 || c3.getModuleId !== void 0));
    }
    function Te2(c3, y2, C2) {
      var A = c3.displayName;
      if (A)
        return A;
      var F2 = y2.displayName || y2.name || "";
      return F2 !== "" ? C2 + "(" + F2 + ")" : C2;
    }
    function B2(c3) {
      return c3.displayName || "Context";
    }
    function K2(c3) {
      if (c3 == null)
        return null;
      if (typeof c3.tag == "number" && w2("Received an unexpected object in getComponentNameFromType(). This is likely a bug in React. Please file an issue."), typeof c3 == "function")
        return c3.displayName || c3.name || null;
      if (typeof c3 == "string")
        return c3;
      switch (c3) {
        case n2:
          return "Fragment";
        case r2:
          return "Portal";
        case s2:
          return "Profiler";
        case o2:
          return "StrictMode";
        case u3:
          return "Suspense";
        case p2:
          return "SuspenseList";
      }
      if (typeof c3 == "object")
        switch (c3.$$typeof) {
          case i2:
            var y2 = c3;
            return B2(y2) + ".Consumer";
          case a3:
            var C2 = c3;
            return B2(C2._context) + ".Provider";
          case d2:
            return Te2(c3, c3.render, "ForwardRef");
          case m3:
            var A = c3.displayName || null;
            return A !== null ? A : K2(c3.type) || "Memo";
          case g3: {
            var F2 = c3, M3 = F2._payload, j3 = F2._init;
            try {
              return K2(j3(M3));
            } catch {
              return null;
            }
          }
        }
      return null;
    }
    var Q2 = Object.assign, ce2 = 0, pe2, Ne2, xe2, se2, _e2, ee2, S2;
    function O2() {
    }
    O2.__reactDisabledLog = true;
    function U2() {
      {
        if (ce2 === 0) {
          pe2 = console.log, Ne2 = console.info, xe2 = console.warn, se2 = console.error, _e2 = console.group, ee2 = console.groupCollapsed, S2 = console.groupEnd;
          var c3 = {
            configurable: true,
            enumerable: true,
            value: O2,
            writable: true
          };
          Object.defineProperties(console, {
            info: c3,
            log: c3,
            warn: c3,
            error: c3,
            group: c3,
            groupCollapsed: c3,
            groupEnd: c3
          });
        }
        ce2++;
      }
    }
    function D3() {
      {
        if (ce2--, ce2 === 0) {
          var c3 = {
            configurable: true,
            enumerable: true,
            writable: true
          };
          Object.defineProperties(console, {
            log: Q2({}, c3, {
              value: pe2
            }),
            info: Q2({}, c3, {
              value: Ne2
            }),
            warn: Q2({}, c3, {
              value: xe2
            }),
            error: Q2({}, c3, {
              value: se2
            }),
            group: Q2({}, c3, {
              value: _e2
            }),
            groupCollapsed: Q2({}, c3, {
              value: ee2
            }),
            groupEnd: Q2({}, c3, {
              value: S2
            })
          });
        }
        ce2 < 0 && w2("disabledDepth fell below zero. This is a bug in React. Please file an issue.");
      }
    }
    var te2 = x2.ReactCurrentDispatcher, le2;
    function mt(c3, y2, C2) {
      {
        if (le2 === void 0)
          try {
            throw Error();
          } catch (F2) {
            var A = F2.stack.trim().match(/\n( *(at )?)/);
            le2 = A && A[1] || "";
          }
        return `
` + le2 + c3;
      }
    }
    var Mt = false, gt;
    {
      var ks = typeof WeakMap == "function" ? WeakMap : Map;
      gt = new ks();
    }
    function Or(c3, y2) {
      if (!c3 || Mt)
        return "";
      {
        var C2 = gt.get(c3);
        if (C2 !== void 0)
          return C2;
      }
      var A;
      Mt = true;
      var F2 = Error.prepareStackTrace;
      Error.prepareStackTrace = void 0;
      var M3;
      M3 = te2.current, te2.current = null, U2();
      try {
        if (y2) {
          var j3 = function() {
            throw Error();
          };
          if (Object.defineProperty(j3.prototype, "props", {
            set: function() {
              throw Error();
            }
          }), typeof Reflect == "object" && Reflect.construct) {
            try {
              Reflect.construct(j3, []);
            } catch (re2) {
              A = re2;
            }
            Reflect.construct(c3, [], j3);
          } else {
            try {
              j3.call();
            } catch (re2) {
              A = re2;
            }
            c3.call(j3.prototype);
          }
        } else {
          try {
            throw Error();
          } catch (re2) {
            A = re2;
          }
          c3();
        }
      } catch (re2) {
        if (re2 && A && typeof re2.stack == "string") {
          for (var _2 = re2.stack.split(`
`), Y2 = A.stack.split(`
`), G2 = _2.length - 1, V2 = Y2.length - 1; G2 >= 1 && V2 >= 0 && _2[G2] !== Y2[V2]; )
            V2--;
          for (; G2 >= 1 && V2 >= 0; G2--, V2--)
            if (_2[G2] !== Y2[V2]) {
              if (G2 !== 1 || V2 !== 1)
                do
                  if (G2--, V2--, V2 < 0 || _2[G2] !== Y2[V2]) {
                    var ne2 = `
` + _2[G2].replace(" at new ", " at ");
                    return c3.displayName && ne2.includes("<anonymous>") && (ne2 = ne2.replace("<anonymous>", c3.displayName)), typeof c3 == "function" && gt.set(c3, ne2), ne2;
                  }
                while (G2 >= 1 && V2 >= 0);
              break;
            }
        }
      } finally {
        Mt = false, te2.current = M3, D3(), Error.prepareStackTrace = F2;
      }
      var $e = c3 ? c3.displayName || c3.name : "", Oe2 = $e ? mt($e) : "";
      return typeof c3 == "function" && gt.set(c3, Oe2), Oe2;
    }
    function Ts(c3, y2, C2) {
      return Or(c3, false);
    }
    function Ns(c3) {
      var y2 = c3.prototype;
      return !!(y2 && y2.isReactComponent);
    }
    function bt(c3, y2, C2) {
      if (c3 == null)
        return "";
      if (typeof c3 == "function")
        return Or(c3, Ns(c3));
      if (typeof c3 == "string")
        return mt(c3);
      switch (c3) {
        case u3:
          return mt("Suspense");
        case p2:
          return mt("SuspenseList");
      }
      if (typeof c3 == "object")
        switch (c3.$$typeof) {
          case d2:
            return Ts(c3.render);
          case m3:
            return bt(c3.type, y2, C2);
          case g3: {
            var A = c3, F2 = A._payload, M3 = A._init;
            try {
              return bt(M3(F2), y2, C2);
            } catch {
            }
          }
        }
      return "";
    }
    var rt = Object.prototype.hasOwnProperty, jr = {}, Lr = x2.ReactDebugCurrentFrame;
    function vt(c3) {
      if (c3) {
        var y2 = c3._owner, C2 = bt(c3.type, c3._source, y2 ? y2.type : null);
        Lr.setExtraStackFrame(C2);
      } else
        Lr.setExtraStackFrame(null);
    }
    function _s(c3, y2, C2, A, F2) {
      {
        var M3 = Function.call.bind(rt);
        for (var j3 in c3)
          if (M3(c3, j3)) {
            var _2 = void 0;
            try {
              if (typeof c3[j3] != "function") {
                var Y2 = Error((A || "React class") + ": " + C2 + " type `" + j3 + "` is invalid; it must be a function, usually from the `prop-types` package, but received `" + typeof c3[j3] + "`.This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.");
                throw Y2.name = "Invariant Violation", Y2;
              }
              _2 = c3[j3](y2, j3, A, C2, null, "SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED");
            } catch (G2) {
              _2 = G2;
            }
            _2 && !(_2 instanceof Error) && (vt(F2), w2("%s: type specification of %s `%s` is invalid; the type checker function must return `null` or an `Error` but returned a %s. You may have forgotten to pass an argument to the type checker creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and shape all require an argument).", A || "React class", C2, j3, typeof _2), vt(null)), _2 instanceof Error && !(_2.message in jr) && (jr[_2.message] = true, vt(F2), w2("Failed %s type: %s", C2, _2.message), vt(null));
          }
      }
    }
    var Os = Array.isArray;
    function Ut(c3) {
      return Os(c3);
    }
    function js(c3) {
      {
        var y2 = typeof Symbol == "function" && Symbol.toStringTag, C2 = y2 && c3[Symbol.toStringTag] || c3.constructor.name || "Object";
        return C2;
      }
    }
    function Ls(c3) {
      try {
        return Dr(c3), false;
      } catch {
        return true;
      }
    }
    function Dr(c3) {
      return "" + c3;
    }
    function Fr2(c3) {
      if (Ls(c3))
        return w2("The provided key is an unsupported type %s. This value must be coerced to a string before before using it here.", js(c3)), Dr(c3);
    }
    var nt = x2.ReactCurrentOwner, Ds = {
      key: true,
      ref: true,
      __self: true,
      __source: true
    }, Br, Mr, zt;
    zt = {};
    function Fs(c3) {
      if (rt.call(c3, "ref")) {
        var y2 = Object.getOwnPropertyDescriptor(c3, "ref").get;
        if (y2 && y2.isReactWarning)
          return false;
      }
      return c3.ref !== void 0;
    }
    function Bs(c3) {
      if (rt.call(c3, "key")) {
        var y2 = Object.getOwnPropertyDescriptor(c3, "key").get;
        if (y2 && y2.isReactWarning)
          return false;
      }
      return c3.key !== void 0;
    }
    function Ms(c3, y2) {
      if (typeof c3.ref == "string" && nt.current && y2 && nt.current.stateNode !== y2) {
        var C2 = K2(nt.current.type);
        zt[C2] || (w2('Component "%s" contains the string ref "%s". Support for string refs will be removed in a future major release. This case cannot be automatically converted to an arrow function. We ask you to manually fix this case by using useRef() or createRef() instead. Learn more about using refs safely here: https://reactjs.org/link/strict-mode-string-ref', K2(nt.current.type), c3.ref), zt[C2] = true);
      }
    }
    function Us(c3, y2) {
      {
        var C2 = function() {
          Br || (Br = true, w2("%s: `key` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", y2));
        };
        C2.isReactWarning = true, Object.defineProperty(c3, "key", {
          get: C2,
          configurable: true
        });
      }
    }
    function zs(c3, y2) {
      {
        var C2 = function() {
          Mr || (Mr = true, w2("%s: `ref` is not a prop. Trying to access it will result in `undefined` being returned. If you need to access the same value within the child component, you should pass it as a different prop. (https://reactjs.org/link/special-props)", y2));
        };
        C2.isReactWarning = true, Object.defineProperty(c3, "ref", {
          get: C2,
          configurable: true
        });
      }
    }
    var $s = function(c3, y2, C2, A, F2, M3, j3) {
      var _2 = {
        // This tag allows us to uniquely identify this as a React Element
        $$typeof: t2,
        // Built-in properties that belong on the element
        type: c3,
        key: y2,
        ref: C2,
        props: j3,
        // Record the component responsible for creating this element.
        _owner: M3
      };
      return _2._store = {}, Object.defineProperty(_2._store, "validated", {
        configurable: false,
        enumerable: false,
        writable: true,
        value: false
      }), Object.defineProperty(_2, "_self", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: A
      }), Object.defineProperty(_2, "_source", {
        configurable: false,
        enumerable: false,
        writable: false,
        value: F2
      }), Object.freeze && (Object.freeze(_2.props), Object.freeze(_2)), _2;
    };
    function Ws(c3, y2, C2, A, F2) {
      {
        var M3, j3 = {}, _2 = null, Y2 = null;
        C2 !== void 0 && (Fr2(C2), _2 = "" + C2), Bs(y2) && (Fr2(y2.key), _2 = "" + y2.key), Fs(y2) && (Y2 = y2.ref, Ms(y2, F2));
        for (M3 in y2)
          rt.call(y2, M3) && !Ds.hasOwnProperty(M3) && (j3[M3] = y2[M3]);
        if (c3 && c3.defaultProps) {
          var G2 = c3.defaultProps;
          for (M3 in G2)
            j3[M3] === void 0 && (j3[M3] = G2[M3]);
        }
        if (_2 || Y2) {
          var V2 = typeof c3 == "function" ? c3.displayName || c3.name || "Unknown" : c3;
          _2 && Us(j3, V2), Y2 && zs(j3, V2);
        }
        return $s(c3, _2, Y2, F2, A, nt.current, j3);
      }
    }
    var $t = x2.ReactCurrentOwner, Ur = x2.ReactDebugCurrentFrame;
    function ze2(c3) {
      if (c3) {
        var y2 = c3._owner, C2 = bt(c3.type, c3._source, y2 ? y2.type : null);
        Ur.setExtraStackFrame(C2);
      } else
        Ur.setExtraStackFrame(null);
    }
    var Wt;
    Wt = false;
    function Gt(c3) {
      return typeof c3 == "object" && c3 !== null && c3.$$typeof === t2;
    }
    function zr() {
      {
        if ($t.current) {
          var c3 = K2($t.current.type);
          if (c3)
            return `

Check the render method of \`` + c3 + "`.";
        }
        return "";
      }
    }
    function Gs(c3) {
      return "";
    }
    var $r = {};
    function Vs(c3) {
      {
        var y2 = zr();
        if (!y2) {
          var C2 = typeof c3 == "string" ? c3 : c3.displayName || c3.name;
          C2 && (y2 = `

Check the top-level render call using <` + C2 + ">.");
        }
        return y2;
      }
    }
    function Wr(c3, y2) {
      {
        if (!c3._store || c3._store.validated || c3.key != null)
          return;
        c3._store.validated = true;
        var C2 = Vs(y2);
        if ($r[C2])
          return;
        $r[C2] = true;
        var A = "";
        c3 && c3._owner && c3._owner !== $t.current && (A = " It was passed a child from " + K2(c3._owner.type) + "."), ze2(c3), w2('Each child in a list should have a unique "key" prop.%s%s See https://reactjs.org/link/warning-keys for more information.', C2, A), ze2(null);
      }
    }
    function Gr(c3, y2) {
      {
        if (typeof c3 != "object")
          return;
        if (Ut(c3))
          for (var C2 = 0; C2 < c3.length; C2++) {
            var A = c3[C2];
            Gt(A) && Wr(A, y2);
          }
        else if (Gt(c3))
          c3._store && (c3._store.validated = true);
        else if (c3) {
          var F2 = v2(c3);
          if (typeof F2 == "function" && F2 !== c3.entries)
            for (var M3 = F2.call(c3), j3; !(j3 = M3.next()).done; )
              Gt(j3.value) && Wr(j3.value, y2);
        }
      }
    }
    function Hs(c3) {
      {
        var y2 = c3.type;
        if (y2 == null || typeof y2 == "string")
          return;
        var C2;
        if (typeof y2 == "function")
          C2 = y2.propTypes;
        else if (typeof y2 == "object" && (y2.$$typeof === d2 || // Note: Memo only checks outer props here.
        // Inner props are checked in the reconciler.
        y2.$$typeof === m3))
          C2 = y2.propTypes;
        else
          return;
        if (C2) {
          var A = K2(y2);
          _s(C2, c3.props, "prop", A, c3);
        } else if (y2.PropTypes !== void 0 && !Wt) {
          Wt = true;
          var F2 = K2(y2);
          w2("Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?", F2 || "Unknown");
        }
        typeof y2.getDefaultProps == "function" && !y2.getDefaultProps.isReactClassApproved && w2("getDefaultProps is only used on classic React.createClass definitions. Use a static property named `defaultProps` instead.");
      }
    }
    function Js(c3) {
      {
        for (var y2 = Object.keys(c3.props), C2 = 0; C2 < y2.length; C2++) {
          var A = y2[C2];
          if (A !== "children" && A !== "key") {
            ze2(c3), w2("Invalid prop `%s` supplied to `React.Fragment`. React.Fragment can only have `key` and `children` props.", A), ze2(null);
            break;
          }
        }
        c3.ref !== null && (ze2(c3), w2("Invalid attribute `ref` supplied to `React.Fragment`."), ze2(null));
      }
    }
    var Vr = {};
    function Hr(c3, y2, C2, A, F2, M3) {
      {
        var j3 = oe2(c3);
        if (!j3) {
          var _2 = "";
          (c3 === void 0 || typeof c3 == "object" && c3 !== null && Object.keys(c3).length === 0) && (_2 += " You likely forgot to export your component from the file it's defined in, or you might have mixed up default and named imports.");
          var Y2 = Gs();
          Y2 ? _2 += Y2 : _2 += zr();
          var G2;
          c3 === null ? G2 = "null" : Ut(c3) ? G2 = "array" : c3 !== void 0 && c3.$$typeof === t2 ? (G2 = "<" + (K2(c3.type) || "Unknown") + " />", _2 = " Did you accidentally export a JSX literal instead of a component?") : G2 = typeof c3, w2("React.jsx: type is invalid -- expected a string (for built-in components) or a class/function (for composite components) but got: %s.%s", G2, _2);
        }
        var V2 = Ws(c3, y2, C2, F2, M3);
        if (V2 == null)
          return V2;
        if (j3) {
          var ne2 = y2.children;
          if (ne2 !== void 0)
            if (A)
              if (Ut(ne2)) {
                for (var $e = 0; $e < ne2.length; $e++)
                  Gr(ne2[$e], c3);
                Object.freeze && Object.freeze(ne2);
              } else
                w2("React.jsx: Static children should always be an array. You are likely explicitly calling React.jsxs or React.jsxDEV. Use the Babel transform instead.");
            else
              Gr(ne2, c3);
        }
        if (rt.call(y2, "key")) {
          var Oe2 = K2(c3), re2 = Object.keys(y2).filter(function(Qs) {
            return Qs !== "key";
          }), Vt = re2.length > 0 ? "{key: someKey, " + re2.join(": ..., ") + ": ...}" : "{key: someKey}";
          if (!Vr[Oe2 + Vt]) {
            var Zs = re2.length > 0 ? "{" + re2.join(": ..., ") + ": ...}" : "{}";
            w2(`A props object containing a "key" prop is being spread into JSX:
  let props = %s;
  <%s {...props} />
React keys must be passed directly to JSX without using spread:
  let props = %s;
  <%s key={someKey} {...props} />`, Vt, Oe2, Zs, Oe2), Vr[Oe2 + Vt] = true;
          }
        }
        return c3 === n2 ? Js(V2) : Hs(V2), V2;
      }
    }
    function Ks(c3, y2, C2) {
      return Hr(c3, y2, C2, true);
    }
    function Ys(c3, y2, C2) {
      return Hr(c3, y2, C2, false);
    }
    var qs = Ys, Xs = Ks;
    st.Fragment = n2, st.jsx = qs, st.jsxs = Xs;
  }()), st;
}
false ? or.exports = mi() : or.exports = gi();
var l2 = or.exports;
function Un(e2) {
  var t2, r2, n2 = "";
  if (typeof e2 == "string" || typeof e2 == "number") n2 += e2;
  else if (typeof e2 == "object") if (Array.isArray(e2)) {
    var o2 = e2.length;
    for (t2 = 0; t2 < o2; t2++) e2[t2] && (r2 = Un(e2[t2])) && (n2 && (n2 += " "), n2 += r2);
  } else for (r2 in e2) e2[r2] && (n2 && (n2 += " "), n2 += r2);
  return n2;
}
function zn() {
  for (var e2, t2, r2 = 0, n2 = "", o2 = arguments.length; r2 < o2; r2++) (e2 = arguments[r2]) && (t2 = Un(e2)) && (n2 && (n2 += " "), n2 += t2);
  return n2;
}
var vr = "-";
var bi = (e2) => {
  const t2 = yi(e2), {
    conflictingClassGroups: r2,
    conflictingClassGroupModifiers: n2
  } = e2;
  return {
    getClassGroupId: (a3) => {
      const i2 = a3.split(vr);
      return i2[0] === "" && i2.length !== 1 && i2.shift(), $n(i2, t2) || vi(a3);
    },
    getConflictingClassGroupIds: (a3, i2) => {
      const d2 = r2[a3] || [];
      return i2 && n2[a3] ? [...d2, ...n2[a3]] : d2;
    }
  };
};
var $n = (e2, t2) => {
  var a3;
  if (e2.length === 0)
    return t2.classGroupId;
  const r2 = e2[0], n2 = t2.nextPart.get(r2), o2 = n2 ? $n(e2.slice(1), n2) : void 0;
  if (o2)
    return o2;
  if (t2.validators.length === 0)
    return;
  const s2 = e2.join(vr);
  return (a3 = t2.validators.find(({
    validator: i2
  }) => i2(s2))) == null ? void 0 : a3.classGroupId;
};
var Xr = /^\[(.+)\]$/;
var vi = (e2) => {
  if (Xr.test(e2)) {
    const t2 = Xr.exec(e2)[1], r2 = t2 == null ? void 0 : t2.substring(0, t2.indexOf(":"));
    if (r2)
      return "arbitrary.." + r2;
  }
};
var yi = (e2) => {
  const {
    theme: t2,
    prefix: r2
  } = e2, n2 = {
    nextPart: /* @__PURE__ */ new Map(),
    validators: []
  };
  return wi(Object.entries(e2.classGroups), r2).forEach(([s2, a3]) => {
    sr(a3, n2, s2, t2);
  }), n2;
};
var sr = (e2, t2, r2, n2) => {
  e2.forEach((o2) => {
    if (typeof o2 == "string") {
      const s2 = o2 === "" ? t2 : Zr(t2, o2);
      s2.classGroupId = r2;
      return;
    }
    if (typeof o2 == "function") {
      if (xi(o2)) {
        sr(o2(n2), t2, r2, n2);
        return;
      }
      t2.validators.push({
        validator: o2,
        classGroupId: r2
      });
      return;
    }
    Object.entries(o2).forEach(([s2, a3]) => {
      sr(a3, Zr(t2, s2), r2, n2);
    });
  });
};
var Zr = (e2, t2) => {
  let r2 = e2;
  return t2.split(vr).forEach((n2) => {
    r2.nextPart.has(n2) || r2.nextPart.set(n2, {
      nextPart: /* @__PURE__ */ new Map(),
      validators: []
    }), r2 = r2.nextPart.get(n2);
  }), r2;
};
var xi = (e2) => e2.isThemeGetter;
var wi = (e2, t2) => t2 ? e2.map(([r2, n2]) => {
  const o2 = n2.map((s2) => typeof s2 == "string" ? t2 + s2 : typeof s2 == "object" ? Object.fromEntries(Object.entries(s2).map(([a3, i2]) => [t2 + a3, i2])) : s2);
  return [r2, o2];
}) : e2;
var Ei = (e2) => {
  if (e2 < 1)
    return {
      get: () => {
      },
      set: () => {
      }
    };
  let t2 = 0, r2 = /* @__PURE__ */ new Map(), n2 = /* @__PURE__ */ new Map();
  const o2 = (s2, a3) => {
    r2.set(s2, a3), t2++, t2 > e2 && (t2 = 0, n2 = r2, r2 = /* @__PURE__ */ new Map());
  };
  return {
    get(s2) {
      let a3 = r2.get(s2);
      if (a3 !== void 0)
        return a3;
      if ((a3 = n2.get(s2)) !== void 0)
        return o2(s2, a3), a3;
    },
    set(s2, a3) {
      r2.has(s2) ? r2.set(s2, a3) : o2(s2, a3);
    }
  };
};
var Wn = "!";
var Ci = (e2) => {
  const {
    separator: t2,
    experimentalParseClassName: r2
  } = e2, n2 = t2.length === 1, o2 = t2[0], s2 = t2.length, a3 = (i2) => {
    const d2 = [];
    let u3 = 0, p2 = 0, m3;
    for (let v2 = 0; v2 < i2.length; v2++) {
      let x2 = i2[v2];
      if (u3 === 0) {
        if (x2 === o2 && (n2 || i2.slice(v2, v2 + s2) === t2)) {
          d2.push(i2.slice(p2, v2)), p2 = v2 + s2;
          continue;
        }
        if (x2 === "/") {
          m3 = v2;
          continue;
        }
      }
      x2 === "[" ? u3++ : x2 === "]" && u3--;
    }
    const g3 = d2.length === 0 ? i2 : i2.substring(p2), b4 = g3.startsWith(Wn), E3 = b4 ? g3.substring(1) : g3, h = m3 && m3 > p2 ? m3 - p2 : void 0;
    return {
      modifiers: d2,
      hasImportantModifier: b4,
      baseClassName: E3,
      maybePostfixModifierPosition: h
    };
  };
  return r2 ? (i2) => r2({
    className: i2,
    parseClassName: a3
  }) : a3;
};
var Pi2 = (e2) => {
  if (e2.length <= 1)
    return e2;
  const t2 = [];
  let r2 = [];
  return e2.forEach((n2) => {
    n2[0] === "[" ? (t2.push(...r2.sort(), n2), r2 = []) : r2.push(n2);
  }), t2.push(...r2.sort()), t2;
};
var Si = (e2) => ({
  cache: Ei(e2.cacheSize),
  parseClassName: Ci(e2),
  ...bi(e2)
});
var Ri = /\s+/;
var Ai = (e2, t2) => {
  const {
    parseClassName: r2,
    getClassGroupId: n2,
    getConflictingClassGroupIds: o2
  } = t2, s2 = [], a3 = e2.trim().split(Ri);
  let i2 = "";
  for (let d2 = a3.length - 1; d2 >= 0; d2 -= 1) {
    const u3 = a3[d2], {
      modifiers: p2,
      hasImportantModifier: m3,
      baseClassName: g3,
      maybePostfixModifierPosition: b4
    } = r2(u3);
    let E3 = !!b4, h = n2(E3 ? g3.substring(0, b4) : g3);
    if (!h) {
      if (!E3) {
        i2 = u3 + (i2.length > 0 ? " " + i2 : i2);
        continue;
      }
      if (h = n2(g3), !h) {
        i2 = u3 + (i2.length > 0 ? " " + i2 : i2);
        continue;
      }
      E3 = false;
    }
    const v2 = Pi2(p2).join(":"), x2 = m3 ? v2 + Wn : v2, w2 = x2 + h;
    if (s2.includes(w2))
      continue;
    s2.push(w2);
    const P = o2(h, E3);
    for (let R2 = 0; R2 < P.length; ++R2) {
      const N2 = P[R2];
      s2.push(x2 + N2);
    }
    i2 = u3 + (i2.length > 0 ? " " + i2 : i2);
  }
  return i2;
};
function Ii() {
  let e2 = 0, t2, r2, n2 = "";
  for (; e2 < arguments.length; )
    (t2 = arguments[e2++]) && (r2 = Gn(t2)) && (n2 && (n2 += " "), n2 += r2);
  return n2;
}
var Gn = (e2) => {
  if (typeof e2 == "string")
    return e2;
  let t2, r2 = "";
  for (let n2 = 0; n2 < e2.length; n2++)
    e2[n2] && (t2 = Gn(e2[n2])) && (r2 && (r2 += " "), r2 += t2);
  return r2;
};
function ki(e2, ...t2) {
  let r2, n2, o2, s2 = a3;
  function a3(d2) {
    const u3 = t2.reduce((p2, m3) => m3(p2), e2());
    return r2 = Si(u3), n2 = r2.cache.get, o2 = r2.cache.set, s2 = i2, i2(d2);
  }
  function i2(d2) {
    const u3 = n2(d2);
    if (u3)
      return u3;
    const p2 = Ai(d2, r2);
    return o2(d2, p2), p2;
  }
  return function() {
    return s2(Ii.apply(null, arguments));
  };
}
var z2 = (e2) => {
  const t2 = (r2) => r2[e2] || [];
  return t2.isThemeGetter = true, t2;
};
var Vn = /^\[(?:([a-z-]+):)?(.+)\]$/i;
var Ti = /^\d+\/\d+$/;
var Ni = /* @__PURE__ */ new Set(["px", "full", "screen"]);
var _i = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/;
var Oi = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/;
var ji = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/;
var Li = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/;
var Di = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/;
var me2 = (e2) => Ke(e2) || Ni.has(e2) || Ti.test(e2);
var Ee2 = (e2) => Ze(e2, "length", Gi);
var Ke = (e2) => !!e2 && !Number.isNaN(Number(e2));
var Ht = (e2) => Ze(e2, "number", Ke);
var it = (e2) => !!e2 && Number.isInteger(Number(e2));
var Fi = (e2) => e2.endsWith("%") && Ke(e2.slice(0, -1));
var k3 = (e2) => Vn.test(e2);
var Ce2 = (e2) => _i.test(e2);
var Bi = /* @__PURE__ */ new Set(["length", "size", "percentage"]);
var Mi = (e2) => Ze(e2, Bi, Hn);
var Ui = (e2) => Ze(e2, "position", Hn);
var zi = /* @__PURE__ */ new Set(["image", "url"]);
var $i = (e2) => Ze(e2, zi, Hi);
var Wi = (e2) => Ze(e2, "", Vi);
var at = () => true;
var Ze = (e2, t2, r2) => {
  const n2 = Vn.exec(e2);
  return n2 ? n2[1] ? typeof t2 == "string" ? n2[1] === t2 : t2.has(n2[1]) : r2(n2[2]) : false;
};
var Gi = (e2) => (
  // `colorFunctionRegex` check is necessary because color functions can have percentages in them which which would be incorrectly classified as lengths.
  // For example, `hsl(0 0% 0%)` would be classified as a length without this check.
  // I could also use lookbehind assertion in `lengthUnitRegex` but that isn't supported widely enough.
  Oi.test(e2) && !ji.test(e2)
);
var Hn = () => false;
var Vi = (e2) => Li.test(e2);
var Hi = (e2) => Di.test(e2);
var Ji = () => {
  const e2 = z2("colors"), t2 = z2("spacing"), r2 = z2("blur"), n2 = z2("brightness"), o2 = z2("borderColor"), s2 = z2("borderRadius"), a3 = z2("borderSpacing"), i2 = z2("borderWidth"), d2 = z2("contrast"), u3 = z2("grayscale"), p2 = z2("hueRotate"), m3 = z2("invert"), g3 = z2("gap"), b4 = z2("gradientColorStops"), E3 = z2("gradientColorStopPositions"), h = z2("inset"), v2 = z2("margin"), x2 = z2("opacity"), w2 = z2("padding"), P = z2("saturate"), R2 = z2("scale"), N2 = z2("sepia"), W3 = z2("skew"), L2 = z2("space"), J2 = z2("translate"), Z2 = () => ["auto", "contain", "none"], oe2 = () => ["auto", "hidden", "clip", "visible", "scroll"], Te2 = () => ["auto", k3, t2], B2 = () => [k3, t2], K2 = () => ["", me2, Ee2], Q2 = () => ["auto", Ke, k3], ce2 = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"], pe2 = () => ["solid", "dashed", "dotted", "double", "none"], Ne2 = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"], xe2 = () => ["start", "end", "center", "between", "around", "evenly", "stretch"], se2 = () => ["", "0", k3], _e2 = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"], ee2 = () => [Ke, k3];
  return {
    cacheSize: 500,
    separator: ":",
    theme: {
      colors: [at],
      spacing: [me2, Ee2],
      blur: ["none", "", Ce2, k3],
      brightness: ee2(),
      borderColor: [e2],
      borderRadius: ["none", "", "full", Ce2, k3],
      borderSpacing: B2(),
      borderWidth: K2(),
      contrast: ee2(),
      grayscale: se2(),
      hueRotate: ee2(),
      invert: se2(),
      gap: B2(),
      gradientColorStops: [e2],
      gradientColorStopPositions: [Fi, Ee2],
      inset: Te2(),
      margin: Te2(),
      opacity: ee2(),
      padding: B2(),
      saturate: ee2(),
      scale: ee2(),
      sepia: se2(),
      skew: ee2(),
      space: B2(),
      translate: B2()
    },
    classGroups: {
      // Layout
      /**
       * Aspect Ratio
       * @see https://tailwindcss.com/docs/aspect-ratio
       */
      aspect: [{
        aspect: ["auto", "square", "video", k3]
      }],
      /**
       * Container
       * @see https://tailwindcss.com/docs/container
       */
      container: ["container"],
      /**
       * Columns
       * @see https://tailwindcss.com/docs/columns
       */
      columns: [{
        columns: [Ce2]
      }],
      /**
       * Break After
       * @see https://tailwindcss.com/docs/break-after
       */
      "break-after": [{
        "break-after": _e2()
      }],
      /**
       * Break Before
       * @see https://tailwindcss.com/docs/break-before
       */
      "break-before": [{
        "break-before": _e2()
      }],
      /**
       * Break Inside
       * @see https://tailwindcss.com/docs/break-inside
       */
      "break-inside": [{
        "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
      }],
      /**
       * Box Decoration Break
       * @see https://tailwindcss.com/docs/box-decoration-break
       */
      "box-decoration": [{
        "box-decoration": ["slice", "clone"]
      }],
      /**
       * Box Sizing
       * @see https://tailwindcss.com/docs/box-sizing
       */
      box: [{
        box: ["border", "content"]
      }],
      /**
       * Display
       * @see https://tailwindcss.com/docs/display
       */
      display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
      /**
       * Floats
       * @see https://tailwindcss.com/docs/float
       */
      float: [{
        float: ["right", "left", "none", "start", "end"]
      }],
      /**
       * Clear
       * @see https://tailwindcss.com/docs/clear
       */
      clear: [{
        clear: ["left", "right", "both", "none", "start", "end"]
      }],
      /**
       * Isolation
       * @see https://tailwindcss.com/docs/isolation
       */
      isolation: ["isolate", "isolation-auto"],
      /**
       * Object Fit
       * @see https://tailwindcss.com/docs/object-fit
       */
      "object-fit": [{
        object: ["contain", "cover", "fill", "none", "scale-down"]
      }],
      /**
       * Object Position
       * @see https://tailwindcss.com/docs/object-position
       */
      "object-position": [{
        object: [...ce2(), k3]
      }],
      /**
       * Overflow
       * @see https://tailwindcss.com/docs/overflow
       */
      overflow: [{
        overflow: oe2()
      }],
      /**
       * Overflow X
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-x": [{
        "overflow-x": oe2()
      }],
      /**
       * Overflow Y
       * @see https://tailwindcss.com/docs/overflow
       */
      "overflow-y": [{
        "overflow-y": oe2()
      }],
      /**
       * Overscroll Behavior
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      overscroll: [{
        overscroll: Z2()
      }],
      /**
       * Overscroll Behavior X
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-x": [{
        "overscroll-x": Z2()
      }],
      /**
       * Overscroll Behavior Y
       * @see https://tailwindcss.com/docs/overscroll-behavior
       */
      "overscroll-y": [{
        "overscroll-y": Z2()
      }],
      /**
       * Position
       * @see https://tailwindcss.com/docs/position
       */
      position: ["static", "fixed", "absolute", "relative", "sticky"],
      /**
       * Top / Right / Bottom / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      inset: [{
        inset: [h]
      }],
      /**
       * Right / Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-x": [{
        "inset-x": [h]
      }],
      /**
       * Top / Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      "inset-y": [{
        "inset-y": [h]
      }],
      /**
       * Start
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      start: [{
        start: [h]
      }],
      /**
       * End
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      end: [{
        end: [h]
      }],
      /**
       * Top
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      top: [{
        top: [h]
      }],
      /**
       * Right
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      right: [{
        right: [h]
      }],
      /**
       * Bottom
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      bottom: [{
        bottom: [h]
      }],
      /**
       * Left
       * @see https://tailwindcss.com/docs/top-right-bottom-left
       */
      left: [{
        left: [h]
      }],
      /**
       * Visibility
       * @see https://tailwindcss.com/docs/visibility
       */
      visibility: ["visible", "invisible", "collapse"],
      /**
       * Z-Index
       * @see https://tailwindcss.com/docs/z-index
       */
      z: [{
        z: ["auto", it, k3]
      }],
      // Flexbox and Grid
      /**
       * Flex Basis
       * @see https://tailwindcss.com/docs/flex-basis
       */
      basis: [{
        basis: Te2()
      }],
      /**
       * Flex Direction
       * @see https://tailwindcss.com/docs/flex-direction
       */
      "flex-direction": [{
        flex: ["row", "row-reverse", "col", "col-reverse"]
      }],
      /**
       * Flex Wrap
       * @see https://tailwindcss.com/docs/flex-wrap
       */
      "flex-wrap": [{
        flex: ["wrap", "wrap-reverse", "nowrap"]
      }],
      /**
       * Flex
       * @see https://tailwindcss.com/docs/flex
       */
      flex: [{
        flex: ["1", "auto", "initial", "none", k3]
      }],
      /**
       * Flex Grow
       * @see https://tailwindcss.com/docs/flex-grow
       */
      grow: [{
        grow: se2()
      }],
      /**
       * Flex Shrink
       * @see https://tailwindcss.com/docs/flex-shrink
       */
      shrink: [{
        shrink: se2()
      }],
      /**
       * Order
       * @see https://tailwindcss.com/docs/order
       */
      order: [{
        order: ["first", "last", "none", it, k3]
      }],
      /**
       * Grid Template Columns
       * @see https://tailwindcss.com/docs/grid-template-columns
       */
      "grid-cols": [{
        "grid-cols": [at]
      }],
      /**
       * Grid Column Start / End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start-end": [{
        col: ["auto", {
          span: ["full", it, k3]
        }, k3]
      }],
      /**
       * Grid Column Start
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-start": [{
        "col-start": Q2()
      }],
      /**
       * Grid Column End
       * @see https://tailwindcss.com/docs/grid-column
       */
      "col-end": [{
        "col-end": Q2()
      }],
      /**
       * Grid Template Rows
       * @see https://tailwindcss.com/docs/grid-template-rows
       */
      "grid-rows": [{
        "grid-rows": [at]
      }],
      /**
       * Grid Row Start / End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start-end": [{
        row: ["auto", {
          span: [it, k3]
        }, k3]
      }],
      /**
       * Grid Row Start
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-start": [{
        "row-start": Q2()
      }],
      /**
       * Grid Row End
       * @see https://tailwindcss.com/docs/grid-row
       */
      "row-end": [{
        "row-end": Q2()
      }],
      /**
       * Grid Auto Flow
       * @see https://tailwindcss.com/docs/grid-auto-flow
       */
      "grid-flow": [{
        "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
      }],
      /**
       * Grid Auto Columns
       * @see https://tailwindcss.com/docs/grid-auto-columns
       */
      "auto-cols": [{
        "auto-cols": ["auto", "min", "max", "fr", k3]
      }],
      /**
       * Grid Auto Rows
       * @see https://tailwindcss.com/docs/grid-auto-rows
       */
      "auto-rows": [{
        "auto-rows": ["auto", "min", "max", "fr", k3]
      }],
      /**
       * Gap
       * @see https://tailwindcss.com/docs/gap
       */
      gap: [{
        gap: [g3]
      }],
      /**
       * Gap X
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-x": [{
        "gap-x": [g3]
      }],
      /**
       * Gap Y
       * @see https://tailwindcss.com/docs/gap
       */
      "gap-y": [{
        "gap-y": [g3]
      }],
      /**
       * Justify Content
       * @see https://tailwindcss.com/docs/justify-content
       */
      "justify-content": [{
        justify: ["normal", ...xe2()]
      }],
      /**
       * Justify Items
       * @see https://tailwindcss.com/docs/justify-items
       */
      "justify-items": [{
        "justify-items": ["start", "end", "center", "stretch"]
      }],
      /**
       * Justify Self
       * @see https://tailwindcss.com/docs/justify-self
       */
      "justify-self": [{
        "justify-self": ["auto", "start", "end", "center", "stretch"]
      }],
      /**
       * Align Content
       * @see https://tailwindcss.com/docs/align-content
       */
      "align-content": [{
        content: ["normal", ...xe2(), "baseline"]
      }],
      /**
       * Align Items
       * @see https://tailwindcss.com/docs/align-items
       */
      "align-items": [{
        items: ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Align Self
       * @see https://tailwindcss.com/docs/align-self
       */
      "align-self": [{
        self: ["auto", "start", "end", "center", "stretch", "baseline"]
      }],
      /**
       * Place Content
       * @see https://tailwindcss.com/docs/place-content
       */
      "place-content": [{
        "place-content": [...xe2(), "baseline"]
      }],
      /**
       * Place Items
       * @see https://tailwindcss.com/docs/place-items
       */
      "place-items": [{
        "place-items": ["start", "end", "center", "baseline", "stretch"]
      }],
      /**
       * Place Self
       * @see https://tailwindcss.com/docs/place-self
       */
      "place-self": [{
        "place-self": ["auto", "start", "end", "center", "stretch"]
      }],
      // Spacing
      /**
       * Padding
       * @see https://tailwindcss.com/docs/padding
       */
      p: [{
        p: [w2]
      }],
      /**
       * Padding X
       * @see https://tailwindcss.com/docs/padding
       */
      px: [{
        px: [w2]
      }],
      /**
       * Padding Y
       * @see https://tailwindcss.com/docs/padding
       */
      py: [{
        py: [w2]
      }],
      /**
       * Padding Start
       * @see https://tailwindcss.com/docs/padding
       */
      ps: [{
        ps: [w2]
      }],
      /**
       * Padding End
       * @see https://tailwindcss.com/docs/padding
       */
      pe: [{
        pe: [w2]
      }],
      /**
       * Padding Top
       * @see https://tailwindcss.com/docs/padding
       */
      pt: [{
        pt: [w2]
      }],
      /**
       * Padding Right
       * @see https://tailwindcss.com/docs/padding
       */
      pr: [{
        pr: [w2]
      }],
      /**
       * Padding Bottom
       * @see https://tailwindcss.com/docs/padding
       */
      pb: [{
        pb: [w2]
      }],
      /**
       * Padding Left
       * @see https://tailwindcss.com/docs/padding
       */
      pl: [{
        pl: [w2]
      }],
      /**
       * Margin
       * @see https://tailwindcss.com/docs/margin
       */
      m: [{
        m: [v2]
      }],
      /**
       * Margin X
       * @see https://tailwindcss.com/docs/margin
       */
      mx: [{
        mx: [v2]
      }],
      /**
       * Margin Y
       * @see https://tailwindcss.com/docs/margin
       */
      my: [{
        my: [v2]
      }],
      /**
       * Margin Start
       * @see https://tailwindcss.com/docs/margin
       */
      ms: [{
        ms: [v2]
      }],
      /**
       * Margin End
       * @see https://tailwindcss.com/docs/margin
       */
      me: [{
        me: [v2]
      }],
      /**
       * Margin Top
       * @see https://tailwindcss.com/docs/margin
       */
      mt: [{
        mt: [v2]
      }],
      /**
       * Margin Right
       * @see https://tailwindcss.com/docs/margin
       */
      mr: [{
        mr: [v2]
      }],
      /**
       * Margin Bottom
       * @see https://tailwindcss.com/docs/margin
       */
      mb: [{
        mb: [v2]
      }],
      /**
       * Margin Left
       * @see https://tailwindcss.com/docs/margin
       */
      ml: [{
        ml: [v2]
      }],
      /**
       * Space Between X
       * @see https://tailwindcss.com/docs/space
       */
      "space-x": [{
        "space-x": [L2]
      }],
      /**
       * Space Between X Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-x-reverse": ["space-x-reverse"],
      /**
       * Space Between Y
       * @see https://tailwindcss.com/docs/space
       */
      "space-y": [{
        "space-y": [L2]
      }],
      /**
       * Space Between Y Reverse
       * @see https://tailwindcss.com/docs/space
       */
      "space-y-reverse": ["space-y-reverse"],
      // Sizing
      /**
       * Width
       * @see https://tailwindcss.com/docs/width
       */
      w: [{
        w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", k3, t2]
      }],
      /**
       * Min-Width
       * @see https://tailwindcss.com/docs/min-width
       */
      "min-w": [{
        "min-w": [k3, t2, "min", "max", "fit"]
      }],
      /**
       * Max-Width
       * @see https://tailwindcss.com/docs/max-width
       */
      "max-w": [{
        "max-w": [k3, t2, "none", "full", "min", "max", "fit", "prose", {
          screen: [Ce2]
        }, Ce2]
      }],
      /**
       * Height
       * @see https://tailwindcss.com/docs/height
       */
      h: [{
        h: [k3, t2, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Min-Height
       * @see https://tailwindcss.com/docs/min-height
       */
      "min-h": [{
        "min-h": [k3, t2, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Max-Height
       * @see https://tailwindcss.com/docs/max-height
       */
      "max-h": [{
        "max-h": [k3, t2, "min", "max", "fit", "svh", "lvh", "dvh"]
      }],
      /**
       * Size
       * @see https://tailwindcss.com/docs/size
       */
      size: [{
        size: [k3, t2, "auto", "min", "max", "fit"]
      }],
      // Typography
      /**
       * Font Size
       * @see https://tailwindcss.com/docs/font-size
       */
      "font-size": [{
        text: ["base", Ce2, Ee2]
      }],
      /**
       * Font Smoothing
       * @see https://tailwindcss.com/docs/font-smoothing
       */
      "font-smoothing": ["antialiased", "subpixel-antialiased"],
      /**
       * Font Style
       * @see https://tailwindcss.com/docs/font-style
       */
      "font-style": ["italic", "not-italic"],
      /**
       * Font Weight
       * @see https://tailwindcss.com/docs/font-weight
       */
      "font-weight": [{
        font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", Ht]
      }],
      /**
       * Font Family
       * @see https://tailwindcss.com/docs/font-family
       */
      "font-family": [{
        font: [at]
      }],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-normal": ["normal-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-ordinal": ["ordinal"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-slashed-zero": ["slashed-zero"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-figure": ["lining-nums", "oldstyle-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-spacing": ["proportional-nums", "tabular-nums"],
      /**
       * Font Variant Numeric
       * @see https://tailwindcss.com/docs/font-variant-numeric
       */
      "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
      /**
       * Letter Spacing
       * @see https://tailwindcss.com/docs/letter-spacing
       */
      tracking: [{
        tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", k3]
      }],
      /**
       * Line Clamp
       * @see https://tailwindcss.com/docs/line-clamp
       */
      "line-clamp": [{
        "line-clamp": ["none", Ke, Ht]
      }],
      /**
       * Line Height
       * @see https://tailwindcss.com/docs/line-height
       */
      leading: [{
        leading: ["none", "tight", "snug", "normal", "relaxed", "loose", me2, k3]
      }],
      /**
       * List Style Image
       * @see https://tailwindcss.com/docs/list-style-image
       */
      "list-image": [{
        "list-image": ["none", k3]
      }],
      /**
       * List Style Type
       * @see https://tailwindcss.com/docs/list-style-type
       */
      "list-style-type": [{
        list: ["none", "disc", "decimal", k3]
      }],
      /**
       * List Style Position
       * @see https://tailwindcss.com/docs/list-style-position
       */
      "list-style-position": [{
        list: ["inside", "outside"]
      }],
      /**
       * Placeholder Color
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/placeholder-color
       */
      "placeholder-color": [{
        placeholder: [e2]
      }],
      /**
       * Placeholder Opacity
       * @see https://tailwindcss.com/docs/placeholder-opacity
       */
      "placeholder-opacity": [{
        "placeholder-opacity": [x2]
      }],
      /**
       * Text Alignment
       * @see https://tailwindcss.com/docs/text-align
       */
      "text-alignment": [{
        text: ["left", "center", "right", "justify", "start", "end"]
      }],
      /**
       * Text Color
       * @see https://tailwindcss.com/docs/text-color
       */
      "text-color": [{
        text: [e2]
      }],
      /**
       * Text Opacity
       * @see https://tailwindcss.com/docs/text-opacity
       */
      "text-opacity": [{
        "text-opacity": [x2]
      }],
      /**
       * Text Decoration
       * @see https://tailwindcss.com/docs/text-decoration
       */
      "text-decoration": ["underline", "overline", "line-through", "no-underline"],
      /**
       * Text Decoration Style
       * @see https://tailwindcss.com/docs/text-decoration-style
       */
      "text-decoration-style": [{
        decoration: [...pe2(), "wavy"]
      }],
      /**
       * Text Decoration Thickness
       * @see https://tailwindcss.com/docs/text-decoration-thickness
       */
      "text-decoration-thickness": [{
        decoration: ["auto", "from-font", me2, Ee2]
      }],
      /**
       * Text Underline Offset
       * @see https://tailwindcss.com/docs/text-underline-offset
       */
      "underline-offset": [{
        "underline-offset": ["auto", me2, k3]
      }],
      /**
       * Text Decoration Color
       * @see https://tailwindcss.com/docs/text-decoration-color
       */
      "text-decoration-color": [{
        decoration: [e2]
      }],
      /**
       * Text Transform
       * @see https://tailwindcss.com/docs/text-transform
       */
      "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
      /**
       * Text Overflow
       * @see https://tailwindcss.com/docs/text-overflow
       */
      "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
      /**
       * Text Wrap
       * @see https://tailwindcss.com/docs/text-wrap
       */
      "text-wrap": [{
        text: ["wrap", "nowrap", "balance", "pretty"]
      }],
      /**
       * Text Indent
       * @see https://tailwindcss.com/docs/text-indent
       */
      indent: [{
        indent: B2()
      }],
      /**
       * Vertical Alignment
       * @see https://tailwindcss.com/docs/vertical-align
       */
      "vertical-align": [{
        align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", k3]
      }],
      /**
       * Whitespace
       * @see https://tailwindcss.com/docs/whitespace
       */
      whitespace: [{
        whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
      }],
      /**
       * Word Break
       * @see https://tailwindcss.com/docs/word-break
       */
      break: [{
        break: ["normal", "words", "all", "keep"]
      }],
      /**
       * Hyphens
       * @see https://tailwindcss.com/docs/hyphens
       */
      hyphens: [{
        hyphens: ["none", "manual", "auto"]
      }],
      /**
       * Content
       * @see https://tailwindcss.com/docs/content
       */
      content: [{
        content: ["none", k3]
      }],
      // Backgrounds
      /**
       * Background Attachment
       * @see https://tailwindcss.com/docs/background-attachment
       */
      "bg-attachment": [{
        bg: ["fixed", "local", "scroll"]
      }],
      /**
       * Background Clip
       * @see https://tailwindcss.com/docs/background-clip
       */
      "bg-clip": [{
        "bg-clip": ["border", "padding", "content", "text"]
      }],
      /**
       * Background Opacity
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/background-opacity
       */
      "bg-opacity": [{
        "bg-opacity": [x2]
      }],
      /**
       * Background Origin
       * @see https://tailwindcss.com/docs/background-origin
       */
      "bg-origin": [{
        "bg-origin": ["border", "padding", "content"]
      }],
      /**
       * Background Position
       * @see https://tailwindcss.com/docs/background-position
       */
      "bg-position": [{
        bg: [...ce2(), Ui]
      }],
      /**
       * Background Repeat
       * @see https://tailwindcss.com/docs/background-repeat
       */
      "bg-repeat": [{
        bg: ["no-repeat", {
          repeat: ["", "x", "y", "round", "space"]
        }]
      }],
      /**
       * Background Size
       * @see https://tailwindcss.com/docs/background-size
       */
      "bg-size": [{
        bg: ["auto", "cover", "contain", Mi]
      }],
      /**
       * Background Image
       * @see https://tailwindcss.com/docs/background-image
       */
      "bg-image": [{
        bg: ["none", {
          "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
        }, $i]
      }],
      /**
       * Background Color
       * @see https://tailwindcss.com/docs/background-color
       */
      "bg-color": [{
        bg: [e2]
      }],
      /**
       * Gradient Color Stops From Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from-pos": [{
        from: [E3]
      }],
      /**
       * Gradient Color Stops Via Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via-pos": [{
        via: [E3]
      }],
      /**
       * Gradient Color Stops To Position
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to-pos": [{
        to: [E3]
      }],
      /**
       * Gradient Color Stops From
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-from": [{
        from: [b4]
      }],
      /**
       * Gradient Color Stops Via
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-via": [{
        via: [b4]
      }],
      /**
       * Gradient Color Stops To
       * @see https://tailwindcss.com/docs/gradient-color-stops
       */
      "gradient-to": [{
        to: [b4]
      }],
      // Borders
      /**
       * Border Radius
       * @see https://tailwindcss.com/docs/border-radius
       */
      rounded: [{
        rounded: [s2]
      }],
      /**
       * Border Radius Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-s": [{
        "rounded-s": [s2]
      }],
      /**
       * Border Radius End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-e": [{
        "rounded-e": [s2]
      }],
      /**
       * Border Radius Top
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-t": [{
        "rounded-t": [s2]
      }],
      /**
       * Border Radius Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-r": [{
        "rounded-r": [s2]
      }],
      /**
       * Border Radius Bottom
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-b": [{
        "rounded-b": [s2]
      }],
      /**
       * Border Radius Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-l": [{
        "rounded-l": [s2]
      }],
      /**
       * Border Radius Start Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ss": [{
        "rounded-ss": [s2]
      }],
      /**
       * Border Radius Start End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-se": [{
        "rounded-se": [s2]
      }],
      /**
       * Border Radius End End
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-ee": [{
        "rounded-ee": [s2]
      }],
      /**
       * Border Radius End Start
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-es": [{
        "rounded-es": [s2]
      }],
      /**
       * Border Radius Top Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tl": [{
        "rounded-tl": [s2]
      }],
      /**
       * Border Radius Top Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-tr": [{
        "rounded-tr": [s2]
      }],
      /**
       * Border Radius Bottom Right
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-br": [{
        "rounded-br": [s2]
      }],
      /**
       * Border Radius Bottom Left
       * @see https://tailwindcss.com/docs/border-radius
       */
      "rounded-bl": [{
        "rounded-bl": [s2]
      }],
      /**
       * Border Width
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w": [{
        border: [i2]
      }],
      /**
       * Border Width X
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-x": [{
        "border-x": [i2]
      }],
      /**
       * Border Width Y
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-y": [{
        "border-y": [i2]
      }],
      /**
       * Border Width Start
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-s": [{
        "border-s": [i2]
      }],
      /**
       * Border Width End
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-e": [{
        "border-e": [i2]
      }],
      /**
       * Border Width Top
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-t": [{
        "border-t": [i2]
      }],
      /**
       * Border Width Right
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-r": [{
        "border-r": [i2]
      }],
      /**
       * Border Width Bottom
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-b": [{
        "border-b": [i2]
      }],
      /**
       * Border Width Left
       * @see https://tailwindcss.com/docs/border-width
       */
      "border-w-l": [{
        "border-l": [i2]
      }],
      /**
       * Border Opacity
       * @see https://tailwindcss.com/docs/border-opacity
       */
      "border-opacity": [{
        "border-opacity": [x2]
      }],
      /**
       * Border Style
       * @see https://tailwindcss.com/docs/border-style
       */
      "border-style": [{
        border: [...pe2(), "hidden"]
      }],
      /**
       * Divide Width X
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x": [{
        "divide-x": [i2]
      }],
      /**
       * Divide Width X Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-x-reverse": ["divide-x-reverse"],
      /**
       * Divide Width Y
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y": [{
        "divide-y": [i2]
      }],
      /**
       * Divide Width Y Reverse
       * @see https://tailwindcss.com/docs/divide-width
       */
      "divide-y-reverse": ["divide-y-reverse"],
      /**
       * Divide Opacity
       * @see https://tailwindcss.com/docs/divide-opacity
       */
      "divide-opacity": [{
        "divide-opacity": [x2]
      }],
      /**
       * Divide Style
       * @see https://tailwindcss.com/docs/divide-style
       */
      "divide-style": [{
        divide: pe2()
      }],
      /**
       * Border Color
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color": [{
        border: [o2]
      }],
      /**
       * Border Color X
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-x": [{
        "border-x": [o2]
      }],
      /**
       * Border Color Y
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-y": [{
        "border-y": [o2]
      }],
      /**
       * Border Color S
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-s": [{
        "border-s": [o2]
      }],
      /**
       * Border Color E
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-e": [{
        "border-e": [o2]
      }],
      /**
       * Border Color Top
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-t": [{
        "border-t": [o2]
      }],
      /**
       * Border Color Right
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-r": [{
        "border-r": [o2]
      }],
      /**
       * Border Color Bottom
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-b": [{
        "border-b": [o2]
      }],
      /**
       * Border Color Left
       * @see https://tailwindcss.com/docs/border-color
       */
      "border-color-l": [{
        "border-l": [o2]
      }],
      /**
       * Divide Color
       * @see https://tailwindcss.com/docs/divide-color
       */
      "divide-color": [{
        divide: [o2]
      }],
      /**
       * Outline Style
       * @see https://tailwindcss.com/docs/outline-style
       */
      "outline-style": [{
        outline: ["", ...pe2()]
      }],
      /**
       * Outline Offset
       * @see https://tailwindcss.com/docs/outline-offset
       */
      "outline-offset": [{
        "outline-offset": [me2, k3]
      }],
      /**
       * Outline Width
       * @see https://tailwindcss.com/docs/outline-width
       */
      "outline-w": [{
        outline: [me2, Ee2]
      }],
      /**
       * Outline Color
       * @see https://tailwindcss.com/docs/outline-color
       */
      "outline-color": [{
        outline: [e2]
      }],
      /**
       * Ring Width
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w": [{
        ring: K2()
      }],
      /**
       * Ring Width Inset
       * @see https://tailwindcss.com/docs/ring-width
       */
      "ring-w-inset": ["ring-inset"],
      /**
       * Ring Color
       * @see https://tailwindcss.com/docs/ring-color
       */
      "ring-color": [{
        ring: [e2]
      }],
      /**
       * Ring Opacity
       * @see https://tailwindcss.com/docs/ring-opacity
       */
      "ring-opacity": [{
        "ring-opacity": [x2]
      }],
      /**
       * Ring Offset Width
       * @see https://tailwindcss.com/docs/ring-offset-width
       */
      "ring-offset-w": [{
        "ring-offset": [me2, Ee2]
      }],
      /**
       * Ring Offset Color
       * @see https://tailwindcss.com/docs/ring-offset-color
       */
      "ring-offset-color": [{
        "ring-offset": [e2]
      }],
      // Effects
      /**
       * Box Shadow
       * @see https://tailwindcss.com/docs/box-shadow
       */
      shadow: [{
        shadow: ["", "inner", "none", Ce2, Wi]
      }],
      /**
       * Box Shadow Color
       * @see https://tailwindcss.com/docs/box-shadow-color
       */
      "shadow-color": [{
        shadow: [at]
      }],
      /**
       * Opacity
       * @see https://tailwindcss.com/docs/opacity
       */
      opacity: [{
        opacity: [x2]
      }],
      /**
       * Mix Blend Mode
       * @see https://tailwindcss.com/docs/mix-blend-mode
       */
      "mix-blend": [{
        "mix-blend": [...Ne2(), "plus-lighter", "plus-darker"]
      }],
      /**
       * Background Blend Mode
       * @see https://tailwindcss.com/docs/background-blend-mode
       */
      "bg-blend": [{
        "bg-blend": Ne2()
      }],
      // Filters
      /**
       * Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/filter
       */
      filter: [{
        filter: ["", "none"]
      }],
      /**
       * Blur
       * @see https://tailwindcss.com/docs/blur
       */
      blur: [{
        blur: [r2]
      }],
      /**
       * Brightness
       * @see https://tailwindcss.com/docs/brightness
       */
      brightness: [{
        brightness: [n2]
      }],
      /**
       * Contrast
       * @see https://tailwindcss.com/docs/contrast
       */
      contrast: [{
        contrast: [d2]
      }],
      /**
       * Drop Shadow
       * @see https://tailwindcss.com/docs/drop-shadow
       */
      "drop-shadow": [{
        "drop-shadow": ["", "none", Ce2, k3]
      }],
      /**
       * Grayscale
       * @see https://tailwindcss.com/docs/grayscale
       */
      grayscale: [{
        grayscale: [u3]
      }],
      /**
       * Hue Rotate
       * @see https://tailwindcss.com/docs/hue-rotate
       */
      "hue-rotate": [{
        "hue-rotate": [p2]
      }],
      /**
       * Invert
       * @see https://tailwindcss.com/docs/invert
       */
      invert: [{
        invert: [m3]
      }],
      /**
       * Saturate
       * @see https://tailwindcss.com/docs/saturate
       */
      saturate: [{
        saturate: [P]
      }],
      /**
       * Sepia
       * @see https://tailwindcss.com/docs/sepia
       */
      sepia: [{
        sepia: [N2]
      }],
      /**
       * Backdrop Filter
       * @deprecated since Tailwind CSS v3.0.0
       * @see https://tailwindcss.com/docs/backdrop-filter
       */
      "backdrop-filter": [{
        "backdrop-filter": ["", "none"]
      }],
      /**
       * Backdrop Blur
       * @see https://tailwindcss.com/docs/backdrop-blur
       */
      "backdrop-blur": [{
        "backdrop-blur": [r2]
      }],
      /**
       * Backdrop Brightness
       * @see https://tailwindcss.com/docs/backdrop-brightness
       */
      "backdrop-brightness": [{
        "backdrop-brightness": [n2]
      }],
      /**
       * Backdrop Contrast
       * @see https://tailwindcss.com/docs/backdrop-contrast
       */
      "backdrop-contrast": [{
        "backdrop-contrast": [d2]
      }],
      /**
       * Backdrop Grayscale
       * @see https://tailwindcss.com/docs/backdrop-grayscale
       */
      "backdrop-grayscale": [{
        "backdrop-grayscale": [u3]
      }],
      /**
       * Backdrop Hue Rotate
       * @see https://tailwindcss.com/docs/backdrop-hue-rotate
       */
      "backdrop-hue-rotate": [{
        "backdrop-hue-rotate": [p2]
      }],
      /**
       * Backdrop Invert
       * @see https://tailwindcss.com/docs/backdrop-invert
       */
      "backdrop-invert": [{
        "backdrop-invert": [m3]
      }],
      /**
       * Backdrop Opacity
       * @see https://tailwindcss.com/docs/backdrop-opacity
       */
      "backdrop-opacity": [{
        "backdrop-opacity": [x2]
      }],
      /**
       * Backdrop Saturate
       * @see https://tailwindcss.com/docs/backdrop-saturate
       */
      "backdrop-saturate": [{
        "backdrop-saturate": [P]
      }],
      /**
       * Backdrop Sepia
       * @see https://tailwindcss.com/docs/backdrop-sepia
       */
      "backdrop-sepia": [{
        "backdrop-sepia": [N2]
      }],
      // Tables
      /**
       * Border Collapse
       * @see https://tailwindcss.com/docs/border-collapse
       */
      "border-collapse": [{
        border: ["collapse", "separate"]
      }],
      /**
       * Border Spacing
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing": [{
        "border-spacing": [a3]
      }],
      /**
       * Border Spacing X
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-x": [{
        "border-spacing-x": [a3]
      }],
      /**
       * Border Spacing Y
       * @see https://tailwindcss.com/docs/border-spacing
       */
      "border-spacing-y": [{
        "border-spacing-y": [a3]
      }],
      /**
       * Table Layout
       * @see https://tailwindcss.com/docs/table-layout
       */
      "table-layout": [{
        table: ["auto", "fixed"]
      }],
      /**
       * Caption Side
       * @see https://tailwindcss.com/docs/caption-side
       */
      caption: [{
        caption: ["top", "bottom"]
      }],
      // Transitions and Animation
      /**
       * Tranisition Property
       * @see https://tailwindcss.com/docs/transition-property
       */
      transition: [{
        transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", k3]
      }],
      /**
       * Transition Duration
       * @see https://tailwindcss.com/docs/transition-duration
       */
      duration: [{
        duration: ee2()
      }],
      /**
       * Transition Timing Function
       * @see https://tailwindcss.com/docs/transition-timing-function
       */
      ease: [{
        ease: ["linear", "in", "out", "in-out", k3]
      }],
      /**
       * Transition Delay
       * @see https://tailwindcss.com/docs/transition-delay
       */
      delay: [{
        delay: ee2()
      }],
      /**
       * Animation
       * @see https://tailwindcss.com/docs/animation
       */
      animate: [{
        animate: ["none", "spin", "ping", "pulse", "bounce", k3]
      }],
      // Transforms
      /**
       * Transform
       * @see https://tailwindcss.com/docs/transform
       */
      transform: [{
        transform: ["", "gpu", "none"]
      }],
      /**
       * Scale
       * @see https://tailwindcss.com/docs/scale
       */
      scale: [{
        scale: [R2]
      }],
      /**
       * Scale X
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-x": [{
        "scale-x": [R2]
      }],
      /**
       * Scale Y
       * @see https://tailwindcss.com/docs/scale
       */
      "scale-y": [{
        "scale-y": [R2]
      }],
      /**
       * Rotate
       * @see https://tailwindcss.com/docs/rotate
       */
      rotate: [{
        rotate: [it, k3]
      }],
      /**
       * Translate X
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-x": [{
        "translate-x": [J2]
      }],
      /**
       * Translate Y
       * @see https://tailwindcss.com/docs/translate
       */
      "translate-y": [{
        "translate-y": [J2]
      }],
      /**
       * Skew X
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-x": [{
        "skew-x": [W3]
      }],
      /**
       * Skew Y
       * @see https://tailwindcss.com/docs/skew
       */
      "skew-y": [{
        "skew-y": [W3]
      }],
      /**
       * Transform Origin
       * @see https://tailwindcss.com/docs/transform-origin
       */
      "transform-origin": [{
        origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", k3]
      }],
      // Interactivity
      /**
       * Accent Color
       * @see https://tailwindcss.com/docs/accent-color
       */
      accent: [{
        accent: ["auto", e2]
      }],
      /**
       * Appearance
       * @see https://tailwindcss.com/docs/appearance
       */
      appearance: [{
        appearance: ["none", "auto"]
      }],
      /**
       * Cursor
       * @see https://tailwindcss.com/docs/cursor
       */
      cursor: [{
        cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", k3]
      }],
      /**
       * Caret Color
       * @see https://tailwindcss.com/docs/just-in-time-mode#caret-color-utilities
       */
      "caret-color": [{
        caret: [e2]
      }],
      /**
       * Pointer Events
       * @see https://tailwindcss.com/docs/pointer-events
       */
      "pointer-events": [{
        "pointer-events": ["none", "auto"]
      }],
      /**
       * Resize
       * @see https://tailwindcss.com/docs/resize
       */
      resize: [{
        resize: ["none", "y", "x", ""]
      }],
      /**
       * Scroll Behavior
       * @see https://tailwindcss.com/docs/scroll-behavior
       */
      "scroll-behavior": [{
        scroll: ["auto", "smooth"]
      }],
      /**
       * Scroll Margin
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-m": [{
        "scroll-m": B2()
      }],
      /**
       * Scroll Margin X
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mx": [{
        "scroll-mx": B2()
      }],
      /**
       * Scroll Margin Y
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-my": [{
        "scroll-my": B2()
      }],
      /**
       * Scroll Margin Start
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ms": [{
        "scroll-ms": B2()
      }],
      /**
       * Scroll Margin End
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-me": [{
        "scroll-me": B2()
      }],
      /**
       * Scroll Margin Top
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mt": [{
        "scroll-mt": B2()
      }],
      /**
       * Scroll Margin Right
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mr": [{
        "scroll-mr": B2()
      }],
      /**
       * Scroll Margin Bottom
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-mb": [{
        "scroll-mb": B2()
      }],
      /**
       * Scroll Margin Left
       * @see https://tailwindcss.com/docs/scroll-margin
       */
      "scroll-ml": [{
        "scroll-ml": B2()
      }],
      /**
       * Scroll Padding
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-p": [{
        "scroll-p": B2()
      }],
      /**
       * Scroll Padding X
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-px": [{
        "scroll-px": B2()
      }],
      /**
       * Scroll Padding Y
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-py": [{
        "scroll-py": B2()
      }],
      /**
       * Scroll Padding Start
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-ps": [{
        "scroll-ps": B2()
      }],
      /**
       * Scroll Padding End
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pe": [{
        "scroll-pe": B2()
      }],
      /**
       * Scroll Padding Top
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pt": [{
        "scroll-pt": B2()
      }],
      /**
       * Scroll Padding Right
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pr": [{
        "scroll-pr": B2()
      }],
      /**
       * Scroll Padding Bottom
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pb": [{
        "scroll-pb": B2()
      }],
      /**
       * Scroll Padding Left
       * @see https://tailwindcss.com/docs/scroll-padding
       */
      "scroll-pl": [{
        "scroll-pl": B2()
      }],
      /**
       * Scroll Snap Align
       * @see https://tailwindcss.com/docs/scroll-snap-align
       */
      "snap-align": [{
        snap: ["start", "end", "center", "align-none"]
      }],
      /**
       * Scroll Snap Stop
       * @see https://tailwindcss.com/docs/scroll-snap-stop
       */
      "snap-stop": [{
        snap: ["normal", "always"]
      }],
      /**
       * Scroll Snap Type
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-type": [{
        snap: ["none", "x", "y", "both"]
      }],
      /**
       * Scroll Snap Type Strictness
       * @see https://tailwindcss.com/docs/scroll-snap-type
       */
      "snap-strictness": [{
        snap: ["mandatory", "proximity"]
      }],
      /**
       * Touch Action
       * @see https://tailwindcss.com/docs/touch-action
       */
      touch: [{
        touch: ["auto", "none", "manipulation"]
      }],
      /**
       * Touch Action X
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-x": [{
        "touch-pan": ["x", "left", "right"]
      }],
      /**
       * Touch Action Y
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-y": [{
        "touch-pan": ["y", "up", "down"]
      }],
      /**
       * Touch Action Pinch Zoom
       * @see https://tailwindcss.com/docs/touch-action
       */
      "touch-pz": ["touch-pinch-zoom"],
      /**
       * User Select
       * @see https://tailwindcss.com/docs/user-select
       */
      select: [{
        select: ["none", "text", "all", "auto"]
      }],
      /**
       * Will Change
       * @see https://tailwindcss.com/docs/will-change
       */
      "will-change": [{
        "will-change": ["auto", "scroll", "contents", "transform", k3]
      }],
      // SVG
      /**
       * Fill
       * @see https://tailwindcss.com/docs/fill
       */
      fill: [{
        fill: [e2, "none"]
      }],
      /**
       * Stroke Width
       * @see https://tailwindcss.com/docs/stroke-width
       */
      "stroke-w": [{
        stroke: [me2, Ee2, Ht]
      }],
      /**
       * Stroke
       * @see https://tailwindcss.com/docs/stroke
       */
      stroke: [{
        stroke: [e2, "none"]
      }],
      // Accessibility
      /**
       * Screen Readers
       * @see https://tailwindcss.com/docs/screen-readers
       */
      sr: ["sr-only", "not-sr-only"],
      /**
       * Forced Color Adjust
       * @see https://tailwindcss.com/docs/forced-color-adjust
       */
      "forced-color-adjust": [{
        "forced-color-adjust": ["auto", "none"]
      }]
    },
    conflictingClassGroups: {
      overflow: ["overflow-x", "overflow-y"],
      overscroll: ["overscroll-x", "overscroll-y"],
      inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
      "inset-x": ["right", "left"],
      "inset-y": ["top", "bottom"],
      flex: ["basis", "grow", "shrink"],
      gap: ["gap-x", "gap-y"],
      p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
      px: ["pr", "pl"],
      py: ["pt", "pb"],
      m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
      mx: ["mr", "ml"],
      my: ["mt", "mb"],
      size: ["w", "h"],
      "font-size": ["leading"],
      "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
      "fvn-ordinal": ["fvn-normal"],
      "fvn-slashed-zero": ["fvn-normal"],
      "fvn-figure": ["fvn-normal"],
      "fvn-spacing": ["fvn-normal"],
      "fvn-fraction": ["fvn-normal"],
      "line-clamp": ["display", "overflow"],
      rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
      "rounded-s": ["rounded-ss", "rounded-es"],
      "rounded-e": ["rounded-se", "rounded-ee"],
      "rounded-t": ["rounded-tl", "rounded-tr"],
      "rounded-r": ["rounded-tr", "rounded-br"],
      "rounded-b": ["rounded-br", "rounded-bl"],
      "rounded-l": ["rounded-tl", "rounded-bl"],
      "border-spacing": ["border-spacing-x", "border-spacing-y"],
      "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
      "border-w-x": ["border-w-r", "border-w-l"],
      "border-w-y": ["border-w-t", "border-w-b"],
      "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
      "border-color-x": ["border-color-r", "border-color-l"],
      "border-color-y": ["border-color-t", "border-color-b"],
      "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
      "scroll-mx": ["scroll-mr", "scroll-ml"],
      "scroll-my": ["scroll-mt", "scroll-mb"],
      "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
      "scroll-px": ["scroll-pr", "scroll-pl"],
      "scroll-py": ["scroll-pt", "scroll-pb"],
      touch: ["touch-x", "touch-y", "touch-pz"],
      "touch-x": ["touch"],
      "touch-y": ["touch"],
      "touch-pz": ["touch"]
    },
    conflictingClassGroupModifiers: {
      "font-size": ["leading"]
    }
  };
};
var Ki = ki(Ji);
function I2(...e2) {
  return Ki(zn(e2));
}
var Yi = (e2, t2 = 6) => `${e2.slice(0, t2)}...${e2.slice(-t2)}`;
var ir = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  "div",
  {
    ref: r2,
    className: I2("rounded-xl border bg-black text-white shadow", e2),
    ...t2
  }
));
ir.displayName = "Card";
var ar = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  "div",
  {
    ref: r2,
    className: I2("flex flex-col space-y-1.5 p-6", e2),
    ...t2
  }
));
ar.displayName = "CardHeader";
var cr = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  "h3",
  {
    ref: r2,
    className: I2("font-semibold leading-none tracking-tight", e2),
    ...t2
  }
));
cr.displayName = "CardTitle";
var qi = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  "p",
  {
    ref: r2,
    className: I2("text-sm text-muted-foreground", e2),
    ...t2
  }
));
qi.displayName = "CardDescription";
var lr = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx("div", { ref: r2, className: I2("p-6 pt-0", e2), ...t2 }));
lr.displayName = "CardContent";
var Jn = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  "div",
  {
    ref: r2,
    className: I2("flex items-center p-6 pt-0", e2),
    ...t2
  }
));
Jn.displayName = "CardFooter";
function Qr(e2, t2) {
  if (typeof e2 == "function")
    return e2(t2);
  e2 != null && (e2.current = t2);
}
function Kn(...e2) {
  return (t2) => {
    let r2 = false;
    const n2 = e2.map((o2) => {
      const s2 = Qr(o2, t2);
      return !r2 && typeof s2 == "function" && (r2 = true), s2;
    });
    if (r2)
      return () => {
        for (let o2 = 0; o2 < n2.length; o2++) {
          const s2 = n2[o2];
          typeof s2 == "function" ? s2() : Qr(e2[o2], null);
        }
      };
  };
}
function ve2(...e2) {
  return f2.useCallback(Kn(...e2), e2);
}
var Ot = f2.forwardRef((e2, t2) => {
  const { children: r2, ...n2 } = e2, o2 = f2.Children.toArray(r2), s2 = o2.find(Xi);
  if (s2) {
    const a3 = s2.props.children, i2 = o2.map((d2) => d2 === s2 ? f2.Children.count(a3) > 1 ? f2.Children.only(null) : f2.isValidElement(a3) ? a3.props.children : null : d2);
    return l2.jsx(ur, { ...n2, ref: t2, children: f2.isValidElement(a3) ? f2.cloneElement(a3, void 0, i2) : null });
  }
  return l2.jsx(ur, { ...n2, ref: t2, children: r2 });
});
Ot.displayName = "Slot";
var ur = f2.forwardRef((e2, t2) => {
  const { children: r2, ...n2 } = e2;
  if (f2.isValidElement(r2)) {
    const o2 = Qi(r2);
    return f2.cloneElement(r2, {
      ...Zi(n2, r2.props),
      // @ts-ignore
      ref: t2 ? Kn(t2, o2) : o2
    });
  }
  return f2.Children.count(r2) > 1 ? f2.Children.only(null) : null;
});
ur.displayName = "SlotClone";
var Yn = ({ children: e2 }) => l2.jsx(l2.Fragment, { children: e2 });
function Xi(e2) {
  return f2.isValidElement(e2) && e2.type === Yn;
}
function Zi(e2, t2) {
  const r2 = { ...t2 };
  for (const n2 in t2) {
    const o2 = e2[n2], s2 = t2[n2];
    /^on[A-Z]/.test(n2) ? o2 && s2 ? r2[n2] = (...i2) => {
      s2(...i2), o2(...i2);
    } : o2 && (r2[n2] = o2) : n2 === "style" ? r2[n2] = { ...o2, ...s2 } : n2 === "className" && (r2[n2] = [o2, s2].filter(Boolean).join(" "));
  }
  return { ...e2, ...r2 };
}
function Qi(e2) {
  var n2, o2;
  let t2 = (n2 = Object.getOwnPropertyDescriptor(e2.props, "ref")) == null ? void 0 : n2.get, r2 = t2 && "isReactWarning" in t2 && t2.isReactWarning;
  return r2 ? e2.ref : (t2 = (o2 = Object.getOwnPropertyDescriptor(e2, "ref")) == null ? void 0 : o2.get, r2 = t2 && "isReactWarning" in t2 && t2.isReactWarning, r2 ? e2.props.ref : e2.props.ref || e2.ref);
}
var en = (e2) => typeof e2 == "boolean" ? `${e2}` : e2 === 0 ? "0" : e2;
var tn = zn;
var ea = (e2, t2) => (r2) => {
  var n2;
  if ((t2 == null ? void 0 : t2.variants) == null) return tn(e2, r2 == null ? void 0 : r2.class, r2 == null ? void 0 : r2.className);
  const { variants: o2, defaultVariants: s2 } = t2, a3 = Object.keys(o2).map((u3) => {
    const p2 = r2 == null ? void 0 : r2[u3], m3 = s2 == null ? void 0 : s2[u3];
    if (p2 === null) return null;
    const g3 = en(p2) || en(m3);
    return o2[u3][g3];
  }), i2 = r2 && Object.entries(r2).reduce((u3, p2) => {
    let [m3, g3] = p2;
    return g3 === void 0 || (u3[m3] = g3), u3;
  }, {}), d2 = t2 == null || (n2 = t2.compoundVariants) === null || n2 === void 0 ? void 0 : n2.reduce((u3, p2) => {
    let { class: m3, className: g3, ...b4 } = p2;
    return Object.entries(b4).every((E3) => {
      let [h, v2] = E3;
      return Array.isArray(v2) ? v2.includes({
        ...s2,
        ...i2
      }[h]) : {
        ...s2,
        ...i2
      }[h] === v2;
    }) ? [
      ...u3,
      m3,
      g3
    ] : u3;
  }, []);
  return tn(e2, a3, d2, r2 == null ? void 0 : r2.class, r2 == null ? void 0 : r2.className);
};
var yr = ea(
  "inline-flex items-center justify-center gap-2 whitespace-nowrap rounded-md text-sm font-medium transition-colors focus-visible:outline-none focus-visible:ring-1 focus-visible:ring-ring disabled:pointer-events-none disabled:opacity-50 [&_svg]:pointer-events-none [&_svg]:size-4 [&_svg]:shrink-0",
  {
    variants: {
      variant: {
        default: "bg-primary text-primary-foreground shadow hover:bg-primary/90",
        destructive: "bg-destructive text-destructive-foreground shadow-sm hover:bg-destructive/90",
        outline: "border border-input bg-background shadow-sm hover:bg-accent hover:text-accent-foreground",
        secondary: "bg-secondary text-secondary-foreground shadow-sm hover:bg-secondary/80",
        ghost: "hover:bg-accent hover:text-accent-foreground",
        link: "text-primary underline-offset-4 hover:underline"
      },
      size: {
        default: "h-9 px-4 py-2",
        sm: "h-8 rounded-md px-3 text-xs",
        lg: "h-10 rounded-md px-8",
        icon: "h-9 w-9"
      }
    },
    defaultVariants: {
      variant: "default",
      size: "default"
    }
  }
);
var q2 = f2.forwardRef(
  ({ className: e2, variant: t2, size: r2, asChild: n2 = false, ...o2 }, s2) => {
    const a3 = n2 ? Ot : "button";
    return l2.jsx(
      a3,
      {
        className: I2(yr({ variant: t2, size: r2, className: e2 })),
        ref: s2,
        ...o2
      }
    );
  }
);
q2.displayName = "Button";
var ta = ((e2) => (e2[e2.ADMIN = 0] = "ADMIN", e2[e2.USER = 1] = "USER", e2))(ta || {});
var Ie2 = ((e2) => (e2.APPLE = "APPLE", e2.EMAIL = "EMAIL", e2.GOOGLE = "GOOGLE", e2.FACEBOOK = "FACEBOOK", e2))(Ie2 || {});
var ra = [
  "a",
  "button",
  "div",
  "form",
  "h2",
  "h3",
  "img",
  "input",
  "label",
  "li",
  "nav",
  "ol",
  "p",
  "span",
  "svg",
  "ul"
];
var fe2 = ra.reduce((e2, t2) => {
  const r2 = f2.forwardRef((n2, o2) => {
    const { asChild: s2, ...a3 } = n2, i2 = s2 ? Ot : t2;
    return typeof window < "u" && (window[Symbol.for("radix-ui")] = true), l2.jsx(i2, { ...a3, ref: o2 });
  });
  return r2.displayName = `Primitive.${t2}`, { ...e2, [t2]: r2 };
}, {});
function na(e2, t2) {
  e2 && ri.flushSync(() => e2.dispatchEvent(t2));
}
var oa = "Separator";
var rn = "horizontal";
var sa = ["horizontal", "vertical"];
var qn = f2.forwardRef((e2, t2) => {
  const { decorative: r2, orientation: n2 = rn, ...o2 } = e2, s2 = ia(n2) ? n2 : rn, i2 = r2 ? { role: "none" } : { "aria-orientation": s2 === "vertical" ? s2 : void 0, role: "separator" };
  return l2.jsx(
    fe2.div,
    {
      "data-orientation": s2,
      ...i2,
      ...o2,
      ref: t2
    }
  );
});
qn.displayName = oa;
function ia(e2) {
  return sa.includes(e2);
}
var Xn = qn;
var dr = f2.forwardRef(
  ({ className: e2, orientation: t2 = "horizontal", decorative: r2 = true, ...n2 }, o2) => l2.jsx(
    Xn,
    {
      ref: o2,
      decorative: r2,
      orientation: t2,
      className: I2(
        "shrink-0 bg-border",
        t2 === "horizontal" ? "h-[1px] w-full" : "h-full w-[1px]",
        e2
      ),
      ...n2
    }
  )
);
dr.displayName = Xn.displayName;
var Zn = (0, import_react72.createContext)(void 0);
var Qe = () => {
  const e2 = (0, import_react72.useContext)(Zn);
  if (e2 === void 0)
    throw new Error(
      "useBedrockUser must be used within a Bedrock Passport Provider"
    );
  return e2;
};
var He2 = {
  facebook: (e2) => l2.jsxs("svg", { ...e2, xmlns: "http://www.w3.org/2000/svg", viewBox: "0 0 1024 1024", children: [
    l2.jsx(
      "path",
      {
        fill: "#1877f2",
        d: "M1024,512C1024,229.23016,794.76978,0,512,0S0,229.23016,0,512c0,255.554,187.231,467.37012,432,505.77777V660H302V512H432V399.2C432,270.87982,508.43854,200,625.38922,200,681.40765,200,740,210,740,210V336H675.43713C611.83508,336,592,375.46667,592,415.95728V512H734L711.3,660H592v357.77777C836.769,979.37012,1024,767.554,1024,512Z"
      }
    ),
    l2.jsx(
      "path",
      {
        fill: "#fff",
        d: "M711.3,660,734,512H592V415.95728C592,375.46667,611.83508,336,675.43713,336H740V210s-58.59235-10-114.61078-10C508.43854,200,432,270.87982,432,399.2V512H302V660H432v357.77777a517.39619,517.39619,0,0,0,160,0V660Z"
      }
    )
  ] }),
  google: (e2) => l2.jsx(
    "svg",
    {
      ...e2,
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 186.69 190.5",
      children: l2.jsxs("g", { transform: "translate(1184.583 765.171)", children: [
        l2.jsx(
          "path",
          {
            clipPath: "none",
            mask: "none",
            d: "M-1089.333-687.239v36.888h51.262c-2.251 11.863-9.006 21.908-19.137 28.662l30.913 23.986c18.011-16.625 28.402-41.044 28.402-70.052 0-6.754-.606-13.249-1.732-19.483z",
            fill: "#4285f4"
          }
        ),
        l2.jsx(
          "path",
          {
            clipPath: "none",
            mask: "none",
            d: "M-1142.714-651.791l-6.972 5.337-24.679 19.223h0c15.673 31.086 47.796 52.561 85.03 52.561 25.717 0 47.278-8.486 63.038-23.033l-30.913-23.986c-8.486 5.715-19.31 9.179-32.125 9.179-24.765 0-45.806-16.712-53.34-39.226z",
            fill: "#34a853"
          }
        ),
        l2.jsx(
          "path",
          {
            clipPath: "none",
            mask: "none",
            d: "M-1174.365-712.61c-6.494 12.815-10.217 27.276-10.217 42.689s3.723 29.874 10.217 42.689c0 .086 31.693-24.592 31.693-24.592-1.905-5.715-3.031-11.776-3.031-18.098s1.126-12.383 3.031-18.098z",
            fill: "#fbbc05"
          }
        ),
        l2.jsx(
          "path",
          {
            d: "M-1089.333-727.244c14.028 0 26.497 4.849 36.455 14.201l27.276-27.276c-16.539-15.413-38.013-24.852-63.731-24.852-37.234 0-69.359 21.388-85.032 52.561l31.692 24.592c7.533-22.514 28.575-39.226 53.34-39.226z",
            fill: "#ea4335",
            clipPath: "none",
            mask: "none"
          }
        )
      ] })
    }
  ),
  apple: (e2) => l2.jsx(
    "svg",
    {
      ...e2,
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 496.255 608.728",
      children: l2.jsx(
        "path",
        {
          fill: "#999",
          d: "M273.81 52.973C313.806.257 369.41 0 369.41 0s8.271 49.562-31.463 97.306c-42.426 50.98-90.649 42.638-90.649 42.638s-9.055-40.094 26.512-86.971zM252.385 174.662c20.576 0 58.764-28.284 108.471-28.284 85.562 0 119.222 60.883 119.222 60.883s-65.833 33.659-65.833 115.331c0 92.133 82.01 123.885 82.01 123.885s-57.328 161.357-134.762 161.357c-35.565 0-63.215-23.967-100.688-23.967-38.188 0-76.084 24.861-100.766 24.861C89.33 608.73 0 455.666 0 332.628c0-121.052 75.612-184.554 146.533-184.554 46.105 0 81.883 26.588 105.852 26.588z"
        }
      )
    }
  ),
  wallet: (e2) => l2.jsxs("svg", { ...e2, viewBox: "0 0 24 24", xmlns: "http://www.w3.org/2000/svg", children: [
    l2.jsx(
      "path",
      {
        d: "M19 7V4C19 3.73478 18.8946 3.48043 18.7071 3.29289C18.5196 3.10536 18.2652 3 18 3H5C4.46957 3 3.96086 3.21071 3.58579 3.58579C3.21071 3.96086 3 4.46957 3 5C3 5.53043 3.21071 6.03914 3.58579 6.41421C3.96086 6.78929 4.46957 7 5 7H20C20.2652 7 20.5196 7.10536 20.7071 7.29289C20.8946 7.48043 21 7.73478 21 8V12M21 12H18C17.4696 12 16.9609 12.2107 16.5858 12.5858C16.2107 12.9609 16 13.4696 16 14C16 14.5304 16.2107 15.0391 16.5858 15.4142C16.9609 15.7893 17.4696 16 18 16H21C21.2652 16 21.5196 15.8946 21.7071 15.7071C21.8946 15.5196 22 15.2652 22 15V13C22 12.7348 21.8946 12.4804 21.7071 12.2929C21.5196 12.1054 21.2652 12 21 12Z",
        stroke: "currentColor",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    ),
    l2.jsx(
      "path",
      {
        d: "M3 5V19C3 19.5304 3.21071 20.0391 3.58579 20.4142C3.96086 20.7893 4.46957 21 5 21H20C20.2652 21 20.5196 20.8946 20.7071 20.7071C20.8946 20.5196 21 20.2652 21 20V16",
        stroke: "currentColor",
        strokeWidth: "1.5",
        strokeLinecap: "round",
        strokeLinejoin: "round"
      }
    )
  ] }),
  email: (e2) => l2.jsxs(
    "svg",
    {
      ...e2,
      viewBox: "0 0 24 24",
      fill: "none",
      xmlns: "http://www.w3.org/2000/svg",
      children: [
        l2.jsx("g", { id: "SVGRepo_bgCarrier", strokeWidth: "0" }),
        l2.jsx(
          "g",
          {
            id: "SVGRepo_tracerCarrier",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ),
        l2.jsx("g", { id: "SVGRepo_iconCarrier", children: l2.jsx(
          "path",
          {
            d: "M4 7L10.94 11.3375C11.5885 11.7428 12.4115 11.7428 13.06 11.3375L20 7M5 18H19C20.1046 18 21 17.1046 21 16V8C21 6.89543 20.1046 6 19 6H5C3.89543 6 3 6.89543 3 8V16C3 17.1046 3.89543 18 5 18Z",
            stroke: "currentColor",
            strokeWidth: "2",
            strokeLinecap: "round",
            strokeLinejoin: "round"
          }
        ) })
      ]
    }
  )
};
function aa(e2, t2) {
  const r2 = f2.createContext(t2), n2 = (s2) => {
    const { children: a3, ...i2 } = s2, d2 = f2.useMemo(() => i2, Object.values(i2));
    return l2.jsx(r2.Provider, { value: d2, children: a3 });
  };
  n2.displayName = e2 + "Provider";
  function o2(s2) {
    const a3 = f2.useContext(r2);
    if (a3) return a3;
    if (t2 !== void 0) return t2;
    throw new Error(`\`${s2}\` must be used within \`${e2}\``);
  }
  return [n2, o2];
}
function Qn(e2, t2 = []) {
  let r2 = [];
  function n2(s2, a3) {
    const i2 = f2.createContext(a3), d2 = r2.length;
    r2 = [...r2, a3];
    const u3 = (m3) => {
      var x2;
      const { scope: g3, children: b4, ...E3 } = m3, h = ((x2 = g3 == null ? void 0 : g3[e2]) == null ? void 0 : x2[d2]) || i2, v2 = f2.useMemo(() => E3, Object.values(E3));
      return l2.jsx(h.Provider, { value: v2, children: b4 });
    };
    u3.displayName = s2 + "Provider";
    function p2(m3, g3) {
      var h;
      const b4 = ((h = g3 == null ? void 0 : g3[e2]) == null ? void 0 : h[d2]) || i2, E3 = f2.useContext(b4);
      if (E3) return E3;
      if (a3 !== void 0) return a3;
      throw new Error(`\`${m3}\` must be used within \`${s2}\``);
    }
    return [u3, p2];
  }
  const o2 = () => {
    const s2 = r2.map((a3) => f2.createContext(a3));
    return function(i2) {
      const d2 = (i2 == null ? void 0 : i2[e2]) || s2;
      return f2.useMemo(
        () => ({ [`__scope${e2}`]: { ...i2, [e2]: d2 } }),
        [i2, d2]
      );
    };
  };
  return o2.scopeName = e2, [n2, ca2(o2, ...t2)];
}
function ca2(...e2) {
  const t2 = e2[0];
  if (e2.length === 1) return t2;
  const r2 = () => {
    const n2 = e2.map((o2) => ({
      useScope: o2(),
      scopeName: o2.scopeName
    }));
    return function(s2) {
      const a3 = n2.reduce((i2, { useScope: d2, scopeName: u3 }) => {
        const m3 = d2(s2)[`__scope${u3}`];
        return { ...i2, ...m3 };
      }, {});
      return f2.useMemo(() => ({ [`__scope${t2.scopeName}`]: a3 }), [a3]);
    };
  };
  return r2.scopeName = t2.scopeName, r2;
}
function be2(e2, t2, { checkForDefaultPrevented: r2 = true } = {}) {
  return function(o2) {
    if (e2 == null || e2(o2), r2 === false || !o2.defaultPrevented)
      return t2 == null ? void 0 : t2(o2);
  };
}
var At = globalThis != null && globalThis.document ? f2.useLayoutEffect : () => {
};
var la = f2.useId || (() => {
});
var ua = 0;
function Jt(e2) {
  const [t2, r2] = f2.useState(la());
  return At(() => {
    e2 || r2((n2) => n2 ?? String(ua++));
  }, [e2]), e2 || (t2 ? `radix-${t2}` : "");
}
function Le2(e2) {
  const t2 = f2.useRef(e2);
  return f2.useEffect(() => {
    t2.current = e2;
  }), f2.useMemo(() => (...r2) => {
    var n2;
    return (n2 = t2.current) == null ? void 0 : n2.call(t2, ...r2);
  }, []);
}
function da({
  prop: e2,
  defaultProp: t2,
  onChange: r2 = () => {
  }
}) {
  const [n2, o2] = fa({ defaultProp: t2, onChange: r2 }), s2 = e2 !== void 0, a3 = s2 ? e2 : n2, i2 = Le2(r2), d2 = f2.useCallback(
    (u3) => {
      if (s2) {
        const m3 = typeof u3 == "function" ? u3(e2) : u3;
        m3 !== e2 && i2(m3);
      } else
        o2(u3);
    },
    [s2, e2, o2, i2]
  );
  return [a3, d2];
}
function fa({
  defaultProp: e2,
  onChange: t2
}) {
  const r2 = f2.useState(e2), [n2] = r2, o2 = f2.useRef(n2), s2 = Le2(t2);
  return f2.useEffect(() => {
    o2.current !== n2 && (s2(n2), o2.current = n2);
  }, [n2, o2, s2]), r2;
}
function ha(e2, t2 = globalThis == null ? void 0 : globalThis.document) {
  const r2 = Le2(e2);
  f2.useEffect(() => {
    const n2 = (o2) => {
      o2.key === "Escape" && r2(o2);
    };
    return t2.addEventListener("keydown", n2, { capture: true }), () => t2.removeEventListener("keydown", n2, { capture: true });
  }, [r2, t2]);
}
var pa = "DismissableLayer";
var fr = "dismissableLayer.update";
var ma = "dismissableLayer.pointerDownOutside";
var ga = "dismissableLayer.focusOutside";
var nn;
var eo = f2.createContext({
  layers: /* @__PURE__ */ new Set(),
  layersWithOutsidePointerEventsDisabled: /* @__PURE__ */ new Set(),
  branches: /* @__PURE__ */ new Set()
});
var to3 = f2.forwardRef(
  (e2, t2) => {
    const {
      disableOutsidePointerEvents: r2 = false,
      onEscapeKeyDown: n2,
      onPointerDownOutside: o2,
      onFocusOutside: s2,
      onInteractOutside: a3,
      onDismiss: i2,
      ...d2
    } = e2, u3 = f2.useContext(eo), [p2, m3] = f2.useState(null), g3 = (p2 == null ? void 0 : p2.ownerDocument) ?? (globalThis == null ? void 0 : globalThis.document), [, b4] = f2.useState({}), E3 = ve2(t2, (L2) => m3(L2)), h = Array.from(u3.layers), [v2] = [...u3.layersWithOutsidePointerEventsDisabled].slice(-1), x2 = h.indexOf(v2), w2 = p2 ? h.indexOf(p2) : -1, P = u3.layersWithOutsidePointerEventsDisabled.size > 0, R2 = w2 >= x2, N2 = ya((L2) => {
      const J2 = L2.target, Z2 = [...u3.branches].some((oe2) => oe2.contains(J2));
      !R2 || Z2 || (o2 == null || o2(L2), a3 == null || a3(L2), L2.defaultPrevented || i2 == null || i2());
    }, g3), W3 = xa((L2) => {
      const J2 = L2.target;
      [...u3.branches].some((oe2) => oe2.contains(J2)) || (s2 == null || s2(L2), a3 == null || a3(L2), L2.defaultPrevented || i2 == null || i2());
    }, g3);
    return ha((L2) => {
      w2 === u3.layers.size - 1 && (n2 == null || n2(L2), !L2.defaultPrevented && i2 && (L2.preventDefault(), i2()));
    }, g3), f2.useEffect(() => {
      if (p2)
        return r2 && (u3.layersWithOutsidePointerEventsDisabled.size === 0 && (nn = g3.body.style.pointerEvents, g3.body.style.pointerEvents = "none"), u3.layersWithOutsidePointerEventsDisabled.add(p2)), u3.layers.add(p2), on(), () => {
          r2 && u3.layersWithOutsidePointerEventsDisabled.size === 1 && (g3.body.style.pointerEvents = nn);
        };
    }, [p2, g3, r2, u3]), f2.useEffect(() => () => {
      p2 && (u3.layers.delete(p2), u3.layersWithOutsidePointerEventsDisabled.delete(p2), on());
    }, [p2, u3]), f2.useEffect(() => {
      const L2 = () => b4({});
      return document.addEventListener(fr, L2), () => document.removeEventListener(fr, L2);
    }, []), l2.jsx(
      fe2.div,
      {
        ...d2,
        ref: E3,
        style: {
          pointerEvents: P ? R2 ? "auto" : "none" : void 0,
          ...e2.style
        },
        onFocusCapture: be2(e2.onFocusCapture, W3.onFocusCapture),
        onBlurCapture: be2(e2.onBlurCapture, W3.onBlurCapture),
        onPointerDownCapture: be2(
          e2.onPointerDownCapture,
          N2.onPointerDownCapture
        )
      }
    );
  }
);
to3.displayName = pa;
var ba = "DismissableLayerBranch";
var va = f2.forwardRef((e2, t2) => {
  const r2 = f2.useContext(eo), n2 = f2.useRef(null), o2 = ve2(t2, n2);
  return f2.useEffect(() => {
    const s2 = n2.current;
    if (s2)
      return r2.branches.add(s2), () => {
        r2.branches.delete(s2);
      };
  }, [r2.branches]), l2.jsx(fe2.div, { ...e2, ref: o2 });
});
va.displayName = ba;
function ya(e2, t2 = globalThis == null ? void 0 : globalThis.document) {
  const r2 = Le2(e2), n2 = f2.useRef(false), o2 = f2.useRef(() => {
  });
  return f2.useEffect(() => {
    const s2 = (i2) => {
      if (i2.target && !n2.current) {
        let d2 = function() {
          ro(
            ma,
            r2,
            u3,
            { discrete: true }
          );
        };
        const u3 = { originalEvent: i2 };
        i2.pointerType === "touch" ? (t2.removeEventListener("click", o2.current), o2.current = d2, t2.addEventListener("click", o2.current, { once: true })) : d2();
      } else
        t2.removeEventListener("click", o2.current);
      n2.current = false;
    }, a3 = window.setTimeout(() => {
      t2.addEventListener("pointerdown", s2);
    }, 0);
    return () => {
      window.clearTimeout(a3), t2.removeEventListener("pointerdown", s2), t2.removeEventListener("click", o2.current);
    };
  }, [t2, r2]), {
    // ensures we check React component tree (not just DOM tree)
    onPointerDownCapture: () => n2.current = true
  };
}
function xa(e2, t2 = globalThis == null ? void 0 : globalThis.document) {
  const r2 = Le2(e2), n2 = f2.useRef(false);
  return f2.useEffect(() => {
    const o2 = (s2) => {
      s2.target && !n2.current && ro(ga, r2, { originalEvent: s2 }, {
        discrete: false
      });
    };
    return t2.addEventListener("focusin", o2), () => t2.removeEventListener("focusin", o2);
  }, [t2, r2]), {
    onFocusCapture: () => n2.current = true,
    onBlurCapture: () => n2.current = false
  };
}
function on() {
  const e2 = new CustomEvent(fr);
  document.dispatchEvent(e2);
}
function ro(e2, t2, r2, { discrete: n2 }) {
  const o2 = r2.originalEvent.target, s2 = new CustomEvent(e2, { bubbles: false, cancelable: true, detail: r2 });
  t2 && o2.addEventListener(e2, t2, { once: true }), n2 ? na(o2, s2) : o2.dispatchEvent(s2);
}
var Kt = "focusScope.autoFocusOnMount";
var Yt = "focusScope.autoFocusOnUnmount";
var sn = { bubbles: false, cancelable: true };
var wa = "FocusScope";
var no = f2.forwardRef((e2, t2) => {
  const {
    loop: r2 = false,
    trapped: n2 = false,
    onMountAutoFocus: o2,
    onUnmountAutoFocus: s2,
    ...a3
  } = e2, [i2, d2] = f2.useState(null), u3 = Le2(o2), p2 = Le2(s2), m3 = f2.useRef(null), g3 = ve2(t2, (h) => d2(h)), b4 = f2.useRef({
    paused: false,
    pause() {
      this.paused = true;
    },
    resume() {
      this.paused = false;
    }
  }).current;
  f2.useEffect(() => {
    if (n2) {
      let h = function(P) {
        if (b4.paused || !i2) return;
        const R2 = P.target;
        i2.contains(R2) ? m3.current = R2 : Re2(m3.current, { select: true });
      }, v2 = function(P) {
        if (b4.paused || !i2) return;
        const R2 = P.relatedTarget;
        R2 !== null && (i2.contains(R2) || Re2(m3.current, { select: true }));
      }, x2 = function(P) {
        if (document.activeElement === document.body)
          for (const N2 of P)
            N2.removedNodes.length > 0 && Re2(i2);
      };
      document.addEventListener("focusin", h), document.addEventListener("focusout", v2);
      const w2 = new MutationObserver(x2);
      return i2 && w2.observe(i2, { childList: true, subtree: true }), () => {
        document.removeEventListener("focusin", h), document.removeEventListener("focusout", v2), w2.disconnect();
      };
    }
  }, [n2, i2, b4.paused]), f2.useEffect(() => {
    if (i2) {
      cn.add(b4);
      const h = document.activeElement;
      if (!i2.contains(h)) {
        const x2 = new CustomEvent(Kt, sn);
        i2.addEventListener(Kt, u3), i2.dispatchEvent(x2), x2.defaultPrevented || (Ea(Aa(oo(i2)), { select: true }), document.activeElement === h && Re2(i2));
      }
      return () => {
        i2.removeEventListener(Kt, u3), setTimeout(() => {
          const x2 = new CustomEvent(Yt, sn);
          i2.addEventListener(Yt, p2), i2.dispatchEvent(x2), x2.defaultPrevented || Re2(h ?? document.body, { select: true }), i2.removeEventListener(Yt, p2), cn.remove(b4);
        }, 0);
      };
    }
  }, [i2, u3, p2, b4]);
  const E3 = f2.useCallback(
    (h) => {
      if (!r2 && !n2 || b4.paused) return;
      const v2 = h.key === "Tab" && !h.altKey && !h.ctrlKey && !h.metaKey, x2 = document.activeElement;
      if (v2 && x2) {
        const w2 = h.currentTarget, [P, R2] = Ca(w2);
        P && R2 ? !h.shiftKey && x2 === R2 ? (h.preventDefault(), r2 && Re2(P, { select: true })) : h.shiftKey && x2 === P && (h.preventDefault(), r2 && Re2(R2, { select: true })) : x2 === w2 && h.preventDefault();
      }
    },
    [r2, n2, b4.paused]
  );
  return l2.jsx(fe2.div, { tabIndex: -1, ...a3, ref: g3, onKeyDown: E3 });
});
no.displayName = wa;
function Ea(e2, { select: t2 = false } = {}) {
  const r2 = document.activeElement;
  for (const n2 of e2)
    if (Re2(n2, { select: t2 }), document.activeElement !== r2) return;
}
function Ca(e2) {
  const t2 = oo(e2), r2 = an(t2, e2), n2 = an(t2.reverse(), e2);
  return [r2, n2];
}
function oo(e2) {
  const t2 = [], r2 = document.createTreeWalker(e2, NodeFilter.SHOW_ELEMENT, {
    acceptNode: (n2) => {
      const o2 = n2.tagName === "INPUT" && n2.type === "hidden";
      return n2.disabled || n2.hidden || o2 ? NodeFilter.FILTER_SKIP : n2.tabIndex >= 0 ? NodeFilter.FILTER_ACCEPT : NodeFilter.FILTER_SKIP;
    }
  });
  for (; r2.nextNode(); ) t2.push(r2.currentNode);
  return t2;
}
function an(e2, t2) {
  for (const r2 of e2)
    if (!Pa(r2, { upTo: t2 })) return r2;
}
function Pa(e2, { upTo: t2 }) {
  if (getComputedStyle(e2).visibility === "hidden") return true;
  for (; e2; ) {
    if (t2 !== void 0 && e2 === t2) return false;
    if (getComputedStyle(e2).display === "none") return true;
    e2 = e2.parentElement;
  }
  return false;
}
function Sa(e2) {
  return e2 instanceof HTMLInputElement && "select" in e2;
}
function Re2(e2, { select: t2 = false } = {}) {
  if (e2 && e2.focus) {
    const r2 = document.activeElement;
    e2.focus({ preventScroll: true }), e2 !== r2 && Sa(e2) && t2 && e2.select();
  }
}
var cn = Ra();
function Ra() {
  let e2 = [];
  return {
    add(t2) {
      const r2 = e2[0];
      t2 !== r2 && (r2 == null || r2.pause()), e2 = ln(e2, t2), e2.unshift(t2);
    },
    remove(t2) {
      var r2;
      e2 = ln(e2, t2), (r2 = e2[0]) == null || r2.resume();
    }
  };
}
function ln(e2, t2) {
  const r2 = [...e2], n2 = r2.indexOf(t2);
  return n2 !== -1 && r2.splice(n2, 1), r2;
}
function Aa(e2) {
  return e2.filter((t2) => t2.tagName !== "A");
}
var Ia = "Portal";
var so = f2.forwardRef((e2, t2) => {
  var i2;
  const { container: r2, ...n2 } = e2, [o2, s2] = f2.useState(false);
  At(() => s2(true), []);
  const a3 = r2 || o2 && ((i2 = globalThis == null ? void 0 : globalThis.document) == null ? void 0 : i2.body);
  return a3 ? import_react_dom2.default.createPortal(l2.jsx(fe2.div, { ...n2, ref: t2 }), a3) : null;
});
so.displayName = Ia;
function ka(e2, t2) {
  return f2.useReducer((r2, n2) => t2[r2][n2] ?? r2, e2);
}
var jt = (e2) => {
  const { present: t2, children: r2 } = e2, n2 = Ta(t2), o2 = typeof r2 == "function" ? r2({ present: n2.isPresent }) : f2.Children.only(r2), s2 = ve2(n2.ref, Na(o2));
  return typeof r2 == "function" || n2.isPresent ? f2.cloneElement(o2, { ref: s2 }) : null;
};
jt.displayName = "Presence";
function Ta(e2) {
  const [t2, r2] = f2.useState(), n2 = f2.useRef({}), o2 = f2.useRef(e2), s2 = f2.useRef("none"), a3 = e2 ? "mounted" : "unmounted", [i2, d2] = ka(a3, {
    mounted: {
      UNMOUNT: "unmounted",
      ANIMATION_OUT: "unmountSuspended"
    },
    unmountSuspended: {
      MOUNT: "mounted",
      ANIMATION_END: "unmounted"
    },
    unmounted: {
      MOUNT: "mounted"
    }
  });
  return f2.useEffect(() => {
    const u3 = yt(n2.current);
    s2.current = i2 === "mounted" ? u3 : "none";
  }, [i2]), At(() => {
    const u3 = n2.current, p2 = o2.current;
    if (p2 !== e2) {
      const g3 = s2.current, b4 = yt(u3);
      e2 ? d2("MOUNT") : b4 === "none" || (u3 == null ? void 0 : u3.display) === "none" ? d2("UNMOUNT") : d2(p2 && g3 !== b4 ? "ANIMATION_OUT" : "UNMOUNT"), o2.current = e2;
    }
  }, [e2, d2]), At(() => {
    if (t2) {
      let u3;
      const p2 = t2.ownerDocument.defaultView ?? window, m3 = (b4) => {
        const h = yt(n2.current).includes(b4.animationName);
        if (b4.target === t2 && h && (d2("ANIMATION_END"), !o2.current)) {
          const v2 = t2.style.animationFillMode;
          t2.style.animationFillMode = "forwards", u3 = p2.setTimeout(() => {
            t2.style.animationFillMode === "forwards" && (t2.style.animationFillMode = v2);
          });
        }
      }, g3 = (b4) => {
        b4.target === t2 && (s2.current = yt(n2.current));
      };
      return t2.addEventListener("animationstart", g3), t2.addEventListener("animationcancel", m3), t2.addEventListener("animationend", m3), () => {
        p2.clearTimeout(u3), t2.removeEventListener("animationstart", g3), t2.removeEventListener("animationcancel", m3), t2.removeEventListener("animationend", m3);
      };
    } else
      d2("ANIMATION_END");
  }, [t2, d2]), {
    isPresent: ["mounted", "unmountSuspended"].includes(i2),
    ref: f2.useCallback((u3) => {
      u3 && (n2.current = getComputedStyle(u3)), r2(u3);
    }, [])
  };
}
function yt(e2) {
  return (e2 == null ? void 0 : e2.animationName) || "none";
}
function Na(e2) {
  var n2, o2;
  let t2 = (n2 = Object.getOwnPropertyDescriptor(e2.props, "ref")) == null ? void 0 : n2.get, r2 = t2 && "isReactWarning" in t2 && t2.isReactWarning;
  return r2 ? e2.ref : (t2 = (o2 = Object.getOwnPropertyDescriptor(e2, "ref")) == null ? void 0 : o2.get, r2 = t2 && "isReactWarning" in t2 && t2.isReactWarning, r2 ? e2.props.ref : e2.props.ref || e2.ref);
}
var qt = 0;
function _a() {
  f2.useEffect(() => {
    const e2 = document.querySelectorAll("[data-radix-focus-guard]");
    return document.body.insertAdjacentElement("afterbegin", e2[0] ?? un()), document.body.insertAdjacentElement("beforeend", e2[1] ?? un()), qt++, () => {
      qt === 1 && document.querySelectorAll("[data-radix-focus-guard]").forEach((t2) => t2.remove()), qt--;
    };
  }, []);
}
function un() {
  const e2 = document.createElement("span");
  return e2.setAttribute("data-radix-focus-guard", ""), e2.tabIndex = 0, e2.style.outline = "none", e2.style.opacity = "0", e2.style.position = "fixed", e2.style.pointerEvents = "none", e2;
}
var de2 = function() {
  return de2 = Object.assign || function(t2) {
    for (var r2, n2 = 1, o2 = arguments.length; n2 < o2; n2++) {
      r2 = arguments[n2];
      for (var s2 in r2) Object.prototype.hasOwnProperty.call(r2, s2) && (t2[s2] = r2[s2]);
    }
    return t2;
  }, de2.apply(this, arguments);
};
function io(e2, t2) {
  var r2 = {};
  for (var n2 in e2) Object.prototype.hasOwnProperty.call(e2, n2) && t2.indexOf(n2) < 0 && (r2[n2] = e2[n2]);
  if (e2 != null && typeof Object.getOwnPropertySymbols == "function")
    for (var o2 = 0, n2 = Object.getOwnPropertySymbols(e2); o2 < n2.length; o2++)
      t2.indexOf(n2[o2]) < 0 && Object.prototype.propertyIsEnumerable.call(e2, n2[o2]) && (r2[n2[o2]] = e2[n2[o2]]);
  return r2;
}
function Oa(e2, t2, r2) {
  if (r2 || arguments.length === 2) for (var n2 = 0, o2 = t2.length, s2; n2 < o2; n2++)
    (s2 || !(n2 in t2)) && (s2 || (s2 = Array.prototype.slice.call(t2, 0, n2)), s2[n2] = t2[n2]);
  return e2.concat(s2 || Array.prototype.slice.call(t2));
}
var St = "right-scroll-bar-position";
var Rt = "width-before-scroll-bar";
var ja = "with-scroll-bars-hidden";
var La = "--removed-body-scroll-bar-size";
function Xt(e2, t2) {
  return typeof e2 == "function" ? e2(t2) : e2 && (e2.current = t2), e2;
}
function Da(e2, t2) {
  var r2 = (0, import_react72.useState)(function() {
    return {
      // value
      value: e2,
      // last callback
      callback: t2,
      // "memoized" public interface
      facade: {
        get current() {
          return r2.value;
        },
        set current(n2) {
          var o2 = r2.value;
          o2 !== n2 && (r2.value = n2, r2.callback(n2, o2));
        }
      }
    };
  })[0];
  return r2.callback = t2, r2.facade;
}
var Fa = typeof window < "u" ? f2.useLayoutEffect : f2.useEffect;
var dn = /* @__PURE__ */ new WeakMap();
function Ba(e2, t2) {
  var r2 = Da(null, function(n2) {
    return e2.forEach(function(o2) {
      return Xt(o2, n2);
    });
  });
  return Fa(function() {
    var n2 = dn.get(r2);
    if (n2) {
      var o2 = new Set(n2), s2 = new Set(e2), a3 = r2.current;
      o2.forEach(function(i2) {
        s2.has(i2) || Xt(i2, null);
      }), s2.forEach(function(i2) {
        o2.has(i2) || Xt(i2, a3);
      });
    }
    dn.set(r2, e2);
  }, [e2]), r2;
}
function Ma(e2) {
  return e2;
}
function Ua(e2, t2) {
  t2 === void 0 && (t2 = Ma);
  var r2 = [], n2 = false, o2 = {
    read: function() {
      if (n2)
        throw new Error("Sidecar: could not `read` from an `assigned` medium. `read` could be used only with `useMedium`.");
      return r2.length ? r2[r2.length - 1] : e2;
    },
    useMedium: function(s2) {
      var a3 = t2(s2, n2);
      return r2.push(a3), function() {
        r2 = r2.filter(function(i2) {
          return i2 !== a3;
        });
      };
    },
    assignSyncMedium: function(s2) {
      for (n2 = true; r2.length; ) {
        var a3 = r2;
        r2 = [], a3.forEach(s2);
      }
      r2 = {
        push: function(i2) {
          return s2(i2);
        },
        filter: function() {
          return r2;
        }
      };
    },
    assignMedium: function(s2) {
      n2 = true;
      var a3 = [];
      if (r2.length) {
        var i2 = r2;
        r2 = [], i2.forEach(s2), a3 = r2;
      }
      var d2 = function() {
        var p2 = a3;
        a3 = [], p2.forEach(s2);
      }, u3 = function() {
        return Promise.resolve().then(d2);
      };
      u3(), r2 = {
        push: function(p2) {
          a3.push(p2), u3();
        },
        filter: function(p2) {
          return a3 = a3.filter(p2), r2;
        }
      };
    }
  };
  return o2;
}
function za(e2) {
  e2 === void 0 && (e2 = {});
  var t2 = Ua(null);
  return t2.options = de2({ async: true, ssr: false }, e2), t2;
}
var ao = function(e2) {
  var t2 = e2.sideCar, r2 = io(e2, ["sideCar"]);
  if (!t2)
    throw new Error("Sidecar: please provide `sideCar` property to import the right car");
  var n2 = t2.read();
  if (!n2)
    throw new Error("Sidecar medium not found");
  return f2.createElement(n2, de2({}, r2));
};
ao.isSideCarExport = true;
function $a(e2, t2) {
  return e2.useMedium(t2), ao;
}
var co = za();
var Zt = function() {
};
var Lt = f2.forwardRef(function(e2, t2) {
  var r2 = f2.useRef(null), n2 = f2.useState({
    onScrollCapture: Zt,
    onWheelCapture: Zt,
    onTouchMoveCapture: Zt
  }), o2 = n2[0], s2 = n2[1], a3 = e2.forwardProps, i2 = e2.children, d2 = e2.className, u3 = e2.removeScrollBar, p2 = e2.enabled, m3 = e2.shards, g3 = e2.sideCar, b4 = e2.noIsolation, E3 = e2.inert, h = e2.allowPinchZoom, v2 = e2.as, x2 = v2 === void 0 ? "div" : v2, w2 = e2.gapMode, P = io(e2, ["forwardProps", "children", "className", "removeScrollBar", "enabled", "shards", "sideCar", "noIsolation", "inert", "allowPinchZoom", "as", "gapMode"]), R2 = g3, N2 = Ba([r2, t2]), W3 = de2(de2({}, P), o2);
  return f2.createElement(
    f2.Fragment,
    null,
    p2 && f2.createElement(R2, { sideCar: co, removeScrollBar: u3, shards: m3, noIsolation: b4, inert: E3, setCallbacks: s2, allowPinchZoom: !!h, lockRef: r2, gapMode: w2 }),
    a3 ? f2.cloneElement(f2.Children.only(i2), de2(de2({}, W3), { ref: N2 })) : f2.createElement(x2, de2({}, W3, { className: d2, ref: N2 }), i2)
  );
});
Lt.defaultProps = {
  enabled: true,
  removeScrollBar: true,
  inert: false
};
Lt.classNames = {
  fullWidth: Rt,
  zeroRight: St
};
var Wa = function() {
  if (typeof __webpack_nonce__ < "u")
    return __webpack_nonce__;
};
function Ga() {
  if (!document)
    return null;
  var e2 = document.createElement("style");
  e2.type = "text/css";
  var t2 = Wa();
  return t2 && e2.setAttribute("nonce", t2), e2;
}
function Va(e2, t2) {
  e2.styleSheet ? e2.styleSheet.cssText = t2 : e2.appendChild(document.createTextNode(t2));
}
function Ha(e2) {
  var t2 = document.head || document.getElementsByTagName("head")[0];
  t2.appendChild(e2);
}
var Ja = function() {
  var e2 = 0, t2 = null;
  return {
    add: function(r2) {
      e2 == 0 && (t2 = Ga()) && (Va(t2, r2), Ha(t2)), e2++;
    },
    remove: function() {
      e2--, !e2 && t2 && (t2.parentNode && t2.parentNode.removeChild(t2), t2 = null);
    }
  };
};
var Ka = function() {
  var e2 = Ja();
  return function(t2, r2) {
    f2.useEffect(function() {
      return e2.add(t2), function() {
        e2.remove();
      };
    }, [t2 && r2]);
  };
};
var lo = function() {
  var e2 = Ka(), t2 = function(r2) {
    var n2 = r2.styles, o2 = r2.dynamic;
    return e2(n2, o2), null;
  };
  return t2;
};
var Ya = {
  left: 0,
  top: 0,
  right: 0,
  gap: 0
};
var Qt = function(e2) {
  return parseInt(e2 || "", 10) || 0;
};
var qa = function(e2) {
  var t2 = window.getComputedStyle(document.body), r2 = t2[e2 === "padding" ? "paddingLeft" : "marginLeft"], n2 = t2[e2 === "padding" ? "paddingTop" : "marginTop"], o2 = t2[e2 === "padding" ? "paddingRight" : "marginRight"];
  return [Qt(r2), Qt(n2), Qt(o2)];
};
var Xa = function(e2) {
  if (e2 === void 0 && (e2 = "margin"), typeof window > "u")
    return Ya;
  var t2 = qa(e2), r2 = document.documentElement.clientWidth, n2 = window.innerWidth;
  return {
    left: t2[0],
    top: t2[1],
    right: t2[2],
    gap: Math.max(0, n2 - r2 + t2[2] - t2[0])
  };
};
var Za = lo();
var Ye2 = "data-scroll-locked";
var Qa = function(e2, t2, r2, n2) {
  var o2 = e2.left, s2 = e2.top, a3 = e2.right, i2 = e2.gap;
  return r2 === void 0 && (r2 = "margin"), `
  .`.concat(ja, ` {
   overflow: hidden `).concat(n2, `;
   padding-right: `).concat(i2, "px ").concat(n2, `;
  }
  body[`).concat(Ye2, `] {
    overflow: hidden `).concat(n2, `;
    overscroll-behavior: contain;
    `).concat([
    t2 && "position: relative ".concat(n2, ";"),
    r2 === "margin" && `
    padding-left: `.concat(o2, `px;
    padding-top: `).concat(s2, `px;
    padding-right: `).concat(a3, `px;
    margin-left:0;
    margin-top:0;
    margin-right: `).concat(i2, "px ").concat(n2, `;
    `),
    r2 === "padding" && "padding-right: ".concat(i2, "px ").concat(n2, ";")
  ].filter(Boolean).join(""), `
  }
  
  .`).concat(St, ` {
    right: `).concat(i2, "px ").concat(n2, `;
  }
  
  .`).concat(Rt, ` {
    margin-right: `).concat(i2, "px ").concat(n2, `;
  }
  
  .`).concat(St, " .").concat(St, ` {
    right: 0 `).concat(n2, `;
  }
  
  .`).concat(Rt, " .").concat(Rt, ` {
    margin-right: 0 `).concat(n2, `;
  }
  
  body[`).concat(Ye2, `] {
    `).concat(La, ": ").concat(i2, `px;
  }
`);
};
var fn = function() {
  var e2 = parseInt(document.body.getAttribute(Ye2) || "0", 10);
  return isFinite(e2) ? e2 : 0;
};
var ec = function() {
  f2.useEffect(function() {
    return document.body.setAttribute(Ye2, (fn() + 1).toString()), function() {
      var e2 = fn() - 1;
      e2 <= 0 ? document.body.removeAttribute(Ye2) : document.body.setAttribute(Ye2, e2.toString());
    };
  }, []);
};
var tc = function(e2) {
  var t2 = e2.noRelative, r2 = e2.noImportant, n2 = e2.gapMode, o2 = n2 === void 0 ? "margin" : n2;
  ec();
  var s2 = f2.useMemo(function() {
    return Xa(o2);
  }, [o2]);
  return f2.createElement(Za, { styles: Qa(s2, !t2, o2, r2 ? "" : "!important") });
};
var hr = false;
if (typeof window < "u")
  try {
    xt = Object.defineProperty({}, "passive", {
      get: function() {
        return hr = true, true;
      }
    });
    window.addEventListener("test", xt, xt), window.removeEventListener("test", xt, xt);
  } catch {
    hr = false;
  }
var xt;
var We2 = hr ? { passive: false } : false;
var rc = function(e2) {
  return e2.tagName === "TEXTAREA";
};
var uo = function(e2, t2) {
  if (!(e2 instanceof Element))
    return false;
  var r2 = window.getComputedStyle(e2);
  return (
    // not-not-scrollable
    r2[t2] !== "hidden" && // contains scroll inside self
    !(r2.overflowY === r2.overflowX && !rc(e2) && r2[t2] === "visible")
  );
};
var nc = function(e2) {
  return uo(e2, "overflowY");
};
var oc = function(e2) {
  return uo(e2, "overflowX");
};
var hn = function(e2, t2) {
  var r2 = t2.ownerDocument, n2 = t2;
  do {
    typeof ShadowRoot < "u" && n2 instanceof ShadowRoot && (n2 = n2.host);
    var o2 = fo(e2, n2);
    if (o2) {
      var s2 = ho(e2, n2), a3 = s2[1], i2 = s2[2];
      if (a3 > i2)
        return true;
    }
    n2 = n2.parentNode;
  } while (n2 && n2 !== r2.body);
  return false;
};
var sc = function(e2) {
  var t2 = e2.scrollTop, r2 = e2.scrollHeight, n2 = e2.clientHeight;
  return [
    t2,
    r2,
    n2
  ];
};
var ic = function(e2) {
  var t2 = e2.scrollLeft, r2 = e2.scrollWidth, n2 = e2.clientWidth;
  return [
    t2,
    r2,
    n2
  ];
};
var fo = function(e2, t2) {
  return e2 === "v" ? nc(t2) : oc(t2);
};
var ho = function(e2, t2) {
  return e2 === "v" ? sc(t2) : ic(t2);
};
var ac = function(e2, t2) {
  return e2 === "h" && t2 === "rtl" ? -1 : 1;
};
var cc2 = function(e2, t2, r2, n2, o2) {
  var s2 = ac(e2, window.getComputedStyle(t2).direction), a3 = s2 * n2, i2 = r2.target, d2 = t2.contains(i2), u3 = false, p2 = a3 > 0, m3 = 0, g3 = 0;
  do {
    var b4 = ho(e2, i2), E3 = b4[0], h = b4[1], v2 = b4[2], x2 = h - v2 - s2 * E3;
    (E3 || x2) && fo(e2, i2) && (m3 += x2, g3 += E3), i2 instanceof ShadowRoot ? i2 = i2.host : i2 = i2.parentNode;
  } while (
    // portaled content
    !d2 && i2 !== document.body || // self content
    d2 && (t2.contains(i2) || t2 === i2)
  );
  return (p2 && (Math.abs(m3) < 1 || !o2) || !p2 && (Math.abs(g3) < 1 || !o2)) && (u3 = true), u3;
};
var wt = function(e2) {
  return "changedTouches" in e2 ? [e2.changedTouches[0].clientX, e2.changedTouches[0].clientY] : [0, 0];
};
var pn = function(e2) {
  return [e2.deltaX, e2.deltaY];
};
var mn = function(e2) {
  return e2 && "current" in e2 ? e2.current : e2;
};
var lc = function(e2, t2) {
  return e2[0] === t2[0] && e2[1] === t2[1];
};
var uc = function(e2) {
  return `
  .block-interactivity-`.concat(e2, ` {pointer-events: none;}
  .allow-interactivity-`).concat(e2, ` {pointer-events: all;}
`);
};
var dc = 0;
var Ge2 = [];
function fc(e2) {
  var t2 = f2.useRef([]), r2 = f2.useRef([0, 0]), n2 = f2.useRef(), o2 = f2.useState(dc++)[0], s2 = f2.useState(lo)[0], a3 = f2.useRef(e2);
  f2.useEffect(function() {
    a3.current = e2;
  }, [e2]), f2.useEffect(function() {
    if (e2.inert) {
      document.body.classList.add("block-interactivity-".concat(o2));
      var h = Oa([e2.lockRef.current], (e2.shards || []).map(mn), true).filter(Boolean);
      return h.forEach(function(v2) {
        return v2.classList.add("allow-interactivity-".concat(o2));
      }), function() {
        document.body.classList.remove("block-interactivity-".concat(o2)), h.forEach(function(v2) {
          return v2.classList.remove("allow-interactivity-".concat(o2));
        });
      };
    }
  }, [e2.inert, e2.lockRef.current, e2.shards]);
  var i2 = f2.useCallback(function(h, v2) {
    if ("touches" in h && h.touches.length === 2 || h.type === "wheel" && h.ctrlKey)
      return !a3.current.allowPinchZoom;
    var x2 = wt(h), w2 = r2.current, P = "deltaX" in h ? h.deltaX : w2[0] - x2[0], R2 = "deltaY" in h ? h.deltaY : w2[1] - x2[1], N2, W3 = h.target, L2 = Math.abs(P) > Math.abs(R2) ? "h" : "v";
    if ("touches" in h && L2 === "h" && W3.type === "range")
      return false;
    var J2 = hn(L2, W3);
    if (!J2)
      return true;
    if (J2 ? N2 = L2 : (N2 = L2 === "v" ? "h" : "v", J2 = hn(L2, W3)), !J2)
      return false;
    if (!n2.current && "changedTouches" in h && (P || R2) && (n2.current = N2), !N2)
      return true;
    var Z2 = n2.current || N2;
    return cc2(Z2, v2, h, Z2 === "h" ? P : R2, true);
  }, []), d2 = f2.useCallback(function(h) {
    var v2 = h;
    if (!(!Ge2.length || Ge2[Ge2.length - 1] !== s2)) {
      var x2 = "deltaY" in v2 ? pn(v2) : wt(v2), w2 = t2.current.filter(function(N2) {
        return N2.name === v2.type && (N2.target === v2.target || v2.target === N2.shadowParent) && lc(N2.delta, x2);
      })[0];
      if (w2 && w2.should) {
        v2.cancelable && v2.preventDefault();
        return;
      }
      if (!w2) {
        var P = (a3.current.shards || []).map(mn).filter(Boolean).filter(function(N2) {
          return N2.contains(v2.target);
        }), R2 = P.length > 0 ? i2(v2, P[0]) : !a3.current.noIsolation;
        R2 && v2.cancelable && v2.preventDefault();
      }
    }
  }, []), u3 = f2.useCallback(function(h, v2, x2, w2) {
    var P = { name: h, delta: v2, target: x2, should: w2, shadowParent: hc(x2) };
    t2.current.push(P), setTimeout(function() {
      t2.current = t2.current.filter(function(R2) {
        return R2 !== P;
      });
    }, 1);
  }, []), p2 = f2.useCallback(function(h) {
    r2.current = wt(h), n2.current = void 0;
  }, []), m3 = f2.useCallback(function(h) {
    u3(h.type, pn(h), h.target, i2(h, e2.lockRef.current));
  }, []), g3 = f2.useCallback(function(h) {
    u3(h.type, wt(h), h.target, i2(h, e2.lockRef.current));
  }, []);
  f2.useEffect(function() {
    return Ge2.push(s2), e2.setCallbacks({
      onScrollCapture: m3,
      onWheelCapture: m3,
      onTouchMoveCapture: g3
    }), document.addEventListener("wheel", d2, We2), document.addEventListener("touchmove", d2, We2), document.addEventListener("touchstart", p2, We2), function() {
      Ge2 = Ge2.filter(function(h) {
        return h !== s2;
      }), document.removeEventListener("wheel", d2, We2), document.removeEventListener("touchmove", d2, We2), document.removeEventListener("touchstart", p2, We2);
    };
  }, []);
  var b4 = e2.removeScrollBar, E3 = e2.inert;
  return f2.createElement(
    f2.Fragment,
    null,
    E3 ? f2.createElement(s2, { styles: uc(o2) }) : null,
    b4 ? f2.createElement(tc, { gapMode: e2.gapMode }) : null
  );
}
function hc(e2) {
  for (var t2 = null; e2 !== null; )
    e2 instanceof ShadowRoot && (t2 = e2.host, e2 = e2.host), e2 = e2.parentNode;
  return t2;
}
var pc = $a(co, fc);
var po = f2.forwardRef(function(e2, t2) {
  return f2.createElement(Lt, de2({}, e2, { ref: t2, sideCar: pc }));
});
po.classNames = Lt.classNames;
var mc = function(e2) {
  if (typeof document > "u")
    return null;
  var t2 = Array.isArray(e2) ? e2[0] : e2;
  return t2.ownerDocument.body;
};
var Ve2 = /* @__PURE__ */ new WeakMap();
var Et = /* @__PURE__ */ new WeakMap();
var Ct = {};
var er = 0;
var mo = function(e2) {
  return e2 && (e2.host || mo(e2.parentNode));
};
var gc = function(e2, t2) {
  return t2.map(function(r2) {
    if (e2.contains(r2))
      return r2;
    var n2 = mo(r2);
    return n2 && e2.contains(n2) ? n2 : (console.error("aria-hidden", r2, "in not contained inside", e2, ". Doing nothing"), null);
  }).filter(function(r2) {
    return !!r2;
  });
};
var bc = function(e2, t2, r2, n2) {
  var o2 = gc(t2, Array.isArray(e2) ? e2 : [e2]);
  Ct[r2] || (Ct[r2] = /* @__PURE__ */ new WeakMap());
  var s2 = Ct[r2], a3 = [], i2 = /* @__PURE__ */ new Set(), d2 = new Set(o2), u3 = function(m3) {
    !m3 || i2.has(m3) || (i2.add(m3), u3(m3.parentNode));
  };
  o2.forEach(u3);
  var p2 = function(m3) {
    !m3 || d2.has(m3) || Array.prototype.forEach.call(m3.children, function(g3) {
      if (i2.has(g3))
        p2(g3);
      else
        try {
          var b4 = g3.getAttribute(n2), E3 = b4 !== null && b4 !== "false", h = (Ve2.get(g3) || 0) + 1, v2 = (s2.get(g3) || 0) + 1;
          Ve2.set(g3, h), s2.set(g3, v2), a3.push(g3), h === 1 && E3 && Et.set(g3, true), v2 === 1 && g3.setAttribute(r2, "true"), E3 || g3.setAttribute(n2, "true");
        } catch (x2) {
          console.error("aria-hidden: cannot operate on ", g3, x2);
        }
    });
  };
  return p2(t2), i2.clear(), er++, function() {
    a3.forEach(function(m3) {
      var g3 = Ve2.get(m3) - 1, b4 = s2.get(m3) - 1;
      Ve2.set(m3, g3), s2.set(m3, b4), g3 || (Et.has(m3) || m3.removeAttribute(n2), Et.delete(m3)), b4 || m3.removeAttribute(r2);
    }), er--, er || (Ve2 = /* @__PURE__ */ new WeakMap(), Ve2 = /* @__PURE__ */ new WeakMap(), Et = /* @__PURE__ */ new WeakMap(), Ct = {});
  };
};
var vc = function(e2, t2, r2) {
  r2 === void 0 && (r2 = "data-aria-hidden");
  var n2 = Array.from(Array.isArray(e2) ? e2 : [e2]), o2 = mc(e2);
  return o2 ? (n2.push.apply(n2, Array.from(o2.querySelectorAll("[aria-live]"))), bc(n2, o2, r2, "aria-hidden")) : function() {
    return null;
  };
};
var xr = "Dialog";
var [go, bo] = Qn(xr);
var [yc, ae2] = go(xr);
var vo = (e2) => {
  const {
    __scopeDialog: t2,
    children: r2,
    open: n2,
    defaultOpen: o2,
    onOpenChange: s2,
    modal: a3 = true
  } = e2, i2 = f2.useRef(null), d2 = f2.useRef(null), [u3 = false, p2] = da({
    prop: n2,
    defaultProp: o2,
    onChange: s2
  });
  return l2.jsx(
    yc,
    {
      scope: t2,
      triggerRef: i2,
      contentRef: d2,
      contentId: Jt(),
      titleId: Jt(),
      descriptionId: Jt(),
      open: u3,
      onOpenChange: p2,
      onOpenToggle: f2.useCallback(() => p2((m3) => !m3), [p2]),
      modal: a3,
      children: r2
    }
  );
};
vo.displayName = xr;
var yo = "DialogTrigger";
var xo = f2.forwardRef(
  (e2, t2) => {
    const { __scopeDialog: r2, ...n2 } = e2, o2 = ae2(yo, r2), s2 = ve2(t2, o2.triggerRef);
    return l2.jsx(
      fe2.button,
      {
        type: "button",
        "aria-haspopup": "dialog",
        "aria-expanded": o2.open,
        "aria-controls": o2.contentId,
        "data-state": Cr(o2.open),
        ...n2,
        ref: s2,
        onClick: be2(e2.onClick, o2.onOpenToggle)
      }
    );
  }
);
xo.displayName = yo;
var wr = "DialogPortal";
var [xc, wo] = go(wr, {
  forceMount: void 0
});
var Eo = (e2) => {
  const { __scopeDialog: t2, forceMount: r2, children: n2, container: o2 } = e2, s2 = ae2(wr, t2);
  return l2.jsx(xc, { scope: t2, forceMount: r2, children: f2.Children.map(n2, (a3) => l2.jsx(jt, { present: r2 || s2.open, children: l2.jsx(so, { asChild: true, container: o2, children: a3 }) })) });
};
Eo.displayName = wr;
var It = "DialogOverlay";
var Co = f2.forwardRef(
  (e2, t2) => {
    const r2 = wo(It, e2.__scopeDialog), { forceMount: n2 = r2.forceMount, ...o2 } = e2, s2 = ae2(It, e2.__scopeDialog);
    return s2.modal ? l2.jsx(jt, { present: n2 || s2.open, children: l2.jsx(wc, { ...o2, ref: t2 }) }) : null;
  }
);
Co.displayName = It;
var wc = f2.forwardRef(
  (e2, t2) => {
    const { __scopeDialog: r2, ...n2 } = e2, o2 = ae2(It, r2);
    return (
      // Make sure `Content` is scrollable even when it doesn't live inside `RemoveScroll`
      // ie. when `Overlay` and `Content` are siblings
      l2.jsx(po, { as: Ot, allowPinchZoom: true, shards: [o2.contentRef], children: l2.jsx(
        fe2.div,
        {
          "data-state": Cr(o2.open),
          ...n2,
          ref: t2,
          style: { pointerEvents: "auto", ...n2.style }
        }
      ) })
    );
  }
);
var De2 = "DialogContent";
var Po = f2.forwardRef(
  (e2, t2) => {
    const r2 = wo(De2, e2.__scopeDialog), { forceMount: n2 = r2.forceMount, ...o2 } = e2, s2 = ae2(De2, e2.__scopeDialog);
    return l2.jsx(jt, { present: n2 || s2.open, children: s2.modal ? l2.jsx(Ec, { ...o2, ref: t2 }) : l2.jsx(Cc, { ...o2, ref: t2 }) });
  }
);
Po.displayName = De2;
var Ec = f2.forwardRef(
  (e2, t2) => {
    const r2 = ae2(De2, e2.__scopeDialog), n2 = f2.useRef(null), o2 = ve2(t2, r2.contentRef, n2);
    return f2.useEffect(() => {
      const s2 = n2.current;
      if (s2) return vc(s2);
    }, []), l2.jsx(
      So,
      {
        ...e2,
        ref: o2,
        trapFocus: r2.open,
        disableOutsidePointerEvents: true,
        onCloseAutoFocus: be2(e2.onCloseAutoFocus, (s2) => {
          var a3;
          s2.preventDefault(), (a3 = r2.triggerRef.current) == null || a3.focus();
        }),
        onPointerDownOutside: be2(e2.onPointerDownOutside, (s2) => {
          const a3 = s2.detail.originalEvent, i2 = a3.button === 0 && a3.ctrlKey === true;
          (a3.button === 2 || i2) && s2.preventDefault();
        }),
        onFocusOutside: be2(
          e2.onFocusOutside,
          (s2) => s2.preventDefault()
        )
      }
    );
  }
);
var Cc = f2.forwardRef(
  (e2, t2) => {
    const r2 = ae2(De2, e2.__scopeDialog), n2 = f2.useRef(false), o2 = f2.useRef(false);
    return l2.jsx(
      So,
      {
        ...e2,
        ref: t2,
        trapFocus: false,
        disableOutsidePointerEvents: false,
        onCloseAutoFocus: (s2) => {
          var a3, i2;
          (a3 = e2.onCloseAutoFocus) == null || a3.call(e2, s2), s2.defaultPrevented || (n2.current || (i2 = r2.triggerRef.current) == null || i2.focus(), s2.preventDefault()), n2.current = false, o2.current = false;
        },
        onInteractOutside: (s2) => {
          var d2, u3;
          (d2 = e2.onInteractOutside) == null || d2.call(e2, s2), s2.defaultPrevented || (n2.current = true, s2.detail.originalEvent.type === "pointerdown" && (o2.current = true));
          const a3 = s2.target;
          ((u3 = r2.triggerRef.current) == null ? void 0 : u3.contains(a3)) && s2.preventDefault(), s2.detail.originalEvent.type === "focusin" && o2.current && s2.preventDefault();
        }
      }
    );
  }
);
var So = f2.forwardRef(
  (e2, t2) => {
    const { __scopeDialog: r2, trapFocus: n2, onOpenAutoFocus: o2, onCloseAutoFocus: s2, ...a3 } = e2, i2 = ae2(De2, r2), d2 = f2.useRef(null), u3 = ve2(t2, d2);
    return _a(), l2.jsxs(l2.Fragment, { children: [
      l2.jsx(
        no,
        {
          asChild: true,
          loop: true,
          trapped: n2,
          onMountAutoFocus: o2,
          onUnmountAutoFocus: s2,
          children: l2.jsx(
            to3,
            {
              role: "dialog",
              id: i2.contentId,
              "aria-describedby": i2.descriptionId,
              "aria-labelledby": i2.titleId,
              "data-state": Cr(i2.open),
              ...a3,
              ref: u3,
              onDismiss: () => i2.onOpenChange(false)
            }
          )
        }
      ),
      l2.jsxs(l2.Fragment, { children: [
        l2.jsx(Sc, { titleId: i2.titleId }),
        l2.jsx(Ac, { contentRef: d2, descriptionId: i2.descriptionId })
      ] })
    ] });
  }
);
var Er = "DialogTitle";
var Ro = f2.forwardRef(
  (e2, t2) => {
    const { __scopeDialog: r2, ...n2 } = e2, o2 = ae2(Er, r2);
    return l2.jsx(fe2.h2, { id: o2.titleId, ...n2, ref: t2 });
  }
);
Ro.displayName = Er;
var Ao = "DialogDescription";
var Io = f2.forwardRef(
  (e2, t2) => {
    const { __scopeDialog: r2, ...n2 } = e2, o2 = ae2(Ao, r2);
    return l2.jsx(fe2.p, { id: o2.descriptionId, ...n2, ref: t2 });
  }
);
Io.displayName = Ao;
var ko = "DialogClose";
var To = f2.forwardRef(
  (e2, t2) => {
    const { __scopeDialog: r2, ...n2 } = e2, o2 = ae2(ko, r2);
    return l2.jsx(
      fe2.button,
      {
        type: "button",
        ...n2,
        ref: t2,
        onClick: be2(e2.onClick, () => o2.onOpenChange(false))
      }
    );
  }
);
To.displayName = ko;
function Cr(e2) {
  return e2 ? "open" : "closed";
}
var No = "DialogTitleWarning";
var [Pc, _o] = aa(No, {
  contentName: De2,
  titleName: Er,
  docsSlug: "dialog"
});
var Sc = ({ titleId: e2 }) => {
  const t2 = _o(No), r2 = `\`${t2.contentName}\` requires a \`${t2.titleName}\` for the component to be accessible for screen reader users.

If you want to hide the \`${t2.titleName}\`, you can wrap it with our VisuallyHidden component.

For more information, see https://radix-ui.com/primitives/docs/components/${t2.docsSlug}`;
  return f2.useEffect(() => {
    e2 && (document.getElementById(e2) || console.error(r2));
  }, [r2, e2]), null;
};
var Rc = "DialogDescriptionWarning";
var Ac = ({ contentRef: e2, descriptionId: t2 }) => {
  const n2 = `Warning: Missing \`Description\` or \`aria-describedby={undefined}\` for {${_o(Rc).contentName}}.`;
  return f2.useEffect(() => {
    var s2;
    const o2 = (s2 = e2.current) == null ? void 0 : s2.getAttribute("aria-describedby");
    t2 && o2 && (document.getElementById(t2) || console.warn(n2));
  }, [n2, e2, t2]), null;
};
var Ic = vo;
var kc = xo;
var Tc = Eo;
var Nc = Co;
var _c = Po;
var Oc = Ro;
var jc = Io;
var Oo = To;
var jo = "AlertDialog";
var [Lc, Ad] = Qn(jo, [
  bo
]);
var ye2 = bo();
var Lo = (e2) => {
  const { __scopeAlertDialog: t2, ...r2 } = e2, n2 = ye2(t2);
  return l2.jsx(Ic, { ...n2, ...r2, modal: true });
};
Lo.displayName = jo;
var Dc = "AlertDialogTrigger";
var Fc = f2.forwardRef(
  (e2, t2) => {
    const { __scopeAlertDialog: r2, ...n2 } = e2, o2 = ye2(r2);
    return l2.jsx(kc, { ...o2, ...n2, ref: t2 });
  }
);
Fc.displayName = Dc;
var Bc = "AlertDialogPortal";
var Do = (e2) => {
  const { __scopeAlertDialog: t2, ...r2 } = e2, n2 = ye2(t2);
  return l2.jsx(Tc, { ...n2, ...r2 });
};
Do.displayName = Bc;
var Mc = "AlertDialogOverlay";
var Fo = f2.forwardRef(
  (e2, t2) => {
    const { __scopeAlertDialog: r2, ...n2 } = e2, o2 = ye2(r2);
    return l2.jsx(Nc, { ...o2, ...n2, ref: t2 });
  }
);
Fo.displayName = Mc;
var qe2 = "AlertDialogContent";
var [Uc, zc] = Lc(qe2);
var Bo = f2.forwardRef(
  (e2, t2) => {
    const { __scopeAlertDialog: r2, children: n2, ...o2 } = e2, s2 = ye2(r2), a3 = f2.useRef(null), i2 = ve2(t2, a3), d2 = f2.useRef(null);
    return l2.jsx(
      Pc,
      {
        contentName: qe2,
        titleName: Mo,
        docsSlug: "alert-dialog",
        children: l2.jsx(Uc, { scope: r2, cancelRef: d2, children: l2.jsxs(
          _c,
          {
            role: "alertdialog",
            ...s2,
            ...o2,
            ref: i2,
            onOpenAutoFocus: be2(o2.onOpenAutoFocus, (u3) => {
              var p2;
              u3.preventDefault(), (p2 = d2.current) == null || p2.focus({ preventScroll: true });
            }),
            onPointerDownOutside: (u3) => u3.preventDefault(),
            onInteractOutside: (u3) => u3.preventDefault(),
            children: [
              l2.jsx(Yn, { children: n2 }),
              l2.jsx(Wc, { contentRef: a3 })
            ]
          }
        ) })
      }
    );
  }
);
Bo.displayName = qe2;
var Mo = "AlertDialogTitle";
var Uo = f2.forwardRef(
  (e2, t2) => {
    const { __scopeAlertDialog: r2, ...n2 } = e2, o2 = ye2(r2);
    return l2.jsx(Oc, { ...o2, ...n2, ref: t2 });
  }
);
Uo.displayName = Mo;
var zo = "AlertDialogDescription";
var $o = f2.forwardRef((e2, t2) => {
  const { __scopeAlertDialog: r2, ...n2 } = e2, o2 = ye2(r2);
  return l2.jsx(jc, { ...o2, ...n2, ref: t2 });
});
$o.displayName = zo;
var $c = "AlertDialogAction";
var Wo = f2.forwardRef(
  (e2, t2) => {
    const { __scopeAlertDialog: r2, ...n2 } = e2, o2 = ye2(r2);
    return l2.jsx(Oo, { ...o2, ...n2, ref: t2 });
  }
);
Wo.displayName = $c;
var Go = "AlertDialogCancel";
var Vo = f2.forwardRef(
  (e2, t2) => {
    const { __scopeAlertDialog: r2, ...n2 } = e2, { cancelRef: o2 } = zc(Go, r2), s2 = ye2(r2), a3 = ve2(t2, o2);
    return l2.jsx(Oo, { ...s2, ...n2, ref: a3 });
  }
);
Vo.displayName = Go;
var Wc = ({ contentRef: e2 }) => {
  const t2 = `\`${qe2}\` requires a description for the component to be accessible for screen reader users.

You can add a description to the \`${qe2}\` by passing a \`${zo}\` component as a child, which also benefits sighted users by adding visible context to the dialog.

Alternatively, you can use your own component as a description by assigning it an \`id\` and passing the same value to the \`aria-describedby\` prop in \`${qe2}\`. If the description is confusing or duplicative for sighted users, you can use the \`@radix-ui/react-visually-hidden\` primitive as a wrapper around your description component.

For more information, see https://radix-ui.com/primitives/docs/components/alert-dialog`;
  return f2.useEffect(() => {
    var n2;
    document.getElementById(
      (n2 = e2.current) == null ? void 0 : n2.getAttribute("aria-describedby")
    ) || console.warn(t2);
  }, [t2, e2]), null;
};
var Gc = Lo;
var Vc = Do;
var Ho = Fo;
var Jo = Bo;
var Ko = Wo;
var Yo = Vo;
var qo = Uo;
var Xo = $o;
var Hc = Gc;
var Jc = Vc;
var Zo = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  Ho,
  {
    className: I2(
      "fixed inset-0 z-50 bg-black/80 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0",
      e2
    ),
    ...t2,
    ref: r2
  }
));
Zo.displayName = Ho.displayName;
var Qo = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsxs(Jc, { children: [
  l2.jsx(Zo, {}),
  l2.jsx(
    Jo,
    {
      ref: r2,
      className: I2(
        "fixed left-[50%] top-[50%] z-50 grid w-full max-w-xs sm:max-w-sm translate-x-[-50%] translate-y-[-50%] gap-4 bg-[#2b2b2b] p-6 shadow-lg duration-200 data-[state=open]:animate-in data-[state=closed]:animate-out data-[state=closed]:fade-out-0 data-[state=open]:fade-in-0 data-[state=closed]:zoom-out-95 data-[state=open]:zoom-in-95 data-[state=closed]:slide-out-to-left-1/2 data-[state=closed]:slide-out-to-top-[48%] data-[state=open]:slide-in-from-left-1/2 data-[state=open]:slide-in-from-top-[48%] sm:rounded-lg text-[#dadada] rounded-lg",
        e2
      ),
      ...t2
    }
  )
] }));
Qo.displayName = Jo.displayName;
var es = ({
  className: e2,
  ...t2
}) => l2.jsx(
  "div",
  {
    className: I2("flex flex-col space-y-2 text-center", e2),
    ...t2
  }
);
es.displayName = "AlertDialogHeader";
var ts = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  qo,
  {
    ref: r2,
    className: I2("text-lg font-semibold", e2),
    ...t2
  }
));
ts.displayName = qo.displayName;
var pr = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  Xo,
  {
    ref: r2,
    className: I2("text-[#808080]", e2),
    ...t2
  }
));
pr.displayName = Xo.displayName;
var Kc = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  Ko,
  {
    ref: r2,
    className: I2(yr(), e2),
    ...t2
  }
));
Kc.displayName = Ko.displayName;
var Yc = f2.forwardRef(({ className: e2, ...t2 }, r2) => l2.jsx(
  Yo,
  {
    ref: r2,
    className: I2(
      yr({ variant: "outline" }),
      "mt-2 sm:mt-0",
      e2
    ),
    ...t2
  }
));
Yc.displayName = Yo.displayName;
var qc = () => l2.jsxs(
  "svg",
  {
    className: "h-8 w-8 animate-spin stroke-[#dadada]",
    viewBox: "0 0 256 256",
    children: [
      l2.jsx(
        "line",
        {
          x1: "128",
          y1: "32",
          x2: "128",
          y2: "64",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "24"
        }
      ),
      l2.jsx(
        "line",
        {
          x1: "195.9",
          y1: "60.1",
          x2: "173.3",
          y2: "82.7",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "24"
        }
      ),
      l2.jsx(
        "line",
        {
          x1: "224",
          y1: "128",
          x2: "192",
          y2: "128",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "24"
        }
      ),
      l2.jsx(
        "line",
        {
          x1: "195.9",
          y1: "195.9",
          x2: "173.3",
          y2: "173.3",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "24"
        }
      ),
      l2.jsx(
        "line",
        {
          x1: "128",
          y1: "224",
          x2: "128",
          y2: "192",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "24"
        }
      ),
      l2.jsx(
        "line",
        {
          x1: "60.1",
          y1: "195.9",
          x2: "82.7",
          y2: "173.3",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "24"
        }
      ),
      l2.jsx(
        "line",
        {
          x1: "32",
          y1: "128",
          x2: "64",
          y2: "128",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "24"
        }
      ),
      l2.jsx(
        "line",
        {
          x1: "60.1",
          y1: "60.1",
          x2: "82.7",
          y2: "82.7",
          strokeLinecap: "round",
          strokeLinejoin: "round",
          strokeWidth: "24"
        }
      )
    ]
  }
);
var Xc = (e2) => l2.jsx(Hc, { open: e2.open, children: l2.jsx(Qo, { children: l2.jsxs(es, { children: [
  l2.jsx(ts, { children: "Sign in with Wallet" }),
  l2.jsx(pr, { children: "This app would like to verify you as the owner of this wallet." }),
  l2.jsx(
    "div",
    {
      "aria-label": "Loading...",
      role: "status",
      className: "flex items-center space-x-2 justify-center",
      children: l2.jsxs("div", { className: "relative z-10 flex w-full cursor-pointer items-center overflow-hidden rounded-xl p-1", children: [
        l2.jsx("div", { className: "animate-rotate absolute inset-0 h-full w-full rounded-full bg-[conic-gradient(#2b8bee_20deg,transparent_120deg)]" }),
        l2.jsxs("div", { className: "relative z-20 flex w-full rounded-[0.60rem] bg-[#2b2b2b] p-4 justify-center items-center gap-4", children: [
          l2.jsx(qc, {}),
          l2.jsx("span", { className: "text-sm sm:text-lg font-medium text[#808080]", children: "Awaiting Confirmation" })
        ] })
      ] })
    }
  ),
  l2.jsx(pr, { children: "Please sign the message request in your wallet to continue." })
] }) }) });
var rs = "2.26.3";
var ct = {
  getDocsUrl: ({ docsBaseUrl: e2, docsPath: t2 = "", docsSlug: r2 }) => t2 ? `${e2 ?? "https://viem.sh"}${t2}${r2 ? `#${r2}` : ""}` : void 0,
  version: `viem@${rs}`
};
var $2 = class _$ extends Error {
  constructor(t2, r2 = {}) {
    var i2;
    const n2 = (() => {
      var d2;
      return r2.cause instanceof _$ ? r2.cause.details : (d2 = r2.cause) != null && d2.message ? r2.cause.message : r2.details;
    })(), o2 = r2.cause instanceof _$ && r2.cause.docsPath || r2.docsPath, s2 = (i2 = ct.getDocsUrl) == null ? void 0 : i2.call(ct, { ...r2, docsPath: o2 }), a3 = [
      t2 || "An error occurred.",
      "",
      ...r2.metaMessages ? [...r2.metaMessages, ""] : [],
      ...s2 ? [`Docs: ${s2}`] : [],
      ...n2 ? [`Details: ${n2}`] : [],
      ...ct.version ? [`Version: ${ct.version}`] : []
    ].join(`
`);
    super(a3, r2.cause ? { cause: r2.cause } : void 0), Object.defineProperty(this, "details", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "docsPath", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "metaMessages", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "shortMessage", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "version", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), Object.defineProperty(this, "name", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: "BaseError"
    }), this.details = n2, this.docsPath = o2, this.metaMessages = r2.metaMessages, this.name = r2.name ?? this.name, this.shortMessage = t2, this.version = rs;
  }
  walk(t2) {
    return ns(this, t2);
  }
};
function ns(e2, t2) {
  return t2 != null && t2(e2) ? e2 : e2 && typeof e2 == "object" && "cause" in e2 && e2.cause !== void 0 ? ns(e2.cause, t2) : t2 ? null : e2;
}
var Zc = class extends $2 {
  constructor({ max: t2, min: r2, signed: n2, size: o2, value: s2 }) {
    super(`Number "${s2}" is not in safe ${o2 ? `${o2 * 8}-bit ${n2 ? "signed" : "unsigned"} ` : ""}integer range ${t2 ? `(${r2} to ${t2})` : `(above ${r2})`}`, { name: "IntegerOutOfRangeError" });
  }
};
var Qc = class extends $2 {
  constructor({ givenSize: t2, maxSize: r2 }) {
    super(`Size cannot exceed ${r2} bytes. Given size: ${t2} bytes.`, { name: "SizeOverflowError" });
  }
};
var el = class extends $2 {
  constructor({ offset: t2, position: r2, size: n2 }) {
    super(`Slice ${r2 === "start" ? "starting" : "ending"} at offset "${t2}" is out-of-bounds (size: ${n2}).`, { name: "SliceOffsetOutOfBoundsError" });
  }
};
var os = class extends $2 {
  constructor({ size: t2, targetSize: r2, type: n2 }) {
    super(`${n2.charAt(0).toUpperCase()}${n2.slice(1).toLowerCase()} size (${t2}) exceeds padding size (${r2}).`, { name: "SizeExceedsPaddingSizeError" });
  }
};
function et(e2, { dir: t2, size: r2 = 32 } = {}) {
  return typeof e2 == "string" ? tl(e2, { dir: t2, size: r2 }) : rl(e2, { dir: t2, size: r2 });
}
function tl(e2, { dir: t2, size: r2 = 32 } = {}) {
  if (r2 === null)
    return e2;
  const n2 = e2.replace("0x", "");
  if (n2.length > r2 * 2)
    throw new os({
      size: Math.ceil(n2.length / 2),
      targetSize: r2,
      type: "hex"
    });
  return `0x${n2[t2 === "right" ? "padEnd" : "padStart"](r2 * 2, "0")}`;
}
function rl(e2, { dir: t2, size: r2 = 32 } = {}) {
  if (r2 === null)
    return e2;
  if (e2.length > r2)
    throw new os({
      size: e2.length,
      targetSize: r2,
      type: "bytes"
    });
  const n2 = new Uint8Array(r2);
  for (let o2 = 0; o2 < r2; o2++) {
    const s2 = t2 === "right";
    n2[s2 ? o2 : r2 - o2 - 1] = e2[s2 ? o2 : e2.length - o2 - 1];
  }
  return n2;
}
function ft(e2, { strict: t2 = true } = {}) {
  return !e2 || typeof e2 != "string" ? false : t2 ? /^0x[0-9a-fA-F]*$/.test(e2) : e2.startsWith("0x");
}
function Xe(e2) {
  return ft(e2, { strict: false }) ? Math.ceil((e2.length - 2) / 2) : e2.length;
}
function kt(e2, { dir: t2 = "left" } = {}) {
  let r2 = typeof e2 == "string" ? e2.replace("0x", "") : e2, n2 = 0;
  for (let o2 = 0; o2 < r2.length - 1 && r2[t2 === "left" ? o2 : r2.length - o2 - 1].toString() === "0"; o2++)
    n2++;
  return r2 = t2 === "left" ? r2.slice(n2) : r2.slice(0, r2.length - n2), typeof e2 == "string" ? (r2.length === 1 && t2 === "right" && (r2 = `${r2}0`), `0x${r2.length % 2 === 1 ? `0${r2}` : r2}`) : r2;
}
var nl = new TextEncoder();
function ss(e2, t2 = {}) {
  return typeof e2 == "number" || typeof e2 == "bigint" ? sl(e2, t2) : typeof e2 == "boolean" ? ol(e2, t2) : ft(e2) ? Fe2(e2, t2) : is(e2, t2);
}
function ol(e2, t2 = {}) {
  const r2 = new Uint8Array(1);
  return r2[0] = Number(e2), typeof t2.size == "number" ? (tt(r2, { size: t2.size }), et(r2, { size: t2.size })) : r2;
}
var ge2 = {
  zero: 48,
  nine: 57,
  A: 65,
  F: 70,
  a: 97,
  f: 102
};
function gn(e2) {
  if (e2 >= ge2.zero && e2 <= ge2.nine)
    return e2 - ge2.zero;
  if (e2 >= ge2.A && e2 <= ge2.F)
    return e2 - (ge2.A - 10);
  if (e2 >= ge2.a && e2 <= ge2.f)
    return e2 - (ge2.a - 10);
}
function Fe2(e2, t2 = {}) {
  let r2 = e2;
  t2.size && (tt(r2, { size: t2.size }), r2 = et(r2, { dir: "right", size: t2.size }));
  let n2 = r2.slice(2);
  n2.length % 2 && (n2 = `0${n2}`);
  const o2 = n2.length / 2, s2 = new Uint8Array(o2);
  for (let a3 = 0, i2 = 0; a3 < o2; a3++) {
    const d2 = gn(n2.charCodeAt(i2++)), u3 = gn(n2.charCodeAt(i2++));
    if (d2 === void 0 || u3 === void 0)
      throw new $2(`Invalid byte sequence ("${n2[i2 - 2]}${n2[i2 - 1]}" in "${n2}").`);
    s2[a3] = d2 * 16 + u3;
  }
  return s2;
}
function sl(e2, t2) {
  const r2 = as(e2, t2);
  return Fe2(r2);
}
function is(e2, t2 = {}) {
  const r2 = nl.encode(e2);
  return typeof t2.size == "number" ? (tt(r2, { size: t2.size }), et(r2, { dir: "right", size: t2.size })) : r2;
}
function tt(e2, { size: t2 }) {
  if (Xe(e2) > t2)
    throw new Qc({
      givenSize: Xe(e2),
      maxSize: t2
    });
}
function Je(e2, t2 = {}) {
  const { signed: r2 } = t2;
  t2.size && tt(e2, { size: t2.size });
  const n2 = BigInt(e2);
  if (!r2)
    return n2;
  const o2 = (e2.length - 2) / 2, s2 = (1n << BigInt(o2) * 8n - 1n) - 1n;
  return n2 <= s2 ? n2 : n2 - BigInt(`0x${"f".padStart(o2 * 2, "f")}`) - 1n;
}
function Tt(e2, t2 = {}) {
  return Number(Je(e2, t2));
}
var il = Array.from({ length: 256 }, (e2, t2) => t2.toString(16).padStart(2, "0"));
function T3(e2, t2 = {}) {
  return typeof e2 == "number" || typeof e2 == "bigint" ? as(e2, t2) : typeof e2 == "string" ? ll(e2, t2) : typeof e2 == "boolean" ? al(e2, t2) : ke2(e2, t2);
}
function al(e2, t2 = {}) {
  const r2 = `0x${Number(e2)}`;
  return typeof t2.size == "number" ? (tt(r2, { size: t2.size }), et(r2, { size: t2.size })) : r2;
}
function ke2(e2, t2 = {}) {
  let r2 = "";
  for (let o2 = 0; o2 < e2.length; o2++)
    r2 += il[e2[o2]];
  const n2 = `0x${r2}`;
  return typeof t2.size == "number" ? (tt(n2, { size: t2.size }), et(n2, { dir: "right", size: t2.size })) : n2;
}
function as(e2, t2 = {}) {
  const { signed: r2, size: n2 } = t2, o2 = BigInt(e2);
  let s2;
  n2 ? r2 ? s2 = (1n << BigInt(n2) * 8n - 1n) - 1n : s2 = 2n ** (BigInt(n2) * 8n) - 1n : typeof e2 == "number" && (s2 = BigInt(Number.MAX_SAFE_INTEGER));
  const a3 = typeof s2 == "bigint" && r2 ? -s2 - 1n : 0;
  if (s2 && o2 > s2 || o2 < a3) {
    const d2 = typeof e2 == "bigint" ? "n" : "";
    throw new Zc({
      max: s2 ? `${s2}${d2}` : void 0,
      min: `${a3}${d2}`,
      signed: r2,
      size: n2,
      value: `${e2}${d2}`
    });
  }
  const i2 = `0x${(r2 && o2 < 0 ? (1n << BigInt(n2 * 8)) + BigInt(o2) : o2).toString(16)}`;
  return n2 ? et(i2, { size: n2 }) : i2;
}
var cl = new TextEncoder();
function ll(e2, t2 = {}) {
  const r2 = cl.encode(e2);
  return ke2(r2, t2);
}
function ht(e2) {
  return `0x${e2.reduce((t2, r2) => t2 + r2.replace("0x", ""), "")}`;
}
var Be2 = class extends $2 {
  constructor({ address: t2 }) {
    super(`Address "${t2}" is invalid.`, {
      metaMessages: [
        "- Address must be a hex value of 20 bytes (40 hex characters).",
        "- Address must match its checksum counterpart."
      ],
      name: "InvalidAddressError"
    });
  }
};
var cs = class extends Map {
  constructor(t2) {
    super(), Object.defineProperty(this, "maxSize", {
      enumerable: true,
      configurable: true,
      writable: true,
      value: void 0
    }), this.maxSize = t2;
  }
  get(t2) {
    const r2 = super.get(t2);
    return super.has(t2) && r2 !== void 0 && (this.delete(t2), super.set(t2, r2)), r2;
  }
  set(t2, r2) {
    if (super.set(t2, r2), this.maxSize && this.size > this.maxSize) {
      const n2 = this.keys().next().value;
      n2 && this.delete(n2);
    }
    return this;
  }
};
function bn(e2) {
  if (!Number.isSafeInteger(e2) || e2 < 0)
    throw new Error("positive integer expected, got " + e2);
}
function ul(e2) {
  return e2 instanceof Uint8Array || ArrayBuffer.isView(e2) && e2.constructor.name === "Uint8Array";
}
function Pr(e2, ...t2) {
  if (!ul(e2))
    throw new Error("Uint8Array expected");
  if (t2.length > 0 && !t2.includes(e2.length))
    throw new Error("Uint8Array expected of length " + t2 + ", got length=" + e2.length);
}
function Nt(e2, t2 = true) {
  if (e2.destroyed)
    throw new Error("Hash instance has been destroyed");
  if (t2 && e2.finished)
    throw new Error("Hash#digest() has already been called");
}
function ls(e2, t2) {
  Pr(e2);
  const r2 = t2.outputLen;
  if (e2.length < r2)
    throw new Error("digestInto() expects output buffer of length at least " + r2);
}
var Pt = BigInt(2 ** 32 - 1);
var vn = BigInt(32);
function dl(e2, t2 = false) {
  return t2 ? { h: Number(e2 & Pt), l: Number(e2 >> vn & Pt) } : { h: Number(e2 >> vn & Pt) | 0, l: Number(e2 & Pt) | 0 };
}
function fl(e2, t2 = false) {
  let r2 = new Uint32Array(e2.length), n2 = new Uint32Array(e2.length);
  for (let o2 = 0; o2 < e2.length; o2++) {
    const { h: s2, l: a3 } = dl(e2[o2], t2);
    [r2[o2], n2[o2]] = [s2, a3];
  }
  return [r2, n2];
}
var hl = (e2, t2, r2) => e2 << r2 | t2 >>> 32 - r2;
var pl = (e2, t2, r2) => t2 << r2 | e2 >>> 32 - r2;
var ml = (e2, t2, r2) => t2 << r2 - 32 | e2 >>> 64 - r2;
var gl = (e2, t2, r2) => e2 << r2 - 32 | t2 >>> 64 - r2;
function bl(e2) {
  return new Uint32Array(e2.buffer, e2.byteOffset, Math.floor(e2.byteLength / 4));
}
function tr(e2) {
  return new DataView(e2.buffer, e2.byteOffset, e2.byteLength);
}
function ue2(e2, t2) {
  return e2 << 32 - t2 | e2 >>> t2;
}
var yn = new Uint8Array(new Uint32Array([287454020]).buffer)[0] === 68;
function vl(e2) {
  return e2 << 24 & 4278190080 | e2 << 8 & 16711680 | e2 >>> 8 & 65280 | e2 >>> 24 & 255;
}
function xn(e2) {
  for (let t2 = 0; t2 < e2.length; t2++)
    e2[t2] = vl(e2[t2]);
}
function yl(e2) {
  if (typeof e2 != "string")
    throw new Error("utf8ToBytes expected string, got " + typeof e2);
  return new Uint8Array(new TextEncoder().encode(e2));
}
function Sr(e2) {
  return typeof e2 == "string" && (e2 = yl(e2)), Pr(e2), e2;
}
var us = class {
  // Safe version that clones internal state
  clone() {
    return this._cloneInto();
  }
};
function ds(e2) {
  const t2 = (n2) => e2().update(Sr(n2)).digest(), r2 = e2();
  return t2.outputLen = r2.outputLen, t2.blockLen = r2.blockLen, t2.create = () => e2(), t2;
}
var fs = [];
var hs = [];
var ps = [];
var xl = BigInt(0);
var lt = BigInt(1);
var wl = BigInt(2);
var El = BigInt(7);
var Cl = BigInt(256);
var Pl = BigInt(113);
for (let e2 = 0, t2 = lt, r2 = 1, n2 = 0; e2 < 24; e2++) {
  [r2, n2] = [n2, (2 * r2 + 3 * n2) % 5], fs.push(2 * (5 * n2 + r2)), hs.push((e2 + 1) * (e2 + 2) / 2 % 64);
  let o2 = xl;
  for (let s2 = 0; s2 < 7; s2++)
    t2 = (t2 << lt ^ (t2 >> El) * Pl) % Cl, t2 & wl && (o2 ^= lt << (lt << BigInt(s2)) - lt);
  ps.push(o2);
}
var [Sl, Rl] = fl(ps, true);
var wn = (e2, t2, r2) => r2 > 32 ? ml(e2, t2, r2) : hl(e2, t2, r2);
var En = (e2, t2, r2) => r2 > 32 ? gl(e2, t2, r2) : pl(e2, t2, r2);
function Al(e2, t2 = 24) {
  const r2 = new Uint32Array(10);
  for (let n2 = 24 - t2; n2 < 24; n2++) {
    for (let a3 = 0; a3 < 10; a3++)
      r2[a3] = e2[a3] ^ e2[a3 + 10] ^ e2[a3 + 20] ^ e2[a3 + 30] ^ e2[a3 + 40];
    for (let a3 = 0; a3 < 10; a3 += 2) {
      const i2 = (a3 + 8) % 10, d2 = (a3 + 2) % 10, u3 = r2[d2], p2 = r2[d2 + 1], m3 = wn(u3, p2, 1) ^ r2[i2], g3 = En(u3, p2, 1) ^ r2[i2 + 1];
      for (let b4 = 0; b4 < 50; b4 += 10)
        e2[a3 + b4] ^= m3, e2[a3 + b4 + 1] ^= g3;
    }
    let o2 = e2[2], s2 = e2[3];
    for (let a3 = 0; a3 < 24; a3++) {
      const i2 = hs[a3], d2 = wn(o2, s2, i2), u3 = En(o2, s2, i2), p2 = fs[a3];
      o2 = e2[p2], s2 = e2[p2 + 1], e2[p2] = d2, e2[p2 + 1] = u3;
    }
    for (let a3 = 0; a3 < 50; a3 += 10) {
      for (let i2 = 0; i2 < 10; i2++)
        r2[i2] = e2[a3 + i2];
      for (let i2 = 0; i2 < 10; i2++)
        e2[a3 + i2] ^= ~r2[(i2 + 2) % 10] & r2[(i2 + 4) % 10];
    }
    e2[0] ^= Sl[n2], e2[1] ^= Rl[n2];
  }
  r2.fill(0);
}
var Rr = class _Rr extends us {
  // NOTE: we accept arguments in bytes instead of bits here.
  constructor(t2, r2, n2, o2 = false, s2 = 24) {
    if (super(), this.blockLen = t2, this.suffix = r2, this.outputLen = n2, this.enableXOF = o2, this.rounds = s2, this.pos = 0, this.posOut = 0, this.finished = false, this.destroyed = false, bn(n2), 0 >= this.blockLen || this.blockLen >= 200)
      throw new Error("Sha3 supports only keccak-f1600 function");
    this.state = new Uint8Array(200), this.state32 = bl(this.state);
  }
  keccak() {
    yn || xn(this.state32), Al(this.state32, this.rounds), yn || xn(this.state32), this.posOut = 0, this.pos = 0;
  }
  update(t2) {
    Nt(this);
    const { blockLen: r2, state: n2 } = this;
    t2 = Sr(t2);
    const o2 = t2.length;
    for (let s2 = 0; s2 < o2; ) {
      const a3 = Math.min(r2 - this.pos, o2 - s2);
      for (let i2 = 0; i2 < a3; i2++)
        n2[this.pos++] ^= t2[s2++];
      this.pos === r2 && this.keccak();
    }
    return this;
  }
  finish() {
    if (this.finished)
      return;
    this.finished = true;
    const { state: t2, suffix: r2, pos: n2, blockLen: o2 } = this;
    t2[n2] ^= r2, r2 & 128 && n2 === o2 - 1 && this.keccak(), t2[o2 - 1] ^= 128, this.keccak();
  }
  writeInto(t2) {
    Nt(this, false), Pr(t2), this.finish();
    const r2 = this.state, { blockLen: n2 } = this;
    for (let o2 = 0, s2 = t2.length; o2 < s2; ) {
      this.posOut >= n2 && this.keccak();
      const a3 = Math.min(n2 - this.posOut, s2 - o2);
      t2.set(r2.subarray(this.posOut, this.posOut + a3), o2), this.posOut += a3, o2 += a3;
    }
    return t2;
  }
  xofInto(t2) {
    if (!this.enableXOF)
      throw new Error("XOF is not possible for this instance");
    return this.writeInto(t2);
  }
  xof(t2) {
    return bn(t2), this.xofInto(new Uint8Array(t2));
  }
  digestInto(t2) {
    if (ls(t2, this), this.finished)
      throw new Error("digest() was already called");
    return this.writeInto(t2), this.destroy(), t2;
  }
  digest() {
    return this.digestInto(new Uint8Array(this.outputLen));
  }
  destroy() {
    this.destroyed = true, this.state.fill(0);
  }
  _cloneInto(t2) {
    const { blockLen: r2, suffix: n2, outputLen: o2, rounds: s2, enableXOF: a3 } = this;
    return t2 || (t2 = new _Rr(r2, n2, o2, a3, s2)), t2.state32.set(this.state32), t2.pos = this.pos, t2.posOut = this.posOut, t2.finished = this.finished, t2.rounds = s2, t2.suffix = n2, t2.outputLen = o2, t2.enableXOF = a3, t2.destroyed = this.destroyed, t2;
  }
};
var Il = (e2, t2, r2) => ds(() => new Rr(t2, e2, r2));
var kl = Il(1, 136, 256 / 8);
function Tl(e2, t2) {
  return kl(ft(e2, { strict: false }) ? ss(e2) : e2);
}
var rr = new cs(8192);
function Nl(e2, t2) {
  if (rr.has(`${e2}.${t2}`))
    return rr.get(`${e2}.${t2}`);
  const r2 = e2.substring(2).toLowerCase(), n2 = Tl(is(r2)), o2 = r2.split("");
  for (let a3 = 0; a3 < 40; a3 += 2)
    n2[a3 >> 1] >> 4 >= 8 && o2[a3] && (o2[a3] = o2[a3].toUpperCase()), (n2[a3 >> 1] & 15) >= 8 && o2[a3 + 1] && (o2[a3 + 1] = o2[a3 + 1].toUpperCase());
  const s2 = `0x${o2.join("")}`;
  return rr.set(`${e2}.${t2}`, s2), s2;
}
var _l = /^0x[a-fA-F0-9]{40}$/;
var nr = new cs(8192);
function Me2(e2, t2) {
  const { strict: r2 = true } = t2 ?? {}, n2 = `${e2}.${r2}`;
  if (nr.has(n2))
    return nr.get(n2);
  const o2 = _l.test(e2) ? e2.toLowerCase() === e2 ? true : r2 ? Nl(e2) === e2 : true : false;
  return nr.set(n2, o2), o2;
}
function Ol(e2, t2, r2, { strict: n2 } = {}) {
  return ft(e2, { strict: false }) ? Ll(e2, t2, r2, {
    strict: n2
  }) : jl(e2, t2, r2, {
    strict: n2
  });
}
function ms(e2, t2, r2) {
  if (Xe(e2) !== r2 - t2)
    throw new el({
      offset: r2,
      position: "end",
      size: Xe(e2)
    });
}
function jl(e2, t2, r2, { strict: n2 } = {}) {
  const o2 = e2.slice(t2, r2);
  return n2 && ms(o2, t2, r2), o2;
}
function Ll(e2, t2, r2, { strict: n2 } = {}) {
  const o2 = `0x${e2.replace("0x", "").slice(t2 * 2, r2 * 2)}`;
  return n2 && ms(o2, t2, r2), o2;
}
var Cn = class extends $2 {
  constructor({ offset: t2 }) {
    super(`Offset \`${t2}\` cannot be negative.`, {
      name: "NegativeOffsetError"
    });
  }
};
var Dl = class extends $2 {
  constructor({ length: t2, position: r2 }) {
    super(`Position \`${r2}\` is out of bounds (\`0 < position < ${t2}\`).`, { name: "PositionOutOfBoundsError" });
  }
};
var Fl = class extends $2 {
  constructor({ count: t2, limit: r2 }) {
    super(`Recursive read limit of \`${r2}\` exceeded (recursive read count: \`${t2}\`).`, { name: "RecursiveReadLimitExceededError" });
  }
};
var Bl = {
  bytes: new Uint8Array(),
  dataView: new DataView(new ArrayBuffer(0)),
  position: 0,
  positionReadCount: /* @__PURE__ */ new Map(),
  recursiveReadCount: 0,
  recursiveReadLimit: Number.POSITIVE_INFINITY,
  assertReadLimit() {
    if (this.recursiveReadCount >= this.recursiveReadLimit)
      throw new Fl({
        count: this.recursiveReadCount + 1,
        limit: this.recursiveReadLimit
      });
  },
  assertPosition(e2) {
    if (e2 < 0 || e2 > this.bytes.length - 1)
      throw new Dl({
        length: this.bytes.length,
        position: e2
      });
  },
  decrementPosition(e2) {
    if (e2 < 0)
      throw new Cn({ offset: e2 });
    const t2 = this.position - e2;
    this.assertPosition(t2), this.position = t2;
  },
  getReadCount(e2) {
    return this.positionReadCount.get(e2 || this.position) || 0;
  },
  incrementPosition(e2) {
    if (e2 < 0)
      throw new Cn({ offset: e2 });
    const t2 = this.position + e2;
    this.assertPosition(t2), this.position = t2;
  },
  inspectByte(e2) {
    const t2 = e2 ?? this.position;
    return this.assertPosition(t2), this.bytes[t2];
  },
  inspectBytes(e2, t2) {
    const r2 = t2 ?? this.position;
    return this.assertPosition(r2 + e2 - 1), this.bytes.subarray(r2, r2 + e2);
  },
  inspectUint8(e2) {
    const t2 = e2 ?? this.position;
    return this.assertPosition(t2), this.bytes[t2];
  },
  inspectUint16(e2) {
    const t2 = e2 ?? this.position;
    return this.assertPosition(t2 + 1), this.dataView.getUint16(t2);
  },
  inspectUint24(e2) {
    const t2 = e2 ?? this.position;
    return this.assertPosition(t2 + 2), (this.dataView.getUint16(t2) << 8) + this.dataView.getUint8(t2 + 2);
  },
  inspectUint32(e2) {
    const t2 = e2 ?? this.position;
    return this.assertPosition(t2 + 3), this.dataView.getUint32(t2);
  },
  pushByte(e2) {
    this.assertPosition(this.position), this.bytes[this.position] = e2, this.position++;
  },
  pushBytes(e2) {
    this.assertPosition(this.position + e2.length - 1), this.bytes.set(e2, this.position), this.position += e2.length;
  },
  pushUint8(e2) {
    this.assertPosition(this.position), this.bytes[this.position] = e2, this.position++;
  },
  pushUint16(e2) {
    this.assertPosition(this.position + 1), this.dataView.setUint16(this.position, e2), this.position += 2;
  },
  pushUint24(e2) {
    this.assertPosition(this.position + 2), this.dataView.setUint16(this.position, e2 >> 8), this.dataView.setUint8(this.position + 2, e2 & 255), this.position += 3;
  },
  pushUint32(e2) {
    this.assertPosition(this.position + 3), this.dataView.setUint32(this.position, e2), this.position += 4;
  },
  readByte() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectByte();
    return this.position++, e2;
  },
  readBytes(e2, t2) {
    this.assertReadLimit(), this._touch();
    const r2 = this.inspectBytes(e2);
    return this.position += t2 ?? e2, r2;
  },
  readUint8() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectUint8();
    return this.position += 1, e2;
  },
  readUint16() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectUint16();
    return this.position += 2, e2;
  },
  readUint24() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectUint24();
    return this.position += 3, e2;
  },
  readUint32() {
    this.assertReadLimit(), this._touch();
    const e2 = this.inspectUint32();
    return this.position += 4, e2;
  },
  get remaining() {
    return this.bytes.length - this.position;
  },
  setPosition(e2) {
    const t2 = this.position;
    return this.assertPosition(e2), this.position = e2, () => this.position = t2;
  },
  _touch() {
    if (this.recursiveReadLimit === Number.POSITIVE_INFINITY)
      return;
    const e2 = this.getReadCount();
    this.positionReadCount.set(this.position, e2 + 1), e2 > 0 && this.recursiveReadCount++;
  }
};
function gs(e2, { recursiveReadLimit: t2 = 8192 } = {}) {
  const r2 = Object.create(Bl);
  return r2.bytes = e2, r2.dataView = new DataView(e2.buffer, e2.byteOffset, e2.byteLength), r2.positionReadCount = /* @__PURE__ */ new Map(), r2.recursiveReadLimit = t2, r2;
}
function Ue2(e2, t2 = "hex") {
  const r2 = bs(e2), n2 = gs(new Uint8Array(r2.length));
  return r2.encode(n2), t2 === "hex" ? ke2(n2.bytes) : n2.bytes;
}
function bs(e2) {
  return Array.isArray(e2) ? Ml(e2.map((t2) => bs(t2))) : Ul(e2);
}
function Ml(e2) {
  const t2 = e2.reduce((o2, s2) => o2 + s2.length, 0), r2 = vs(t2);
  return {
    length: t2 <= 55 ? 1 + t2 : 1 + r2 + t2,
    encode(o2) {
      t2 <= 55 ? o2.pushByte(192 + t2) : (o2.pushByte(247 + r2), r2 === 1 ? o2.pushUint8(t2) : r2 === 2 ? o2.pushUint16(t2) : r2 === 3 ? o2.pushUint24(t2) : o2.pushUint32(t2));
      for (const { encode: s2 } of e2)
        s2(o2);
    }
  };
}
function Ul(e2) {
  const t2 = typeof e2 == "string" ? Fe2(e2) : e2, r2 = vs(t2.length);
  return {
    length: t2.length === 1 && t2[0] < 128 ? 1 : t2.length <= 55 ? 1 + t2.length : 1 + r2 + t2.length,
    encode(o2) {
      t2.length === 1 && t2[0] < 128 ? o2.pushBytes(t2) : t2.length <= 55 ? (o2.pushByte(128 + t2.length), o2.pushBytes(t2)) : (o2.pushByte(183 + r2), r2 === 1 ? o2.pushUint8(t2.length) : r2 === 2 ? o2.pushUint16(t2.length) : r2 === 3 ? o2.pushUint24(t2.length) : o2.pushUint32(t2.length), o2.pushBytes(t2));
    }
  };
}
function vs(e2) {
  if (e2 < 2 ** 8)
    return 1;
  if (e2 < 2 ** 16)
    return 2;
  if (e2 < 2 ** 24)
    return 3;
  if (e2 < 2 ** 32)
    return 4;
  throw new $2("Length is too large.");
}
var Dt = class extends $2 {
  constructor({ chainId: t2 }) {
    super(typeof t2 == "number" ? `Chain ID "${t2}" is invalid.` : "Chain ID is invalid.", { name: "InvalidChainIdError" });
  }
};
var zl = {
  ether: -9,
  wei: 9
};
function $l(e2, t2) {
  let r2 = e2.toString();
  const n2 = r2.startsWith("-");
  n2 && (r2 = r2.slice(1)), r2 = r2.padStart(t2, "0");
  let [o2, s2] = [
    r2.slice(0, r2.length - t2),
    r2.slice(r2.length - t2)
  ];
  return s2 = s2.replace(/(0+)$/, ""), `${n2 ? "-" : ""}${o2 || "0"}${s2 ? `.${s2}` : ""}`;
}
function mr(e2, t2 = "wei") {
  return $l(e2, zl[t2]);
}
var Ft = class extends $2 {
  constructor({ cause: t2, maxFeePerGas: r2 } = {}) {
    super(`The fee cap (\`maxFeePerGas\`${r2 ? ` = ${mr(r2)} gwei` : ""}) cannot be higher than the maximum allowed value (2^256-1).`, {
      cause: t2,
      name: "FeeCapTooHighError"
    });
  }
};
Object.defineProperty(Ft, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max fee per gas higher than 2\^256-1|fee cap higher than 2\^256-1/
});
var ys = class extends $2 {
  constructor({ cause: t2, maxPriorityFeePerGas: r2, maxFeePerGas: n2 } = {}) {
    super([
      `The provided tip (\`maxPriorityFeePerGas\`${r2 ? ` = ${mr(r2)} gwei` : ""}) cannot be higher than the fee cap (\`maxFeePerGas\`${n2 ? ` = ${mr(n2)} gwei` : ""}).`
    ].join(`
`), {
      cause: t2,
      name: "TipAboveFeeCapError"
    });
  }
};
Object.defineProperty(ys, "nodeMessage", {
  enumerable: true,
  configurable: true,
  writable: true,
  value: /max priority fee per gas higher than max fee per gas|tip higher than fee cap/
});
function Wl(e2) {
  const t2 = Object.entries(e2).map(([n2, o2]) => o2 === void 0 || o2 === false ? null : [n2, o2]).filter(Boolean), r2 = t2.reduce((n2, [o2]) => Math.max(n2, o2.length), 0);
  return t2.map(([n2, o2]) => `  ${`${n2}:`.padEnd(r2 + 1)}  ${o2}`).join(`
`);
}
var Gl = class extends $2 {
  constructor({ v: t2 }) {
    super(`Invalid \`v\` value "${t2}". Expected 27 or 28.`, {
      name: "InvalidLegacyVError"
    });
  }
};
var Vl = class extends $2 {
  constructor({ transaction: t2 }) {
    super("Cannot infer a transaction type from provided transaction.", {
      metaMessages: [
        "Provided Transaction:",
        "{",
        Wl(t2),
        "}",
        "",
        "To infer the type, either provide:",
        "- a `type` to the Transaction, or",
        "- an EIP-1559 Transaction with `maxFeePerGas`, or",
        "- an EIP-2930 Transaction with `gasPrice` & `accessList`, or",
        "- an EIP-4844 Transaction with `blobs`, `blobVersionedHashes`, `sidecars`, or",
        "- an EIP-7702 Transaction with `authorizationList`, or",
        "- a Legacy Transaction with `gasPrice`"
      ],
      name: "InvalidSerializableTransactionError"
    });
  }
};
var Hl = class extends $2 {
  constructor({ storageKey: t2 }) {
    super(`Size for storage key "${t2}" is invalid. Expected 32 bytes. Got ${Math.floor((t2.length - 2) / 2)} bytes.`, { name: "InvalidStorageKeySizeError" });
  }
};
function Ar(e2, t2) {
  return ({ exclude: r2, format: n2 }) => ({
    exclude: r2,
    format: (o2) => {
      const s2 = t2(o2);
      if (r2)
        for (const a3 of r2)
          delete s2[a3];
      return {
        ...s2,
        ...n2(o2)
      };
    },
    type: e2
  });
}
var Ir = 2n ** 256n - 1n;
var xs = {
  "0x0": "legacy",
  "0x1": "eip2930",
  "0x2": "eip1559",
  "0x3": "eip4844",
  "0x4": "eip7702"
};
function kr(e2) {
  const t2 = {
    ...e2,
    blockHash: e2.blockHash ? e2.blockHash : null,
    blockNumber: e2.blockNumber ? BigInt(e2.blockNumber) : null,
    chainId: e2.chainId ? Tt(e2.chainId) : void 0,
    gas: e2.gas ? BigInt(e2.gas) : void 0,
    gasPrice: e2.gasPrice ? BigInt(e2.gasPrice) : void 0,
    maxFeePerBlobGas: e2.maxFeePerBlobGas ? BigInt(e2.maxFeePerBlobGas) : void 0,
    maxFeePerGas: e2.maxFeePerGas ? BigInt(e2.maxFeePerGas) : void 0,
    maxPriorityFeePerGas: e2.maxPriorityFeePerGas ? BigInt(e2.maxPriorityFeePerGas) : void 0,
    nonce: e2.nonce ? Tt(e2.nonce) : void 0,
    to: e2.to ? e2.to : null,
    transactionIndex: e2.transactionIndex ? Number(e2.transactionIndex) : null,
    type: e2.type ? xs[e2.type] : void 0,
    typeHex: e2.type ? e2.type : void 0,
    value: e2.value ? BigInt(e2.value) : void 0,
    v: e2.v ? BigInt(e2.v) : void 0
  };
  return e2.authorizationList && (t2.authorizationList = Kl2(e2.authorizationList)), t2.yParity = (() => {
    if (e2.yParity)
      return Number(e2.yParity);
    if (typeof t2.v == "bigint") {
      if (t2.v === 0n || t2.v === 27n)
        return 0;
      if (t2.v === 1n || t2.v === 28n)
        return 1;
      if (t2.v >= 35n)
        return t2.v % 2n === 0n ? 1 : 0;
    }
  })(), t2.type === "legacy" && (delete t2.accessList, delete t2.maxFeePerBlobGas, delete t2.maxFeePerGas, delete t2.maxPriorityFeePerGas, delete t2.yParity), t2.type === "eip2930" && (delete t2.maxFeePerBlobGas, delete t2.maxFeePerGas, delete t2.maxPriorityFeePerGas), t2.type === "eip1559" && delete t2.maxFeePerBlobGas, t2;
}
var Jl = Ar("transaction", kr);
function Kl2(e2) {
  return e2.map((t2) => ({
    address: t2.address,
    chainId: Number(t2.chainId),
    nonce: Number(t2.nonce),
    r: t2.r,
    s: t2.s,
    yParity: Number(t2.yParity)
  }));
}
function Yl(e2) {
  const t2 = (e2.transactions ?? []).map((r2) => typeof r2 == "string" ? r2 : kr(r2));
  return {
    ...e2,
    baseFeePerGas: e2.baseFeePerGas ? BigInt(e2.baseFeePerGas) : null,
    blobGasUsed: e2.blobGasUsed ? BigInt(e2.blobGasUsed) : void 0,
    difficulty: e2.difficulty ? BigInt(e2.difficulty) : void 0,
    excessBlobGas: e2.excessBlobGas ? BigInt(e2.excessBlobGas) : void 0,
    gasLimit: e2.gasLimit ? BigInt(e2.gasLimit) : void 0,
    gasUsed: e2.gasUsed ? BigInt(e2.gasUsed) : void 0,
    hash: e2.hash ? e2.hash : null,
    logsBloom: e2.logsBloom ? e2.logsBloom : null,
    nonce: e2.nonce ? e2.nonce : null,
    number: e2.number ? BigInt(e2.number) : null,
    size: e2.size ? BigInt(e2.size) : void 0,
    timestamp: e2.timestamp ? BigInt(e2.timestamp) : void 0,
    transactions: t2,
    totalDifficulty: e2.totalDifficulty ? BigInt(e2.totalDifficulty) : null
  };
}
var ql = Ar("block", Yl);
function ws(e2) {
  const { kzg: t2 } = e2, r2 = e2.to ?? (typeof e2.blobs[0] == "string" ? "hex" : "bytes"), n2 = typeof e2.blobs[0] == "string" ? e2.blobs.map((s2) => Fe2(s2)) : e2.blobs, o2 = [];
  for (const s2 of n2)
    o2.push(Uint8Array.from(t2.blobToKzgCommitment(s2)));
  return r2 === "bytes" ? o2 : o2.map((s2) => ke2(s2));
}
function Es(e2) {
  const { kzg: t2 } = e2, r2 = e2.to ?? (typeof e2.blobs[0] == "string" ? "hex" : "bytes"), n2 = typeof e2.blobs[0] == "string" ? e2.blobs.map((a3) => Fe2(a3)) : e2.blobs, o2 = typeof e2.commitments[0] == "string" ? e2.commitments.map((a3) => Fe2(a3)) : e2.commitments, s2 = [];
  for (let a3 = 0; a3 < n2.length; a3++) {
    const i2 = n2[a3], d2 = o2[a3];
    s2.push(Uint8Array.from(t2.computeBlobKzgProof(i2, d2)));
  }
  return r2 === "bytes" ? s2 : s2.map((a3) => ke2(a3));
}
function Xl(e2, t2, r2, n2) {
  if (typeof e2.setBigUint64 == "function")
    return e2.setBigUint64(t2, r2, n2);
  const o2 = BigInt(32), s2 = BigInt(4294967295), a3 = Number(r2 >> o2 & s2), i2 = Number(r2 & s2), d2 = n2 ? 4 : 0, u3 = n2 ? 0 : 4;
  e2.setUint32(t2 + d2, a3, n2), e2.setUint32(t2 + u3, i2, n2);
}
function Zl(e2, t2, r2) {
  return e2 & t2 ^ ~e2 & r2;
}
function Ql(e2, t2, r2) {
  return e2 & t2 ^ e2 & r2 ^ t2 & r2;
}
var eu = class extends us {
  constructor(t2, r2, n2, o2) {
    super(), this.blockLen = t2, this.outputLen = r2, this.padOffset = n2, this.isLE = o2, this.finished = false, this.length = 0, this.pos = 0, this.destroyed = false, this.buffer = new Uint8Array(t2), this.view = tr(this.buffer);
  }
  update(t2) {
    Nt(this);
    const { view: r2, buffer: n2, blockLen: o2 } = this;
    t2 = Sr(t2);
    const s2 = t2.length;
    for (let a3 = 0; a3 < s2; ) {
      const i2 = Math.min(o2 - this.pos, s2 - a3);
      if (i2 === o2) {
        const d2 = tr(t2);
        for (; o2 <= s2 - a3; a3 += o2)
          this.process(d2, a3);
        continue;
      }
      n2.set(t2.subarray(a3, a3 + i2), this.pos), this.pos += i2, a3 += i2, this.pos === o2 && (this.process(r2, 0), this.pos = 0);
    }
    return this.length += t2.length, this.roundClean(), this;
  }
  digestInto(t2) {
    Nt(this), ls(t2, this), this.finished = true;
    const { buffer: r2, view: n2, blockLen: o2, isLE: s2 } = this;
    let { pos: a3 } = this;
    r2[a3++] = 128, this.buffer.subarray(a3).fill(0), this.padOffset > o2 - a3 && (this.process(n2, 0), a3 = 0);
    for (let m3 = a3; m3 < o2; m3++)
      r2[m3] = 0;
    Xl(n2, o2 - 8, BigInt(this.length * 8), s2), this.process(n2, 0);
    const i2 = tr(t2), d2 = this.outputLen;
    if (d2 % 4)
      throw new Error("_sha2: outputLen should be aligned to 32bit");
    const u3 = d2 / 4, p2 = this.get();
    if (u3 > p2.length)
      throw new Error("_sha2: outputLen bigger than state");
    for (let m3 = 0; m3 < u3; m3++)
      i2.setUint32(4 * m3, p2[m3], s2);
  }
  digest() {
    const { buffer: t2, outputLen: r2 } = this;
    this.digestInto(t2);
    const n2 = t2.slice(0, r2);
    return this.destroy(), n2;
  }
  _cloneInto(t2) {
    t2 || (t2 = new this.constructor()), t2.set(...this.get());
    const { blockLen: r2, buffer: n2, length: o2, finished: s2, destroyed: a3, pos: i2 } = this;
    return t2.length = o2, t2.pos = i2, t2.finished = s2, t2.destroyed = a3, o2 % r2 && t2.buffer.set(n2), t2;
  }
};
var tu = new Uint32Array([
  1116352408,
  1899447441,
  3049323471,
  3921009573,
  961987163,
  1508970993,
  2453635748,
  2870763221,
  3624381080,
  310598401,
  607225278,
  1426881987,
  1925078388,
  2162078206,
  2614888103,
  3248222580,
  3835390401,
  4022224774,
  264347078,
  604807628,
  770255983,
  1249150122,
  1555081692,
  1996064986,
  2554220882,
  2821834349,
  2952996808,
  3210313671,
  3336571891,
  3584528711,
  113926993,
  338241895,
  666307205,
  773529912,
  1294757372,
  1396182291,
  1695183700,
  1986661051,
  2177026350,
  2456956037,
  2730485921,
  2820302411,
  3259730800,
  3345764771,
  3516065817,
  3600352804,
  4094571909,
  275423344,
  430227734,
  506948616,
  659060556,
  883997877,
  958139571,
  1322822218,
  1537002063,
  1747873779,
  1955562222,
  2024104815,
  2227730452,
  2361852424,
  2428436474,
  2756734187,
  3204031479,
  3329325298
]);
var Pe2 = new Uint32Array([
  1779033703,
  3144134277,
  1013904242,
  2773480762,
  1359893119,
  2600822924,
  528734635,
  1541459225
]);
var Se2 = new Uint32Array(64);
var ru = class extends eu {
  constructor() {
    super(64, 32, 8, false), this.A = Pe2[0] | 0, this.B = Pe2[1] | 0, this.C = Pe2[2] | 0, this.D = Pe2[3] | 0, this.E = Pe2[4] | 0, this.F = Pe2[5] | 0, this.G = Pe2[6] | 0, this.H = Pe2[7] | 0;
  }
  get() {
    const { A: t2, B: r2, C: n2, D: o2, E: s2, F: a3, G: i2, H: d2 } = this;
    return [t2, r2, n2, o2, s2, a3, i2, d2];
  }
  // prettier-ignore
  set(t2, r2, n2, o2, s2, a3, i2, d2) {
    this.A = t2 | 0, this.B = r2 | 0, this.C = n2 | 0, this.D = o2 | 0, this.E = s2 | 0, this.F = a3 | 0, this.G = i2 | 0, this.H = d2 | 0;
  }
  process(t2, r2) {
    for (let m3 = 0; m3 < 16; m3++, r2 += 4)
      Se2[m3] = t2.getUint32(r2, false);
    for (let m3 = 16; m3 < 64; m3++) {
      const g3 = Se2[m3 - 15], b4 = Se2[m3 - 2], E3 = ue2(g3, 7) ^ ue2(g3, 18) ^ g3 >>> 3, h = ue2(b4, 17) ^ ue2(b4, 19) ^ b4 >>> 10;
      Se2[m3] = h + Se2[m3 - 7] + E3 + Se2[m3 - 16] | 0;
    }
    let { A: n2, B: o2, C: s2, D: a3, E: i2, F: d2, G: u3, H: p2 } = this;
    for (let m3 = 0; m3 < 64; m3++) {
      const g3 = ue2(i2, 6) ^ ue2(i2, 11) ^ ue2(i2, 25), b4 = p2 + g3 + Zl(i2, d2, u3) + tu[m3] + Se2[m3] | 0, h = (ue2(n2, 2) ^ ue2(n2, 13) ^ ue2(n2, 22)) + Ql(n2, o2, s2) | 0;
      p2 = u3, u3 = d2, d2 = i2, i2 = a3 + b4 | 0, a3 = s2, s2 = o2, o2 = n2, n2 = b4 + h | 0;
    }
    n2 = n2 + this.A | 0, o2 = o2 + this.B | 0, s2 = s2 + this.C | 0, a3 = a3 + this.D | 0, i2 = i2 + this.E | 0, d2 = d2 + this.F | 0, u3 = u3 + this.G | 0, p2 = p2 + this.H | 0, this.set(n2, o2, s2, a3, i2, d2, u3, p2);
  }
  roundClean() {
    Se2.fill(0);
  }
  destroy() {
    this.set(0, 0, 0, 0, 0, 0, 0, 0), this.buffer.fill(0);
  }
};
var nu = ds(() => new ru());
function ou(e2, t2) {
  return nu(ft(e2, { strict: false }) ? ss(e2) : e2);
}
function su(e2) {
  const { commitment: t2, version: r2 = 1 } = e2, n2 = e2.to ?? (typeof t2 == "string" ? "hex" : "bytes"), o2 = ou(t2);
  return o2.set([r2], 0), n2 === "bytes" ? o2 : ke2(o2);
}
function iu(e2) {
  const { commitments: t2, version: r2 } = e2, n2 = e2.to ?? (typeof t2[0] == "string" ? "hex" : "bytes"), o2 = [];
  for (const s2 of t2)
    o2.push(su({
      commitment: s2,
      to: n2,
      version: r2
    }));
  return o2;
}
var Pn = 6;
var Cs = 32;
var Tr = 4096;
var Ps = Cs * Tr;
var Sn = Ps * Pn - // terminator byte (0x80).
1 - // zero byte (0x00) appended to each field element.
1 * Tr * Pn;
var Ss = 1;
var au = class extends $2 {
  constructor({ maxSize: t2, size: r2 }) {
    super("Blob size is too large.", {
      metaMessages: [`Max: ${t2} bytes`, `Given: ${r2} bytes`],
      name: "BlobSizeTooLargeError"
    });
  }
};
var Rs = class extends $2 {
  constructor() {
    super("Blob data must not be empty.", { name: "EmptyBlobError" });
  }
};
var cu = class extends $2 {
  constructor({ hash: t2, size: r2 }) {
    super(`Versioned hash "${t2}" size is invalid.`, {
      metaMessages: ["Expected: 32", `Received: ${r2}`],
      name: "InvalidVersionedHashSizeError"
    });
  }
};
var lu = class extends $2 {
  constructor({ hash: t2, version: r2 }) {
    super(`Versioned hash "${t2}" version is invalid.`, {
      metaMessages: [
        `Expected: ${Ss}`,
        `Received: ${r2}`
      ],
      name: "InvalidVersionedHashVersionError"
    });
  }
};
function uu(e2) {
  const t2 = e2.to ?? (typeof e2.data == "string" ? "hex" : "bytes"), r2 = typeof e2.data == "string" ? Fe2(e2.data) : e2.data, n2 = Xe(r2);
  if (!n2)
    throw new Rs();
  if (n2 > Sn)
    throw new au({
      maxSize: Sn,
      size: n2
    });
  const o2 = [];
  let s2 = true, a3 = 0;
  for (; s2; ) {
    const i2 = gs(new Uint8Array(Ps));
    let d2 = 0;
    for (; d2 < Tr; ) {
      const u3 = r2.slice(a3, a3 + (Cs - 1));
      if (i2.pushByte(0), i2.pushBytes(u3), u3.length < 31) {
        i2.pushByte(128), s2 = false;
        break;
      }
      d2++, a3 += 31;
    }
    o2.push(i2);
  }
  return t2 === "bytes" ? o2.map((i2) => i2.bytes) : o2.map((i2) => ke2(i2.bytes));
}
function du(e2) {
  const { data: t2, kzg: r2, to: n2 } = e2, o2 = e2.blobs ?? uu({ data: t2, to: n2 }), s2 = e2.commitments ?? ws({ blobs: o2, kzg: r2, to: n2 }), a3 = e2.proofs ?? Es({ blobs: o2, commitments: s2, kzg: r2, to: n2 }), i2 = [];
  for (let d2 = 0; d2 < o2.length; d2++)
    i2.push({
      blob: o2[d2],
      commitment: s2[d2],
      proof: a3[d2]
    });
  return i2;
}
function fu(e2) {
  if (e2.type)
    return e2.type;
  if (typeof e2.authorizationList < "u")
    return "eip7702";
  if (typeof e2.blobs < "u" || typeof e2.blobVersionedHashes < "u" || typeof e2.maxFeePerBlobGas < "u" || typeof e2.sidecars < "u")
    return "eip4844";
  if (typeof e2.maxFeePerGas < "u" || typeof e2.maxPriorityFeePerGas < "u")
    return "eip1559";
  if (typeof e2.gasPrice < "u")
    return typeof e2.accessList < "u" ? "eip2930" : "legacy";
  throw new Vl({ transaction: e2 });
}
function hu(e2, { args: t2, eventName: r2 } = {}) {
  return {
    ...e2,
    blockHash: e2.blockHash ? e2.blockHash : null,
    blockNumber: e2.blockNumber ? BigInt(e2.blockNumber) : null,
    logIndex: e2.logIndex ? Number(e2.logIndex) : null,
    transactionHash: e2.transactionHash ? e2.transactionHash : null,
    transactionIndex: e2.transactionIndex ? Number(e2.transactionIndex) : null,
    ...r2 ? { args: t2, eventName: r2 } : {}
  };
}
var pu = {
  "0x0": "reverted",
  "0x1": "success"
};
function mu(e2) {
  const t2 = {
    ...e2,
    blockNumber: e2.blockNumber ? BigInt(e2.blockNumber) : null,
    contractAddress: e2.contractAddress ? e2.contractAddress : null,
    cumulativeGasUsed: e2.cumulativeGasUsed ? BigInt(e2.cumulativeGasUsed) : null,
    effectiveGasPrice: e2.effectiveGasPrice ? BigInt(e2.effectiveGasPrice) : null,
    gasUsed: e2.gasUsed ? BigInt(e2.gasUsed) : null,
    logs: e2.logs ? e2.logs.map((r2) => hu(r2)) : null,
    to: e2.to ? e2.to : null,
    transactionIndex: e2.transactionIndex ? Tt(e2.transactionIndex) : null,
    status: e2.status ? pu[e2.status] : null,
    type: e2.type ? xs[e2.type] || e2.type : null
  };
  return e2.blobGasPrice && (t2.blobGasPrice = BigInt(e2.blobGasPrice)), e2.blobGasUsed && (t2.blobGasUsed = BigInt(e2.blobGasUsed)), t2;
}
var gu = Ar("transactionReceipt", mu);
function he2(e2) {
  return {
    formatters: void 0,
    fees: void 0,
    serializers: void 0,
    ...e2
  };
}
function bu(e2) {
  const { authorizationList: t2 } = e2;
  if (t2)
    for (const r2 of t2) {
      const { chainId: n2 } = r2, o2 = r2.address;
      if (!Me2(o2))
        throw new Be2({ address: o2 });
      if (n2 < 0)
        throw new Dt({ chainId: n2 });
    }
  Nr(e2);
}
function vu(e2) {
  const { blobVersionedHashes: t2 } = e2;
  if (t2) {
    if (t2.length === 0)
      throw new Rs();
    for (const r2 of t2) {
      const n2 = Xe(r2), o2 = Tt(Ol(r2, 0, 1));
      if (n2 !== 32)
        throw new cu({ hash: r2, size: n2 });
      if (o2 !== Ss)
        throw new lu({
          hash: r2,
          version: o2
        });
    }
  }
  Nr(e2);
}
function Nr(e2) {
  const { chainId: t2, maxPriorityFeePerGas: r2, maxFeePerGas: n2, to: o2 } = e2;
  if (t2 <= 0)
    throw new Dt({ chainId: t2 });
  if (o2 && !Me2(o2))
    throw new Be2({ address: o2 });
  if (n2 && n2 > Ir)
    throw new Ft({ maxFeePerGas: n2 });
  if (r2 && n2 && r2 > n2)
    throw new ys({ maxFeePerGas: n2, maxPriorityFeePerGas: r2 });
}
function yu(e2) {
  const { chainId: t2, maxPriorityFeePerGas: r2, gasPrice: n2, maxFeePerGas: o2, to: s2 } = e2;
  if (t2 <= 0)
    throw new Dt({ chainId: t2 });
  if (s2 && !Me2(s2))
    throw new Be2({ address: s2 });
  if (r2 || o2)
    throw new $2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid EIP-2930 Transaction attribute.");
  if (n2 && n2 > Ir)
    throw new Ft({ maxFeePerGas: n2 });
}
function xu(e2) {
  const { chainId: t2, maxPriorityFeePerGas: r2, gasPrice: n2, maxFeePerGas: o2, to: s2 } = e2;
  if (s2 && !Me2(s2))
    throw new Be2({ address: s2 });
  if (typeof t2 < "u" && t2 <= 0)
    throw new Dt({ chainId: t2 });
  if (r2 || o2)
    throw new $2("`maxFeePerGas`/`maxPriorityFeePerGas` is not a valid Legacy Transaction attribute.");
  if (n2 && n2 > Ir)
    throw new Ft({ maxFeePerGas: n2 });
}
function Bt(e2) {
  if (!e2 || e2.length === 0)
    return [];
  const t2 = [];
  for (let r2 = 0; r2 < e2.length; r2++) {
    const { address: n2, storageKeys: o2 } = e2[r2];
    for (let s2 = 0; s2 < o2.length; s2++)
      if (o2[s2].length - 2 !== 64)
        throw new Hl({ storageKey: o2[s2] });
    if (!Me2(n2, { strict: false }))
      throw new Be2({ address: n2 });
    t2.push([n2, o2]);
  }
  return t2;
}
function wu(e2, t2) {
  const r2 = fu(e2);
  return r2 === "eip1559" ? Pu(e2, t2) : r2 === "eip2930" ? Su(e2, t2) : r2 === "eip4844" ? Cu(e2, t2) : r2 === "eip7702" ? Eu(e2, t2) : Ru(e2, t2);
}
function Eu(e2, t2) {
  const { authorizationList: r2, chainId: n2, gas: o2, nonce: s2, to: a3, value: i2, maxFeePerGas: d2, maxPriorityFeePerGas: u3, accessList: p2, data: m3 } = e2;
  bu(e2);
  const g3 = Bt(p2), b4 = Au(r2);
  return ht([
    "0x04",
    Ue2([
      T3(n2),
      s2 ? T3(s2) : "0x",
      u3 ? T3(u3) : "0x",
      d2 ? T3(d2) : "0x",
      o2 ? T3(o2) : "0x",
      a3 ?? "0x",
      i2 ? T3(i2) : "0x",
      m3 ?? "0x",
      g3,
      b4,
      ...pt(e2, t2)
    ])
  ]);
}
function Cu(e2, t2) {
  const { chainId: r2, gas: n2, nonce: o2, to: s2, value: a3, maxFeePerBlobGas: i2, maxFeePerGas: d2, maxPriorityFeePerGas: u3, accessList: p2, data: m3 } = e2;
  vu(e2);
  let g3 = e2.blobVersionedHashes, b4 = e2.sidecars;
  if (e2.blobs && (typeof g3 > "u" || typeof b4 > "u")) {
    const P = typeof e2.blobs[0] == "string" ? e2.blobs : e2.blobs.map((W3) => ke2(W3)), R2 = e2.kzg, N2 = ws({
      blobs: P,
      kzg: R2
    });
    if (typeof g3 > "u" && (g3 = iu({
      commitments: N2
    })), typeof b4 > "u") {
      const W3 = Es({ blobs: P, commitments: N2, kzg: R2 });
      b4 = du({ blobs: P, commitments: N2, proofs: W3 });
    }
  }
  const E3 = Bt(p2), h = [
    T3(r2),
    o2 ? T3(o2) : "0x",
    u3 ? T3(u3) : "0x",
    d2 ? T3(d2) : "0x",
    n2 ? T3(n2) : "0x",
    s2 ?? "0x",
    a3 ? T3(a3) : "0x",
    m3 ?? "0x",
    E3,
    i2 ? T3(i2) : "0x",
    g3 ?? [],
    ...pt(e2, t2)
  ], v2 = [], x2 = [], w2 = [];
  if (b4)
    for (let P = 0; P < b4.length; P++) {
      const { blob: R2, commitment: N2, proof: W3 } = b4[P];
      v2.push(R2), x2.push(N2), w2.push(W3);
    }
  return ht([
    "0x03",
    // If sidecars are enabled, envelope turns into a "wrapper":
    Ue2(b4 ? [h, v2, x2, w2] : h)
  ]);
}
function Pu(e2, t2) {
  const { chainId: r2, gas: n2, nonce: o2, to: s2, value: a3, maxFeePerGas: i2, maxPriorityFeePerGas: d2, accessList: u3, data: p2 } = e2;
  Nr(e2);
  const m3 = Bt(u3), g3 = [
    T3(r2),
    o2 ? T3(o2) : "0x",
    d2 ? T3(d2) : "0x",
    i2 ? T3(i2) : "0x",
    n2 ? T3(n2) : "0x",
    s2 ?? "0x",
    a3 ? T3(a3) : "0x",
    p2 ?? "0x",
    m3,
    ...pt(e2, t2)
  ];
  return ht([
    "0x02",
    Ue2(g3)
  ]);
}
function Su(e2, t2) {
  const { chainId: r2, gas: n2, data: o2, nonce: s2, to: a3, value: i2, accessList: d2, gasPrice: u3 } = e2;
  yu(e2);
  const p2 = Bt(d2), m3 = [
    T3(r2),
    s2 ? T3(s2) : "0x",
    u3 ? T3(u3) : "0x",
    n2 ? T3(n2) : "0x",
    a3 ?? "0x",
    i2 ? T3(i2) : "0x",
    o2 ?? "0x",
    p2,
    ...pt(e2, t2)
  ];
  return ht([
    "0x01",
    Ue2(m3)
  ]);
}
function Ru(e2, t2) {
  const { chainId: r2 = 0, gas: n2, data: o2, nonce: s2, to: a3, value: i2, gasPrice: d2 } = e2;
  xu(e2);
  let u3 = [
    s2 ? T3(s2) : "0x",
    d2 ? T3(d2) : "0x",
    n2 ? T3(n2) : "0x",
    a3 ?? "0x",
    i2 ? T3(i2) : "0x",
    o2 ?? "0x"
  ];
  if (t2) {
    const p2 = (() => {
      if (t2.v >= 35n)
        return (t2.v - 35n) / 2n > 0 ? t2.v : 27n + (t2.v === 35n ? 0n : 1n);
      if (r2 > 0)
        return BigInt(r2 * 2) + BigInt(35n + t2.v - 27n);
      const b4 = 27n + (t2.v === 27n ? 0n : 1n);
      if (t2.v !== b4)
        throw new Gl({ v: t2.v });
      return b4;
    })(), m3 = kt(t2.r), g3 = kt(t2.s);
    u3 = [
      ...u3,
      T3(p2),
      m3 === "0x00" ? "0x" : m3,
      g3 === "0x00" ? "0x" : g3
    ];
  } else r2 > 0 && (u3 = [
    ...u3,
    T3(r2),
    "0x",
    "0x"
  ]);
  return Ue2(u3);
}
function pt(e2, t2) {
  const r2 = t2 ?? e2, { v: n2, yParity: o2 } = r2;
  if (typeof r2.r > "u")
    return [];
  if (typeof r2.s > "u")
    return [];
  if (typeof n2 > "u" && typeof o2 > "u")
    return [];
  const s2 = kt(r2.r), a3 = kt(r2.s);
  return [typeof o2 == "number" ? o2 ? T3(1) : "0x" : n2 === 0n ? "0x" : n2 === 1n ? T3(1) : n2 === 27n ? "0x" : T3(1), s2 === "0x00" ? "0x" : s2, a3 === "0x00" ? "0x" : a3];
}
function Au(e2) {
  if (!e2 || e2.length === 0)
    return [];
  const t2 = [];
  for (const r2 of e2) {
    const { chainId: n2, nonce: o2, ...s2 } = r2, a3 = r2.address;
    t2.push([
      n2 ? T3(n2) : "0x",
      a3,
      o2 ? T3(o2) : "0x",
      ...pt({}, s2)
    ]);
  }
  return t2;
}
function Iu(e2) {
  const t2 = e2.state.current, r2 = e2.state.connections.get(t2), n2 = r2 == null ? void 0 : r2.accounts, o2 = n2 == null ? void 0 : n2[0], s2 = e2.chains.find((i2) => i2.id === (r2 == null ? void 0 : r2.chainId)), a3 = e2.state.status;
  switch (a3) {
    case "connected":
      return {
        address: o2,
        addresses: n2,
        chain: s2,
        chainId: r2 == null ? void 0 : r2.chainId,
        connector: r2 == null ? void 0 : r2.connector,
        isConnected: true,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: false,
        status: a3
      };
    case "reconnecting":
      return {
        address: o2,
        addresses: n2,
        chain: s2,
        chainId: r2 == null ? void 0 : r2.chainId,
        connector: r2 == null ? void 0 : r2.connector,
        isConnected: !!o2,
        isConnecting: false,
        isDisconnected: false,
        isReconnecting: true,
        status: a3
      };
    case "connecting":
      return {
        address: o2,
        addresses: n2,
        chain: s2,
        chainId: r2 == null ? void 0 : r2.chainId,
        connector: r2 == null ? void 0 : r2.connector,
        isConnected: false,
        isConnecting: true,
        isDisconnected: false,
        isReconnecting: false,
        status: a3
      };
    case "disconnected":
      return {
        address: void 0,
        addresses: void 0,
        chain: void 0,
        chainId: void 0,
        connector: void 0,
        isConnected: false,
        isConnecting: false,
        isDisconnected: true,
        isReconnecting: false,
        status: a3
      };
  }
}
function gr(e2, t2) {
  if (e2 === t2)
    return true;
  if (e2 && t2 && typeof e2 == "object" && typeof t2 == "object") {
    if (e2.constructor !== t2.constructor)
      return false;
    let r2, n2;
    if (Array.isArray(e2) && Array.isArray(t2)) {
      if (r2 = e2.length, r2 !== t2.length)
        return false;
      for (n2 = r2; n2-- !== 0; )
        if (!gr(e2[n2], t2[n2]))
          return false;
      return true;
    }
    if (e2.valueOf !== Object.prototype.valueOf)
      return e2.valueOf() === t2.valueOf();
    if (e2.toString !== Object.prototype.toString)
      return e2.toString() === t2.toString();
    const o2 = Object.keys(e2);
    if (r2 = o2.length, r2 !== Object.keys(t2).length)
      return false;
    for (n2 = r2; n2-- !== 0; )
      if (!Object.prototype.hasOwnProperty.call(t2, o2[n2]))
        return false;
    for (n2 = r2; n2-- !== 0; ) {
      const s2 = o2[n2];
      if (s2 && !gr(e2[s2], t2[s2]))
        return false;
    }
    return true;
  }
  return e2 !== e2 && t2 !== t2;
}
function ku(e2, t2) {
  const { onChange: r2 } = t2;
  return e2.subscribe(() => Iu(e2), r2, {
    equalityFn(n2, o2) {
      const { connector: s2, ...a3 } = n2, { connector: i2, ...d2 } = o2;
      return gr(a3, d2) && // check connector separately
      (s2 == null ? void 0 : s2.id) === (i2 == null ? void 0 : i2.id) && (s2 == null ? void 0 : s2.uid) === (i2 == null ? void 0 : i2.uid);
    }
  });
}
function Tu(e2 = {}) {
  const { onConnect: t2, onDisconnect: r2 } = e2, n2 = useConfig(e2);
  (0, import_react72.useEffect)(() => ku(n2, {
    onChange(o2, s2) {
      if ((s2.status === "reconnecting" || s2.status === "connecting") && o2.status === "connected") {
        const { address: a3, addresses: i2, chain: d2, chainId: u3, connector: p2 } = o2, m3 = s2.status === "reconnecting" || // if `previousAccount.status` is `undefined`, the connector connected immediately.
        s2.status === void 0;
        t2 == null || t2({
          address: a3,
          addresses: i2,
          chain: d2,
          chainId: u3,
          connector: p2,
          isReconnected: m3
        });
      } else s2.status === "connected" && o2.status === "disconnected" && (r2 == null || r2());
    }
  }), [n2, t2, r2]);
}
var Nu = (e2) => {
  const {
    getNonce: t2,
    linkWallet: r2,
    loginCallback: n2,
    user: o2,
    verifyNonce: s2,
    isLoggedIn: a3,
    errorWallet: i2
  } = Qe(), { signMessageAsync: d2, status: u3 } = useSignMessage(), { disconnect: p2 } = useDisconnect(), m3 = useChainId(), g3 = async (E3) => {
    console.log("Sign for Linking");
    const h = await t2(), v2 = new import_siwe.SiweMessage({
      domain: window.location.host,
      address: E3,
      statement: "Sign in to Bedrock Passport",
      uri: window.location.origin,
      version: "1",
      nonce: h == null ? void 0 : h.nonce,
      chainId: m3
    }), x2 = await d2({
      message: v2.prepareMessage()
    }).catch(() => {
      throw new Error("LOGIN_SIGN_ERROR");
    }), w2 = await r2(v2, x2);
    if (!w2 || !w2.token)
      throw p2(), new Error("LOGIN_VERIFY_ERROR");
    await n2(
      w2.token.accessToken,
      w2.token.refreshToken
    );
  }, b4 = async (E3) => {
    console.log("Sign After Login");
    const h = await t2(), v2 = new import_siwe.SiweMessage({
      domain: window.location.host,
      address: E3,
      statement: "Sign in to Bedrock Passport",
      uri: window.location.origin,
      version: "1",
      nonce: h == null ? void 0 : h.nonce,
      chainId: m3
    }), x2 = await d2({
      message: v2.prepareMessage()
    }).catch(() => {
      throw new Error("LOGIN_SIGN_ERROR");
    }), w2 = await s2(v2, x2);
    if (!w2 || !w2.token)
      throw p2(), new Error("LOGIN_VERIFY_ERROR");
    await n2(
      w2.token.accessToken,
      w2.token.refreshToken
    );
  };
  return Tu({
    async onConnect(E3) {
      var h, v2;
      console.log("EFFECT_INIT_SIGN"), a3 && ((h = o2 == null ? void 0 : o2.ethAddress) == null ? void 0 : h.toLowerCase()) !== ((v2 = E3.address) == null ? void 0 : v2.toLowerCase()) ? (console.log("EFFECT_INIT_SIGN_LINK"), await g3(E3.address).then(() => {
        const x2 = new CustomEvent("Bedrock_Wallet_Linked", {
          detail: { address: E3.address }
        });
        document.dispatchEvent(x2);
      }).catch((x2) => {
        console.error("EFFECT_INIT_SIGN_LINK", { e: x2 }), p2();
      })) : (console.log("EFFECT_INIT_SIGN_LOGIN"), a3 || await b4(E3.address).then(() => {
        const x2 = new CustomEvent("Bedrock_Wallet_Login", {
          detail: { address: E3.address }
        });
        document.dispatchEvent(x2);
      }).catch((x2) => {
        console.error("EFFECT_INIT_SIGN_LOGIN", { e: x2 }), p2();
      }));
    }
  }), l2.jsxs(l2.Fragment, { children: [
    l2.jsx(Xc, { open: u3 === "pending" }),
    l2.jsxs("div", { className: "grid grid-cols-1 gap-4", children: [
      l2.jsx(ConnectKitButton.Custom, { children: ({ isConnected: E3, show: h, truncatedAddress: v2, isConnecting: x2 }) => l2.jsx(l2.Fragment, { children: l2.jsxs(
        q2,
        {
          onClick: h,
          variant: "outline",
          className: e2.className,
          disabled: x2,
          children: [
            l2.jsx(He2.wallet, {}),
            l2.jsx("span", { children: E3 ? v2 : o2 != null && o2.ethAddress ? Yi(o2.ethAddress) : e2.connectText ?? "Connect" })
          ]
        }
      ) }) }),
      i2 && l2.jsx("div", { className: "text-red-600", children: i2 })
    ] })
  ] });
};
var _u = {
  enableWalletConnect: true,
  enableEmailLogin: true,
  enableGoogleLogin: true,
  enableAppleLogin: true,
  enableItemsDisplay: true,
  enableCurrencyDisplay: false,
  showProfileButton: false,
  showLogoutButton: true
};
var Ou = {
  sm: "h-8 text-sm px-2",
  md: "h-10 text-base px-3",
  lg: "h-12 text-lg px-4"
};
var ju = {
  default: `
    bg-white dark:bg-gray-800
    border border-gray-300 dark:border-gray-700
    focus:border-blue-500 dark:focus:border-blue-400
    focus:ring-blue-500/20 dark:focus:ring-blue-400/20
  `,
  filled: `
    bg-gray-100 dark:bg-gray-700
    border-transparent
    focus:bg-white dark:focus:bg-gray-800
    focus:border-blue-500 dark:focus:border-blue-400
    focus:ring-blue-500/20 dark:focus:ring-blue-400/20
  `,
  outline: `
    bg-transparent
    border border-gray-300 dark:border-gray-600
    focus:border-blue-500 dark:focus:border-blue-400
    focus:ring-blue-500/20 dark:focus:ring-blue-400/20
  `
};
var je2 = f2.forwardRef(
  ({
    className: e2,
    error: t2,
    label: r2,
    leftIcon: n2,
    rightIcon: o2,
    variant: s2 = "default",
    inputSize: a3 = "md",
    type: i2 = "text",
    disabled: d2,
    ...u3
  }, p2) => {
    const m3 = f2.useId();
    return l2.jsxs("div", { className: "w-full", children: [
      r2 && l2.jsx(
        "label",
        {
          htmlFor: m3,
          className: I2(
            "block text-sm font-medium mb-1.5",
            d2 && "opacity-50",
            t2 ? "text-red-500" : "text-gray-700 dark:text-gray-200"
          ),
          children: r2
        }
      ),
      l2.jsxs("div", { className: "relative", children: [
        n2 && l2.jsx("div", { className: "absolute left-3 top-1/2 -translate-y-1/2 text-gray-500 dark:text-gray-400", children: n2 }),
        l2.jsx(
          "input",
          {
            id: m3,
            type: i2,
            disabled: d2,
            ref: p2,
            className: I2(
              // Base styles
              "w-full rounded-md transition-colors",
              "placeholder:text-gray-500 dark:placeholder:text-gray-400",
              "focus:outline-none focus:ring-2",
              "disabled:cursor-not-allowed disabled:opacity-50",
              // Variant styles
              ju[s2],
              // Size styles
              Ou[a3],
              // Icon padding
              n2 && "pl-10",
              o2 && "pr-10",
              // Error styles
              t2 && "border-red-500 focus:border-red-500 focus:ring-red-500/20",
              e2
            ),
            ...u3
          }
        ),
        o2 && l2.jsx("div", { className: "absolute right-3 top-1/2 -translate-y-1/2 text-gray-500 dark:text-gray-400", children: o2 })
      ] }),
      t2 && l2.jsx("p", { className: "mt-1.5 text-sm text-red-500", children: t2 })
    ] });
  }
);
je2.displayName = "Input";
var Lu = (e2) => {
  const [t2, r2] = (0, import_react72.useState)(""), [n2, o2] = (0, import_react72.useState)(""), { signIn: s2, loginCallback: a3 } = Qe(), [i2, d2] = (0, import_react72.useState)(""), u3 = async (m3) => {
    m3.preventDefault(), d2("");
    try {
      const g3 = await s2(Ie2.EMAIL, { email: t2, password: n2 });
      if (console.log("EMAIL LOGIN", {
        res: g3
      }), !g3 || !g3.token) {
        d2("Invalid email or password");
        return;
      }
      const { accessToken: b4, refreshToken: E3 } = g3.token;
      await a3(b4, E3);
    } catch (g3) {
      console.error("Login failed:", { error: g3 }), d2(
        g3 instanceof Error ? g3.message : "Login failed. Please try again."
      );
    }
  }, p2 = async (m3) => {
    m3.preventDefault(), await u3(m3);
  };
  return l2.jsxs("form", { onSubmit: p2, className: "space-y-4", children: [
    i2 && l2.jsx("div", { className: "text-red-500", children: i2 }),
    l2.jsxs("div", { className: "space-y-2", children: [
      l2.jsx(
        je2,
        {
          type: "email",
          placeholder: "Email",
          value: t2,
          onChange: (m3) => r2(m3.target.value),
          required: true
        }
      ),
      l2.jsx(
        je2,
        {
          type: "password",
          placeholder: "Password",
          value: n2,
          onChange: (m3) => o2(m3.target.value),
          required: true
        }
      )
    ] }),
    l2.jsx("div", { className: "flex gap-2", children: l2.jsx(
      q2,
      {
        type: "submit",
        variant: "outline",
        className: I2(e2.buttonClass),
        children: "Sign In"
      }
    ) })
  ] });
};
var Du = (e2) => {
  const [t2, r2] = (0, import_react72.useState)(""), [n2, o2] = (0, import_react72.useState)(""), [s2, a3] = (0, import_react72.useState)(""), { registerEmail: i2, loginCallback: d2 } = Qe(), [u3, p2] = (0, import_react72.useState)(""), m3 = async (b4) => {
    b4.preventDefault(), p2("");
    const E3 = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[a-zA-Z]).{8,}$/;
    if (!n2.match(E3)) {
      p2(
        "Password must have at least 8 characters and contain at least one uppercase letter, one lowercase letter, one number and one special characters"
      );
      return;
    }
    if (n2 !== s2) {
      p2("Password does not match");
      return;
    }
    try {
      const h = await i2(t2, n2, s2);
      if (!h || !h.token) {
        p2(
          "It seems like the email is already registered. Please continue with reset passwor process if you still having problem"
        );
        return;
      }
      const { accessToken: v2, refreshToken: x2 } = h.token;
      await d2(v2, x2);
    } catch (h) {
      console.error("Login failed:", h), p2(
        h instanceof Error ? h.message : "Login failed. Please try again."
      );
    }
  }, g3 = async (b4) => {
    b4.preventDefault(), await m3(b4);
  };
  return l2.jsxs("form", { onSubmit: g3, className: "space-y-4", children: [
    u3 && l2.jsx("div", { className: "text-red-500", children: u3 }),
    l2.jsxs("div", { className: "space-y-2", children: [
      l2.jsx(
        je2,
        {
          type: "email",
          placeholder: "Email",
          value: t2,
          onChange: (b4) => r2(b4.target.value),
          required: true
        }
      ),
      l2.jsx(
        je2,
        {
          type: "password",
          placeholder: "Password",
          value: n2,
          onChange: (b4) => o2(b4.target.value),
          required: true
        }
      ),
      l2.jsx(
        je2,
        {
          type: "password",
          placeholder: "Password Confirmation",
          value: s2,
          onChange: (b4) => a3(b4.target.value),
          required: true
        }
      )
    ] }),
    l2.jsx("div", { className: "flex gap-2", children: l2.jsx(
      q2,
      {
        type: "submit",
        variant: "outline",
        className: I2(e2.buttonClass),
        children: "Register"
      }
    ) })
  ] });
};
var Fu = (e2) => {
  const [t2, r2] = (0, import_react72.useState)(""), { getTokenReset: n2 } = Qe(), [o2, s2] = (0, import_react72.useState)(""), [a3, i2] = (0, import_react72.useState)(""), d2 = async () => {
    if (s2(""), !t2) {
      s2("Please enter an email address");
      return;
    }
    if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(t2)) {
      s2("Please enter a valid email address");
      return;
    }
    try {
      i2(""), console.log("requestToken", { email: t2 });
      const p2 = await n2(t2);
      console.log("getTokenReset", { res: p2 }), i2("Please check your email to continue");
    } catch (p2) {
      console.error("Request failed:", p2), s2(
        "Please check if the email is correct. If the problem persists, please contact support."
      );
    }
  };
  return l2.jsxs("div", { className: "space-y-4", children: [
    o2 && l2.jsx("div", { className: "text-red-500", children: o2 }),
    a3 && l2.jsx("div", { className: "text-green-500", children: a3 }),
    l2.jsxs("div", { className: "space-y-2", children: [
      l2.jsx(
        je2,
        {
          type: "email",
          placeholder: "email",
          value: t2,
          onChange: (u3) => r2(u3.target.value),
          required: true
        }
      ),
      l2.jsx(
        q2,
        {
          type: "button",
          variant: "outline",
          className: I2(e2.buttonClass),
          onClick: d2,
          children: "Recover"
        }
      )
    ] })
  ] });
};
var Bu = () => {
  var r2;
  const {
    currency: e2
  } = Qe();
  let t2;
  return e2 && (t2 = (r2 = e2 == null ? void 0 : e2.Items) == null ? void 0 : r2.map((n2) => l2.jsx("li", { children: l2.jsxs("p", { children: [
    "Bedrock Points: ",
    n2.Amount
  ] }) }))), l2.jsx("div", { children: l2.jsx("div", { children: l2.jsx("ul", { children: t2 }) }) });
};
var Id2 = ({ features: e2, ...t2 }) => {
  const r2 = { ..._u, ...e2 }, {
    signIn: n2,
    user: o2,
    linkSocial: s2,
    widgetText: a3,
    widgetUrl: i2,
    signOut: d2,
    linkProfile: u3,
    isLoggedIn: p2
  } = Qe(), [m3, g3] = (0, import_react72.useState)(false), [b4, E3] = (0, import_react72.useState)(false), [h, v2] = (0, import_react72.useState)(false), x2 = () => {
    o2 != null && o2.ethAddress ? s2(Ie2.GOOGLE) : n2(Ie2.GOOGLE);
  }, w2 = () => {
    o2 != null && o2.ethAddress ? s2(Ie2.APPLE) : n2(Ie2.APPLE);
  };
  return !r2.enableAppleLogin && !r2.enableGoogleLogin && !r2.enableEmailLogin && !r2.enableWalletConnect ? l2.jsxs(ir, { className: I2("min-w-60", t2.panelClass), children: [
    l2.jsx(ar, { children: l2.jsxs("div", { className: I2("flex items-center", t2.headerClass), children: [
      l2.jsx(cr, { className: I2(t2.titleClass), children: t2.title ?? "Sign In to" }),
      t2.logo && l2.jsx(
        "img",
        {
          src: t2.logo,
          alt: t2.logoAlt,
          className: I2(t2.logoClass)
        }
      )
    ] }) }),
    l2.jsx(lr, { className: "grid gap-4", children: "You will need to enable at least one login method" })
  ] }) : l2.jsxs(ir, { className: I2("min-w-60", t2.panelClass), children: [
    l2.jsx(ar, { children: l2.jsxs("div", { className: I2("flex items-center", t2.headerClass), children: [
      l2.jsx(cr, { className: I2(t2.titleClass), children: t2.title ?? "Sign In to" }),
      t2.logo && l2.jsx(
        "img",
        {
          src: t2.logo,
          alt: t2.logoAlt,
          className: I2(t2.logoClass)
        }
      )
    ] }) }),
    l2.jsxs(lr, { className: "grid gap-4", children: [
      o2 != null && o2.email ? l2.jsxs(l2.Fragment, { children: [
        l2.jsxs("div", { className: "flex flex-row gap-4 justify-center items-center", children: [
          o2.provider === Ie2.APPLE ? l2.jsx(q2, { variant: "outline", disabled: true, children: l2.jsx(He2.apple, {}) }) : l2.jsx(q2, { variant: "outline", disabled: true, children: l2.jsx(He2.google, {}) }),
          l2.jsx("div", { children: o2 == null ? void 0 : o2.email })
        ] }),
        l2.jsxs(
          "div",
          {
            className: I2(
              "flex justify-start items-center w-full gap-2",
              t2.linkRowClass
            ),
            children: [
              r2.showProfileButton && l2.jsx(
                q2,
                {
                  variant: "outline",
                  className: I2(t2.buttonClass, ""),
                  onClick: u3,
                  children: "Profile"
                }
              ),
              r2.showLogoutButton && l2.jsx(
                q2,
                {
                  variant: "outline",
                  onClick: d2,
                  className: I2(t2.buttonClass, ""),
                  children: "Logout"
                }
              )
            ]
          }
        ),
        r2.enableCurrencyDisplay && l2.jsx(
          "div",
          {
            className: I2(
              t2.linkRowClass,
              " flex justify-start items-center w-full gap-2"
            ),
            children: l2.jsx(Bu, {})
          }
        )
      ] }) : !m3 && !b4 && !h ? l2.jsxs("div", { className: "flex flex-col gap-4", children: [
        l2.jsx("h4", { className: "text-white text-center font-bold text-sm", children: "Continue with" }),
        l2.jsxs("div", { className: "grid auto-cols-fr grid-flow-col gap-2 ", children: [
          r2.enableGoogleLogin && l2.jsx(
            q2,
            {
              variant: "outline",
              className: I2(t2.buttonClass, ""),
              onClick: () => x2(),
              children: l2.jsx(He2.google, {})
            }
          ),
          r2.enableAppleLogin && l2.jsx(
            q2,
            {
              variant: "outline",
              className: I2(t2.buttonClass),
              onClick: () => w2(),
              children: l2.jsx(He2.apple, {})
            }
          ),
          r2.enableEmailLogin && l2.jsx(
            q2,
            {
              variant: "outline",
              className: I2(t2.buttonClass),
              onClick: () => g3(true),
              children: l2.jsx(He2.email, {})
            }
          )
        ] })
      ] }) : l2.jsxs(l2.Fragment, { children: [
        b4 && l2.jsx(Du, { buttonClass: t2.buttonClass }),
        m3 && l2.jsx(Lu, { buttonClass: t2.buttonClass }),
        h && l2.jsx(
          Fu,
          {
            buttonClass: t2.buttonClass,
            separatorClass: t2.separatorTextClass
          }
        )
      ] }),
      m3 || b4 || h ? l2.jsxs(l2.Fragment, { children: [
        l2.jsxs("div", { className: "relative", children: [
          l2.jsx(
            dr,
            {
              className: I2("my-4", "bg-white", t2.separatorClass),
              orientation: "horizontal"
            }
          ),
          !p2 && l2.jsx(
            "span",
            {
              className: I2(
                "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex justify-center items-center py-1 px-2",
                "bg-black",
                t2.separatorTextClass
              ),
              children: t2.separatorText ?? "or"
            }
          )
        ] }),
        l2.jsxs("div", { className: "flex items-center justify-center w-full gap-2", children: [
          l2.jsx(
            q2,
            {
              type: "button",
              variant: "outline",
              className: I2(t2.buttonClass),
              onClick: () => {
                g3(false), E3(false), v2(false);
              },
              children: "Back"
            }
          ),
          l2.jsx(
            q2,
            {
              type: "button",
              variant: "outline",
              className: I2(t2.buttonClass),
              onClick: () => {
                if (h) {
                  g3(false), E3(true), v2(false);
                  return;
                }
                g3(!m3), E3(!b4);
              },
              children: b4 ? "Sign In" : "Register"
            }
          ),
          !h && l2.jsx(
            q2,
            {
              type: "button",
              variant: "outline",
              className: I2(t2.buttonClass),
              onClick: () => {
                g3(false), E3(false), v2(true);
              },
              children: "Reset"
            }
          )
        ] })
      ] }) : l2.jsx(l2.Fragment, { children: r2.enableWalletConnect && t2.showConnectWallet && l2.jsxs(l2.Fragment, { children: [
        (r2.enableAppleLogin || r2.enableGoogleLogin || r2.enableEmailLogin) && l2.jsxs("div", { className: "relative", children: [
          l2.jsx(
            dr,
            {
              className: I2("my-4", "bg-white", t2.separatorClass),
              orientation: "horizontal"
            }
          ),
          !p2 && l2.jsx(
            "span",
            {
              className: I2(
                "absolute top-1/2 left-1/2 -translate-x-1/2 -translate-y-1/2 flex justify-center items-center py-1 px-2",
                "bg-black",
                t2.separatorTextClass
              ),
              children: t2.separatorText ?? "or"
            }
          )
        ] }),
        l2.jsx("div", { className: "flex items-center justify-center w-full", children: l2.jsx(
          Nu,
          {
            className: I2(t2.walletButtonClass ?? t2.buttonClass),
            connectText: t2.walletButtonText
          }
        ) })
      ] }) })
    ] }),
    l2.jsx(Jn, { className: "flex justify-center", children: l2.jsx("a", { href: i2, rel: "nofollow", target: "_blank", children: l2.jsx("h4", { className: "text-white text-center font-bold text-sm", children: a3 }) }) })
  ] });
};
var Mu = (e2, t2, r2, n2, o2) => `${e2}/api/v1/auth/${t2}?state=${r2}`;
var Uu = (e2, t2, r2, n2, o2) => `${e2}/api/v1/auth/identifier/${t2}?state=${r2}`;
function _r(e2, t2) {
  let r2;
  try {
    r2 = e2();
  } catch {
    return;
  }
  return {
    getItem: (o2) => {
      var s2;
      const a3 = (d2) => d2 === null ? null : JSON.parse(d2, void 0), i2 = (s2 = r2.getItem(o2)) != null ? s2 : null;
      return i2 instanceof Promise ? i2.then(a3) : a3(i2);
    },
    setItem: (o2, s2) => r2.setItem(
      o2,
      JSON.stringify(s2, void 0)
    ),
    removeItem: (o2) => r2.removeItem(o2)
  };
}
var br = (e2) => (t2) => {
  try {
    const r2 = e2(t2);
    return r2 instanceof Promise ? r2 : {
      then(n2) {
        return br(n2)(r2);
      },
      catch(n2) {
        return this;
      }
    };
  } catch (r2) {
    return {
      then(n2) {
        return this;
      },
      catch(n2) {
        return br(n2)(r2);
      }
    };
  }
};
var zu = (e2, t2) => (r2, n2, o2) => {
  let s2 = {
    storage: _r(() => localStorage),
    partialize: (h) => h,
    version: 0,
    merge: (h, v2) => ({
      ...v2,
      ...h
    }),
    ...t2
  }, a3 = false;
  const i2 = /* @__PURE__ */ new Set(), d2 = /* @__PURE__ */ new Set();
  let u3 = s2.storage;
  if (!u3)
    return e2(
      (...h) => {
        console.warn(
          `[zustand persist middleware] Unable to update item '${s2.name}', the given storage is currently unavailable.`
        ), r2(...h);
      },
      n2,
      o2
    );
  const p2 = () => {
    const h = s2.partialize({ ...n2() });
    return u3.setItem(s2.name, {
      state: h,
      version: s2.version
    });
  }, m3 = o2.setState;
  o2.setState = (h, v2) => {
    m3(h, v2), p2();
  };
  const g3 = e2(
    (...h) => {
      r2(...h), p2();
    },
    n2,
    o2
  );
  o2.getInitialState = () => g3;
  let b4;
  const E3 = () => {
    var h, v2;
    if (!u3) return;
    a3 = false, i2.forEach((w2) => {
      var P;
      return w2((P = n2()) != null ? P : g3);
    });
    const x2 = ((v2 = s2.onRehydrateStorage) == null ? void 0 : v2.call(s2, (h = n2()) != null ? h : g3)) || void 0;
    return br(u3.getItem.bind(u3))(s2.name).then((w2) => {
      if (w2)
        if (typeof w2.version == "number" && w2.version !== s2.version) {
          if (s2.migrate) {
            const P = s2.migrate(
              w2.state,
              w2.version
            );
            return P instanceof Promise ? P.then((R2) => [true, R2]) : [true, P];
          }
          console.error(
            "State loaded from storage couldn't be migrated since no migrate function was provided"
          );
        } else
          return [false, w2.state];
      return [false, void 0];
    }).then((w2) => {
      var P;
      const [R2, N2] = w2;
      if (b4 = s2.merge(
        N2,
        (P = n2()) != null ? P : g3
      ), r2(b4, true), R2)
        return p2();
    }).then(() => {
      x2 == null || x2(b4, void 0), b4 = n2(), a3 = true, d2.forEach((w2) => w2(b4));
    }).catch((w2) => {
      x2 == null || x2(void 0, w2);
    });
  };
  return o2.persist = {
    setOptions: (h) => {
      s2 = {
        ...s2,
        ...h
      }, h.storage && (u3 = h.storage);
    },
    clearStorage: () => {
      u3 == null || u3.removeItem(s2.name);
    },
    getOptions: () => s2,
    rehydrate: () => E3(),
    hasHydrated: () => a3,
    onHydrate: (h) => (i2.add(h), () => {
      i2.delete(h);
    }),
    onFinishHydration: (h) => (d2.add(h), () => {
      d2.delete(h);
    })
  }, s2.skipHydration || E3(), b4 || g3;
};
var As = zu;
create4()(
  As(
    (e2, t2) => ({
      user: void 0,
      setUser: (r2) => e2({ user: r2 }),
      getUser: () => t2().user,
      deleteUser: () => e2({ user: void 0 })
    }),
    {
      name: "passport-user",
      storage: _r(() => localStorage),
      partialize: (e2) => ({ user: e2.user })
    }
  )
);
var $u = create4()(
  As(
    (e2, t2) => ({
      accessToken: void 0,
      refreshToken: void 0,
      setAccessToken: (r2) => e2({ accessToken: r2 }),
      setRefreshToken: (r2) => e2({ refreshToken: r2 }),
      getAccessToken: () => t2().accessToken,
      getRefreshToken: () => t2().refreshToken,
      deleteTokens: () => e2({ accessToken: void 0, refreshToken: void 0 })
    }),
    {
      name: "passport-token",
      storage: _r(() => localStorage),
      partialize: (e2) => ({
        accessToken: e2.accessToken,
        refreshToken: e2.refreshToken
      })
    }
  )
);
var Wu = () => {
  const {
    setRefreshToken: e2,
    setAccessToken: t2,
    getAccessToken: r2,
    getRefreshToken: n2,
    deleteTokens: o2
  } = $u();
  return {
    login: async (u3, p2) => {
      if (!u3) {
        console.error("[passport.login]: Access token is empty");
        return;
      }
      if (!p2) {
        console.error("[passport.login]: Refresh token is empty");
        return;
      }
      t2(u3), e2(p2);
    },
    accessToken: r2,
    refreshToken: n2,
    setAccessToken: (u3) => {
      t2(u3);
    },
    setRefreshToken: (u3) => {
      e2(u3);
    },
    logout: () => {
      o2();
    }
  };
};
var Gu = {
  gasPriceOracle: { address: "0x420000000000000000000000000000000000000F" },
  l1Block: { address: "0x4200000000000000000000000000000000000015" },
  l2CrossDomainMessenger: {
    address: "0x4200000000000000000000000000000000000007"
  },
  l2Erc721Bridge: { address: "0x4200000000000000000000000000000000000014" },
  l2StandardBridge: { address: "0x4200000000000000000000000000000000000010" },
  l2ToL1MessagePasser: {
    address: "0x4200000000000000000000000000000000000016"
  }
};
var Vu = {
  block: ql({
    format(e2) {
      var r2;
      return {
        transactions: (r2 = e2.transactions) == null ? void 0 : r2.map((n2) => {
          if (typeof n2 == "string")
            return n2;
          const o2 = kr(n2);
          return o2.typeHex === "0x7e" && (o2.isSystemTx = n2.isSystemTx, o2.mint = n2.mint ? Je(n2.mint) : void 0, o2.sourceHash = n2.sourceHash, o2.type = "deposit"), o2;
        }),
        stateRoot: e2.stateRoot
      };
    }
  }),
  transaction: Jl({
    format(e2) {
      const t2 = {};
      return e2.type === "0x7e" && (t2.isSystemTx = e2.isSystemTx, t2.mint = e2.mint ? Je(e2.mint) : void 0, t2.sourceHash = e2.sourceHash, t2.type = "deposit"), t2;
    }
  }),
  transactionReceipt: gu({
    format(e2) {
      return {
        l1GasPrice: e2.l1GasPrice ? Je(e2.l1GasPrice) : null,
        l1GasUsed: e2.l1GasUsed ? Je(e2.l1GasUsed) : null,
        l1Fee: e2.l1Fee ? Je(e2.l1Fee) : null,
        l1FeeScalar: e2.l1FeeScalar ? Number(e2.l1FeeScalar) : null
      };
    }
  })
};
function Hu(e2, t2) {
  return Yu(e2) ? Ku(e2) : wu(e2, t2);
}
var Ju = {
  transaction: Hu
};
function Ku(e2) {
  qu(e2);
  const { sourceHash: t2, data: r2, from: n2, gas: o2, isSystemTx: s2, mint: a3, to: i2, value: d2 } = e2, u3 = [
    t2,
    n2,
    i2 ?? "0x",
    a3 ? T3(a3) : "0x",
    d2 ? T3(d2) : "0x",
    o2 ? T3(o2) : "0x",
    s2 ? "0x1" : "0x",
    r2 ?? "0x"
  ];
  return ht([
    "0x7e",
    Ue2(u3)
  ]);
}
function Yu(e2) {
  return e2.type === "deposit" || typeof e2.sourceHash < "u";
}
function qu(e2) {
  const { from: t2, to: r2 } = e2;
  if (t2 && !Me2(t2))
    throw new Be2({ address: t2 });
  if (r2 && !Me2(r2))
    throw new Be2({ address: r2 });
}
var _t = {
  contracts: Gu,
  formatters: Vu,
  serializers: Ju
};
var Xu = 42161;
var Rn = he2({
  id: 33139,
  name: "Ape Chain",
  nativeCurrency: {
    name: "ApeCoin",
    symbol: "APE",
    decimals: 18
  },
  rpcUrls: {
    default: {
      http: ["https://rpc.apechain.com/http"],
      webSocket: ["wss://rpc.apechain.com/ws"]
    }
  },
  blockExplorers: {
    default: {
      name: "Apescan",
      url: "https://apescan.io",
      apiUrl: "https://api.apescan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xcA11bde05977b3631167028862bE2a173976CA11",
      blockCreated: 20889
    }
  },
  sourceId: Xu
});
var An = he2({
  id: 42161,
  name: "Arbitrum One",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://arb1.arbitrum.io/rpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Arbiscan",
      url: "https://arbiscan.io",
      apiUrl: "https://api.arbiscan.io/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 7654707
    }
  }
});
var In = he2({
  id: 43114,
  name: "Avalanche",
  nativeCurrency: {
    decimals: 18,
    name: "Avalanche",
    symbol: "AVAX"
  },
  rpcUrls: {
    default: { http: ["https://api.avax.network/ext/bc/C/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "SnowTrace",
      url: "https://snowtrace.io",
      apiUrl: "https://api.snowtrace.io"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 11907934
    }
  }
});
var ut = 1;
var kn = he2({
  ..._t,
  id: 8453,
  name: "Base",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.base.org"]
    }
  },
  blockExplorers: {
    default: {
      name: "Basescan",
      url: "https://basescan.org",
      apiUrl: "https://api.basescan.org/api"
    }
  },
  contracts: {
    ..._t.contracts,
    disputeGameFactory: {
      [ut]: {
        address: "0x43edB88C4B80fDD2AdFF2412A7BebF9dF42cB40e"
      }
    },
    l2OutputOracle: {
      [ut]: {
        address: "0x56315b90c40730925ec5485cf004d835058518A0"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 5022
    },
    portal: {
      [ut]: {
        address: "0x49048044D57e1C92A77f79988d21Fa8fAF74E97e",
        blockCreated: 17482143
      }
    },
    l1StandardBridge: {
      [ut]: {
        address: "0x3154Cf16ccdb4C6d922629664174b904d80F2C35",
        blockCreated: 17482143
      }
    }
  },
  sourceId: ut
});
var Tn = he2({
  id: 56,
  name: "BNB Smart Chain",
  nativeCurrency: {
    decimals: 18,
    name: "BNB",
    symbol: "BNB"
  },
  rpcUrls: {
    default: { http: ["https://56.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "BscScan",
      url: "https://bscscan.com",
      apiUrl: "https://api.bscscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 15921452
    }
  }
});
var Nn = he2({
  id: 250,
  name: "Fantom",
  nativeCurrency: {
    decimals: 18,
    name: "Fantom",
    symbol: "FTM"
  },
  rpcUrls: {
    default: { http: ["https://250.rpc.thirdweb.com"] }
  },
  blockExplorers: {
    default: {
      name: "FTMScan",
      url: "https://ftmscan.com",
      apiUrl: "https://api.ftmscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 33001987
    }
  }
});
var _n = he2({
  id: 1,
  name: "Ethereum",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://eth.merkle.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Etherscan",
      url: "https://etherscan.io",
      apiUrl: "https://api.etherscan.io/api"
    }
  },
  contracts: {
    ensRegistry: {
      address: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e"
    },
    ensUniversalResolver: {
      address: "0xce01f8eee7E479C928F8919abD53E553a36CeF67",
      blockCreated: 19258213
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 14353601
    }
  }
});
var dt = 1;
var On = he2({
  ..._t,
  id: 10,
  name: "OP Mainnet",
  nativeCurrency: { name: "Ether", symbol: "ETH", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://mainnet.optimism.io"]
    }
  },
  blockExplorers: {
    default: {
      name: "Optimism Explorer",
      url: "https://optimistic.etherscan.io",
      apiUrl: "https://api-optimistic.etherscan.io/api"
    }
  },
  contracts: {
    ..._t.contracts,
    disputeGameFactory: {
      [dt]: {
        address: "0xe5965Ab5962eDc7477C8520243A95517CD252fA9"
      }
    },
    l2OutputOracle: {
      [dt]: {
        address: "0xdfe97868233d1aa22e815a266982f2cf17685a27"
      }
    },
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 4286263
    },
    portal: {
      [dt]: {
        address: "0xbEb5Fc579115071764c7423A4f12eDde41f106Ed"
      }
    },
    l1StandardBridge: {
      [dt]: {
        address: "0x99C9fc46f92E8a1c0deC1b1747d010903E884bE1"
      }
    }
  },
  sourceId: dt
});
var jn = he2({
  id: 137,
  name: "Polygon",
  nativeCurrency: { name: "POL", symbol: "POL", decimals: 18 },
  rpcUrls: {
    default: {
      http: ["https://polygon-rpc.com"]
    }
  },
  blockExplorers: {
    default: {
      name: "PolygonScan",
      url: "https://polygonscan.com",
      apiUrl: "https://api.polygonscan.com/api"
    }
  },
  contracts: {
    multicall3: {
      address: "0xca11bde05977b3631167028862be2a173976ca11",
      blockCreated: 25770160
    }
  }
});
var Ln = he2({
  id: 728126428,
  name: "Tron",
  nativeCurrency: { name: "TRON", symbol: "TRX", decimals: 6 },
  rpcUrls: {
    default: {
      http: ["https://api.trongrid.io/jsonrpc"]
    }
  },
  blockExplorers: {
    default: {
      name: "Tronscan",
      url: "https://tronscan.org",
      apiUrl: "https://apilist.tronscanapi.com/api"
    }
  }
});
var Dn = {
  id: 987,
  name: "Orange Testnet L1 Testnet",
  nativeCurrency: { name: "Juice", symbol: "JUICE", decimals: 18 },
  rpcUrls: {
    default: { http: ["https://subnets.avax.network/orangetest/testnet/rpc"] }
  },
  blockExplorers: {
    default: {
      name: "AvaScan",
      url: "https://subnets-test.avax.network/orangetest"
    }
  }
};
var Zu = new QueryClient();
var Qu = ({ ...e2 }) => {
  const t2 = createConfig(
    defaultConfig({
      chains: [
        _n,
        In,
        An,
        kn,
        Tn,
        Nn,
        Ln,
        Rn,
        On,
        jn,
        Dn
      ],
      transports: {
        [_n.id]: http(),
        [In.id]: http(),
        [An.id]: http(),
        [kn.id]: http(),
        [Tn.id]: http(),
        [Nn.id]: http(),
        [Ln.id]: http(),
        [Rn.id]: http(),
        [On.id]: http(),
        [jn.id]: http(),
        [Dn.id]: http()
      },
      // Required API Keys
      walletConnectProjectId: e2.walletConnectProjectId,
      appName: e2.appName,
      // Optional App Info
      appDescription: e2.appDescription ?? "",
      appUrl: e2.appUrl ?? "",
      appIcon: e2.appIcon ?? ""
    })
  );
  return l2.jsx(WagmiProvider, { config: t2, children: l2.jsx(QueryClientProvider, { client: Zu, children: l2.jsx(
    ConnectKitProvider,
    {
      options: {
        initialChainId: e2.defaultChainId ?? 1,
        enforceSupportedChains: true
      },
      children: e2.children
    }
  ) }) });
};
new TextEncoder();
var Is = new TextDecoder();
var ed = (e2) => {
  const t2 = atob(e2), r2 = new Uint8Array(t2.length);
  for (let n2 = 0; n2 < t2.length; n2++)
    r2[n2] = t2.charCodeAt(n2);
  return r2;
};
var td = (e2) => {
  let t2 = e2;
  t2 instanceof Uint8Array && (t2 = Is.decode(t2)), t2 = t2.replace(/-/g, "+").replace(/_/g, "/").replace(/\s/g, "");
  try {
    return ed(t2);
  } catch {
    throw new TypeError("The input to be decoded is not correctly encoded.");
  }
};
var X3 = class extends Error {
  constructor(t2, r2) {
    var n2;
    super(t2, r2), this.code = "ERR_JOSE_GENERIC", this.name = this.constructor.name, (n2 = Error.captureStackTrace) == null || n2.call(Error, this, this.constructor);
  }
};
X3.code = "ERR_JOSE_GENERIC";
var rd = class extends X3 {
  constructor(t2, r2, n2 = "unspecified", o2 = "unspecified") {
    super(t2, { cause: { claim: n2, reason: o2, payload: r2 } }), this.code = "ERR_JWT_CLAIM_VALIDATION_FAILED", this.claim = n2, this.reason = o2, this.payload = r2;
  }
};
rd.code = "ERR_JWT_CLAIM_VALIDATION_FAILED";
var nd = class extends X3 {
  constructor(t2, r2, n2 = "unspecified", o2 = "unspecified") {
    super(t2, { cause: { claim: n2, reason: o2, payload: r2 } }), this.code = "ERR_JWT_EXPIRED", this.claim = n2, this.reason = o2, this.payload = r2;
  }
};
nd.code = "ERR_JWT_EXPIRED";
var od = class extends X3 {
  constructor() {
    super(...arguments), this.code = "ERR_JOSE_ALG_NOT_ALLOWED";
  }
};
od.code = "ERR_JOSE_ALG_NOT_ALLOWED";
var sd = class extends X3 {
  constructor() {
    super(...arguments), this.code = "ERR_JOSE_NOT_SUPPORTED";
  }
};
sd.code = "ERR_JOSE_NOT_SUPPORTED";
var id2 = class extends X3 {
  constructor(t2 = "decryption operation failed", r2) {
    super(t2, r2), this.code = "ERR_JWE_DECRYPTION_FAILED";
  }
};
id2.code = "ERR_JWE_DECRYPTION_FAILED";
var ad = class extends X3 {
  constructor() {
    super(...arguments), this.code = "ERR_JWE_INVALID";
  }
};
ad.code = "ERR_JWE_INVALID";
var cd = class extends X3 {
  constructor() {
    super(...arguments), this.code = "ERR_JWS_INVALID";
  }
};
cd.code = "ERR_JWS_INVALID";
var Ae2 = class extends X3 {
  constructor() {
    super(...arguments), this.code = "ERR_JWT_INVALID";
  }
};
Ae2.code = "ERR_JWT_INVALID";
var ld = class extends X3 {
  constructor() {
    super(...arguments), this.code = "ERR_JWK_INVALID";
  }
};
ld.code = "ERR_JWK_INVALID";
var ud = class extends X3 {
  constructor() {
    super(...arguments), this.code = "ERR_JWKS_INVALID";
  }
};
ud.code = "ERR_JWKS_INVALID";
var dd = class extends X3 {
  constructor(t2 = "no applicable key found in the JSON Web Key Set", r2) {
    super(t2, r2), this.code = "ERR_JWKS_NO_MATCHING_KEY";
  }
};
dd.code = "ERR_JWKS_NO_MATCHING_KEY";
var fd = class extends X3 {
  constructor(t2 = "multiple matching keys found in the JSON Web Key Set", r2) {
    super(t2, r2), this.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
  }
};
fd.code = "ERR_JWKS_MULTIPLE_MATCHING_KEYS";
var hd = class extends X3 {
  constructor(t2 = "request timed out", r2) {
    super(t2, r2), this.code = "ERR_JWKS_TIMEOUT";
  }
};
hd.code = "ERR_JWKS_TIMEOUT";
var pd = class extends X3 {
  constructor(t2 = "signature verification failed", r2) {
    super(t2, r2), this.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
  }
};
pd.code = "ERR_JWS_SIGNATURE_VERIFICATION_FAILED";
function md(e2) {
  return typeof e2 == "object" && e2 !== null;
}
function gd(e2) {
  if (!md(e2) || Object.prototype.toString.call(e2) !== "[object Object]")
    return false;
  if (Object.getPrototypeOf(e2) === null)
    return true;
  let t2 = e2;
  for (; Object.getPrototypeOf(t2) !== null; )
    t2 = Object.getPrototypeOf(t2);
  return Object.getPrototypeOf(e2) === t2;
}
var bd = td;
function vd(e2) {
  if (typeof e2 != "string")
    throw new Ae2("JWTs must use Compact JWS serialization, JWT must be a string");
  const { 1: t2, length: r2 } = e2.split(".");
  if (r2 === 5)
    throw new Ae2("Only JWTs using Compact JWS serialization can be decoded");
  if (r2 !== 3)
    throw new Ae2("Invalid JWT");
  if (!t2)
    throw new Ae2("JWTs must contain a payload");
  let n2;
  try {
    n2 = bd(t2);
  } catch {
    throw new Ae2("Failed to base64url decode the payload");
  }
  let o2;
  try {
    o2 = JSON.parse(Is.decode(n2));
  } catch {
    throw new Ae2("Failed to parse the decoded payload as JSON");
  }
  if (!gd(o2))
    throw new Ae2("Invalid JWT Claims Set");
  return o2;
}
var kd = ({ ...e2 }) => {
  const [t2, r2] = (0, import_react72.useState)(true), [n2, o2] = (0, import_react72.useState)("Built on Bedrock"), [s2, a3] = (0, import_react72.useState)("https://bedrockpassport.com"), { baseUrl: i2, authCallbackUrl: d2, tenantId: u3 } = e2, [p2, m3] = (0, import_react72.useState)(""), g3 = axios_default.create({
    baseURL: `${i2}/api`
  }), [b4, E3] = (0, import_react72.useState)(), [h, v2] = (0, import_react72.useState)(), { accessToken: x2, refreshToken: w2, login: P, logout: R2 } = Wu(), N2 = async (S2) => {
    try {
      let O2 = x2();
      if (O2) {
        const U2 = vd(O2);
        if (U2.exp && U2.exp * 1e3 < Date.now()) {
          const D3 = w2();
          if (!D3)
            return R2(), S2;
          const te2 = await axios_default.post(`${i2}/api/v1/auth/refresh`, {
            refreshToken: D3,
            provider: U2.provider
          }).then((le2) => le2.data.accessToken).catch((le2) => {
            console.error(le2.cause);
          });
          if (!te2)
            return R2(), S2;
          te2 && (P(te2, D3), O2 = x2());
        }
      }
      S2.headers.Authorization = `Bearer ${O2}`;
    } catch (O2) {
      console.error("[interceptor.error] ", { e: O2 });
    }
    return S2;
  };
  g3.defaults.headers.common["Ocp-Apim-Subscription-Key"] = e2.subscriptionKey ?? "DEMO_BEDROCK_PASSPORT_KEY", g3.interceptors.request.use(N2);
  const W3 = async (S2, O2) => {
    if (S2 === Ie2.EMAIL && O2)
      return await g3.post("/v1/auth/email/login", {
        email: O2.email,
        password: O2.password
      }).then((D3) => D3.data).catch(
        (D3) => {
          var te2, le2;
          throw console.error(D3.cause), new Error(((le2 = (te2 = D3.response) == null ? void 0 : te2.data) == null ? void 0 : le2.message) ?? "Login failed");
        }
      );
    {
      const U2 = Mu(i2, S2, d2);
      window.location.href = `${U2}${u3 ? `&tenantId=${u3}` : ""}`;
    }
  }, L2 = (0, import_react72.useCallback)(async () => g3.get("/v1/auth/user", {}).then((S2) => S2.data).catch((S2) => {
    console.error(S2.toJSON);
  }), [g3]), J2 = (0, import_react72.useCallback)(async () => g3.get("/v1/auth/widget").then((S2) => S2.data).catch((S2) => {
    console.error(S2.toJSON);
  }), [g3]), Z2 = (0, import_react72.useCallback)(
    async (S2, O2) => {
      if (!S2 || !O2)
        return false;
      P(S2, O2);
      const U2 = await L2();
      return U2 ? U2 ? (E3(U2), true) : false : (R2(), false);
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    []
  ), oe2 = () => {
    R2(), E3(void 0), v2(void 0), r2(true);
  };
  (0, import_react72.useEffect)(
    () => {
      console.log("[mount.start]: Bedrock Passport");
      const S2 = async () => {
        const D3 = await L2();
        D3 && E3(D3);
      }, O2 = async () => {
        const D3 = await J2();
        D3 && (o2(D3.text), a3(D3.url));
      }, U2 = async () => {
        const D3 = await se2();
        D3 && v2(D3);
      };
      return t2 && (r2(false), O2(), x2() && (console.info("[INIT]: Token found"), S2(), U2())), () => {
        console.log("[mount.finish]: Bedrock Passport Provider");
      };
    },
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [x2, t2]
  );
  const Te2 = (0, import_react72.useCallback)(async () => g3.get("/v1/message/nonce").then((S2) => S2.data).catch((S2) => {
    console.error(S2.toJSON);
  }), [g3]), B2 = (0, import_react72.useCallback)(
    async (S2, O2) => g3.post("/v1/message/verify", {
      message: S2,
      signature: O2,
      tenantId: u3
    }).then((U2) => U2.data).catch((U2) => {
      console.error(U2.toJSON);
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    [g3]
  ), K2 = (S2) => {
    const O2 = Uu(i2, S2, d2);
    window.location.href = `${O2}&token=${x2()}${u3 ? `&tenantId=${u3}` : ""}`;
  }, Q2 = (0, import_react72.useCallback)(
    async (S2, O2) => (console.log("[passport.link.wallet]"), m3(""), g3.post("/v1/auth/identifier/wallet", {
      message: S2,
      signature: O2
    }).then((U2) => U2.data).catch((U2) => {
      console.error(U2.message), m3("Wallet already used");
    })),
    [g3]
  ), ce2 = () => {
    const S2 = "https://bedrockpassport.com/login";
    window.location.href = `${S2}?token=${x2()}&refreshToken=${w2()}`;
  }, pe2 = async (S2, O2, U2) => {
    try {
      return await g3.post("/v1/auth/email/register", {
        email: S2,
        password: O2,
        passwordConfirm: U2
      }).then((te2) => te2.data).catch((te2) => {
        throw console.error(te2.message), new Error("[BRP-005] Email registration failed");
      });
    } catch (D3) {
      throw console.error("[Bedrock Passport] Email registration error:", D3), D3;
    }
  }, Ne2 = async (S2) => {
    try {
      const O2 = await g3.post(
        "/v1/auth/email/reset",
        {
          email: S2
        }
      );
      if (!O2.data)
        throw new Error("[BRP-005] Email registration failed");
      return O2.data;
    } catch (O2) {
      throw console.error("[Bedrock Passport] Email registration error:", O2), O2;
    }
  }, xe2 = async (S2, O2, U2) => {
    try {
      const D3 = await g3.post(
        "/v1/auth/email/password",
        {
          password: S2,
          passwordConfirm: O2,
          token: U2
        }
      );
      if (!D3.data)
        throw new Error("[BRP-007] password change failed");
      return D3.data;
    } catch (D3) {
      throw console.error("[Bedrock Passport] password change error:", D3), D3;
    }
  }, se2 = (0, import_react72.useCallback)(async () => g3.post("/v1/economy/currency", {
    titleId: u3,
    count: 10,
    inventory: "default"
  }).then((S2) => S2.data).catch((S2) => {
    console.error(S2.toJSON);
  }), [g3]), _e2 = (0, import_react72.useCallback)(async () => g3.post("/v1/economy/inventoryItems", {
    titleId: u3,
    count: 10,
    inventory: "default"
  }).then((S2) => S2.data).catch((S2) => {
    console.error(S2.toJSON);
  }), [g3]), ee2 = {
    user: b4,
    signIn: W3,
    signOut: oe2,
    loginCallback: Z2,
    accessToken: x2(),
    isLoggedIn: !!x2(),
    getNonce: Te2,
    verifyNonce: B2,
    linkSocial: K2,
    linkWallet: Q2,
    errorWallet: p2,
    setErrorWallet: m3,
    widgetText: n2,
    widgetUrl: s2,
    linkProfile: ce2,
    registerEmail: pe2,
    getTokenReset: Ne2,
    changePassword: xe2,
    getCurrency: se2,
    getItems: _e2,
    currency: h,
    apiClient: g3
  };
  return l2.jsx(Zn.Provider, { value: ee2, children: l2.jsx(
    Qu,
    {
      walletConnectProjectId: e2.walletConnectId ?? "c00e7bea048e69d5adaea82259539eb6",
      appName: e2.appName ?? "Bedrock Passport",
      appDescription: e2.appDescription,
      appUrl: e2.appUrl,
      appIcon: e2.appIcon,
      baseUrl: i2,
      tenantId: u3,
      children: e2.children
    }
  ) });
};
export {
  kd as BedrockPassportProvider,
  Id2 as LoginPanel,
  Ie2 as UserProvider,
  ta as UserRole,
  Qe as useBedrockPassport,
  Wu as useBedrockToken
};
/*! Bundled license information:

use-sync-external-store/cjs/use-sync-external-store-shim.development.js:
  (**
   * @license React
   * use-sync-external-store-shim.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

use-sync-external-store/cjs/use-sync-external-store-shim/with-selector.development.js:
  (**
   * @license React
   * use-sync-external-store-shim/with-selector.development.js
   *
   * Copyright (c) Meta Platforms, Inc. and affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (**
   * @license React
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

react-is/cjs/react-is.development.js:
  (** @license React v16.13.1
   * react-is.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@noble/hashes/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/modular.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/curve.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/abstract/weierstrass.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/_shortw_utils.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/secp256k1.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

aes-js/lib.commonjs/aes.js:
  (*! MIT License. Copyright 2015-2022 Richard Moore <me@ricmoo.com>. See LICENSE.txt. *)

@noble/curves/esm/abstract/bls.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/abstract/tower.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/curves/esm/bls12-381.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/base/lib/esm/index.js:
  (*! scure-base - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip32/lib/esm/index.js:
  (*! scure-bip32 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/hashes/esm/utils.js:
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@scure/bip39/esm/index.js:
  (*! scure-bip39 - MIT License (c) 2022 Patricio Palladino, Paul Miller (paulmillr.com) *)

@noble/curves/esm/p256.js:
  (*! noble-curves - MIT License (c) 2022 Paul Miller (paulmillr.com) *)

@bedrock_org/passport/dist/index.es.js:
  (**
   * @license React
   * react-jsx-runtime.production.min.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)

@bedrock_org/passport/dist/index.es.js:
  (**
   * @license React
   * react-jsx-runtime.development.js
   *
   * Copyright (c) Facebook, Inc. and its affiliates.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   *)
  (*! noble-hashes - MIT License (c) 2022 Paul Miller (paulmillr.com) *)
*/
//# sourceMappingURL=@bedrock_org_passport.js.map
