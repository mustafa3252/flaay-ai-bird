// Generated by dts-bundle-generator v7.2.0

import { Client, Hex, JsonRpcAccount, PublicActions, PublicRpcSchema, Transport, WalletActions, WalletRpcSchema } from 'viem';
import { CreateConnectorFn } from 'wagmi';

export declare enum UsernameType {
	EMAIL = "EMAIL",
	PHONE = "PHONE"
}
export declare enum SessionStatus {
	AUTHENTICATED = "AUTHENTICATED",
	NOT_AUTHENTICATED = "NOT_AUTHENTICATED"
}
export declare enum CommunicationTypes {
	/**
	 * Session
	 */
	sessionInit = "sessionInit",
	sessionGetCurrent = "sessionGetCurrent",
	sessionClear = "sessionClear",
	/**
	 * Ethereum
	 */
	ethereumJsonRpcRequest = "ethereumJsonRpcRequest",
	ethereumJsonRpcRequiresApproval = "ethereumJsonRpcRequiresApproval"
}
export interface EthereumJsonRpcData {
	method: string;
	params: unknown[];
}
export interface EthereumJsonRpcRequest {
	type: CommunicationTypes.ethereumJsonRpcRequest;
	data: EthereumJsonRpcData;
}
export interface EthereumJsonRpcRequiresApproval {
	type: CommunicationTypes.ethereumJsonRpcRequiresApproval;
	data: EthereumJsonRpcData;
}
export type EthereumCommunication = EthereumJsonRpcRequest | EthereumJsonRpcRequiresApproval;
declare enum SubscriptionTypes {
	/**
	 * Session related
	 */
	sessionChanged = "sessionChanged",
	/**
	 * Network related
	 */
	ethereumNetworkChanged = "ethereumNetworkChanged",
	/**
	 * Modal related
	 */
	modalOpen = "modalOpen",
	modalClose = "modalClose",
	modalUpdate = "modalUpdate"
}
export interface NetworkOnChangeData {
	chainId: string;
}
export interface NetworkOnChange {
	type: SubscriptionTypes.ethereumNetworkChanged;
	data: NetworkOnChangeData;
}
export type EthereumSubscription = NetworkOnChange;
export interface SessionInitData {
	clientSessionKey: string | null;
	deviceId: string | null;
}
export interface SessionInit {
	type: CommunicationTypes.sessionInit;
	data: SessionInitData;
}
export interface SessionGetCurrent {
	type: CommunicationTypes.sessionGetCurrent;
}
export interface SessionClear {
	type: CommunicationTypes.sessionClear;
}
export type SessionCommunication = SessionInit | SessionGetCurrent | SessionClear;
export type WalletData = {
	address: string;
};
export type AuthenticateSession = {
	wallet: WalletData;
	idToken: string;
	status: SessionStatus.AUTHENTICATED;
};
export type NotAuthenticatedSession = {
	status: SessionStatus.NOT_AUTHENTICATED;
};
export type Session = NotAuthenticatedSession | AuthenticateSession;
export interface SessionOnChange {
	type: SubscriptionTypes.sessionChanged;
	data: Session;
}
export type SessionSubscription = SessionOnChange;
export interface ModalOpenData {
	width: number;
	height: number;
}
export interface ModalOpen {
	type: SubscriptionTypes.modalOpen;
	data: ModalOpenData;
}
export interface ModalClose {
	type: SubscriptionTypes.modalClose;
	data: null;
}
export interface ModalUpdateData {
	width: number;
	height: number;
}
export interface ModalUpdate {
	type: SubscriptionTypes.modalUpdate;
	data: ModalUpdateData;
}
export type ModalSubscription = ModalOpen | ModalClose | ModalUpdate;
export type Communication = SessionCommunication | EthereumCommunication;
export type Subscription = SessionSubscription | EthereumSubscription | ModalSubscription;
export type EnvironmentConfig = {
	name: "production" | string;
	webElementsAppUrl: string;
};
export declare const production: EnvironmentConfig;
export type ConnectConfig = {
	environment: EnvironmentConfig;
};
export declare enum SdkStatus {
	DISCONNECTED = 0,
	CONNECTING = 1,
	CONNECTED = 2
}
export declare enum SessionCreateResult {
	/**
	 * User successfully authenticated
	 */
	SUCCESS = "SUCCESS",
	/**
	 * User cancelled popup by closing it or by timeout
	 */
	USER_CANCELLED = "USER_CANCELLED",
	/**
	 * Popup was blocked by the browser
	 */
	BROWSER_BLOCKED = "BROWSER_BLOCKED"
}
export type SessionCreateResponse = {
	status: SessionCreateResult.SUCCESS;
	deviceId: string;
	clientSessionKey: string;
	wallet: WalletData;
	idToken: string;
} | {
	status: SessionCreateResult.USER_CANCELLED | SessionCreateResult.BROWSER_BLOCKED;
};
export interface IFamilyAccountsSdk {
	connect: (config?: ConnectConfig) => Promise<void>;
	isConnected: () => boolean;
	isConnecting: () => boolean;
	disconnect: () => Promise<void>;
	onConnectionChange: (callback: (isConnected: boolean) => void) => () => void;
	session: {
		create: () => Promise<SessionCreateResponse>;
		init: () => Promise<Session>;
		getCurrent: () => Promise<Session>;
		clear: () => Promise<void>;
		onChange: (callback: (newValue: Session) => void) => () => void;
	};
	ethereum: {
		onNetworkChange: (callback: (newValue: NetworkOnChangeData) => void) => () => void;
	};
}
export declare const FamilyAccountsSdk: IFamilyAccountsSdk;
export type FamilyAccountsSdk = typeof FamilyAccountsSdk;
export type FamilyAccountsCustomActions = {
	getIdToken(): Promise<string | null>;
	switchAccounts(): Promise<Hex[]>;
	disconnect(): Promise<void>;
};
export declare const familyAccountsCustomActions: (client: Client) => FamilyAccountsCustomActions;
export type FamilyAccountsClient = Client<Transport, undefined, JsonRpcAccount, WalletRpcSchema & PublicRpcSchema, WalletActions<undefined, JsonRpcAccount> & PublicActions<Transport, undefined> & FamilyAccountsCustomActions>;
export declare const createFamilyAccountsClient: () => Promise<FamilyAccountsClient>;
export type RequestArguments = {
	method: string;
	params?: unknown;
};
export type EthereumProviderOptions = {
	debug?: boolean;
	options?: ConnectConfig;
};
export declare class EthereumProviderConnectionTimeoutError extends Error {
	constructor();
}
/**
 * This follows the EIP - https://eips.ethereum.org/EIPS/eip-1193
 */
export declare class EthereumProvider {
	private _eventEmitter;
	private _accountsChangedUnsubscriptionCallback;
	private _networkChangedUnsubscriptionCallback;
	private _connectUnsubscriptionCallback;
	private _disconnectUnsubscriptionCallback;
	private _config?;
	constructor(options?: EthereumProviderOptions);
	private log;
	/**
	 * @returns true if the provider is connected and ready to process requests
	 */
	isConnected(): boolean;
	/**
	 * JSONRPC request
	 * @param args The request arguments
	 */
	request(args: RequestArguments): Promise<any>;
	/**
	 * JSONRPC request
	 * @param method The request jsonrpc method
	 * @param params The request parameters
	 * @deprecated Please use `request` instead.
	 */
	send(method: string, params?: unknown[] | object): Promise<unknown>;
	/**
	 * The provider event emitters
	 * @param eventName The event name
	 * @param listener The listener to callback
	 */
	on(eventName: "message", listener: (messageInfo: {
		type: string;
		data: unknown;
	}) => void): this;
	on(eventName: "connect", listener: (connectInfo: {
		chainId: string;
	}) => void): this;
	on(eventName: "disconnect", listener: () => void): this;
	on(eventName: "chainChanged", listener: (chainId: string) => void): this;
	on(eventName: "accountsChanged", listener: (accounts: string[]) => void): this;
	/**
	 * Remove the provider event emitters
	 * @param eventName The event name
	 * @param listener The listener to callback
	 */
	removeListener(eventName: "message" | "connect" | "disconnect" | "chainChanged" | "accountsChanged", listener: (...params: any[]) => void): this;
	private subscribeToNetworkChangeEvent;
	private unsubscribeFromNetworkChangeEvent;
	private subscribeToAccountChangeEvent;
	private unsubscribeFromAccountChangeEvent;
	private subscribeToConnectEvent;
	private unsubscribeFromConnectEvent;
	private subscribeToDisconnectEvent;
	private unsubscribeFromDisconnectEvent;
	/**
	 * Wait for the provider to be connected
	 * This is done to make provider compatible with `wagmi` `injected` connector that tries to attach events before the provider is connected
	 */
	private waitForConnection;
}
export declare const familyAccountsConnector: {
	(options?: EthereumProviderOptions): CreateConnectorFn;
	version: string;
};

export {};
